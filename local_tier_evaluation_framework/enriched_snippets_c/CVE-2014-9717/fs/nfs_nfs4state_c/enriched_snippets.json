[
  {
    "function_name": "nfs4_run_state_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2440-2449",
    "snippet": "static int nfs4_run_state_manager(void *ptr)\n{\n\tstruct nfs_client *clp = ptr;\n\n\tallow_signal(SIGKILL);\n\tnfs4_state_manager(clp);\n\tnfs_put_client(clp);\n\tmodule_put_and_exit(0);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs4_run_state_manager(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put_and_exit",
          "args": [
            "0"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_put_client",
          "args": [
            "clp"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/client.c",
          "lines": "267-286",
          "snippet": "void nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <net/ipv6.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs_xdr.h>\n#include <net/ipv6.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_manager",
          "args": [
            "clp"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2326-2438",
          "snippet": "static void nfs4_state_manager(struct nfs_client *clp)\n{\n\tint status = 0;\n\tconst char *section = \"\", *section_sep = \"\";\n\n\t/* Ensure exclusive access to NFSv4 state */\n\tdo {\n\t\tif (test_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state)) {\n\t\t\tsection = \"purge state\";\n\t\t\tstatus = nfs4_purge_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state)) {\n\t\t\tsection = \"lease expired\";\n\t\t\t/* We're going to have to re-establish a clientid */\n\t\t\tstatus = nfs4_reclaim_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Initialize or reset the session */\n\t\tif (test_and_clear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state)) {\n\t\t\tsection = \"reset session\";\n\t\t\tstatus = nfs4_reset_session(clp);\n\t\t\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* Send BIND_CONN_TO_SESSION */\n\t\tif (test_and_clear_bit(NFS4CLNT_BIND_CONN_TO_SESSION,\n\t\t\t\t&clp->cl_state)) {\n\t\t\tsection = \"bind conn to session\";\n\t\t\tstatus = nfs4_bind_conn_to_session(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state)) {\n\t\t\tsection = \"check lease\";\n\t\t\tstatus = nfs4_check_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_MOVED, &clp->cl_state)) {\n\t\t\tsection = \"migration\";\n\t\t\tstatus = nfs4_handle_migration(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_LEASE_MOVED, &clp->cl_state)) {\n\t\t\tsection = \"lease moved\";\n\t\t\tstatus = nfs4_handle_lease_moved(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* First recover reboot state... */\n\t\tif (test_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state)) {\n\t\t\tsection = \"reclaim reboot\";\n\t\t\tstatus = nfs4_do_reclaim(clp,\n\t\t\t\tclp->cl_mvops->reboot_recovery_ops);\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t}\n\n\t\t/* Now recover expired state... */\n\t\tif (test_and_clear_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state)) {\n\t\t\tsection = \"reclaim nograce\";\n\t\t\tstatus = nfs4_do_reclaim(clp,\n\t\t\t\tclp->cl_mvops->nograce_recovery_ops);\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tnfs4_end_drain_session(clp);\n\t\tif (test_and_clear_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state)) {\n\t\t\tnfs_client_return_marked_delegations(clp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\t/* Did we race with an attempt to give us more work? */\n\t\tif (clp->cl_state == 0)\n\t\t\tbreak;\n\t\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\t\tbreak;\n\t} while (atomic_read(&clp->cl_count) > 1);\n\treturn;\nout_error:\n\tif (strlen(section))\n\t\tsection_sep = \": \";\n\tpr_warn_ratelimited(\"NFS: state manager%s%s failed on NFSv4 server %s\"\n\t\t\t\" with error %d\\n\", section_sep, section,\n\t\t\tclp->cl_hostname, -status);\n\tssleep(1);\n\tnfs4_end_drain_session(clp);\n\tnfs4_clear_state_manager_bit(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_manager(struct nfs_client *clp)\n{\n\tint status = 0;\n\tconst char *section = \"\", *section_sep = \"\";\n\n\t/* Ensure exclusive access to NFSv4 state */\n\tdo {\n\t\tif (test_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state)) {\n\t\t\tsection = \"purge state\";\n\t\t\tstatus = nfs4_purge_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state)) {\n\t\t\tsection = \"lease expired\";\n\t\t\t/* We're going to have to re-establish a clientid */\n\t\t\tstatus = nfs4_reclaim_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Initialize or reset the session */\n\t\tif (test_and_clear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state)) {\n\t\t\tsection = \"reset session\";\n\t\t\tstatus = nfs4_reset_session(clp);\n\t\t\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* Send BIND_CONN_TO_SESSION */\n\t\tif (test_and_clear_bit(NFS4CLNT_BIND_CONN_TO_SESSION,\n\t\t\t\t&clp->cl_state)) {\n\t\t\tsection = \"bind conn to session\";\n\t\t\tstatus = nfs4_bind_conn_to_session(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state)) {\n\t\t\tsection = \"check lease\";\n\t\t\tstatus = nfs4_check_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_MOVED, &clp->cl_state)) {\n\t\t\tsection = \"migration\";\n\t\t\tstatus = nfs4_handle_migration(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_LEASE_MOVED, &clp->cl_state)) {\n\t\t\tsection = \"lease moved\";\n\t\t\tstatus = nfs4_handle_lease_moved(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* First recover reboot state... */\n\t\tif (test_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state)) {\n\t\t\tsection = \"reclaim reboot\";\n\t\t\tstatus = nfs4_do_reclaim(clp,\n\t\t\t\tclp->cl_mvops->reboot_recovery_ops);\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t}\n\n\t\t/* Now recover expired state... */\n\t\tif (test_and_clear_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state)) {\n\t\t\tsection = \"reclaim nograce\";\n\t\t\tstatus = nfs4_do_reclaim(clp,\n\t\t\t\tclp->cl_mvops->nograce_recovery_ops);\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tnfs4_end_drain_session(clp);\n\t\tif (test_and_clear_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state)) {\n\t\t\tnfs_client_return_marked_delegations(clp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\t/* Did we race with an attempt to give us more work? */\n\t\tif (clp->cl_state == 0)\n\t\t\tbreak;\n\t\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\t\tbreak;\n\t} while (atomic_read(&clp->cl_count) > 1);\n\treturn;\nout_error:\n\tif (strlen(section))\n\t\tsection_sep = \": \";\n\tpr_warn_ratelimited(\"NFS: state manager%s%s failed on NFSv4 server %s\"\n\t\t\t\" with error %d\\n\", section_sep, section,\n\t\t\tclp->cl_hostname, -status);\n\tssleep(1);\n\tnfs4_end_drain_session(clp);\n\tnfs4_clear_state_manager_bit(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "allow_signal",
          "args": [
            "SIGKILL"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nstatic int nfs4_run_state_manager(void *ptr)\n{\n\tstruct nfs_client *clp = ptr;\n\n\tallow_signal(SIGKILL);\n\tnfs4_state_manager(clp);\n\tnfs_put_client(clp);\n\tmodule_put_and_exit(0);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_state_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2326-2438",
    "snippet": "static void nfs4_state_manager(struct nfs_client *clp)\n{\n\tint status = 0;\n\tconst char *section = \"\", *section_sep = \"\";\n\n\t/* Ensure exclusive access to NFSv4 state */\n\tdo {\n\t\tif (test_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state)) {\n\t\t\tsection = \"purge state\";\n\t\t\tstatus = nfs4_purge_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state)) {\n\t\t\tsection = \"lease expired\";\n\t\t\t/* We're going to have to re-establish a clientid */\n\t\t\tstatus = nfs4_reclaim_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Initialize or reset the session */\n\t\tif (test_and_clear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state)) {\n\t\t\tsection = \"reset session\";\n\t\t\tstatus = nfs4_reset_session(clp);\n\t\t\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* Send BIND_CONN_TO_SESSION */\n\t\tif (test_and_clear_bit(NFS4CLNT_BIND_CONN_TO_SESSION,\n\t\t\t\t&clp->cl_state)) {\n\t\t\tsection = \"bind conn to session\";\n\t\t\tstatus = nfs4_bind_conn_to_session(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state)) {\n\t\t\tsection = \"check lease\";\n\t\t\tstatus = nfs4_check_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_MOVED, &clp->cl_state)) {\n\t\t\tsection = \"migration\";\n\t\t\tstatus = nfs4_handle_migration(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_LEASE_MOVED, &clp->cl_state)) {\n\t\t\tsection = \"lease moved\";\n\t\t\tstatus = nfs4_handle_lease_moved(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* First recover reboot state... */\n\t\tif (test_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state)) {\n\t\t\tsection = \"reclaim reboot\";\n\t\t\tstatus = nfs4_do_reclaim(clp,\n\t\t\t\tclp->cl_mvops->reboot_recovery_ops);\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t}\n\n\t\t/* Now recover expired state... */\n\t\tif (test_and_clear_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state)) {\n\t\t\tsection = \"reclaim nograce\";\n\t\t\tstatus = nfs4_do_reclaim(clp,\n\t\t\t\tclp->cl_mvops->nograce_recovery_ops);\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tnfs4_end_drain_session(clp);\n\t\tif (test_and_clear_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state)) {\n\t\t\tnfs_client_return_marked_delegations(clp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\t/* Did we race with an attempt to give us more work? */\n\t\tif (clp->cl_state == 0)\n\t\t\tbreak;\n\t\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\t\tbreak;\n\t} while (atomic_read(&clp->cl_count) > 1);\n\treturn;\nout_error:\n\tif (strlen(section))\n\t\tsection_sep = \": \";\n\tpr_warn_ratelimited(\"NFS: state manager%s%s failed on NFSv4 server %s\"\n\t\t\t\" with error %d\\n\", section_sep, section,\n\t\t\tclp->cl_hostname, -status);\n\tssleep(1);\n\tnfs4_end_drain_session(clp);\n\tnfs4_clear_state_manager_bit(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_clear_state_manager_bit",
          "args": [
            "clp"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_clear_state_manager_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1135-1142",
          "snippet": "static void nfs4_clear_state_manager_bit(struct nfs_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING);\n\trpc_wake_up(&clp->cl_rpcwaitq);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_clear_state_manager_bit(struct nfs_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING);\n\trpc_wake_up(&clp->cl_rpcwaitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_end_drain_session",
          "args": [
            "clp"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_end_drain_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "227-240",
          "snippet": "static void nfs4_end_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\n\tif (clp->cl_slot_tbl) {\n\t\tnfs4_end_drain_slot_table(clp->cl_slot_tbl);\n\t\treturn;\n\t}\n\n\tif (ses != NULL) {\n\t\tnfs4_end_drain_slot_table(&ses->bc_slot_table);\n\t\tnfs4_end_drain_slot_table(&ses->fc_slot_table);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_end_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\n\tif (clp->cl_slot_tbl) {\n\t\tnfs4_end_drain_slot_table(clp->cl_slot_tbl);\n\t\treturn;\n\t}\n\n\tif (ses != NULL) {\n\t\tnfs4_end_drain_slot_table(&ses->bc_slot_table);\n\t\tnfs4_end_drain_slot_table(&ses->fc_slot_table);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "1"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"NFS: state manager%s%s failed on NFSv4 server %s\"\n\t\t\t\" with error %d\\n\"",
            "section_sep",
            "section",
            "clp->cl_hostname",
            "-status"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "section"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&clp->cl_count"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS4CLNT_MANAGER_RUNNING",
            "&clp->cl_state"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_client_return_marked_delegations",
          "args": [
            "clp"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_client_return_marked_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "466-502",
          "snippet": "int nfs_client_return_marked_delegations(struct nfs_client *clp)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs_server *server;\n\tstruct inode *inode;\n\tint err = 0;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tlist_for_each_entry_rcu(delegation, &server->delegations,\n\t\t\t\t\t\t\t\tsuper_list) {\n\t\t\tif (!nfs_delegation_need_return(delegation))\n\t\t\t\tcontinue;\n\t\t\tif (!nfs_sb_active(server->super))\n\t\t\t\tcontinue;\n\t\t\tinode = nfs_delegation_grab_inode(delegation);\n\t\t\tif (inode == NULL) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tnfs_sb_deactive(server->super);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tdelegation = nfs_start_delegation_return_locked(NFS_I(inode));\n\t\t\trcu_read_unlock();\n\n\t\t\terr = nfs_end_delegation_return(inode, delegation, 0);\n\t\t\tiput(inode);\n\t\t\tnfs_sb_deactive(server->super);\n\t\t\tif (!err)\n\t\t\t\tgoto restart;\n\t\t\tset_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state);\n\t\t\treturn err;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nint nfs_client_return_marked_delegations(struct nfs_client *clp)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs_server *server;\n\tstruct inode *inode;\n\tint err = 0;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tlist_for_each_entry_rcu(delegation, &server->delegations,\n\t\t\t\t\t\t\t\tsuper_list) {\n\t\t\tif (!nfs_delegation_need_return(delegation))\n\t\t\t\tcontinue;\n\t\t\tif (!nfs_sb_active(server->super))\n\t\t\t\tcontinue;\n\t\t\tinode = nfs_delegation_grab_inode(delegation);\n\t\t\tif (inode == NULL) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tnfs_sb_deactive(server->super);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tdelegation = nfs_start_delegation_return_locked(NFS_I(inode));\n\t\t\trcu_read_unlock();\n\n\t\t\terr = nfs_end_delegation_return(inode, delegation, 0);\n\t\t\tiput(inode);\n\t\t\tnfs_sb_deactive(server->super);\n\t\t\tif (!err)\n\t\t\t\tgoto restart;\n\t\t\tset_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state);\n\t\t\treturn err;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS4CLNT_DELEGRETURN",
            "&clp->cl_state"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_do_reclaim",
          "args": [
            "clp",
            "clp->cl_mvops->nograce_recovery_ops"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_do_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1707-1746",
          "snippet": "static int nfs4_do_reclaim(struct nfs_client *clp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct nfs_server *server;\n\tstruct rb_node *pos;\n\tint status = 0;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tnfs4_purge_state_owners(server);\n\t\tspin_lock(&clp->cl_lock);\n\t\tfor (pos = rb_first(&server->state_owners);\n\t\t     pos != NULL;\n\t\t     pos = rb_next(pos)) {\n\t\t\tsp = rb_entry(pos,\n\t\t\t\tstruct nfs4_state_owner, so_server_node);\n\t\t\tif (!test_and_clear_bit(ops->owner_flag_bit,\n\t\t\t\t\t\t\t&sp->so_flags))\n\t\t\t\tcontinue;\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\tspin_unlock(&clp->cl_lock);\n\t\t\trcu_read_unlock();\n\n\t\t\tstatus = nfs4_reclaim_open_state(sp, ops);\n\t\t\tif (status < 0) {\n\t\t\t\tset_bit(ops->owner_flag_bit, &sp->so_flags);\n\t\t\t\tnfs4_put_state_owner(sp);\n\t\t\t\tstatus = nfs4_recovery_handle_error(clp, status);\n\t\t\t\treturn (status != 0) ? status : -EAGAIN;\n\t\t\t}\n\n\t\t\tnfs4_put_state_owner(sp);\n\t\t\tgoto restart;\n\t\t}\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_do_reclaim(struct nfs_client *clp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct nfs_server *server;\n\tstruct rb_node *pos;\n\tint status = 0;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tnfs4_purge_state_owners(server);\n\t\tspin_lock(&clp->cl_lock);\n\t\tfor (pos = rb_first(&server->state_owners);\n\t\t     pos != NULL;\n\t\t     pos = rb_next(pos)) {\n\t\t\tsp = rb_entry(pos,\n\t\t\t\tstruct nfs4_state_owner, so_server_node);\n\t\t\tif (!test_and_clear_bit(ops->owner_flag_bit,\n\t\t\t\t\t\t\t&sp->so_flags))\n\t\t\t\tcontinue;\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\tspin_unlock(&clp->cl_lock);\n\t\t\trcu_read_unlock();\n\n\t\t\tstatus = nfs4_reclaim_open_state(sp, ops);\n\t\t\tif (status < 0) {\n\t\t\t\tset_bit(ops->owner_flag_bit, &sp->so_flags);\n\t\t\t\tnfs4_put_state_owner(sp);\n\t\t\t\tstatus = nfs4_recovery_handle_error(clp, status);\n\t\t\t\treturn (status != 0) ? status : -EAGAIN;\n\t\t\t}\n\n\t\t\tnfs4_put_state_owner(sp);\n\t\t\tgoto restart;\n\t\t}\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_end_reclaim_reboot",
          "args": [
            "clp"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_end_reclaim_reboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1640-1651",
          "snippet": "static void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_recovery_ops *ops;\n\tstruct rpc_cred *cred;\n\n\tif (!nfs4_state_clear_reclaim_reboot(clp))\n\t\treturn;\n\tops = clp->cl_mvops->reboot_recovery_ops;\n\tcred = nfs4_get_clid_cred(clp);\n\tnfs4_reclaim_complete(clp, ops, cred);\n\tput_rpccred(cred);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_recovery_ops *ops;\n\tstruct rpc_cred *cred;\n\n\tif (!nfs4_state_clear_reclaim_reboot(clp))\n\t\treturn;\n\tops = clp->cl_mvops->reboot_recovery_ops;\n\tcred = nfs4_get_clid_cred(clp);\n\tnfs4_reclaim_complete(clp, ops, cred);\n\tput_rpccred(cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS4CLNT_RECLAIM_REBOOT",
            "&clp->cl_state"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_handle_lease_moved",
          "args": [
            "clp"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_handle_lease_moved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1995-2037",
          "snippet": "static int nfs4_handle_lease_moved(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\t\t\tclp->cl_mvops->state_renewal_ops;\n\tstruct nfs_server *server;\n\tstruct rpc_cred *cred;\n\n\tdprintk(\"%s: lease moved reported on \\\"%s\\\"\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\n\tspin_lock(&clp->cl_lock);\n\tcred = ops->get_state_renewal_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\tif (cred == NULL)\n\t\treturn -NFS4ERR_NOENT;\n\n\tclp->cl_mig_gen++;\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tstruct inode *inode;\n\t\tint status;\n\n\t\tif (server->mig_gen == clp->cl_mig_gen)\n\t\t\tcontinue;\n\t\tserver->mig_gen = clp->cl_mig_gen;\n\n\t\trcu_read_unlock();\n\n\t\tinode = server->super->s_root->d_inode;\n\t\tstatus = nfs4_proc_fsid_present(inode, cred);\n\t\tif (status != -NFS4ERR_MOVED)\n\t\t\tgoto restart;\t/* wasn't this one */\n\t\tif (nfs4_try_migration(server, cred) == -NFS4ERR_LEASE_MOVED)\n\t\t\tgoto restart;\t/* there are more */\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n\nout:\n\tput_rpccred(cred);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_handle_lease_moved(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\t\t\tclp->cl_mvops->state_renewal_ops;\n\tstruct nfs_server *server;\n\tstruct rpc_cred *cred;\n\n\tdprintk(\"%s: lease moved reported on \\\"%s\\\"\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\n\tspin_lock(&clp->cl_lock);\n\tcred = ops->get_state_renewal_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\tif (cred == NULL)\n\t\treturn -NFS4ERR_NOENT;\n\n\tclp->cl_mig_gen++;\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tstruct inode *inode;\n\t\tint status;\n\n\t\tif (server->mig_gen == clp->cl_mig_gen)\n\t\t\tcontinue;\n\t\tserver->mig_gen = clp->cl_mig_gen;\n\n\t\trcu_read_unlock();\n\n\t\tinode = server->super->s_root->d_inode;\n\t\tstatus = nfs4_proc_fsid_present(inode, cred);\n\t\tif (status != -NFS4ERR_MOVED)\n\t\t\tgoto restart;\t/* wasn't this one */\n\t\tif (nfs4_try_migration(server, cred) == -NFS4ERR_LEASE_MOVED)\n\t\t\tgoto restart;\t/* there are more */\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n\nout:\n\tput_rpccred(cred);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_handle_migration",
          "args": [
            "clp"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_handle_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1947-1988",
          "snippet": "static int nfs4_handle_migration(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\t\t\tclp->cl_mvops->state_renewal_ops;\n\tstruct nfs_server *server;\n\tstruct rpc_cred *cred;\n\n\tdprintk(\"%s: migration reported on \\\"%s\\\"\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\n\tspin_lock(&clp->cl_lock);\n\tcred = ops->get_state_renewal_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\tif (cred == NULL)\n\t\treturn -NFS4ERR_NOENT;\n\n\tclp->cl_mig_gen++;\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tint status;\n\n\t\tif (server->mig_gen == clp->cl_mig_gen)\n\t\t\tcontinue;\n\t\tserver->mig_gen = clp->cl_mig_gen;\n\n\t\tif (!test_and_clear_bit(NFS_MIG_IN_TRANSITION,\n\t\t\t\t\t\t&server->mig_status))\n\t\t\tcontinue;\n\n\t\trcu_read_unlock();\n\t\tstatus = nfs4_try_migration(server, cred);\n\t\tif (status < 0) {\n\t\t\tput_rpccred(cred);\n\t\t\treturn status;\n\t\t}\n\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tput_rpccred(cred);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_handle_migration(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\t\t\tclp->cl_mvops->state_renewal_ops;\n\tstruct nfs_server *server;\n\tstruct rpc_cred *cred;\n\n\tdprintk(\"%s: migration reported on \\\"%s\\\"\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\n\tspin_lock(&clp->cl_lock);\n\tcred = ops->get_state_renewal_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\tif (cred == NULL)\n\t\treturn -NFS4ERR_NOENT;\n\n\tclp->cl_mig_gen++;\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tint status;\n\n\t\tif (server->mig_gen == clp->cl_mig_gen)\n\t\t\tcontinue;\n\t\tserver->mig_gen = clp->cl_mig_gen;\n\n\t\tif (!test_and_clear_bit(NFS_MIG_IN_TRANSITION,\n\t\t\t\t\t\t&server->mig_status))\n\t\t\tcontinue;\n\n\t\trcu_read_unlock();\n\t\tstatus = nfs4_try_migration(server, cred);\n\t\tif (status < 0) {\n\t\t\tput_rpccred(cred);\n\t\t\treturn status;\n\t\t}\n\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tput_rpccred(cred);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_check_lease",
          "args": [
            "clp"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1748-1775",
          "snippet": "static int nfs4_check_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\tclp->cl_mvops->state_renewal_ops;\n\tint status;\n\n\t/* Is the client already known to have an expired lease? */\n\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\treturn 0;\n\tspin_lock(&clp->cl_lock);\n\tcred = ops->get_state_renewal_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\tif (cred == NULL) {\n\t\tcred = nfs4_get_clid_cred(clp);\n\t\tstatus = -ENOKEY;\n\t\tif (cred == NULL)\n\t\t\tgoto out;\n\t}\n\tstatus = ops->renew_lease(clp, cred);\n\tput_rpccred(cred);\n\tif (status == -ETIMEDOUT) {\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\t\treturn 0;\n\t}\nout:\n\treturn nfs4_recovery_handle_error(clp, status);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_check_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\tclp->cl_mvops->state_renewal_ops;\n\tint status;\n\n\t/* Is the client already known to have an expired lease? */\n\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\treturn 0;\n\tspin_lock(&clp->cl_lock);\n\tcred = ops->get_state_renewal_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\tif (cred == NULL) {\n\t\tcred = nfs4_get_clid_cred(clp);\n\t\tstatus = -ENOKEY;\n\t\tif (cred == NULL)\n\t\t\tgoto out;\n\t}\n\tstatus = ops->renew_lease(clp, cred);\n\tput_rpccred(cred);\n\tif (status == -ETIMEDOUT) {\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\t\treturn 0;\n\t}\nout:\n\treturn nfs4_recovery_handle_error(clp, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_bind_conn_to_session",
          "args": [
            "clp"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_bind_conn_to_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2320-2323",
          "snippet": "static int nfs4_bind_conn_to_session(struct nfs_client *clp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_bind_conn_to_session(struct nfs_client *clp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_reset_session",
          "args": [
            "clp"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reset_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2318-2318",
          "snippet": "static int nfs4_reset_session(struct nfs_client *clp) { return 0; }",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_reset_session(struct nfs_client *clp) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_reclaim_lease",
          "args": [
            "clp"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reclaim_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1848-1862",
          "snippet": "static int nfs4_reclaim_lease(struct nfs_client *clp)\n{\n\tint status;\n\n\tstatus = nfs4_establish_lease(clp);\n\tif (status < 0)\n\t\treturn nfs4_handle_reclaim_lease_error(clp, status);\n\tif (test_and_clear_bit(NFS4CLNT_SERVER_SCOPE_MISMATCH, &clp->cl_state))\n\t\tnfs4_state_start_reclaim_nograce(clp);\n\tif (!test_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\n\tclear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tclear_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_reclaim_lease(struct nfs_client *clp)\n{\n\tint status;\n\n\tstatus = nfs4_establish_lease(clp);\n\tif (status < 0)\n\t\treturn nfs4_handle_reclaim_lease_error(clp, status);\n\tif (test_and_clear_bit(NFS4CLNT_SERVER_SCOPE_MISMATCH, &clp->cl_state))\n\t\tnfs4_state_start_reclaim_nograce(clp);\n\tif (!test_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\n\tclear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tclear_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_purge_lease",
          "args": [
            "clp"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_purge_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1864-1875",
          "snippet": "static int nfs4_purge_lease(struct nfs_client *clp)\n{\n\tint status;\n\n\tstatus = nfs4_establish_lease(clp);\n\tif (status < 0)\n\t\treturn nfs4_handle_reclaim_lease_error(clp, status);\n\tclear_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tnfs4_state_start_reclaim_nograce(clp);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_purge_lease(struct nfs_client *clp)\n{\n\tint status;\n\n\tstatus = nfs4_establish_lease(clp);\n\tif (status < 0)\n\t\treturn nfs4_handle_reclaim_lease_error(clp, status);\n\tclear_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tnfs4_state_start_reclaim_nograce(clp);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_manager(struct nfs_client *clp)\n{\n\tint status = 0;\n\tconst char *section = \"\", *section_sep = \"\";\n\n\t/* Ensure exclusive access to NFSv4 state */\n\tdo {\n\t\tif (test_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state)) {\n\t\t\tsection = \"purge state\";\n\t\t\tstatus = nfs4_purge_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state)) {\n\t\t\tsection = \"lease expired\";\n\t\t\t/* We're going to have to re-establish a clientid */\n\t\t\tstatus = nfs4_reclaim_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Initialize or reset the session */\n\t\tif (test_and_clear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state)) {\n\t\t\tsection = \"reset session\";\n\t\t\tstatus = nfs4_reset_session(clp);\n\t\t\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* Send BIND_CONN_TO_SESSION */\n\t\tif (test_and_clear_bit(NFS4CLNT_BIND_CONN_TO_SESSION,\n\t\t\t\t&clp->cl_state)) {\n\t\t\tsection = \"bind conn to session\";\n\t\t\tstatus = nfs4_bind_conn_to_session(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state)) {\n\t\t\tsection = \"check lease\";\n\t\t\tstatus = nfs4_check_lease(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_MOVED, &clp->cl_state)) {\n\t\t\tsection = \"migration\";\n\t\t\tstatus = nfs4_handle_migration(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (test_and_clear_bit(NFS4CLNT_LEASE_MOVED, &clp->cl_state)) {\n\t\t\tsection = \"lease moved\";\n\t\t\tstatus = nfs4_handle_lease_moved(clp);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* First recover reboot state... */\n\t\tif (test_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state)) {\n\t\t\tsection = \"reclaim reboot\";\n\t\t\tstatus = nfs4_do_reclaim(clp,\n\t\t\t\tclp->cl_mvops->reboot_recovery_ops);\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t}\n\n\t\t/* Now recover expired state... */\n\t\tif (test_and_clear_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state)) {\n\t\t\tsection = \"reclaim nograce\";\n\t\t\tstatus = nfs4_do_reclaim(clp,\n\t\t\t\tclp->cl_mvops->nograce_recovery_ops);\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (status < 0)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tnfs4_end_drain_session(clp);\n\t\tif (test_and_clear_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state)) {\n\t\t\tnfs_client_return_marked_delegations(clp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\t/* Did we race with an attempt to give us more work? */\n\t\tif (clp->cl_state == 0)\n\t\t\tbreak;\n\t\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\t\tbreak;\n\t} while (atomic_read(&clp->cl_count) > 1);\n\treturn;\nout_error:\n\tif (strlen(section))\n\t\tsection_sep = \": \";\n\tpr_warn_ratelimited(\"NFS: state manager%s%s failed on NFSv4 server %s\"\n\t\t\t\" with error %d\\n\", section_sep, section,\n\t\t\tclp->cl_hostname, -status);\n\tssleep(1);\n\tnfs4_end_drain_session(clp);\n\tnfs4_clear_state_manager_bit(clp);\n}"
  },
  {
    "function_name": "nfs4_bind_conn_to_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2320-2323",
    "snippet": "static int nfs4_bind_conn_to_session(struct nfs_client *clp)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_bind_conn_to_session(struct nfs_client *clp)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_reset_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2318-2318",
    "snippet": "static int nfs4_reset_session(struct nfs_client *clp) { return 0; }",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_reset_session(struct nfs_client *clp) { return 0; }"
  },
  {
    "function_name": "nfs4_bind_conn_to_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2290-2316",
    "snippet": "static int nfs4_bind_conn_to_session(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint ret;\n\n\tif (!nfs4_has_session(clp))\n\t\treturn 0;\n\tnfs4_begin_drain_session(clp);\n\tcred = nfs4_get_clid_cred(clp);\n\tret = nfs4_proc_bind_conn_to_session(clp, cred);\n\tif (cred)\n\t\tput_rpccred(cred);\n\tclear_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\tswitch (ret) {\n\tcase 0:\n\t\tdprintk(\"%s: bind_conn_to_session was successful for server %s!\\n\",\n\t\t\t__func__, clp->cl_hostname);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\t\tssleep(1);\n\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\tbreak;\n\tdefault:\n\t\treturn nfs4_recovery_handle_error(clp, ret);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_recovery_handle_error",
          "args": [
            "clp",
            "ret"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_recovery_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1665-1705",
          "snippet": "static int nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs40_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_clear_reclaim_reboot(clp);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\t\t/* Zero session reset errors */\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: failed to handle error %d for server %s\\n\",\n\t\t\t\t\t__func__, error, clp->cl_hostname);\n\t\t\treturn error;\n\t}\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, error,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs40_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_clear_reclaim_reboot(clp);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\t\t/* Zero session reset errors */\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: failed to handle error %d for server %s\\n\",\n\t\t\t\t\t__func__, error, clp->cl_hostname);\n\t\t\treturn error;\n\t}\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, error,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_BIND_CONN_TO_SESSION",
            "&clp->cl_state"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "1"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: bind_conn_to_session was successful for server %s!\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS4CLNT_BIND_CONN_TO_SESSION",
            "&clp->cl_state"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_proc_bind_conn_to_session",
          "args": [
            "clp",
            "cred"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_bind_conn_to_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "6652-6699",
          "snippet": "int nfs4_proc_bind_conn_to_session(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status;\n\tstruct nfs41_bind_conn_to_session_args args = {\n\t\t.client = clp,\n\t\t.dir = NFS4_CDFC4_FORE_OR_BOTH,\n\t};\n\tstruct nfs41_bind_conn_to_session_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc =\n\t\t\t&nfs4_procedures[NFSPROC4_CLNT_BIND_CONN_TO_SESSION],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tnfs4_copy_sessionid(&args.sessionid, &clp->cl_session->sess_id);\n\tif (!(clp->cl_session->flags & SESSION4_BACK_CHAN))\n\t\targs.dir = NFS4_CDFC4_FORE;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\ttrace_nfs4_bind_conn_to_session(clp, status);\n\tif (status == 0) {\n\t\tif (memcmp(res.sessionid.data,\n\t\t    clp->cl_session->sess_id.data, NFS4_MAX_SESSIONID_LEN)) {\n\t\t\tdprintk(\"NFS: %s: Session ID mismatch\\n\", __func__);\n\t\t\tstatus = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((res.dir & args.dir) != res.dir || res.dir == 0) {\n\t\t\tdprintk(\"NFS: %s: Unexpected direction from server\\n\",\n\t\t\t\t__func__);\n\t\t\tstatus = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (res.use_conn_in_rdma_mode != args.use_conn_in_rdma_mode) {\n\t\t\tdprintk(\"NFS: %s: Server returned RDMA mode = true\\n\",\n\t\t\t\t__func__);\n\t\t\tstatus = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tdprintk(\"<-- %s status= %d\\n\", __func__, status);\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _nfs4_proc_open(struct nfs4_opendata *data);",
            "static int _nfs4_recover_proc_open(struct nfs4_opendata *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int _nfs4_proc_open(struct nfs4_opendata *data);\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data);\n\nint nfs4_proc_bind_conn_to_session(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status;\n\tstruct nfs41_bind_conn_to_session_args args = {\n\t\t.client = clp,\n\t\t.dir = NFS4_CDFC4_FORE_OR_BOTH,\n\t};\n\tstruct nfs41_bind_conn_to_session_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc =\n\t\t\t&nfs4_procedures[NFSPROC4_CLNT_BIND_CONN_TO_SESSION],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tnfs4_copy_sessionid(&args.sessionid, &clp->cl_session->sess_id);\n\tif (!(clp->cl_session->flags & SESSION4_BACK_CHAN))\n\t\targs.dir = NFS4_CDFC4_FORE;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\ttrace_nfs4_bind_conn_to_session(clp, status);\n\tif (status == 0) {\n\t\tif (memcmp(res.sessionid.data,\n\t\t    clp->cl_session->sess_id.data, NFS4_MAX_SESSIONID_LEN)) {\n\t\t\tdprintk(\"NFS: %s: Session ID mismatch\\n\", __func__);\n\t\t\tstatus = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((res.dir & args.dir) != res.dir || res.dir == 0) {\n\t\t\tdprintk(\"NFS: %s: Unexpected direction from server\\n\",\n\t\t\t\t__func__);\n\t\t\tstatus = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (res.use_conn_in_rdma_mode != args.use_conn_in_rdma_mode) {\n\t\t\tdprintk(\"NFS: %s: Server returned RDMA mode = true\\n\",\n\t\t\t\t__func__);\n\t\t\tstatus = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tdprintk(\"<-- %s status= %d\\n\", __func__, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_clid_cred",
          "args": [
            "clp"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_clid_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "376-384",
          "snippet": "struct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_begin_drain_session",
          "args": [
            "clp"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_begin_drain_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "255-269",
          "snippet": "static int nfs4_begin_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\tint ret = 0;\n\n\tif (clp->cl_slot_tbl)\n\t\treturn nfs4_drain_slot_tbl(clp->cl_slot_tbl);\n\n\t/* back channel */\n\tret = nfs4_drain_slot_tbl(&ses->bc_slot_table);\n\tif (ret)\n\t\treturn ret;\n\t/* fore channel */\n\treturn nfs4_drain_slot_tbl(&ses->fc_slot_table);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_begin_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\tint ret = 0;\n\n\tif (clp->cl_slot_tbl)\n\t\treturn nfs4_drain_slot_tbl(clp->cl_slot_tbl);\n\n\t/* back channel */\n\tret = nfs4_drain_slot_tbl(&ses->bc_slot_table);\n\tif (ret)\n\t\treturn ret;\n\t/* fore channel */\n\treturn nfs4_drain_slot_tbl(&ses->fc_slot_table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_has_session",
          "args": [
            "clp"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4session.h",
          "lines": "148-151",
          "snippet": "static inline int nfs4_has_session(const struct nfs_client *clp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nfs4_has_session(const struct nfs_client *clp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_bind_conn_to_session(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint ret;\n\n\tif (!nfs4_has_session(clp))\n\t\treturn 0;\n\tnfs4_begin_drain_session(clp);\n\tcred = nfs4_get_clid_cred(clp);\n\tret = nfs4_proc_bind_conn_to_session(clp, cred);\n\tif (cred)\n\t\tput_rpccred(cred);\n\tclear_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\tswitch (ret) {\n\tcase 0:\n\t\tdprintk(\"%s: bind_conn_to_session was successful for server %s!\\n\",\n\t\t\t__func__, clp->cl_hostname);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\t\tssleep(1);\n\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\tbreak;\n\tdefault:\n\t\treturn nfs4_recovery_handle_error(clp, ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_reset_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2247-2288",
    "snippet": "static int nfs4_reset_session(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint status;\n\n\tif (!nfs4_has_session(clp))\n\t\treturn 0;\n\tnfs4_begin_drain_session(clp);\n\tcred = nfs4_get_clid_cred(clp);\n\tstatus = nfs4_proc_destroy_session(clp->cl_session, cred);\n\tswitch (status) {\n\tcase 0:\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_DEADSESSION:\n\t\tbreak;\n\tcase -NFS4ERR_BACK_CHAN_BUSY:\n\tcase -NFS4ERR_DELAY:\n\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\tstatus = 0;\n\t\tssleep(1);\n\t\tgoto out;\n\tdefault:\n\t\tstatus = nfs4_recovery_handle_error(clp, status);\n\t\tgoto out;\n\t}\n\n\tmemset(clp->cl_session->sess_id.data, 0, NFS4_MAX_SESSIONID_LEN);\n\tstatus = nfs4_proc_create_session(clp, cred);\n\tif (status) {\n\t\tdprintk(\"%s: session reset failed with status %d for server %s!\\n\",\n\t\t\t__func__, status, clp->cl_hostname);\n\t\tstatus = nfs4_handle_reclaim_lease_error(clp, status);\n\t\tgoto out;\n\t}\n\tnfs41_finish_session_reset(clp);\n\tdprintk(\"%s: session reset was successful for server %s!\\n\",\n\t\t\t__func__, clp->cl_hostname);\nout:\n\tif (cred)\n\t\tput_rpccred(cred);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: session reset was successful for server %s!\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs41_finish_session_reset",
          "args": [
            "clp"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_finish_session_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "297-304",
          "snippet": "static void nfs41_finish_session_reset(struct nfs_client *clp)\n{\n\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\tclear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t/* create_session negotiated new slot table */\n\tclear_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\tnfs41_setup_state_renewal(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_finish_session_reset(struct nfs_client *clp)\n{\n\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\tclear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t/* create_session negotiated new slot table */\n\tclear_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\tnfs41_setup_state_renewal(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_handle_reclaim_lease_error",
          "args": [
            "clp",
            "status"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_handle_reclaim_lease_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1780-1824",
          "snippet": "static int nfs4_handle_reclaim_lease_error(struct nfs_client *clp, int status)\n{\n\tswitch (status) {\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tif (test_and_set_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state))\n\t\t\treturn -ESERVERFAULT;\n\t\t/* Lease confirmation error: retry after purging the lease */\n\t\tssleep(1);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tbreak;\n\tcase -NFS4ERR_CLID_INUSE:\n\t\tpr_err(\"NFS: Server %s reports our clientid is in use\\n\",\n\t\t\tclp->cl_hostname);\n\t\tnfs_mark_client_ready(clp, -EPERM);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\treturn -EPERM;\n\tcase -EACCES:\n\tcase -NFS4ERR_DELAY:\n\tcase -ETIMEDOUT:\n\tcase -EAGAIN:\n\t\tssleep(1);\n\t\tbreak;\n\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING)\n\t\t\tnfs_mark_client_ready(clp, -EPROTONOSUPPORT);\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\",\n\t\t\t\t__func__, -EPROTONOSUPPORT, clp->cl_hostname);\n\t\treturn -EPROTONOSUPPORT;\n\tcase -NFS4ERR_NOT_SAME: /* FixMe: implement recovery\n\t\t\t\t * in nfs4_exchange_id */\n\tdefault:\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\", __func__,\n\t\t\t\tstatus, clp->cl_hostname);\n\t\treturn status;\n\t}\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, status,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_handle_reclaim_lease_error(struct nfs_client *clp, int status)\n{\n\tswitch (status) {\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tif (test_and_set_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state))\n\t\t\treturn -ESERVERFAULT;\n\t\t/* Lease confirmation error: retry after purging the lease */\n\t\tssleep(1);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tbreak;\n\tcase -NFS4ERR_CLID_INUSE:\n\t\tpr_err(\"NFS: Server %s reports our clientid is in use\\n\",\n\t\t\tclp->cl_hostname);\n\t\tnfs_mark_client_ready(clp, -EPERM);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\treturn -EPERM;\n\tcase -EACCES:\n\tcase -NFS4ERR_DELAY:\n\tcase -ETIMEDOUT:\n\tcase -EAGAIN:\n\t\tssleep(1);\n\t\tbreak;\n\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING)\n\t\t\tnfs_mark_client_ready(clp, -EPROTONOSUPPORT);\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\",\n\t\t\t\t__func__, -EPROTONOSUPPORT, clp->cl_hostname);\n\t\treturn -EPROTONOSUPPORT;\n\tcase -NFS4ERR_NOT_SAME: /* FixMe: implement recovery\n\t\t\t\t * in nfs4_exchange_id */\n\tdefault:\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\", __func__,\n\t\t\t\tstatus, clp->cl_hostname);\n\t\treturn status;\n\t}\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, status,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: session reset failed with status %d for server %s!\\n\"",
            "__func__",
            "status",
            "clp->cl_hostname"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_proc_create_session",
          "args": [
            "clp",
            "cred"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_create_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "7293-7317",
          "snippet": "int nfs4_proc_create_session(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status;\n\tunsigned *ptr;\n\tstruct nfs4_session *session = clp->cl_session;\n\n\tdprintk(\"--> %s clp=%p session=%p\\n\", __func__, clp, session);\n\n\tstatus = _nfs4_proc_create_session(clp, cred);\n\tif (status)\n\t\tgoto out;\n\n\t/* Init or reset the session slot tables */\n\tstatus = nfs4_setup_session_slot_tables(session);\n\tdprintk(\"slot table setup returned %d\\n\", status);\n\tif (status)\n\t\tgoto out;\n\n\tptr = (unsigned *)&session->sess_id.data[0];\n\tdprintk(\"%s client>seqid %d sessionid %u:%u:%u:%u\\n\", __func__,\n\t\tclp->cl_seqid, ptr[0], ptr[1], ptr[2], ptr[3]);\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _nfs4_proc_open(struct nfs4_opendata *data);",
            "static int _nfs4_recover_proc_open(struct nfs4_opendata *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int _nfs4_proc_open(struct nfs4_opendata *data);\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data);\n\nint nfs4_proc_create_session(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status;\n\tunsigned *ptr;\n\tstruct nfs4_session *session = clp->cl_session;\n\n\tdprintk(\"--> %s clp=%p session=%p\\n\", __func__, clp, session);\n\n\tstatus = _nfs4_proc_create_session(clp, cred);\n\tif (status)\n\t\tgoto out;\n\n\t/* Init or reset the session slot tables */\n\tstatus = nfs4_setup_session_slot_tables(session);\n\tdprintk(\"slot table setup returned %d\\n\", status);\n\tif (status)\n\t\tgoto out;\n\n\tptr = (unsigned *)&session->sess_id.data[0];\n\tdprintk(\"%s client>seqid %d sessionid %u:%u:%u:%u\\n\", __func__,\n\t\tclp->cl_seqid, ptr[0], ptr[1], ptr[2], ptr[3]);\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "clp->cl_session->sess_id.data",
            "0",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_recovery_handle_error",
          "args": [
            "clp",
            "status"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_recovery_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1665-1705",
          "snippet": "static int nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs40_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_clear_reclaim_reboot(clp);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\t\t/* Zero session reset errors */\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: failed to handle error %d for server %s\\n\",\n\t\t\t\t\t__func__, error, clp->cl_hostname);\n\t\t\treturn error;\n\t}\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, error,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs40_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_clear_reclaim_reboot(clp);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\t\t/* Zero session reset errors */\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: failed to handle error %d for server %s\\n\",\n\t\t\t\t\t__func__, error, clp->cl_hostname);\n\t\t\treturn error;\n\t}\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, error,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "1"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_SESSION_RESET",
            "&clp->cl_state"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_proc_destroy_session",
          "args": [
            "clp->cl_session",
            "cred"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_destroy_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "7323-7348",
          "snippet": "int nfs4_proc_destroy_session(struct nfs4_session *session,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DESTROY_SESSION],\n\t\t.rpc_argp = session,\n\t\t.rpc_cred = cred,\n\t};\n\tint status = 0;\n\n\tdprintk(\"--> nfs4_proc_destroy_session\\n\");\n\n\t/* session is still being setup */\n\tif (!test_and_clear_bit(NFS4_SESSION_ESTABLISHED, &session->session_state))\n\t\treturn 0;\n\n\tstatus = rpc_call_sync(session->clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\ttrace_nfs4_destroy_session(session->clp, status);\n\n\tif (status)\n\t\tdprintk(\"NFS: Got error %d from the server on DESTROY_SESSION. \"\n\t\t\t\"Session has been destroyed regardless...\\n\", status);\n\n\tdprintk(\"<-- nfs4_proc_destroy_session\\n\");\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_proc_destroy_session(struct nfs4_session *session,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DESTROY_SESSION],\n\t\t.rpc_argp = session,\n\t\t.rpc_cred = cred,\n\t};\n\tint status = 0;\n\n\tdprintk(\"--> nfs4_proc_destroy_session\\n\");\n\n\t/* session is still being setup */\n\tif (!test_and_clear_bit(NFS4_SESSION_ESTABLISHED, &session->session_state))\n\t\treturn 0;\n\n\tstatus = rpc_call_sync(session->clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\ttrace_nfs4_destroy_session(session->clp, status);\n\n\tif (status)\n\t\tdprintk(\"NFS: Got error %d from the server on DESTROY_SESSION. \"\n\t\t\t\"Session has been destroyed regardless...\\n\", status);\n\n\tdprintk(\"<-- nfs4_proc_destroy_session\\n\");\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_clid_cred",
          "args": [
            "clp"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_clid_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "376-384",
          "snippet": "struct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_begin_drain_session",
          "args": [
            "clp"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_begin_drain_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "255-269",
          "snippet": "static int nfs4_begin_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\tint ret = 0;\n\n\tif (clp->cl_slot_tbl)\n\t\treturn nfs4_drain_slot_tbl(clp->cl_slot_tbl);\n\n\t/* back channel */\n\tret = nfs4_drain_slot_tbl(&ses->bc_slot_table);\n\tif (ret)\n\t\treturn ret;\n\t/* fore channel */\n\treturn nfs4_drain_slot_tbl(&ses->fc_slot_table);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_begin_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\tint ret = 0;\n\n\tif (clp->cl_slot_tbl)\n\t\treturn nfs4_drain_slot_tbl(clp->cl_slot_tbl);\n\n\t/* back channel */\n\tret = nfs4_drain_slot_tbl(&ses->bc_slot_table);\n\tif (ret)\n\t\treturn ret;\n\t/* fore channel */\n\treturn nfs4_drain_slot_tbl(&ses->fc_slot_table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_has_session",
          "args": [
            "clp"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4session.h",
          "lines": "148-151",
          "snippet": "static inline int nfs4_has_session(const struct nfs_client *clp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nfs4_has_session(const struct nfs_client *clp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_reset_session(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint status;\n\n\tif (!nfs4_has_session(clp))\n\t\treturn 0;\n\tnfs4_begin_drain_session(clp);\n\tcred = nfs4_get_clid_cred(clp);\n\tstatus = nfs4_proc_destroy_session(clp->cl_session, cred);\n\tswitch (status) {\n\tcase 0:\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_DEADSESSION:\n\t\tbreak;\n\tcase -NFS4ERR_BACK_CHAN_BUSY:\n\tcase -NFS4ERR_DELAY:\n\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\tstatus = 0;\n\t\tssleep(1);\n\t\tgoto out;\n\tdefault:\n\t\tstatus = nfs4_recovery_handle_error(clp, status);\n\t\tgoto out;\n\t}\n\n\tmemset(clp->cl_session->sess_id.data, 0, NFS4_MAX_SESSIONID_LEN);\n\tstatus = nfs4_proc_create_session(clp, cred);\n\tif (status) {\n\t\tdprintk(\"%s: session reset failed with status %d for server %s!\\n\",\n\t\t\t__func__, status, clp->cl_hostname);\n\t\tstatus = nfs4_handle_reclaim_lease_error(clp, status);\n\t\tgoto out;\n\t}\n\tnfs41_finish_session_reset(clp);\n\tdprintk(\"%s: session reset was successful for server %s!\\n\",\n\t\t\t__func__, clp->cl_hostname);\nout:\n\tif (cred)\n\t\tput_rpccred(cred);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs41_handle_sequence_flag_errors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2222-2245",
    "snippet": "void nfs41_handle_sequence_flag_errors(struct nfs_client *clp, u32 flags)\n{\n\tif (!flags)\n\t\treturn;\n\n\tdprintk(\"%s: \\\"%s\\\" (client ID %llx) flags=0x%08x\\n\",\n\t\t__func__, clp->cl_hostname, clp->cl_clientid, flags);\n\n\tif (flags & SEQ4_STATUS_RESTART_RECLAIM_NEEDED)\n\t\tnfs41_handle_server_reboot(clp);\n\tif (flags & (SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED |\n\t\t\t    SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED |\n\t\t\t    SEQ4_STATUS_ADMIN_STATE_REVOKED))\n\t\tnfs41_handle_state_revoked(clp);\n\tif (flags & SEQ4_STATUS_LEASE_MOVED)\n\t\tnfs4_schedule_lease_moved_recovery(clp);\n\tif (flags & SEQ4_STATUS_RECALLABLE_STATE_REVOKED)\n\t\tnfs41_handle_recallable_state_revoked(clp);\n\tif (flags & SEQ4_STATUS_BACKCHANNEL_FAULT)\n\t\tnfs41_handle_backchannel_fault(clp);\n\telse if (flags & (SEQ4_STATUS_CB_PATH_DOWN |\n\t\t\t\tSEQ4_STATUS_CB_PATH_DOWN_SESSION))\n\t\tnfs41_handle_cb_path_down(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs41_handle_cb_path_down",
          "args": [
            "clp"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_handle_cb_path_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2215-2220",
          "snippet": "static void nfs41_handle_cb_path_down(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_BIND_CONN_TO_SESSION,\n\t\t&clp->cl_state) == 0)\n\t\tnfs4_schedule_state_manager(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_handle_cb_path_down(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_BIND_CONN_TO_SESSION,\n\t\t&clp->cl_state) == 0)\n\t\tnfs4_schedule_state_manager(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_handle_backchannel_fault",
          "args": [
            "clp"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_handle_backchannel_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2206-2213",
          "snippet": "static void nfs41_handle_backchannel_fault(struct nfs_client *clp)\n{\n\tnfs_expire_all_delegations(clp);\n\tif (test_and_set_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state) == 0)\n\t\tnfs4_schedule_state_manager(clp);\n\tdprintk(\"%s: server %s declared a backchannel fault\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_handle_backchannel_fault(struct nfs_client *clp)\n{\n\tnfs_expire_all_delegations(clp);\n\tif (test_and_set_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state) == 0)\n\t\tnfs4_schedule_state_manager(clp);\n\tdprintk(\"%s: server %s declared a backchannel fault\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_handle_recallable_state_revoked",
          "args": [
            "clp"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_handle_recallable_state_revoked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2198-2204",
          "snippet": "static void nfs41_handle_recallable_state_revoked(struct nfs_client *clp)\n{\n\t/* This will need to handle layouts too */\n\tnfs_expire_all_delegations(clp);\n\tdprintk(\"%s: Recallable state revoked on server %s!\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_handle_recallable_state_revoked(struct nfs_client *clp)\n{\n\t/* This will need to handle layouts too */\n\tnfs_expire_all_delegations(clp);\n\tdprintk(\"%s: Recallable state revoked on server %s!\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_schedule_lease_moved_recovery",
          "args": [
            "clp"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_lease_moved_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1231-1238",
          "snippet": "void nfs4_schedule_lease_moved_recovery(struct nfs_client *clp)\n{\n\tdprintk(\"%s: scheduling lease-moved recovery for client ID %llx on %s\\n\",\n\t\t__func__, clp->cl_clientid, clp->cl_hostname);\n\n\tset_bit(NFS4CLNT_LEASE_MOVED, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_schedule_lease_moved_recovery(struct nfs_client *clp)\n{\n\tdprintk(\"%s: scheduling lease-moved recovery for client ID %llx on %s\\n\",\n\t\t__func__, clp->cl_clientid, clp->cl_hostname);\n\n\tset_bit(NFS4CLNT_LEASE_MOVED, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_handle_state_revoked",
          "args": [
            "clp"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_handle_state_revoked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2192-2196",
          "snippet": "static void nfs41_handle_state_revoked(struct nfs_client *clp)\n{\n\tnfs4_reset_all_state(clp);\n\tdprintk(\"%s: state revoked on server %s\\n\", __func__, clp->cl_hostname);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_handle_state_revoked(struct nfs_client *clp)\n{\n\tnfs4_reset_all_state(clp);\n\tdprintk(\"%s: state revoked on server %s\\n\", __func__, clp->cl_hostname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_handle_server_reboot",
          "args": [
            "clp"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_handle_server_reboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2182-2190",
          "snippet": "static void nfs41_handle_server_reboot(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) == 0) {\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tdprintk(\"%s: server %s rebooted!\\n\", __func__,\n\t\t\t\tclp->cl_hostname);\n\t\tnfs4_schedule_state_manager(clp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_handle_server_reboot(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) == 0) {\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tdprintk(\"%s: server %s rebooted!\\n\", __func__,\n\t\t\t\tclp->cl_hostname);\n\t\tnfs4_schedule_state_manager(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: \\\"%s\\\" (client ID %llx) flags=0x%08x\\n\"",
            "__func__",
            "clp->cl_hostname",
            "clp->cl_clientid",
            "flags"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs41_handle_sequence_flag_errors(struct nfs_client *clp, u32 flags)\n{\n\tif (!flags)\n\t\treturn;\n\n\tdprintk(\"%s: \\\"%s\\\" (client ID %llx) flags=0x%08x\\n\",\n\t\t__func__, clp->cl_hostname, clp->cl_clientid, flags);\n\n\tif (flags & SEQ4_STATUS_RESTART_RECLAIM_NEEDED)\n\t\tnfs41_handle_server_reboot(clp);\n\tif (flags & (SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED |\n\t\t\t    SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED |\n\t\t\t    SEQ4_STATUS_ADMIN_STATE_REVOKED))\n\t\tnfs41_handle_state_revoked(clp);\n\tif (flags & SEQ4_STATUS_LEASE_MOVED)\n\t\tnfs4_schedule_lease_moved_recovery(clp);\n\tif (flags & SEQ4_STATUS_RECALLABLE_STATE_REVOKED)\n\t\tnfs41_handle_recallable_state_revoked(clp);\n\tif (flags & SEQ4_STATUS_BACKCHANNEL_FAULT)\n\t\tnfs41_handle_backchannel_fault(clp);\n\telse if (flags & (SEQ4_STATUS_CB_PATH_DOWN |\n\t\t\t\tSEQ4_STATUS_CB_PATH_DOWN_SESSION))\n\t\tnfs41_handle_cb_path_down(clp);\n}"
  },
  {
    "function_name": "nfs41_handle_cb_path_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2215-2220",
    "snippet": "static void nfs41_handle_cb_path_down(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_BIND_CONN_TO_SESSION,\n\t\t&clp->cl_state) == 0)\n\t\tnfs4_schedule_state_manager(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS4CLNT_BIND_CONN_TO_SESSION",
            "&clp->cl_state"
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_handle_cb_path_down(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_BIND_CONN_TO_SESSION,\n\t\t&clp->cl_state) == 0)\n\t\tnfs4_schedule_state_manager(clp);\n}"
  },
  {
    "function_name": "nfs41_handle_backchannel_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2206-2213",
    "snippet": "static void nfs41_handle_backchannel_fault(struct nfs_client *clp)\n{\n\tnfs_expire_all_delegations(clp);\n\tif (test_and_set_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state) == 0)\n\t\tnfs4_schedule_state_manager(clp);\n\tdprintk(\"%s: server %s declared a backchannel fault\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: server %s declared a backchannel fault\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS4CLNT_SESSION_RESET",
            "&clp->cl_state"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_expire_all_delegations",
          "args": [
            "clp"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_expire_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "590-594",
          "snippet": "void nfs_expire_all_delegations(struct nfs_client *clp)\n{\n\tnfs_client_mark_return_all_delegations(clp);\n\tnfs_delegation_run_state_manager(clp);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nvoid nfs_expire_all_delegations(struct nfs_client *clp)\n{\n\tnfs_client_mark_return_all_delegations(clp);\n\tnfs_delegation_run_state_manager(clp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_handle_backchannel_fault(struct nfs_client *clp)\n{\n\tnfs_expire_all_delegations(clp);\n\tif (test_and_set_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state) == 0)\n\t\tnfs4_schedule_state_manager(clp);\n\tdprintk(\"%s: server %s declared a backchannel fault\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}"
  },
  {
    "function_name": "nfs41_handle_recallable_state_revoked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2198-2204",
    "snippet": "static void nfs41_handle_recallable_state_revoked(struct nfs_client *clp)\n{\n\t/* This will need to handle layouts too */\n\tnfs_expire_all_delegations(clp);\n\tdprintk(\"%s: Recallable state revoked on server %s!\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Recallable state revoked on server %s!\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_expire_all_delegations",
          "args": [
            "clp"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_expire_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "590-594",
          "snippet": "void nfs_expire_all_delegations(struct nfs_client *clp)\n{\n\tnfs_client_mark_return_all_delegations(clp);\n\tnfs_delegation_run_state_manager(clp);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nvoid nfs_expire_all_delegations(struct nfs_client *clp)\n{\n\tnfs_client_mark_return_all_delegations(clp);\n\tnfs_delegation_run_state_manager(clp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_handle_recallable_state_revoked(struct nfs_client *clp)\n{\n\t/* This will need to handle layouts too */\n\tnfs_expire_all_delegations(clp);\n\tdprintk(\"%s: Recallable state revoked on server %s!\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}"
  },
  {
    "function_name": "nfs41_handle_state_revoked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2192-2196",
    "snippet": "static void nfs41_handle_state_revoked(struct nfs_client *clp)\n{\n\tnfs4_reset_all_state(clp);\n\tdprintk(\"%s: state revoked on server %s\\n\", __func__, clp->cl_hostname);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: state revoked on server %s\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_reset_all_state",
          "args": [
            "clp"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reset_all_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2170-2180",
          "snippet": "static void nfs4_reset_all_state(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) == 0) {\n\t\tset_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\tdprintk(\"%s: scheduling reset of all state for server %s!\\n\",\n\t\t\t\t__func__, clp->cl_hostname);\n\t\tnfs4_schedule_state_manager(clp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_reset_all_state(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) == 0) {\n\t\tset_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\tdprintk(\"%s: scheduling reset of all state for server %s!\\n\",\n\t\t\t\t__func__, clp->cl_hostname);\n\t\tnfs4_schedule_state_manager(clp);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_handle_state_revoked(struct nfs_client *clp)\n{\n\tnfs4_reset_all_state(clp);\n\tdprintk(\"%s: state revoked on server %s\\n\", __func__, clp->cl_hostname);\n}"
  },
  {
    "function_name": "nfs41_handle_server_reboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2182-2190",
    "snippet": "static void nfs41_handle_server_reboot(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) == 0) {\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tdprintk(\"%s: server %s rebooted!\\n\", __func__,\n\t\t\t\tclp->cl_hostname);\n\t\tnfs4_schedule_state_manager(clp);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: server %s rebooted!\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_state_start_reclaim_reboot",
          "args": [
            "clp"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_start_reclaim_reboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1584-1589",
          "snippet": "static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\t/* Mark all delegations for reclaim */\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\t/* Mark all delegations for reclaim */\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS4CLNT_LEASE_EXPIRED",
            "&clp->cl_state"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_handle_server_reboot(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) == 0) {\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tdprintk(\"%s: server %s rebooted!\\n\", __func__,\n\t\t\t\tclp->cl_hostname);\n\t\tnfs4_schedule_state_manager(clp);\n\t}\n}"
  },
  {
    "function_name": "nfs4_reset_all_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2170-2180",
    "snippet": "static void nfs4_reset_all_state(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) == 0) {\n\t\tset_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\tdprintk(\"%s: scheduling reset of all state for server %s!\\n\",\n\t\t\t\t__func__, clp->cl_hostname);\n\t\tnfs4_schedule_state_manager(clp);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: scheduling reset of all state for server %s!\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_state_start_reclaim_nograce",
          "args": [
            "clp"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_start_reclaim_nograce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1659-1663",
          "snippet": "static void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_delegation_clear_all(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_delegation_clear_all(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS4CLNT_LEASE_CONFIRM",
            "&clp->cl_state"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_PURGE_STATE",
            "&clp->cl_state"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS4CLNT_LEASE_EXPIRED",
            "&clp->cl_state"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_reset_all_state(struct nfs_client *clp)\n{\n\tif (test_and_set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) == 0) {\n\t\tset_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\tdprintk(\"%s: scheduling reset of all state for server %s!\\n\",\n\t\t\t\t__func__, clp->cl_hostname);\n\t\tnfs4_schedule_state_manager(clp);\n\t}\n}"
  },
  {
    "function_name": "nfs41_server_notify_highest_slotid_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2165-2168",
    "snippet": "void nfs41_server_notify_highest_slotid_update(struct nfs_client *clp)\n{\n\tnfs41_ping_server(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs41_ping_server",
          "args": [
            "clp"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_ping_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2153-2158",
          "snippet": "static void nfs41_ping_server(struct nfs_client *clp)\n{\n\t/* Use CHECK_LEASE to ping the server with a SEQUENCE */\n\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_ping_server(struct nfs_client *clp)\n{\n\t/* Use CHECK_LEASE to ping the server with a SEQUENCE */\n\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs41_server_notify_highest_slotid_update(struct nfs_client *clp)\n{\n\tnfs41_ping_server(clp);\n}"
  },
  {
    "function_name": "nfs41_server_notify_target_slotid_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2160-2163",
    "snippet": "void nfs41_server_notify_target_slotid_update(struct nfs_client *clp)\n{\n\tnfs41_ping_server(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs41_ping_server",
          "args": [
            "clp"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_ping_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2153-2158",
          "snippet": "static void nfs41_ping_server(struct nfs_client *clp)\n{\n\t/* Use CHECK_LEASE to ping the server with a SEQUENCE */\n\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_ping_server(struct nfs_client *clp)\n{\n\t/* Use CHECK_LEASE to ping the server with a SEQUENCE */\n\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs41_server_notify_target_slotid_update(struct nfs_client *clp)\n{\n\tnfs41_ping_server(clp);\n}"
  },
  {
    "function_name": "nfs41_ping_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2153-2158",
    "snippet": "static void nfs41_ping_server(struct nfs_client *clp)\n{\n\t/* Use CHECK_LEASE to ping the server with a SEQUENCE */\n\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_CHECK_LEASE",
            "&clp->cl_state"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_ping_server(struct nfs_client *clp)\n{\n\t/* Use CHECK_LEASE to ping the server with a SEQUENCE */\n\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}"
  },
  {
    "function_name": "nfs4_schedule_session_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2138-2150",
    "snippet": "void nfs4_schedule_session_recovery(struct nfs4_session *session, int err)\n{\n\tstruct nfs_client *clp = session->clp;\n\n\tswitch (err) {\n\tdefault:\n\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t}\n\tnfs4_schedule_lease_recovery(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_lease_recovery",
          "args": [
            "clp"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_lease_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1177-1186",
          "snippet": "void nfs4_schedule_lease_recovery(struct nfs_client *clp)\n{\n\tif (!clp)\n\t\treturn;\n\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tdprintk(\"%s: scheduling lease recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_schedule_lease_recovery(struct nfs_client *clp)\n{\n\tif (!clp)\n\t\treturn;\n\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tdprintk(\"%s: scheduling lease recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_BIND_CONN_TO_SESSION",
            "&clp->cl_state"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_schedule_session_recovery(struct nfs4_session *session, int err)\n{\n\tstruct nfs_client *clp = session->clp;\n\n\tswitch (err) {\n\tdefault:\n\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t}\n\tnfs4_schedule_lease_recovery(clp);\n}"
  },
  {
    "function_name": "nfs4_discover_server_trunking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "2052-2135",
    "snippet": "int nfs4_discover_server_trunking(struct nfs_client *clp,\n\t\t\t\t  struct nfs_client **result)\n{\n\tconst struct nfs4_state_recovery_ops *ops =\n\t\t\t\tclp->cl_mvops->reboot_recovery_ops;\n\tstruct rpc_clnt *clnt;\n\tstruct rpc_cred *cred;\n\tint i, status;\n\n\tdprintk(\"NFS: %s: testing '%s'\\n\", __func__, clp->cl_hostname);\n\n\tclnt = clp->cl_rpcclient;\n\ti = 0;\n\n\tmutex_lock(&nfs_clid_init_mutex);\nagain:\n\tstatus  = -ENOENT;\n\tcred = nfs4_get_clid_cred(clp);\n\tif (cred == NULL)\n\t\tgoto out_unlock;\n\n\tstatus = ops->detect_trunking(clp, result, cred);\n\tput_rpccred(cred);\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ETIMEDOUT:\n\t\tif (clnt->cl_softrtry)\n\t\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -EAGAIN:\n\t\tssleep(1);\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tdprintk(\"NFS: %s after status %d, retrying\\n\",\n\t\t\t__func__, status);\n\t\tgoto again;\n\tcase -EACCES:\n\t\tif (i++ == 0) {\n\t\t\tnfs4_root_machine_cred(clp);\n\t\t\tgoto again;\n\t\t}\n\t\tif (clnt->cl_auth->au_flavor == RPC_AUTH_UNIX)\n\t\t\tbreak;\n\tcase -NFS4ERR_CLID_INUSE:\n\tcase -NFS4ERR_WRONGSEC:\n\t\t/* No point in retrying if we already used RPC_AUTH_UNIX */\n\t\tif (clnt->cl_auth->au_flavor == RPC_AUTH_UNIX) {\n\t\t\tstatus = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tclnt = rpc_clone_client_set_auth(clnt, RPC_AUTH_UNIX);\n\t\tif (IS_ERR(clnt)) {\n\t\t\tstatus = PTR_ERR(clnt);\n\t\t\tbreak;\n\t\t}\n\t\t/* Note: this is safe because we haven't yet marked the\n\t\t * client as ready, so we are the only user of\n\t\t * clp->cl_rpcclient\n\t\t */\n\t\tclnt = xchg(&clp->cl_rpcclient, clnt);\n\t\trpc_shutdown_client(clnt);\n\t\tclnt = clp->cl_rpcclient;\n\t\tgoto again;\n\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\tstatus = -EPROTONOSUPPORT;\n\t\tbreak;\n\n\tcase -EKEYEXPIRED:\n\tcase -NFS4ERR_NOT_SAME: /* FixMe: implement recovery\n\t\t\t\t * in nfs4_exchange_id */\n\t\tstatus = -EKEYEXPIRED;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"NFS: %s unhandled error %d. Exiting with error EIO\\n\",\n\t\t\t\t__func__, status);\n\t\tstatus = -EIO;\n\t}\n\nout_unlock:\n\tmutex_unlock(&nfs_clid_init_mutex);\n\tdprintk(\"NFS: %s: status = %d\\n\", __func__, status);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nfs_clid_init_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: %s: status = %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfs_clid_init_mutex"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"NFS: %s unhandled error %d. Exiting with error EIO\\n\"",
            "__func__",
            "status"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_shutdown_client",
          "args": [
            "clnt"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&clp->cl_rpcclient",
            "clnt"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "clnt"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "clnt"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_clone_client_set_auth",
          "args": [
            "clnt",
            "RPC_AUTH_UNIX"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_root_machine_cred",
          "args": [
            "clp"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_root_machine_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "157-168",
          "snippet": "static void nfs4_root_machine_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred, *new;\n\n\tnew = rpc_lookup_machine_cred(NULL);\n\tspin_lock(&clp->cl_lock);\n\tcred = clp->cl_machine_cred;\n\tclp->cl_machine_cred = new;\n\tspin_unlock(&clp->cl_lock);\n\tif (cred != NULL)\n\t\tput_rpccred(cred);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_root_machine_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred, *new;\n\n\tnew = rpc_lookup_machine_cred(NULL);\n\tspin_lock(&clp->cl_lock);\n\tcred = clp->cl_machine_cred;\n\tclp->cl_machine_cred = new;\n\tspin_unlock(&clp->cl_lock);\n\tif (cred != NULL)\n\t\tput_rpccred(cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: %s after status %d, retrying\\n\"",
            "__func__",
            "status"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "1"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->detect_trunking",
          "args": [
            "clp",
            "result",
            "cred"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_get_clid_cred",
          "args": [
            "clp"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_clid_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "376-384",
          "snippet": "struct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfs_clid_init_mutex"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: %s: testing '%s'\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(nfs_clid_init_mutex);\n\nint nfs4_discover_server_trunking(struct nfs_client *clp,\n\t\t\t\t  struct nfs_client **result)\n{\n\tconst struct nfs4_state_recovery_ops *ops =\n\t\t\t\tclp->cl_mvops->reboot_recovery_ops;\n\tstruct rpc_clnt *clnt;\n\tstruct rpc_cred *cred;\n\tint i, status;\n\n\tdprintk(\"NFS: %s: testing '%s'\\n\", __func__, clp->cl_hostname);\n\n\tclnt = clp->cl_rpcclient;\n\ti = 0;\n\n\tmutex_lock(&nfs_clid_init_mutex);\nagain:\n\tstatus  = -ENOENT;\n\tcred = nfs4_get_clid_cred(clp);\n\tif (cred == NULL)\n\t\tgoto out_unlock;\n\n\tstatus = ops->detect_trunking(clp, result, cred);\n\tput_rpccred(cred);\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ETIMEDOUT:\n\t\tif (clnt->cl_softrtry)\n\t\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -EAGAIN:\n\t\tssleep(1);\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tdprintk(\"NFS: %s after status %d, retrying\\n\",\n\t\t\t__func__, status);\n\t\tgoto again;\n\tcase -EACCES:\n\t\tif (i++ == 0) {\n\t\t\tnfs4_root_machine_cred(clp);\n\t\t\tgoto again;\n\t\t}\n\t\tif (clnt->cl_auth->au_flavor == RPC_AUTH_UNIX)\n\t\t\tbreak;\n\tcase -NFS4ERR_CLID_INUSE:\n\tcase -NFS4ERR_WRONGSEC:\n\t\t/* No point in retrying if we already used RPC_AUTH_UNIX */\n\t\tif (clnt->cl_auth->au_flavor == RPC_AUTH_UNIX) {\n\t\t\tstatus = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tclnt = rpc_clone_client_set_auth(clnt, RPC_AUTH_UNIX);\n\t\tif (IS_ERR(clnt)) {\n\t\t\tstatus = PTR_ERR(clnt);\n\t\t\tbreak;\n\t\t}\n\t\t/* Note: this is safe because we haven't yet marked the\n\t\t * client as ready, so we are the only user of\n\t\t * clp->cl_rpcclient\n\t\t */\n\t\tclnt = xchg(&clp->cl_rpcclient, clnt);\n\t\trpc_shutdown_client(clnt);\n\t\tclnt = clp->cl_rpcclient;\n\t\tgoto again;\n\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\tstatus = -EPROTONOSUPPORT;\n\t\tbreak;\n\n\tcase -EKEYEXPIRED:\n\tcase -NFS4ERR_NOT_SAME: /* FixMe: implement recovery\n\t\t\t\t * in nfs4_exchange_id */\n\t\tstatus = -EKEYEXPIRED;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"NFS: %s unhandled error %d. Exiting with error EIO\\n\",\n\t\t\t\t__func__, status);\n\t\tstatus = -EIO;\n\t}\n\nout_unlock:\n\tmutex_unlock(&nfs_clid_init_mutex);\n\tdprintk(\"NFS: %s: status = %d\\n\", __func__, status);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_handle_lease_moved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1995-2037",
    "snippet": "static int nfs4_handle_lease_moved(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\t\t\tclp->cl_mvops->state_renewal_ops;\n\tstruct nfs_server *server;\n\tstruct rpc_cred *cred;\n\n\tdprintk(\"%s: lease moved reported on \\\"%s\\\"\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\n\tspin_lock(&clp->cl_lock);\n\tcred = ops->get_state_renewal_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\tif (cred == NULL)\n\t\treturn -NFS4ERR_NOENT;\n\n\tclp->cl_mig_gen++;\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tstruct inode *inode;\n\t\tint status;\n\n\t\tif (server->mig_gen == clp->cl_mig_gen)\n\t\t\tcontinue;\n\t\tserver->mig_gen = clp->cl_mig_gen;\n\n\t\trcu_read_unlock();\n\n\t\tinode = server->super->s_root->d_inode;\n\t\tstatus = nfs4_proc_fsid_present(inode, cred);\n\t\tif (status != -NFS4ERR_MOVED)\n\t\t\tgoto restart;\t/* wasn't this one */\n\t\tif (nfs4_try_migration(server, cred) == -NFS4ERR_LEASE_MOVED)\n\t\t\tgoto restart;\t/* there are more */\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n\nout:\n\tput_rpccred(cred);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_try_migration",
          "args": [
            "server",
            "cred"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_try_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1884-1942",
          "snippet": "static int nfs4_try_migration(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_fs_locations *locations = NULL;\n\tstruct inode *inode;\n\tstruct page *page;\n\tint status, result;\n\n\tdprintk(\"--> %s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t\t(unsigned long long)server->fsid.major,\n\t\t\t(unsigned long long)server->fsid.minor,\n\t\t\tclp->cl_hostname);\n\n\tresult = 0;\n\tpage = alloc_page(GFP_KERNEL);\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (page == NULL || locations == NULL) {\n\t\tdprintk(\"<-- %s: no memory\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tinode = server->super->s_root->d_inode;\n\tresult = nfs4_proc_get_locations(inode, locations, page, cred);\n\tif (result) {\n\t\tdprintk(\"<-- %s: failed to retrieve fs_locations: %d\\n\",\n\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\n\tresult = -NFS4ERR_NXIO;\n\tif (!(locations->fattr.valid & NFS_ATTR_FATTR_V4_LOCATIONS)) {\n\t\tdprintk(\"<-- %s: No fs_locations data, migration skipped\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tnfs4_begin_drain_session(clp);\n\n\tstatus = nfs4_replace_transport(server, locations);\n\tif (status != 0) {\n\t\tdprintk(\"<-- %s: failed to replace transport: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto out;\n\t}\n\n\tresult = 0;\n\tdprintk(\"<-- %s: migration succeeded\\n\", __func__);\n\nout:\n\tif (page != NULL)\n\t\t__free_page(page);\n\tkfree(locations);\n\tif (result) {\n\t\tpr_err(\"NFS: migration recovery failed (server %s)\\n\",\n\t\t\t\tclp->cl_hostname);\n\t\tset_bit(NFS_MIG_FAILED, &server->mig_status);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_try_migration(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_fs_locations *locations = NULL;\n\tstruct inode *inode;\n\tstruct page *page;\n\tint status, result;\n\n\tdprintk(\"--> %s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t\t(unsigned long long)server->fsid.major,\n\t\t\t(unsigned long long)server->fsid.minor,\n\t\t\tclp->cl_hostname);\n\n\tresult = 0;\n\tpage = alloc_page(GFP_KERNEL);\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (page == NULL || locations == NULL) {\n\t\tdprintk(\"<-- %s: no memory\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tinode = server->super->s_root->d_inode;\n\tresult = nfs4_proc_get_locations(inode, locations, page, cred);\n\tif (result) {\n\t\tdprintk(\"<-- %s: failed to retrieve fs_locations: %d\\n\",\n\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\n\tresult = -NFS4ERR_NXIO;\n\tif (!(locations->fattr.valid & NFS_ATTR_FATTR_V4_LOCATIONS)) {\n\t\tdprintk(\"<-- %s: No fs_locations data, migration skipped\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tnfs4_begin_drain_session(clp);\n\n\tstatus = nfs4_replace_transport(server, locations);\n\tif (status != 0) {\n\t\tdprintk(\"<-- %s: failed to replace transport: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto out;\n\t}\n\n\tresult = 0;\n\tdprintk(\"<-- %s: migration succeeded\\n\", __func__);\n\nout:\n\tif (page != NULL)\n\t\t__free_page(page);\n\tkfree(locations);\n\tif (result) {\n\t\tpr_err(\"NFS: migration recovery failed (server %s)\\n\",\n\t\t\t\tclp->cl_hostname);\n\t\tset_bit(NFS_MIG_FAILED, &server->mig_status);\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_proc_fsid_present",
          "args": [
            "inode",
            "cred"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_fsid_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "6517-6539",
          "snippet": "int nfs4_proc_fsid_present(struct inode *inode, struct rpc_cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tconst struct nfs4_mig_recovery_ops *ops =\n\t\t\t\t\tclp->cl_mvops->mig_recovery_ops;\n\tstruct nfs4_exception exception = { };\n\tint status;\n\n\tdprintk(\"%s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t(unsigned long long)server->fsid.major,\n\t\t(unsigned long long)server->fsid.minor,\n\t\tclp->cl_hostname);\n\tnfs_display_fhandle(NFS_FH(inode), __func__);\n\n\tdo {\n\t\tstatus = ops->fsid_present(inode, cred);\n\t\tif (status != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, status, &exception);\n\t} while (exception.retry);\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_proc_fsid_present(struct inode *inode, struct rpc_cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tconst struct nfs4_mig_recovery_ops *ops =\n\t\t\t\t\tclp->cl_mvops->mig_recovery_ops;\n\tstruct nfs4_exception exception = { };\n\tint status;\n\n\tdprintk(\"%s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t(unsigned long long)server->fsid.major,\n\t\t(unsigned long long)server->fsid.minor,\n\t\tclp->cl_hostname);\n\tnfs_display_fhandle(NFS_FH(inode), __func__);\n\n\tdo {\n\t\tstatus = ops->fsid_present(inode, cred);\n\t\tif (status != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, status, &exception);\n\t} while (exception.retry);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "server",
            "&clp->cl_superblocks",
            "client_link"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_state_renewal_cred_locked",
          "args": [
            "clp"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: lease moved reported on \\\"%s\\\"\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_handle_lease_moved(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\t\t\tclp->cl_mvops->state_renewal_ops;\n\tstruct nfs_server *server;\n\tstruct rpc_cred *cred;\n\n\tdprintk(\"%s: lease moved reported on \\\"%s\\\"\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\n\tspin_lock(&clp->cl_lock);\n\tcred = ops->get_state_renewal_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\tif (cred == NULL)\n\t\treturn -NFS4ERR_NOENT;\n\n\tclp->cl_mig_gen++;\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tstruct inode *inode;\n\t\tint status;\n\n\t\tif (server->mig_gen == clp->cl_mig_gen)\n\t\t\tcontinue;\n\t\tserver->mig_gen = clp->cl_mig_gen;\n\n\t\trcu_read_unlock();\n\n\t\tinode = server->super->s_root->d_inode;\n\t\tstatus = nfs4_proc_fsid_present(inode, cred);\n\t\tif (status != -NFS4ERR_MOVED)\n\t\t\tgoto restart;\t/* wasn't this one */\n\t\tif (nfs4_try_migration(server, cred) == -NFS4ERR_LEASE_MOVED)\n\t\t\tgoto restart;\t/* there are more */\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n\nout:\n\tput_rpccred(cred);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_handle_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1947-1988",
    "snippet": "static int nfs4_handle_migration(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\t\t\tclp->cl_mvops->state_renewal_ops;\n\tstruct nfs_server *server;\n\tstruct rpc_cred *cred;\n\n\tdprintk(\"%s: migration reported on \\\"%s\\\"\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\n\tspin_lock(&clp->cl_lock);\n\tcred = ops->get_state_renewal_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\tif (cred == NULL)\n\t\treturn -NFS4ERR_NOENT;\n\n\tclp->cl_mig_gen++;\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tint status;\n\n\t\tif (server->mig_gen == clp->cl_mig_gen)\n\t\t\tcontinue;\n\t\tserver->mig_gen = clp->cl_mig_gen;\n\n\t\tif (!test_and_clear_bit(NFS_MIG_IN_TRANSITION,\n\t\t\t\t\t\t&server->mig_status))\n\t\t\tcontinue;\n\n\t\trcu_read_unlock();\n\t\tstatus = nfs4_try_migration(server, cred);\n\t\tif (status < 0) {\n\t\t\tput_rpccred(cred);\n\t\t\treturn status;\n\t\t}\n\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tput_rpccred(cred);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_try_migration",
          "args": [
            "server",
            "cred"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_try_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1884-1942",
          "snippet": "static int nfs4_try_migration(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_fs_locations *locations = NULL;\n\tstruct inode *inode;\n\tstruct page *page;\n\tint status, result;\n\n\tdprintk(\"--> %s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t\t(unsigned long long)server->fsid.major,\n\t\t\t(unsigned long long)server->fsid.minor,\n\t\t\tclp->cl_hostname);\n\n\tresult = 0;\n\tpage = alloc_page(GFP_KERNEL);\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (page == NULL || locations == NULL) {\n\t\tdprintk(\"<-- %s: no memory\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tinode = server->super->s_root->d_inode;\n\tresult = nfs4_proc_get_locations(inode, locations, page, cred);\n\tif (result) {\n\t\tdprintk(\"<-- %s: failed to retrieve fs_locations: %d\\n\",\n\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\n\tresult = -NFS4ERR_NXIO;\n\tif (!(locations->fattr.valid & NFS_ATTR_FATTR_V4_LOCATIONS)) {\n\t\tdprintk(\"<-- %s: No fs_locations data, migration skipped\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tnfs4_begin_drain_session(clp);\n\n\tstatus = nfs4_replace_transport(server, locations);\n\tif (status != 0) {\n\t\tdprintk(\"<-- %s: failed to replace transport: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto out;\n\t}\n\n\tresult = 0;\n\tdprintk(\"<-- %s: migration succeeded\\n\", __func__);\n\nout:\n\tif (page != NULL)\n\t\t__free_page(page);\n\tkfree(locations);\n\tif (result) {\n\t\tpr_err(\"NFS: migration recovery failed (server %s)\\n\",\n\t\t\t\tclp->cl_hostname);\n\t\tset_bit(NFS_MIG_FAILED, &server->mig_status);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_try_migration(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_fs_locations *locations = NULL;\n\tstruct inode *inode;\n\tstruct page *page;\n\tint status, result;\n\n\tdprintk(\"--> %s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t\t(unsigned long long)server->fsid.major,\n\t\t\t(unsigned long long)server->fsid.minor,\n\t\t\tclp->cl_hostname);\n\n\tresult = 0;\n\tpage = alloc_page(GFP_KERNEL);\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (page == NULL || locations == NULL) {\n\t\tdprintk(\"<-- %s: no memory\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tinode = server->super->s_root->d_inode;\n\tresult = nfs4_proc_get_locations(inode, locations, page, cred);\n\tif (result) {\n\t\tdprintk(\"<-- %s: failed to retrieve fs_locations: %d\\n\",\n\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\n\tresult = -NFS4ERR_NXIO;\n\tif (!(locations->fattr.valid & NFS_ATTR_FATTR_V4_LOCATIONS)) {\n\t\tdprintk(\"<-- %s: No fs_locations data, migration skipped\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tnfs4_begin_drain_session(clp);\n\n\tstatus = nfs4_replace_transport(server, locations);\n\tif (status != 0) {\n\t\tdprintk(\"<-- %s: failed to replace transport: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto out;\n\t}\n\n\tresult = 0;\n\tdprintk(\"<-- %s: migration succeeded\\n\", __func__);\n\nout:\n\tif (page != NULL)\n\t\t__free_page(page);\n\tkfree(locations);\n\tif (result) {\n\t\tpr_err(\"NFS: migration recovery failed (server %s)\\n\",\n\t\t\t\tclp->cl_hostname);\n\t\tset_bit(NFS_MIG_FAILED, &server->mig_status);\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS_MIG_IN_TRANSITION",
            "&server->mig_status"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "server",
            "&clp->cl_superblocks",
            "client_link"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_state_renewal_cred_locked",
          "args": [
            "clp"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: migration reported on \\\"%s\\\"\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_handle_migration(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\t\t\tclp->cl_mvops->state_renewal_ops;\n\tstruct nfs_server *server;\n\tstruct rpc_cred *cred;\n\n\tdprintk(\"%s: migration reported on \\\"%s\\\"\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\n\tspin_lock(&clp->cl_lock);\n\tcred = ops->get_state_renewal_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\tif (cred == NULL)\n\t\treturn -NFS4ERR_NOENT;\n\n\tclp->cl_mig_gen++;\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tint status;\n\n\t\tif (server->mig_gen == clp->cl_mig_gen)\n\t\t\tcontinue;\n\t\tserver->mig_gen = clp->cl_mig_gen;\n\n\t\tif (!test_and_clear_bit(NFS_MIG_IN_TRANSITION,\n\t\t\t\t\t\t&server->mig_status))\n\t\t\tcontinue;\n\n\t\trcu_read_unlock();\n\t\tstatus = nfs4_try_migration(server, cred);\n\t\tif (status < 0) {\n\t\t\tput_rpccred(cred);\n\t\t\treturn status;\n\t\t}\n\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tput_rpccred(cred);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_try_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1884-1942",
    "snippet": "static int nfs4_try_migration(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_fs_locations *locations = NULL;\n\tstruct inode *inode;\n\tstruct page *page;\n\tint status, result;\n\n\tdprintk(\"--> %s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t\t(unsigned long long)server->fsid.major,\n\t\t\t(unsigned long long)server->fsid.minor,\n\t\t\tclp->cl_hostname);\n\n\tresult = 0;\n\tpage = alloc_page(GFP_KERNEL);\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (page == NULL || locations == NULL) {\n\t\tdprintk(\"<-- %s: no memory\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tinode = server->super->s_root->d_inode;\n\tresult = nfs4_proc_get_locations(inode, locations, page, cred);\n\tif (result) {\n\t\tdprintk(\"<-- %s: failed to retrieve fs_locations: %d\\n\",\n\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\n\tresult = -NFS4ERR_NXIO;\n\tif (!(locations->fattr.valid & NFS_ATTR_FATTR_V4_LOCATIONS)) {\n\t\tdprintk(\"<-- %s: No fs_locations data, migration skipped\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tnfs4_begin_drain_session(clp);\n\n\tstatus = nfs4_replace_transport(server, locations);\n\tif (status != 0) {\n\t\tdprintk(\"<-- %s: failed to replace transport: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto out;\n\t}\n\n\tresult = 0;\n\tdprintk(\"<-- %s: migration succeeded\\n\", __func__);\n\nout:\n\tif (page != NULL)\n\t\t__free_page(page);\n\tkfree(locations);\n\tif (result) {\n\t\tpr_err(\"NFS: migration recovery failed (server %s)\\n\",\n\t\t\t\tclp->cl_hostname);\n\t\tset_bit(NFS_MIG_FAILED, &server->mig_status);\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_MIG_FAILED",
            "&server->mig_status"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"NFS: migration recovery failed (server %s)\\n\"",
            "clp->cl_hostname"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "locations"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s: migration succeeded\\n\"",
            "__func__"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s: failed to replace transport: %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_replace_transport",
          "args": [
            "server",
            "locations"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_replace_transport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "487-523",
          "snippet": "int nfs4_replace_transport(struct nfs_server *server,\n\t\t\t   const struct nfs4_fs_locations *locations)\n{\n\tchar *page = NULL, *page2 = NULL;\n\tint loc, error;\n\n\terror = -ENOENT;\n\tif (locations == NULL || locations->nlocations <= 0)\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\tpage = (char *) __get_free_page(GFP_USER);\n\tif (!page)\n\t\tgoto out;\n\tpage2 = (char *) __get_free_page(GFP_USER);\n\tif (!page2)\n\t\tgoto out;\n\n\tfor (loc = 0; loc < locations->nlocations; loc++) {\n\t\tconst struct nfs4_fs_location *location =\n\t\t\t\t\t\t&locations->locations[loc];\n\n\t\tif (location == NULL || location->nservers <= 0 ||\n\t\t    location->rootpath.ncomponents == 0)\n\t\t\tcontinue;\n\n\t\terror = nfs4_try_replacing_one_location(server, page,\n\t\t\t\t\t\t\tpage2, location);\n\t\tif (error == 0)\n\t\t\tbreak;\n\t}\n\nout:\n\tfree_page((unsigned long)page);\n\tfree_page((unsigned long)page2);\n\treturn error;\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nint nfs4_replace_transport(struct nfs_server *server,\n\t\t\t   const struct nfs4_fs_locations *locations)\n{\n\tchar *page = NULL, *page2 = NULL;\n\tint loc, error;\n\n\terror = -ENOENT;\n\tif (locations == NULL || locations->nlocations <= 0)\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\tpage = (char *) __get_free_page(GFP_USER);\n\tif (!page)\n\t\tgoto out;\n\tpage2 = (char *) __get_free_page(GFP_USER);\n\tif (!page2)\n\t\tgoto out;\n\n\tfor (loc = 0; loc < locations->nlocations; loc++) {\n\t\tconst struct nfs4_fs_location *location =\n\t\t\t\t\t\t&locations->locations[loc];\n\n\t\tif (location == NULL || location->nservers <= 0 ||\n\t\t    location->rootpath.ncomponents == 0)\n\t\t\tcontinue;\n\n\t\terror = nfs4_try_replacing_one_location(server, page,\n\t\t\t\t\t\t\tpage2, location);\n\t\tif (error == 0)\n\t\t\tbreak;\n\t}\n\nout:\n\tfree_page((unsigned long)page);\n\tfree_page((unsigned long)page2);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_begin_drain_session",
          "args": [
            "clp"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_begin_drain_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "255-269",
          "snippet": "static int nfs4_begin_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\tint ret = 0;\n\n\tif (clp->cl_slot_tbl)\n\t\treturn nfs4_drain_slot_tbl(clp->cl_slot_tbl);\n\n\t/* back channel */\n\tret = nfs4_drain_slot_tbl(&ses->bc_slot_table);\n\tif (ret)\n\t\treturn ret;\n\t/* fore channel */\n\treturn nfs4_drain_slot_tbl(&ses->fc_slot_table);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_begin_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\tint ret = 0;\n\n\tif (clp->cl_slot_tbl)\n\t\treturn nfs4_drain_slot_tbl(clp->cl_slot_tbl);\n\n\t/* back channel */\n\tret = nfs4_drain_slot_tbl(&ses->bc_slot_table);\n\tif (ret)\n\t\treturn ret;\n\t/* fore channel */\n\treturn nfs4_drain_slot_tbl(&ses->fc_slot_table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s: No fs_locations data, migration skipped\\n\"",
            "__func__"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s: failed to retrieve fs_locations: %d\\n\"",
            "__func__",
            "result"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_proc_get_locations",
          "args": [
            "inode",
            "locations",
            "page",
            "cred"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_get_locations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "6389-6413",
          "snippet": "int nfs4_proc_get_locations(struct inode *inode,\n\t\t\t    struct nfs4_fs_locations *locations,\n\t\t\t    struct page *page, struct rpc_cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tconst struct nfs4_mig_recovery_ops *ops =\n\t\t\t\t\tclp->cl_mvops->mig_recovery_ops;\n\tstruct nfs4_exception exception = { };\n\tint status;\n\n\tdprintk(\"%s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t(unsigned long long)server->fsid.major,\n\t\t(unsigned long long)server->fsid.minor,\n\t\tclp->cl_hostname);\n\tnfs_display_fhandle(NFS_FH(inode), __func__);\n\n\tdo {\n\t\tstatus = ops->get_locations(inode, locations, page, cred);\n\t\tif (status != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, status, &exception);\n\t} while (exception.retry);\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_proc_get_locations(struct inode *inode,\n\t\t\t    struct nfs4_fs_locations *locations,\n\t\t\t    struct page *page, struct rpc_cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tconst struct nfs4_mig_recovery_ops *ops =\n\t\t\t\t\tclp->cl_mvops->mig_recovery_ops;\n\tstruct nfs4_exception exception = { };\n\tint status;\n\n\tdprintk(\"%s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t(unsigned long long)server->fsid.major,\n\t\t(unsigned long long)server->fsid.minor,\n\t\tclp->cl_hostname);\n\tnfs_display_fhandle(NFS_FH(inode), __func__);\n\n\tdo {\n\t\tstatus = ops->get_locations(inode, locations, page, cred);\n\t\tif (status != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, status, &exception);\n\t} while (exception.retry);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s: no memory\\n\"",
            "__func__"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct nfs4_fs_locations)",
            "GFP_KERNEL"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s: FSID %llx:%llx on \\\"%s\\\"\\n\"",
            "__func__",
            "(unsigned long long)server->fsid.major",
            "(unsigned long long)server->fsid.minor",
            "clp->cl_hostname"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_try_migration(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_fs_locations *locations = NULL;\n\tstruct inode *inode;\n\tstruct page *page;\n\tint status, result;\n\n\tdprintk(\"--> %s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t\t(unsigned long long)server->fsid.major,\n\t\t\t(unsigned long long)server->fsid.minor,\n\t\t\tclp->cl_hostname);\n\n\tresult = 0;\n\tpage = alloc_page(GFP_KERNEL);\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (page == NULL || locations == NULL) {\n\t\tdprintk(\"<-- %s: no memory\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tinode = server->super->s_root->d_inode;\n\tresult = nfs4_proc_get_locations(inode, locations, page, cred);\n\tif (result) {\n\t\tdprintk(\"<-- %s: failed to retrieve fs_locations: %d\\n\",\n\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\n\tresult = -NFS4ERR_NXIO;\n\tif (!(locations->fattr.valid & NFS_ATTR_FATTR_V4_LOCATIONS)) {\n\t\tdprintk(\"<-- %s: No fs_locations data, migration skipped\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tnfs4_begin_drain_session(clp);\n\n\tstatus = nfs4_replace_transport(server, locations);\n\tif (status != 0) {\n\t\tdprintk(\"<-- %s: failed to replace transport: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto out;\n\t}\n\n\tresult = 0;\n\tdprintk(\"<-- %s: migration succeeded\\n\", __func__);\n\nout:\n\tif (page != NULL)\n\t\t__free_page(page);\n\tkfree(locations);\n\tif (result) {\n\t\tpr_err(\"NFS: migration recovery failed (server %s)\\n\",\n\t\t\t\tclp->cl_hostname);\n\t\tset_bit(NFS_MIG_FAILED, &server->mig_status);\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "nfs4_purge_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1864-1875",
    "snippet": "static int nfs4_purge_lease(struct nfs_client *clp)\n{\n\tint status;\n\n\tstatus = nfs4_establish_lease(clp);\n\tif (status < 0)\n\t\treturn nfs4_handle_reclaim_lease_error(clp, status);\n\tclear_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tnfs4_state_start_reclaim_nograce(clp);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_state_start_reclaim_nograce",
          "args": [
            "clp"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_start_reclaim_nograce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1659-1663",
          "snippet": "static void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_delegation_clear_all(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_delegation_clear_all(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_LEASE_EXPIRED",
            "&clp->cl_state"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS4CLNT_PURGE_STATE",
            "&clp->cl_state"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_handle_reclaim_lease_error",
          "args": [
            "clp",
            "status"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_handle_reclaim_lease_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1780-1824",
          "snippet": "static int nfs4_handle_reclaim_lease_error(struct nfs_client *clp, int status)\n{\n\tswitch (status) {\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tif (test_and_set_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state))\n\t\t\treturn -ESERVERFAULT;\n\t\t/* Lease confirmation error: retry after purging the lease */\n\t\tssleep(1);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tbreak;\n\tcase -NFS4ERR_CLID_INUSE:\n\t\tpr_err(\"NFS: Server %s reports our clientid is in use\\n\",\n\t\t\tclp->cl_hostname);\n\t\tnfs_mark_client_ready(clp, -EPERM);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\treturn -EPERM;\n\tcase -EACCES:\n\tcase -NFS4ERR_DELAY:\n\tcase -ETIMEDOUT:\n\tcase -EAGAIN:\n\t\tssleep(1);\n\t\tbreak;\n\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING)\n\t\t\tnfs_mark_client_ready(clp, -EPROTONOSUPPORT);\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\",\n\t\t\t\t__func__, -EPROTONOSUPPORT, clp->cl_hostname);\n\t\treturn -EPROTONOSUPPORT;\n\tcase -NFS4ERR_NOT_SAME: /* FixMe: implement recovery\n\t\t\t\t * in nfs4_exchange_id */\n\tdefault:\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\", __func__,\n\t\t\t\tstatus, clp->cl_hostname);\n\t\treturn status;\n\t}\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, status,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_handle_reclaim_lease_error(struct nfs_client *clp, int status)\n{\n\tswitch (status) {\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tif (test_and_set_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state))\n\t\t\treturn -ESERVERFAULT;\n\t\t/* Lease confirmation error: retry after purging the lease */\n\t\tssleep(1);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tbreak;\n\tcase -NFS4ERR_CLID_INUSE:\n\t\tpr_err(\"NFS: Server %s reports our clientid is in use\\n\",\n\t\t\tclp->cl_hostname);\n\t\tnfs_mark_client_ready(clp, -EPERM);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\treturn -EPERM;\n\tcase -EACCES:\n\tcase -NFS4ERR_DELAY:\n\tcase -ETIMEDOUT:\n\tcase -EAGAIN:\n\t\tssleep(1);\n\t\tbreak;\n\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING)\n\t\t\tnfs_mark_client_ready(clp, -EPROTONOSUPPORT);\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\",\n\t\t\t\t__func__, -EPROTONOSUPPORT, clp->cl_hostname);\n\t\treturn -EPROTONOSUPPORT;\n\tcase -NFS4ERR_NOT_SAME: /* FixMe: implement recovery\n\t\t\t\t * in nfs4_exchange_id */\n\tdefault:\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\", __func__,\n\t\t\t\tstatus, clp->cl_hostname);\n\t\treturn status;\n\t}\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, status,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_establish_lease",
          "args": [
            "clp"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_establish_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1826-1842",
          "snippet": "static int nfs4_establish_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tconst struct nfs4_state_recovery_ops *ops =\n\t\tclp->cl_mvops->reboot_recovery_ops;\n\tint status;\n\n\tcred = nfs4_get_clid_cred(clp);\n\tif (cred == NULL)\n\t\treturn -ENOENT;\n\tstatus = ops->establish_clid(clp, cred);\n\tput_rpccred(cred);\n\tif (status != 0)\n\t\treturn status;\n\tpnfs_destroy_all_layouts(clp);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_establish_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tconst struct nfs4_state_recovery_ops *ops =\n\t\tclp->cl_mvops->reboot_recovery_ops;\n\tint status;\n\n\tcred = nfs4_get_clid_cred(clp);\n\tif (cred == NULL)\n\t\treturn -ENOENT;\n\tstatus = ops->establish_clid(clp, cred);\n\tput_rpccred(cred);\n\tif (status != 0)\n\t\treturn status;\n\tpnfs_destroy_all_layouts(clp);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_purge_lease(struct nfs_client *clp)\n{\n\tint status;\n\n\tstatus = nfs4_establish_lease(clp);\n\tif (status < 0)\n\t\treturn nfs4_handle_reclaim_lease_error(clp, status);\n\tclear_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tnfs4_state_start_reclaim_nograce(clp);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_reclaim_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1848-1862",
    "snippet": "static int nfs4_reclaim_lease(struct nfs_client *clp)\n{\n\tint status;\n\n\tstatus = nfs4_establish_lease(clp);\n\tif (status < 0)\n\t\treturn nfs4_handle_reclaim_lease_error(clp, status);\n\tif (test_and_clear_bit(NFS4CLNT_SERVER_SCOPE_MISMATCH, &clp->cl_state))\n\t\tnfs4_state_start_reclaim_nograce(clp);\n\tif (!test_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\n\tclear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tclear_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS4CLNT_LEASE_EXPIRED",
            "&clp->cl_state"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_RECLAIM_REBOOT",
            "&clp->cl_state"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS4CLNT_RECLAIM_NOGRACE",
            "&clp->cl_state"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_start_reclaim_nograce",
          "args": [
            "clp"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_start_reclaim_nograce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1659-1663",
          "snippet": "static void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_delegation_clear_all(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_delegation_clear_all(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS4CLNT_SERVER_SCOPE_MISMATCH",
            "&clp->cl_state"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_handle_reclaim_lease_error",
          "args": [
            "clp",
            "status"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_handle_reclaim_lease_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1780-1824",
          "snippet": "static int nfs4_handle_reclaim_lease_error(struct nfs_client *clp, int status)\n{\n\tswitch (status) {\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tif (test_and_set_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state))\n\t\t\treturn -ESERVERFAULT;\n\t\t/* Lease confirmation error: retry after purging the lease */\n\t\tssleep(1);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tbreak;\n\tcase -NFS4ERR_CLID_INUSE:\n\t\tpr_err(\"NFS: Server %s reports our clientid is in use\\n\",\n\t\t\tclp->cl_hostname);\n\t\tnfs_mark_client_ready(clp, -EPERM);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\treturn -EPERM;\n\tcase -EACCES:\n\tcase -NFS4ERR_DELAY:\n\tcase -ETIMEDOUT:\n\tcase -EAGAIN:\n\t\tssleep(1);\n\t\tbreak;\n\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING)\n\t\t\tnfs_mark_client_ready(clp, -EPROTONOSUPPORT);\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\",\n\t\t\t\t__func__, -EPROTONOSUPPORT, clp->cl_hostname);\n\t\treturn -EPROTONOSUPPORT;\n\tcase -NFS4ERR_NOT_SAME: /* FixMe: implement recovery\n\t\t\t\t * in nfs4_exchange_id */\n\tdefault:\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\", __func__,\n\t\t\t\tstatus, clp->cl_hostname);\n\t\treturn status;\n\t}\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, status,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_handle_reclaim_lease_error(struct nfs_client *clp, int status)\n{\n\tswitch (status) {\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tif (test_and_set_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state))\n\t\t\treturn -ESERVERFAULT;\n\t\t/* Lease confirmation error: retry after purging the lease */\n\t\tssleep(1);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tbreak;\n\tcase -NFS4ERR_CLID_INUSE:\n\t\tpr_err(\"NFS: Server %s reports our clientid is in use\\n\",\n\t\t\tclp->cl_hostname);\n\t\tnfs_mark_client_ready(clp, -EPERM);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\treturn -EPERM;\n\tcase -EACCES:\n\tcase -NFS4ERR_DELAY:\n\tcase -ETIMEDOUT:\n\tcase -EAGAIN:\n\t\tssleep(1);\n\t\tbreak;\n\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING)\n\t\t\tnfs_mark_client_ready(clp, -EPROTONOSUPPORT);\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\",\n\t\t\t\t__func__, -EPROTONOSUPPORT, clp->cl_hostname);\n\t\treturn -EPROTONOSUPPORT;\n\tcase -NFS4ERR_NOT_SAME: /* FixMe: implement recovery\n\t\t\t\t * in nfs4_exchange_id */\n\tdefault:\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\", __func__,\n\t\t\t\tstatus, clp->cl_hostname);\n\t\treturn status;\n\t}\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, status,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_establish_lease",
          "args": [
            "clp"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_establish_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1826-1842",
          "snippet": "static int nfs4_establish_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tconst struct nfs4_state_recovery_ops *ops =\n\t\tclp->cl_mvops->reboot_recovery_ops;\n\tint status;\n\n\tcred = nfs4_get_clid_cred(clp);\n\tif (cred == NULL)\n\t\treturn -ENOENT;\n\tstatus = ops->establish_clid(clp, cred);\n\tput_rpccred(cred);\n\tif (status != 0)\n\t\treturn status;\n\tpnfs_destroy_all_layouts(clp);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_establish_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tconst struct nfs4_state_recovery_ops *ops =\n\t\tclp->cl_mvops->reboot_recovery_ops;\n\tint status;\n\n\tcred = nfs4_get_clid_cred(clp);\n\tif (cred == NULL)\n\t\treturn -ENOENT;\n\tstatus = ops->establish_clid(clp, cred);\n\tput_rpccred(cred);\n\tif (status != 0)\n\t\treturn status;\n\tpnfs_destroy_all_layouts(clp);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_reclaim_lease(struct nfs_client *clp)\n{\n\tint status;\n\n\tstatus = nfs4_establish_lease(clp);\n\tif (status < 0)\n\t\treturn nfs4_handle_reclaim_lease_error(clp, status);\n\tif (test_and_clear_bit(NFS4CLNT_SERVER_SCOPE_MISMATCH, &clp->cl_state))\n\t\tnfs4_state_start_reclaim_nograce(clp);\n\tif (!test_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\n\tclear_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tclear_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_establish_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1826-1842",
    "snippet": "static int nfs4_establish_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tconst struct nfs4_state_recovery_ops *ops =\n\t\tclp->cl_mvops->reboot_recovery_ops;\n\tint status;\n\n\tcred = nfs4_get_clid_cred(clp);\n\tif (cred == NULL)\n\t\treturn -ENOENT;\n\tstatus = ops->establish_clid(clp, cred);\n\tput_rpccred(cred);\n\tif (status != 0)\n\t\treturn status;\n\tpnfs_destroy_all_layouts(clp);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_destroy_all_layouts",
          "args": [
            "clp"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_destroy_all_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "531-533",
          "snippet": "static inline void pnfs_destroy_all_layouts(struct nfs_client *clp)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_destroy_all_layouts(struct nfs_client *clp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->establish_clid",
          "args": [
            "clp",
            "cred"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_get_clid_cred",
          "args": [
            "clp"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_clid_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "376-384",
          "snippet": "struct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_establish_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tconst struct nfs4_state_recovery_ops *ops =\n\t\tclp->cl_mvops->reboot_recovery_ops;\n\tint status;\n\n\tcred = nfs4_get_clid_cred(clp);\n\tif (cred == NULL)\n\t\treturn -ENOENT;\n\tstatus = ops->establish_clid(clp, cred);\n\tput_rpccred(cred);\n\tif (status != 0)\n\t\treturn status;\n\tpnfs_destroy_all_layouts(clp);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_handle_reclaim_lease_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1780-1824",
    "snippet": "static int nfs4_handle_reclaim_lease_error(struct nfs_client *clp, int status)\n{\n\tswitch (status) {\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tif (test_and_set_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state))\n\t\t\treturn -ESERVERFAULT;\n\t\t/* Lease confirmation error: retry after purging the lease */\n\t\tssleep(1);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tbreak;\n\tcase -NFS4ERR_CLID_INUSE:\n\t\tpr_err(\"NFS: Server %s reports our clientid is in use\\n\",\n\t\t\tclp->cl_hostname);\n\t\tnfs_mark_client_ready(clp, -EPERM);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\treturn -EPERM;\n\tcase -EACCES:\n\tcase -NFS4ERR_DELAY:\n\tcase -ETIMEDOUT:\n\tcase -EAGAIN:\n\t\tssleep(1);\n\t\tbreak;\n\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING)\n\t\t\tnfs_mark_client_ready(clp, -EPROTONOSUPPORT);\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\",\n\t\t\t\t__func__, -EPROTONOSUPPORT, clp->cl_hostname);\n\t\treturn -EPROTONOSUPPORT;\n\tcase -NFS4ERR_NOT_SAME: /* FixMe: implement recovery\n\t\t\t\t * in nfs4_exchange_id */\n\tdefault:\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\", __func__,\n\t\t\t\tstatus, clp->cl_hostname);\n\t\treturn status;\n\t}\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, status,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: handled error %d for server %s\\n\"",
            "__func__",
            "status",
            "clp->cl_hostname"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_LEASE_EXPIRED",
            "&clp->cl_state"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with error %d for server %s\\n\"",
            "__func__",
            "status",
            "clp->cl_hostname"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with error %d for server %s\\n\"",
            "__func__",
            "-EPROTONOSUPPORT",
            "clp->cl_hostname"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_mark_client_ready",
          "args": [
            "clp",
            "-EPROTONOSUPPORT"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_mark_client_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/client.c",
          "lines": "529-534",
          "snippet": "void nfs_mark_client_ready(struct nfs_client *clp, int state)\n{\n\tsmp_wmb();\n\tclp->cl_cons_state = state;\n\twake_up_all(&nfs_client_active_wq);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <net/ipv6.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(nfs_client_active_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs_xdr.h>\n#include <net/ipv6.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(nfs_client_active_wq);\n\nvoid nfs_mark_client_ready(struct nfs_client *clp, int state)\n{\n\tsmp_wmb();\n\tclp->cl_cons_state = state;\n\twake_up_all(&nfs_client_active_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "1"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS4CLNT_LEASE_CONFIRM",
            "&clp->cl_state"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"NFS: Server %s reports our clientid is in use\\n\"",
            "clp->cl_hostname"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_state_start_reclaim_reboot",
          "args": [
            "clp"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_start_reclaim_reboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1584-1589",
          "snippet": "static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\t/* Mark all delegations for reclaim */\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\t/* Mark all delegations for reclaim */\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "1"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS4CLNT_PURGE_STATE",
            "&clp->cl_state"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_handle_reclaim_lease_error(struct nfs_client *clp, int status)\n{\n\tswitch (status) {\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tif (test_and_set_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state))\n\t\t\treturn -ESERVERFAULT;\n\t\t/* Lease confirmation error: retry after purging the lease */\n\t\tssleep(1);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\tbreak;\n\tcase -NFS4ERR_CLID_INUSE:\n\t\tpr_err(\"NFS: Server %s reports our clientid is in use\\n\",\n\t\t\tclp->cl_hostname);\n\t\tnfs_mark_client_ready(clp, -EPERM);\n\t\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\t\treturn -EPERM;\n\tcase -EACCES:\n\tcase -NFS4ERR_DELAY:\n\tcase -ETIMEDOUT:\n\tcase -EAGAIN:\n\t\tssleep(1);\n\t\tbreak;\n\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING)\n\t\t\tnfs_mark_client_ready(clp, -EPROTONOSUPPORT);\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\",\n\t\t\t\t__func__, -EPROTONOSUPPORT, clp->cl_hostname);\n\t\treturn -EPROTONOSUPPORT;\n\tcase -NFS4ERR_NOT_SAME: /* FixMe: implement recovery\n\t\t\t\t * in nfs4_exchange_id */\n\tdefault:\n\t\tdprintk(\"%s: exit with error %d for server %s\\n\", __func__,\n\t\t\t\tstatus, clp->cl_hostname);\n\t\treturn status;\n\t}\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, status,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_check_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1748-1775",
    "snippet": "static int nfs4_check_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\tclp->cl_mvops->state_renewal_ops;\n\tint status;\n\n\t/* Is the client already known to have an expired lease? */\n\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\treturn 0;\n\tspin_lock(&clp->cl_lock);\n\tcred = ops->get_state_renewal_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\tif (cred == NULL) {\n\t\tcred = nfs4_get_clid_cred(clp);\n\t\tstatus = -ENOKEY;\n\t\tif (cred == NULL)\n\t\t\tgoto out;\n\t}\n\tstatus = ops->renew_lease(clp, cred);\n\tput_rpccred(cred);\n\tif (status == -ETIMEDOUT) {\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\t\treturn 0;\n\t}\nout:\n\treturn nfs4_recovery_handle_error(clp, status);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_recovery_handle_error",
          "args": [
            "clp",
            "status"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_recovery_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1665-1705",
          "snippet": "static int nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs40_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_clear_reclaim_reboot(clp);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\t\t/* Zero session reset errors */\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: failed to handle error %d for server %s\\n\",\n\t\t\t\t\t__func__, error, clp->cl_hostname);\n\t\t\treturn error;\n\t}\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, error,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs40_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_clear_reclaim_reboot(clp);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\t\t/* Zero session reset errors */\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: failed to handle error %d for server %s\\n\",\n\t\t\t\t\t__func__, error, clp->cl_hostname);\n\t\t\treturn error;\n\t}\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, error,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_CHECK_LEASE",
            "&clp->cl_state"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->renew_lease",
          "args": [
            "clp",
            "cred"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "renew_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "472-475",
          "snippet": "static void renew_lease(const struct nfs_server *server, unsigned long timestamp)\n{\n\tdo_renew_lease(server->nfs_client, timestamp);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic void renew_lease(const struct nfs_server *server, unsigned long timestamp)\n{\n\tdo_renew_lease(server->nfs_client, timestamp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_clid_cred",
          "args": [
            "clp"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_clid_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "376-384",
          "snippet": "struct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->get_state_renewal_cred_locked",
          "args": [
            "clp"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS4CLNT_LEASE_EXPIRED",
            "&clp->cl_state"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_check_lease(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tconst struct nfs4_state_maintenance_ops *ops =\n\t\tclp->cl_mvops->state_renewal_ops;\n\tint status;\n\n\t/* Is the client already known to have an expired lease? */\n\tif (test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\treturn 0;\n\tspin_lock(&clp->cl_lock);\n\tcred = ops->get_state_renewal_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\tif (cred == NULL) {\n\t\tcred = nfs4_get_clid_cred(clp);\n\t\tstatus = -ENOKEY;\n\t\tif (cred == NULL)\n\t\t\tgoto out;\n\t}\n\tstatus = ops->renew_lease(clp, cred);\n\tput_rpccred(cred);\n\tif (status == -ETIMEDOUT) {\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\t\treturn 0;\n\t}\nout:\n\treturn nfs4_recovery_handle_error(clp, status);\n}"
  },
  {
    "function_name": "nfs4_do_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1707-1746",
    "snippet": "static int nfs4_do_reclaim(struct nfs_client *clp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct nfs_server *server;\n\tstruct rb_node *pos;\n\tint status = 0;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tnfs4_purge_state_owners(server);\n\t\tspin_lock(&clp->cl_lock);\n\t\tfor (pos = rb_first(&server->state_owners);\n\t\t     pos != NULL;\n\t\t     pos = rb_next(pos)) {\n\t\t\tsp = rb_entry(pos,\n\t\t\t\tstruct nfs4_state_owner, so_server_node);\n\t\t\tif (!test_and_clear_bit(ops->owner_flag_bit,\n\t\t\t\t\t\t\t&sp->so_flags))\n\t\t\t\tcontinue;\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\tspin_unlock(&clp->cl_lock);\n\t\t\trcu_read_unlock();\n\n\t\t\tstatus = nfs4_reclaim_open_state(sp, ops);\n\t\t\tif (status < 0) {\n\t\t\t\tset_bit(ops->owner_flag_bit, &sp->so_flags);\n\t\t\t\tnfs4_put_state_owner(sp);\n\t\t\t\tstatus = nfs4_recovery_handle_error(clp, status);\n\t\t\t\treturn (status != 0) ? status : -EAGAIN;\n\t\t\t}\n\n\t\t\tnfs4_put_state_owner(sp);\n\t\t\tgoto restart;\n\t\t}\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_state_owner",
          "args": [
            "sp"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_state_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "595-606",
          "snippet": "void nfs4_put_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!atomic_dec_and_lock(&sp->so_count, &clp->cl_lock))\n\t\treturn;\n\n\tsp->so_expires = jiffies;\n\tlist_add_tail(&sp->so_lru, &server->state_owners_lru);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_put_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!atomic_dec_and_lock(&sp->so_count, &clp->cl_lock))\n\t\treturn;\n\n\tsp->so_expires = jiffies;\n\tlist_add_tail(&sp->so_lru, &server->state_owners_lru);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_recovery_handle_error",
          "args": [
            "clp",
            "status"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_recovery_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1665-1705",
          "snippet": "static int nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs40_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_clear_reclaim_reboot(clp);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\t\t/* Zero session reset errors */\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: failed to handle error %d for server %s\\n\",\n\t\t\t\t\t__func__, error, clp->cl_hostname);\n\t\t\treturn error;\n\t}\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, error,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs40_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_clear_reclaim_reboot(clp);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\t\t/* Zero session reset errors */\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: failed to handle error %d for server %s\\n\",\n\t\t\t\t\t__func__, error, clp->cl_hostname);\n\t\t\treturn error;\n\t}\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, error,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "ops->owner_flag_bit",
            "&sp->so_flags"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_reclaim_open_state",
          "args": [
            "sp",
            "ops"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reclaim_open_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1444-1531",
          "snippet": "static int nfs4_reclaim_open_state(struct nfs4_state_owner *sp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct nfs4_state *state;\n\tstruct nfs4_lock_state *lock;\n\tint status = 0;\n\n\t/* Note: we rely on the sp->so_states list being ordered \n\t * so that we always reclaim open(O_RDWR) and/or open(O_WRITE)\n\t * states first.\n\t * This is needed to ensure that the server won't give us any\n\t * read delegations that we have to return if, say, we are\n\t * recovering after a network partition or a reboot from a\n\t * server that doesn't support a grace period.\n\t */\n\tspin_lock(&sp->so_lock);\n\traw_write_seqcount_begin(&sp->so_reclaim_seqcount);\nrestart:\n\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\tif (!test_and_clear_bit(ops->state_flag_bit, &state->flags))\n\t\t\tcontinue;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tcontinue;\n\t\tif (state->state == 0)\n\t\t\tcontinue;\n\t\tatomic_inc(&state->count);\n\t\tspin_unlock(&sp->so_lock);\n\t\tstatus = ops->recover_open(sp, state);\n\t\tif (status >= 0) {\n\t\t\tstatus = nfs4_reclaim_locks(state, ops);\n\t\t\tif (status >= 0) {\n\t\t\t\tif (!test_bit(NFS_DELEGATED_STATE, &state->flags)) {\n\t\t\t\t\tspin_lock(&state->state_lock);\n\t\t\t\t\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\t\t\t\t\tif (!test_bit(NFS_LOCK_INITIALIZED, &lock->ls_flags))\n\t\t\t\t\t\t\tpr_warn_ratelimited(\"NFS: \"\n\t\t\t\t\t\t\t\t\t    \"%s: Lock reclaim \"\n\t\t\t\t\t\t\t\t\t    \"failed!\\n\", __func__);\n\t\t\t\t\t}\n\t\t\t\t\tspin_unlock(&state->state_lock);\n\t\t\t\t}\n\t\t\t\tnfs4_put_open_state(state);\n\t\t\t\tspin_lock(&sp->so_lock);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tswitch (status) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"NFS: %s: unhandled error %d\\n\",\n\t\t\t\t\t__func__, status);\n\t\t\tcase -ENOENT:\n\t\t\tcase -ENOMEM:\n\t\t\tcase -ESTALE:\n\t\t\t\t/* Open state on this file cannot be recovered */\n\t\t\t\tnfs4_state_mark_recovery_failed(state, status);\n\t\t\t\tbreak;\n\t\t\tcase -EAGAIN:\n\t\t\t\tssleep(1);\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);\n\t\t\t\tbreak;\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tnfs4_put_open_state(state);\n\t\tspin_lock(&sp->so_lock);\n\t\tgoto restart;\n\t}\n\traw_write_seqcount_end(&sp->so_reclaim_seqcount);\n\tspin_unlock(&sp->so_lock);\n\treturn 0;\nout_err:\n\tnfs4_put_open_state(state);\n\tspin_lock(&sp->so_lock);\n\traw_write_seqcount_end(&sp->so_reclaim_seqcount);\n\tspin_unlock(&sp->so_lock);\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_reclaim_open_state(struct nfs4_state_owner *sp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct nfs4_state *state;\n\tstruct nfs4_lock_state *lock;\n\tint status = 0;\n\n\t/* Note: we rely on the sp->so_states list being ordered \n\t * so that we always reclaim open(O_RDWR) and/or open(O_WRITE)\n\t * states first.\n\t * This is needed to ensure that the server won't give us any\n\t * read delegations that we have to return if, say, we are\n\t * recovering after a network partition or a reboot from a\n\t * server that doesn't support a grace period.\n\t */\n\tspin_lock(&sp->so_lock);\n\traw_write_seqcount_begin(&sp->so_reclaim_seqcount);\nrestart:\n\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\tif (!test_and_clear_bit(ops->state_flag_bit, &state->flags))\n\t\t\tcontinue;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tcontinue;\n\t\tif (state->state == 0)\n\t\t\tcontinue;\n\t\tatomic_inc(&state->count);\n\t\tspin_unlock(&sp->so_lock);\n\t\tstatus = ops->recover_open(sp, state);\n\t\tif (status >= 0) {\n\t\t\tstatus = nfs4_reclaim_locks(state, ops);\n\t\t\tif (status >= 0) {\n\t\t\t\tif (!test_bit(NFS_DELEGATED_STATE, &state->flags)) {\n\t\t\t\t\tspin_lock(&state->state_lock);\n\t\t\t\t\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\t\t\t\t\tif (!test_bit(NFS_LOCK_INITIALIZED, &lock->ls_flags))\n\t\t\t\t\t\t\tpr_warn_ratelimited(\"NFS: \"\n\t\t\t\t\t\t\t\t\t    \"%s: Lock reclaim \"\n\t\t\t\t\t\t\t\t\t    \"failed!\\n\", __func__);\n\t\t\t\t\t}\n\t\t\t\t\tspin_unlock(&state->state_lock);\n\t\t\t\t}\n\t\t\t\tnfs4_put_open_state(state);\n\t\t\t\tspin_lock(&sp->so_lock);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tswitch (status) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"NFS: %s: unhandled error %d\\n\",\n\t\t\t\t\t__func__, status);\n\t\t\tcase -ENOENT:\n\t\t\tcase -ENOMEM:\n\t\t\tcase -ESTALE:\n\t\t\t\t/* Open state on this file cannot be recovered */\n\t\t\t\tnfs4_state_mark_recovery_failed(state, status);\n\t\t\t\tbreak;\n\t\t\tcase -EAGAIN:\n\t\t\t\tssleep(1);\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);\n\t\t\t\tbreak;\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tnfs4_put_open_state(state);\n\t\tspin_lock(&sp->so_lock);\n\t\tgoto restart;\n\t}\n\traw_write_seqcount_end(&sp->so_reclaim_seqcount);\n\tspin_unlock(&sp->so_lock);\n\treturn 0;\nout_err:\n\tnfs4_put_open_state(state);\n\tspin_lock(&sp->so_lock);\n\traw_write_seqcount_end(&sp->so_reclaim_seqcount);\n\tspin_unlock(&sp->so_lock);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sp->so_count"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "ops->owner_flag_bit",
            "&sp->so_flags"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "pos",
            "structnfs4_state_owner",
            "so_server_node"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "pos"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&server->state_owners"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_purge_state_owners",
          "args": [
            "server"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_purge_state_owners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "615-632",
          "snippet": "void nfs4_purge_state_owners(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *tmp;\n\tLIST_HEAD(doomed);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(sp, tmp, &server->state_owners_lru, so_lru) {\n\t\tlist_move(&sp->so_lru, &doomed);\n\t\tnfs4_remove_state_owner_locked(sp);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tlist_for_each_entry_safe(sp, tmp, &doomed, so_lru) {\n\t\tlist_del(&sp->so_lru);\n\t\tnfs4_free_state_owner(sp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_purge_state_owners(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *tmp;\n\tLIST_HEAD(doomed);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(sp, tmp, &server->state_owners_lru, so_lru) {\n\t\tlist_move(&sp->so_lru, &doomed);\n\t\tnfs4_remove_state_owner_locked(sp);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tlist_for_each_entry_safe(sp, tmp, &doomed, so_lru) {\n\t\tlist_del(&sp->so_lru);\n\t\tnfs4_free_state_owner(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "server",
            "&clp->cl_superblocks",
            "client_link"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_do_reclaim(struct nfs_client *clp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct nfs4_state_owner *sp;\n\tstruct nfs_server *server;\n\tstruct rb_node *pos;\n\tint status = 0;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tnfs4_purge_state_owners(server);\n\t\tspin_lock(&clp->cl_lock);\n\t\tfor (pos = rb_first(&server->state_owners);\n\t\t     pos != NULL;\n\t\t     pos = rb_next(pos)) {\n\t\t\tsp = rb_entry(pos,\n\t\t\t\tstruct nfs4_state_owner, so_server_node);\n\t\t\tif (!test_and_clear_bit(ops->owner_flag_bit,\n\t\t\t\t\t\t\t&sp->so_flags))\n\t\t\t\tcontinue;\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\tspin_unlock(&clp->cl_lock);\n\t\t\trcu_read_unlock();\n\n\t\t\tstatus = nfs4_reclaim_open_state(sp, ops);\n\t\t\tif (status < 0) {\n\t\t\t\tset_bit(ops->owner_flag_bit, &sp->so_flags);\n\t\t\t\tnfs4_put_state_owner(sp);\n\t\t\t\tstatus = nfs4_recovery_handle_error(clp, status);\n\t\t\t\treturn (status != 0) ? status : -EAGAIN;\n\t\t\t}\n\n\t\t\tnfs4_put_state_owner(sp);\n\t\t\tgoto restart;\n\t\t}\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_recovery_handle_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1665-1705",
    "snippet": "static int nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs40_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_clear_reclaim_reboot(clp);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\t\t/* Zero session reset errors */\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: failed to handle error %d for server %s\\n\",\n\t\t\t\t\t__func__, error, clp->cl_hostname);\n\t\t\treturn error;\n\t}\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, error,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: handled error %d for server %s\\n\"",
            "__func__",
            "error",
            "clp->cl_hostname"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: failed to handle error %d for server %s\\n\"",
            "__func__",
            "error",
            "clp->cl_hostname"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_BIND_CONN_TO_SESSION",
            "&clp->cl_state"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_start_reclaim_nograce",
          "args": [
            "clp"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_start_reclaim_nograce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1659-1663",
          "snippet": "static void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_delegation_clear_all(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_delegation_clear_all(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_start_reclaim_reboot",
          "args": [
            "clp"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_start_reclaim_reboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1584-1589",
          "snippet": "static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\t/* Mark all delegations for reclaim */\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\t/* Mark all delegations for reclaim */\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_clear_reclaim_reboot",
          "args": [
            "clp"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_clear_reclaim_reboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1624-1638",
          "snippet": "static int nfs4_state_clear_reclaim_reboot(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\tif (!test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_clear_reclaim_server(server);\n\trcu_read_unlock();\n\n\tnfs_delegation_reap_unclaimed(clp);\n\treturn 1;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_state_clear_reclaim_reboot(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\tif (!test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_clear_reclaim_server(server);\n\trcu_read_unlock();\n\n\tnfs_delegation_reap_unclaimed(clp);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_end_reclaim_reboot",
          "args": [
            "clp"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_end_reclaim_reboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1640-1651",
          "snippet": "static void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_recovery_ops *ops;\n\tstruct rpc_cred *cred;\n\n\tif (!nfs4_state_clear_reclaim_reboot(clp))\n\t\treturn;\n\tops = clp->cl_mvops->reboot_recovery_ops;\n\tcred = nfs4_get_clid_cred(clp);\n\tnfs4_reclaim_complete(clp, ops, cred);\n\tput_rpccred(cred);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_recovery_ops *ops;\n\tstruct rpc_cred *cred;\n\n\tif (!nfs4_state_clear_reclaim_reboot(clp))\n\t\treturn;\n\tops = clp->cl_mvops->reboot_recovery_ops;\n\tcred = nfs4_get_clid_cred(clp);\n\tnfs4_reclaim_complete(clp, ops, cred);\n\tput_rpccred(cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs40_handle_cb_pathdown",
          "args": [
            "clp"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "nfs40_handle_cb_pathdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1285-1291",
          "snippet": "static void nfs40_handle_cb_pathdown(struct nfs_client *clp)\n{\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tnfs_expire_all_delegations(clp);\n\tdprintk(\"%s: handling CB_PATHDOWN recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs40_handle_cb_pathdown(struct nfs_client *clp)\n{\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tnfs_expire_all_delegations(clp);\n\tdprintk(\"%s: handling CB_PATHDOWN recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs40_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\tnfs4_state_end_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_clear_reclaim_reboot(clp);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\t\t/* Zero session reset errors */\n\t\t\tbreak;\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: failed to handle error %d for server %s\\n\",\n\t\t\t\t\t__func__, error, clp->cl_hostname);\n\t\t\treturn error;\n\t}\n\tdprintk(\"%s: handled error %d for server %s\\n\", __func__, error,\n\t\t\tclp->cl_hostname);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_state_start_reclaim_nograce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1659-1663",
    "snippet": "static void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_delegation_clear_all(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_state_mark_reclaim_helper",
          "args": [
            "clp",
            "nfs4_state_mark_reclaim_nograce"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_mark_reclaim_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1573-1582",
          "snippet": "static void nfs4_state_mark_reclaim_helper(struct nfs_client *clp,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_reset_seqids(server, mark_reclaim);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_mark_reclaim_helper(struct nfs_client *clp,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_reset_seqids(server, mark_reclaim);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_delegation_clear_all",
          "args": [
            "clp"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_delegation_clear_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1653-1657",
          "snippet": "static void nfs_delegation_clear_all(struct nfs_client *clp)\n{\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs_delegation_reap_unclaimed(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs_delegation_clear_all(struct nfs_client *clp)\n{\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs_delegation_reap_unclaimed(clp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_start_reclaim_nograce(struct nfs_client *clp)\n{\n\tnfs_delegation_clear_all(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_nograce);\n}"
  },
  {
    "function_name": "nfs_delegation_clear_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1653-1657",
    "snippet": "static void nfs_delegation_clear_all(struct nfs_client *clp)\n{\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs_delegation_reap_unclaimed(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_delegation_reap_unclaimed",
          "args": [
            "clp"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_delegation_reap_unclaimed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "813-852",
          "snippet": "void nfs_delegation_reap_unclaimed(struct nfs_client *clp)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs_server *server;\n\tstruct inode *inode;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tlist_for_each_entry_rcu(delegation, &server->delegations,\n\t\t\t\t\t\t\t\tsuper_list) {\n\t\t\tif (test_bit(NFS_DELEGATION_RETURNING,\n\t\t\t\t\t\t&delegation->flags))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM,\n\t\t\t\t\t\t&delegation->flags) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (!nfs_sb_active(server->super))\n\t\t\t\tcontinue;\n\t\t\tinode = nfs_delegation_grab_inode(delegation);\n\t\t\tif (inode == NULL) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tnfs_sb_deactive(server->super);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tdelegation = nfs_start_delegation_return_locked(NFS_I(inode));\n\t\t\trcu_read_unlock();\n\t\t\tif (delegation != NULL) {\n\t\t\t\tdelegation = nfs_detach_delegation(NFS_I(inode),\n\t\t\t\t\tdelegation, server);\n\t\t\t\tif (delegation != NULL)\n\t\t\t\t\tnfs_free_delegation(delegation);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\tnfs_sb_deactive(server->super);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nvoid nfs_delegation_reap_unclaimed(struct nfs_client *clp)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs_server *server;\n\tstruct inode *inode;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tlist_for_each_entry_rcu(delegation, &server->delegations,\n\t\t\t\t\t\t\t\tsuper_list) {\n\t\t\tif (test_bit(NFS_DELEGATION_RETURNING,\n\t\t\t\t\t\t&delegation->flags))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM,\n\t\t\t\t\t\t&delegation->flags) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (!nfs_sb_active(server->super))\n\t\t\t\tcontinue;\n\t\t\tinode = nfs_delegation_grab_inode(delegation);\n\t\t\tif (inode == NULL) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tnfs_sb_deactive(server->super);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tdelegation = nfs_start_delegation_return_locked(NFS_I(inode));\n\t\t\trcu_read_unlock();\n\t\t\tif (delegation != NULL) {\n\t\t\t\tdelegation = nfs_detach_delegation(NFS_I(inode),\n\t\t\t\t\tdelegation, server);\n\t\t\t\tif (delegation != NULL)\n\t\t\t\t\tnfs_free_delegation(delegation);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\tnfs_sb_deactive(server->super);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_delegation_mark_reclaim",
          "args": [
            "clp"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_delegation_mark_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "798-806",
          "snippet": "void nfs_delegation_mark_reclaim(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs_delegation_mark_reclaim_server(server);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nvoid nfs_delegation_mark_reclaim(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs_delegation_mark_reclaim_server(server);\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs_delegation_clear_all(struct nfs_client *clp)\n{\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs_delegation_reap_unclaimed(clp);\n}"
  },
  {
    "function_name": "nfs4_state_end_reclaim_reboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1640-1651",
    "snippet": "static void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_recovery_ops *ops;\n\tstruct rpc_cred *cred;\n\n\tif (!nfs4_state_clear_reclaim_reboot(clp))\n\t\treturn;\n\tops = clp->cl_mvops->reboot_recovery_ops;\n\tcred = nfs4_get_clid_cred(clp);\n\tnfs4_reclaim_complete(clp, ops, cred);\n\tput_rpccred(cred);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_reclaim_complete",
          "args": [
            "clp",
            "ops",
            "cred"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reclaim_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1591-1598",
          "snippet": "static void nfs4_reclaim_complete(struct nfs_client *clp,\n\t\t\t\t const struct nfs4_state_recovery_ops *ops,\n\t\t\t\t struct rpc_cred *cred)\n{\n\t/* Notify the server we're done reclaiming our state */\n\tif (ops->reclaim_complete)\n\t\t(void)ops->reclaim_complete(clp, cred);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_reclaim_complete(struct nfs_client *clp,\n\t\t\t\t const struct nfs4_state_recovery_ops *ops,\n\t\t\t\t struct rpc_cred *cred)\n{\n\t/* Notify the server we're done reclaiming our state */\n\tif (ops->reclaim_complete)\n\t\t(void)ops->reclaim_complete(clp, cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_clid_cred",
          "args": [
            "clp"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_clid_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "376-384",
          "snippet": "struct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_clear_reclaim_reboot",
          "args": [
            "clp"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_clear_reclaim_reboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1624-1638",
          "snippet": "static int nfs4_state_clear_reclaim_reboot(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\tif (!test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_clear_reclaim_server(server);\n\trcu_read_unlock();\n\n\tnfs_delegation_reap_unclaimed(clp);\n\treturn 1;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_state_clear_reclaim_reboot(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\tif (!test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_clear_reclaim_server(server);\n\trcu_read_unlock();\n\n\tnfs_delegation_reap_unclaimed(clp);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)\n{\n\tconst struct nfs4_state_recovery_ops *ops;\n\tstruct rpc_cred *cred;\n\n\tif (!nfs4_state_clear_reclaim_reboot(clp))\n\t\treturn;\n\tops = clp->cl_mvops->reboot_recovery_ops;\n\tcred = nfs4_get_clid_cred(clp);\n\tnfs4_reclaim_complete(clp, ops, cred);\n\tput_rpccred(cred);\n}"
  },
  {
    "function_name": "nfs4_state_clear_reclaim_reboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1624-1638",
    "snippet": "static int nfs4_state_clear_reclaim_reboot(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\tif (!test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_clear_reclaim_server(server);\n\trcu_read_unlock();\n\n\tnfs_delegation_reap_unclaimed(clp);\n\treturn 1;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_delegation_reap_unclaimed",
          "args": [
            "clp"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_delegation_reap_unclaimed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "813-852",
          "snippet": "void nfs_delegation_reap_unclaimed(struct nfs_client *clp)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs_server *server;\n\tstruct inode *inode;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tlist_for_each_entry_rcu(delegation, &server->delegations,\n\t\t\t\t\t\t\t\tsuper_list) {\n\t\t\tif (test_bit(NFS_DELEGATION_RETURNING,\n\t\t\t\t\t\t&delegation->flags))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM,\n\t\t\t\t\t\t&delegation->flags) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (!nfs_sb_active(server->super))\n\t\t\t\tcontinue;\n\t\t\tinode = nfs_delegation_grab_inode(delegation);\n\t\t\tif (inode == NULL) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tnfs_sb_deactive(server->super);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tdelegation = nfs_start_delegation_return_locked(NFS_I(inode));\n\t\t\trcu_read_unlock();\n\t\t\tif (delegation != NULL) {\n\t\t\t\tdelegation = nfs_detach_delegation(NFS_I(inode),\n\t\t\t\t\tdelegation, server);\n\t\t\t\tif (delegation != NULL)\n\t\t\t\t\tnfs_free_delegation(delegation);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\tnfs_sb_deactive(server->super);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nvoid nfs_delegation_reap_unclaimed(struct nfs_client *clp)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs_server *server;\n\tstruct inode *inode;\n\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tlist_for_each_entry_rcu(delegation, &server->delegations,\n\t\t\t\t\t\t\t\tsuper_list) {\n\t\t\tif (test_bit(NFS_DELEGATION_RETURNING,\n\t\t\t\t\t\t&delegation->flags))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM,\n\t\t\t\t\t\t&delegation->flags) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (!nfs_sb_active(server->super))\n\t\t\t\tcontinue;\n\t\t\tinode = nfs_delegation_grab_inode(delegation);\n\t\t\tif (inode == NULL) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tnfs_sb_deactive(server->super);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tdelegation = nfs_start_delegation_return_locked(NFS_I(inode));\n\t\t\trcu_read_unlock();\n\t\t\tif (delegation != NULL) {\n\t\t\t\tdelegation = nfs_detach_delegation(NFS_I(inode),\n\t\t\t\t\tdelegation, server);\n\t\t\t\tif (delegation != NULL)\n\t\t\t\t\tnfs_free_delegation(delegation);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\tnfs_sb_deactive(server->super);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_clear_reclaim_server",
          "args": [
            "server"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_clear_reclaim_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1600-1622",
          "snippet": "static void nfs4_clear_reclaim_server(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\tspin_lock(&clp->cl_lock);\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (!test_and_clear_bit(NFS_STATE_RECLAIM_REBOOT,\n\t\t\t\t\t\t&state->flags))\n\t\t\t\tcontinue;\n\t\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_clear_reclaim_server(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\tspin_lock(&clp->cl_lock);\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (!test_and_clear_bit(NFS_STATE_RECLAIM_REBOOT,\n\t\t\t\t\t\t&state->flags))\n\t\t\t\tcontinue;\n\t\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "server",
            "&clp->cl_superblocks",
            "client_link"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS4CLNT_RECLAIM_REBOOT",
            "&clp->cl_state"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_state_clear_reclaim_reboot(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\tif (!test_and_clear_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_clear_reclaim_server(server);\n\trcu_read_unlock();\n\n\tnfs_delegation_reap_unclaimed(clp);\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs4_clear_reclaim_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1600-1622",
    "snippet": "static void nfs4_clear_reclaim_server(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\tspin_lock(&clp->cl_lock);\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (!test_and_clear_bit(NFS_STATE_RECLAIM_REBOOT,\n\t\t\t\t\t\t&state->flags))\n\t\t\t\tcontinue;\n\t\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_mark_reclaim_nograce",
          "args": [
            "clp",
            "state"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_mark_reclaim_nograce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1313-1320",
          "snippet": "int nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS_STATE_RECLAIM_REBOOT",
            "&state->flags"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "state",
            "&sp->so_states",
            "open_states"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sp->so_lock"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "pos",
            "structnfs4_state_owner",
            "so_server_node"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "pos"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&server->state_owners"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_clear_reclaim_server(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\tspin_lock(&clp->cl_lock);\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (!test_and_clear_bit(NFS_STATE_RECLAIM_REBOOT,\n\t\t\t\t\t\t&state->flags))\n\t\t\t\tcontinue;\n\t\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}"
  },
  {
    "function_name": "nfs4_reclaim_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1591-1598",
    "snippet": "static void nfs4_reclaim_complete(struct nfs_client *clp,\n\t\t\t\t const struct nfs4_state_recovery_ops *ops,\n\t\t\t\t struct rpc_cred *cred)\n{\n\t/* Notify the server we're done reclaiming our state */\n\tif (ops->reclaim_complete)\n\t\t(void)ops->reclaim_complete(clp, cred);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->reclaim_complete",
          "args": [
            "clp",
            "cred"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_reclaim_complete(struct nfs_client *clp,\n\t\t\t\t const struct nfs4_state_recovery_ops *ops,\n\t\t\t\t struct rpc_cred *cred)\n{\n\t/* Notify the server we're done reclaiming our state */\n\tif (ops->reclaim_complete)\n\t\t(void)ops->reclaim_complete(clp, cred);\n}"
  },
  {
    "function_name": "nfs4_state_start_reclaim_reboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1584-1589",
    "snippet": "static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\t/* Mark all delegations for reclaim */\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_state_mark_reclaim_helper",
          "args": [
            "clp",
            "nfs4_state_mark_reclaim_reboot"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_mark_reclaim_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1573-1582",
          "snippet": "static void nfs4_state_mark_reclaim_helper(struct nfs_client *clp,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_reset_seqids(server, mark_reclaim);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_mark_reclaim_helper(struct nfs_client *clp,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_reset_seqids(server, mark_reclaim);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_delegation_mark_reclaim",
          "args": [
            "clp"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_delegation_mark_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "798-806",
          "snippet": "void nfs_delegation_mark_reclaim(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs_delegation_mark_reclaim_server(server);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nvoid nfs_delegation_mark_reclaim(struct nfs_client *clp)\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs_delegation_mark_reclaim_server(server);\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\t/* Mark all delegations for reclaim */\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}"
  },
  {
    "function_name": "nfs4_state_mark_reclaim_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1573-1582",
    "snippet": "static void nfs4_state_mark_reclaim_helper(struct nfs_client *clp,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_reset_seqids(server, mark_reclaim);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_reset_seqids",
          "args": [
            "server",
            "mark_reclaim"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reset_seqids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1549-1571",
          "snippet": "static void nfs4_reset_seqids(struct nfs_server *server,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\tspin_lock(&clp->cl_lock);\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tsp->so_seqid.flags = 0;\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (mark_reclaim(clp, state))\n\t\t\t\tnfs4_clear_open_state(state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_reset_seqids(struct nfs_server *server,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\tspin_lock(&clp->cl_lock);\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tsp->so_seqid.flags = 0;\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (mark_reclaim(clp, state))\n\t\t\t\tnfs4_clear_open_state(state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "server",
            "&clp->cl_superblocks",
            "client_link"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_mark_reclaim_helper(struct nfs_client *clp,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_reset_seqids(server, mark_reclaim);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "nfs4_reset_seqids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1549-1571",
    "snippet": "static void nfs4_reset_seqids(struct nfs_server *server,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\tspin_lock(&clp->cl_lock);\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tsp->so_seqid.flags = 0;\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (mark_reclaim(clp, state))\n\t\t\t\tnfs4_clear_open_state(state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_clear_open_state",
          "args": [
            "state"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_clear_open_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1533-1547",
          "snippet": "static void nfs4_clear_open_state(struct nfs4_state *state)\n{\n\tstruct nfs4_lock_state *lock;\n\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tspin_lock(&state->state_lock);\n\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\tlock->ls_seqid.flags = 0;\n\t\tclear_bit(NFS_LOCK_INITIALIZED, &lock->ls_flags);\n\t}\n\tspin_unlock(&state->state_lock);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_clear_open_state(struct nfs4_state *state)\n{\n\tstruct nfs4_lock_state *lock;\n\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tspin_lock(&state->state_lock);\n\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\tlock->ls_seqid.flags = 0;\n\t\tclear_bit(NFS_LOCK_INITIALIZED, &lock->ls_flags);\n\t}\n\tspin_unlock(&state->state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_reclaim",
          "args": [
            "clp",
            "state"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_mark_reclaim_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1573-1582",
          "snippet": "static void nfs4_state_mark_reclaim_helper(struct nfs_client *clp,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_reset_seqids(server, mark_reclaim);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_mark_reclaim_helper(struct nfs_client *clp,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_server *server;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\tnfs4_reset_seqids(server, mark_reclaim);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "state",
            "&sp->so_states",
            "open_states"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sp->so_lock"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "pos",
            "structnfs4_state_owner",
            "so_server_node"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "pos"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&server->state_owners"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_reset_seqids(struct nfs_server *server,\n\tint (*mark_reclaim)(struct nfs_client *clp, struct nfs4_state *state))\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\tstruct nfs4_state *state;\n\n\tspin_lock(&clp->cl_lock);\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tsp->so_seqid.flags = 0;\n\t\tspin_lock(&sp->so_lock);\n\t\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\t\tif (mark_reclaim(clp, state))\n\t\t\t\tnfs4_clear_open_state(state);\n\t\t}\n\t\tspin_unlock(&sp->so_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}"
  },
  {
    "function_name": "nfs4_clear_open_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1533-1547",
    "snippet": "static void nfs4_clear_open_state(struct nfs4_state *state)\n{\n\tstruct nfs4_lock_state *lock;\n\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tspin_lock(&state->state_lock);\n\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\tlock->ls_seqid.flags = 0;\n\t\tclear_bit(NFS_LOCK_INITIALIZED, &lock->ls_flags);\n\t}\n\tspin_unlock(&state->state_lock);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state->state_lock"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_LOCK_INITIALIZED",
            "&lock->ls_flags"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "&state->lock_states",
            "ls_locks"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state->state_lock"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_clear_open_state(struct nfs4_state *state)\n{\n\tstruct nfs4_lock_state *lock;\n\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tspin_lock(&state->state_lock);\n\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\tlock->ls_seqid.flags = 0;\n\t\tclear_bit(NFS_LOCK_INITIALIZED, &lock->ls_flags);\n\t}\n\tspin_unlock(&state->state_lock);\n}"
  },
  {
    "function_name": "nfs4_reclaim_open_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1444-1531",
    "snippet": "static int nfs4_reclaim_open_state(struct nfs4_state_owner *sp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct nfs4_state *state;\n\tstruct nfs4_lock_state *lock;\n\tint status = 0;\n\n\t/* Note: we rely on the sp->so_states list being ordered \n\t * so that we always reclaim open(O_RDWR) and/or open(O_WRITE)\n\t * states first.\n\t * This is needed to ensure that the server won't give us any\n\t * read delegations that we have to return if, say, we are\n\t * recovering after a network partition or a reboot from a\n\t * server that doesn't support a grace period.\n\t */\n\tspin_lock(&sp->so_lock);\n\traw_write_seqcount_begin(&sp->so_reclaim_seqcount);\nrestart:\n\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\tif (!test_and_clear_bit(ops->state_flag_bit, &state->flags))\n\t\t\tcontinue;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tcontinue;\n\t\tif (state->state == 0)\n\t\t\tcontinue;\n\t\tatomic_inc(&state->count);\n\t\tspin_unlock(&sp->so_lock);\n\t\tstatus = ops->recover_open(sp, state);\n\t\tif (status >= 0) {\n\t\t\tstatus = nfs4_reclaim_locks(state, ops);\n\t\t\tif (status >= 0) {\n\t\t\t\tif (!test_bit(NFS_DELEGATED_STATE, &state->flags)) {\n\t\t\t\t\tspin_lock(&state->state_lock);\n\t\t\t\t\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\t\t\t\t\tif (!test_bit(NFS_LOCK_INITIALIZED, &lock->ls_flags))\n\t\t\t\t\t\t\tpr_warn_ratelimited(\"NFS: \"\n\t\t\t\t\t\t\t\t\t    \"%s: Lock reclaim \"\n\t\t\t\t\t\t\t\t\t    \"failed!\\n\", __func__);\n\t\t\t\t\t}\n\t\t\t\t\tspin_unlock(&state->state_lock);\n\t\t\t\t}\n\t\t\t\tnfs4_put_open_state(state);\n\t\t\t\tspin_lock(&sp->so_lock);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tswitch (status) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"NFS: %s: unhandled error %d\\n\",\n\t\t\t\t\t__func__, status);\n\t\t\tcase -ENOENT:\n\t\t\tcase -ENOMEM:\n\t\t\tcase -ESTALE:\n\t\t\t\t/* Open state on this file cannot be recovered */\n\t\t\t\tnfs4_state_mark_recovery_failed(state, status);\n\t\t\t\tbreak;\n\t\t\tcase -EAGAIN:\n\t\t\t\tssleep(1);\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);\n\t\t\t\tbreak;\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tnfs4_put_open_state(state);\n\t\tspin_lock(&sp->so_lock);\n\t\tgoto restart;\n\t}\n\traw_write_seqcount_end(&sp->so_reclaim_seqcount);\n\tspin_unlock(&sp->so_lock);\n\treturn 0;\nout_err:\n\tnfs4_put_open_state(state);\n\tspin_lock(&sp->so_lock);\n\traw_write_seqcount_end(&sp->so_reclaim_seqcount);\n\tspin_unlock(&sp->so_lock);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sp->so_lock"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_end",
          "args": [
            "&sp->so_reclaim_seqcount"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sp->so_lock"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_open_state",
          "args": [
            "state"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_open_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "724-739",
          "snippet": "void nfs4_put_open_state(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs4_state_owner *owner = state->owner;\n\n\tif (!atomic_dec_and_lock(&state->count, &owner->so_lock))\n\t\treturn;\n\tspin_lock(&inode->i_lock);\n\tlist_del(&state->inode_states);\n\tlist_del(&state->open_states);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&owner->so_lock);\n\tiput(inode);\n\tnfs4_free_open_state(state);\n\tnfs4_put_state_owner(owner);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_put_open_state(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs4_state_owner *owner = state->owner;\n\n\tif (!atomic_dec_and_lock(&state->count, &owner->so_lock))\n\t\treturn;\n\tspin_lock(&inode->i_lock);\n\tlist_del(&state->inode_states);\n\tlist_del(&state->open_states);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&owner->so_lock);\n\tiput(inode);\n\tnfs4_free_open_state(state);\n\tnfs4_put_state_owner(owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_end",
          "args": [
            "&sp->so_reclaim_seqcount"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_state_mark_reclaim_nograce",
          "args": [
            "sp->so_server->nfs_client",
            "state"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_mark_reclaim_nograce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1313-1320",
          "snippet": "int nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "1"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_state_mark_recovery_failed",
          "args": [
            "state",
            "status"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_mark_recovery_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1377-1381",
          "snippet": "static void nfs4_state_mark_recovery_failed(struct nfs4_state *state, int error)\n{\n\tset_bit(NFS_STATE_RECOVERY_FAILED, &state->flags);\n\tnfs4_state_mark_open_context_bad(state);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_mark_recovery_failed(struct nfs4_state *state, int error)\n{\n\tset_bit(NFS_STATE_RECOVERY_FAILED, &state->flags);\n\tnfs4_state_mark_open_context_bad(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFS: %s: unhandled error %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"NFS: \"\n\t\t\t\t\t\t\t\t\t    \"%s: Lock reclaim \"\n\t\t\t\t\t\t\t\t\t    \"failed!\\n\"",
            "__func__"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LOCK_INITIALIZED",
            "&lock->ls_flags"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "&state->lock_states",
            "ls_locks"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_reclaim_locks",
          "args": [
            "state",
            "ops"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reclaim_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1384-1442",
          "snippet": "static int nfs4_reclaim_locks(struct nfs4_state *state, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct file_lock *fl;\n\tint status = 0;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tstruct list_head *list;\n\n\tif (flctx == NULL)\n\t\treturn 0;\n\n\tlist = &flctx->flc_posix;\n\n\t/* Guard against delegation returns and new lock/unlock calls */\n\tdown_write(&nfsi->rwsem);\n\tspin_lock(&flctx->flc_lock);\nrestart:\n\tlist_for_each_entry(fl, list, fl_list) {\n\t\tif (nfs_file_open_context(fl->fl_file)->state != state)\n\t\t\tcontinue;\n\t\tspin_unlock(&flctx->flc_lock);\n\t\tstatus = ops->recover_lock(state, fl);\n\t\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -ESTALE:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tpr_err(\"NFS: %s: unhandled error %d\\n\",\n\t\t\t\t\t__func__, status);\n\t\tcase -ENOMEM:\n\t\tcase -NFS4ERR_DENIED:\n\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t/* kill_proc(fl->fl_pid, SIGLOST, 1); */\n\t\t\tstatus = 0;\n\t\t}\n\t\tspin_lock(&flctx->flc_lock);\n\t}\n\tif (list == &flctx->flc_posix) {\n\t\tlist = &flctx->flc_flock;\n\t\tgoto restart;\n\t}\n\tspin_unlock(&flctx->flc_lock);\nout:\n\tup_write(&nfsi->rwsem);\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_reclaim_locks(struct nfs4_state *state, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct file_lock *fl;\n\tint status = 0;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tstruct list_head *list;\n\n\tif (flctx == NULL)\n\t\treturn 0;\n\n\tlist = &flctx->flc_posix;\n\n\t/* Guard against delegation returns and new lock/unlock calls */\n\tdown_write(&nfsi->rwsem);\n\tspin_lock(&flctx->flc_lock);\nrestart:\n\tlist_for_each_entry(fl, list, fl_list) {\n\t\tif (nfs_file_open_context(fl->fl_file)->state != state)\n\t\t\tcontinue;\n\t\tspin_unlock(&flctx->flc_lock);\n\t\tstatus = ops->recover_lock(state, fl);\n\t\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -ESTALE:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tpr_err(\"NFS: %s: unhandled error %d\\n\",\n\t\t\t\t\t__func__, status);\n\t\tcase -ENOMEM:\n\t\tcase -NFS4ERR_DENIED:\n\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t/* kill_proc(fl->fl_pid, SIGLOST, 1); */\n\t\t\tstatus = 0;\n\t\t}\n\t\tspin_lock(&flctx->flc_lock);\n\t}\n\tif (list == &flctx->flc_posix) {\n\t\tlist = &flctx->flc_flock;\n\t\tgoto restart;\n\t}\n\tspin_unlock(&flctx->flc_lock);\nout:\n\tup_write(&nfsi->rwsem);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->recover_open",
          "args": [
            "sp",
            "state"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&state->count"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_valid_open_stateid",
          "args": [
            "state"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_valid_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "516-519",
          "snippet": "static inline bool nfs4_valid_open_stateid(const struct nfs4_state *state)\n{\n\treturn test_bit(NFS_STATE_RECOVERY_FAILED, &state->flags) == 0;\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline bool nfs4_valid_open_stateid(const struct nfs4_state *state)\n{\n\treturn test_bit(NFS_STATE_RECOVERY_FAILED, &state->flags) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "ops->state_flag_bit",
            "&state->flags"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "state",
            "&sp->so_states",
            "open_states"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_begin",
          "args": [
            "&sp->so_reclaim_seqcount"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_reclaim_open_state(struct nfs4_state_owner *sp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct nfs4_state *state;\n\tstruct nfs4_lock_state *lock;\n\tint status = 0;\n\n\t/* Note: we rely on the sp->so_states list being ordered \n\t * so that we always reclaim open(O_RDWR) and/or open(O_WRITE)\n\t * states first.\n\t * This is needed to ensure that the server won't give us any\n\t * read delegations that we have to return if, say, we are\n\t * recovering after a network partition or a reboot from a\n\t * server that doesn't support a grace period.\n\t */\n\tspin_lock(&sp->so_lock);\n\traw_write_seqcount_begin(&sp->so_reclaim_seqcount);\nrestart:\n\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\tif (!test_and_clear_bit(ops->state_flag_bit, &state->flags))\n\t\t\tcontinue;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tcontinue;\n\t\tif (state->state == 0)\n\t\t\tcontinue;\n\t\tatomic_inc(&state->count);\n\t\tspin_unlock(&sp->so_lock);\n\t\tstatus = ops->recover_open(sp, state);\n\t\tif (status >= 0) {\n\t\t\tstatus = nfs4_reclaim_locks(state, ops);\n\t\t\tif (status >= 0) {\n\t\t\t\tif (!test_bit(NFS_DELEGATED_STATE, &state->flags)) {\n\t\t\t\t\tspin_lock(&state->state_lock);\n\t\t\t\t\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\t\t\t\t\tif (!test_bit(NFS_LOCK_INITIALIZED, &lock->ls_flags))\n\t\t\t\t\t\t\tpr_warn_ratelimited(\"NFS: \"\n\t\t\t\t\t\t\t\t\t    \"%s: Lock reclaim \"\n\t\t\t\t\t\t\t\t\t    \"failed!\\n\", __func__);\n\t\t\t\t\t}\n\t\t\t\t\tspin_unlock(&state->state_lock);\n\t\t\t\t}\n\t\t\t\tnfs4_put_open_state(state);\n\t\t\t\tspin_lock(&sp->so_lock);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tswitch (status) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"NFS: %s: unhandled error %d\\n\",\n\t\t\t\t\t__func__, status);\n\t\t\tcase -ENOENT:\n\t\t\tcase -ENOMEM:\n\t\t\tcase -ESTALE:\n\t\t\t\t/* Open state on this file cannot be recovered */\n\t\t\t\tnfs4_state_mark_recovery_failed(state, status);\n\t\t\t\tbreak;\n\t\t\tcase -EAGAIN:\n\t\t\t\tssleep(1);\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);\n\t\t\t\tbreak;\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_server->nfs_client, state);\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tnfs4_put_open_state(state);\n\t\tspin_lock(&sp->so_lock);\n\t\tgoto restart;\n\t}\n\traw_write_seqcount_end(&sp->so_reclaim_seqcount);\n\tspin_unlock(&sp->so_lock);\n\treturn 0;\nout_err:\n\tnfs4_put_open_state(state);\n\tspin_lock(&sp->so_lock);\n\traw_write_seqcount_end(&sp->so_reclaim_seqcount);\n\tspin_unlock(&sp->so_lock);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_reclaim_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1384-1442",
    "snippet": "static int nfs4_reclaim_locks(struct nfs4_state *state, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct file_lock *fl;\n\tint status = 0;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tstruct list_head *list;\n\n\tif (flctx == NULL)\n\t\treturn 0;\n\n\tlist = &flctx->flc_posix;\n\n\t/* Guard against delegation returns and new lock/unlock calls */\n\tdown_write(&nfsi->rwsem);\n\tspin_lock(&flctx->flc_lock);\nrestart:\n\tlist_for_each_entry(fl, list, fl_list) {\n\t\tif (nfs_file_open_context(fl->fl_file)->state != state)\n\t\t\tcontinue;\n\t\tspin_unlock(&flctx->flc_lock);\n\t\tstatus = ops->recover_lock(state, fl);\n\t\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -ESTALE:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tpr_err(\"NFS: %s: unhandled error %d\\n\",\n\t\t\t\t\t__func__, status);\n\t\tcase -ENOMEM:\n\t\tcase -NFS4ERR_DENIED:\n\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t/* kill_proc(fl->fl_pid, SIGLOST, 1); */\n\t\t\tstatus = 0;\n\t\t}\n\t\tspin_lock(&flctx->flc_lock);\n\t}\n\tif (list == &flctx->flc_posix) {\n\t\tlist = &flctx->flc_flock;\n\t\tgoto restart;\n\t}\n\tspin_unlock(&flctx->flc_lock);\nout:\n\tup_write(&nfsi->rwsem);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nfsi->rwsem"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&flctx->flc_lock"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&flctx->flc_lock"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"NFS: %s: unhandled error %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->recover_lock",
          "args": [
            "state",
            "fl"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_file_open_context",
          "args": [
            "fl->fl_file"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "list",
            "fl_list"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nfsi->rwsem"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_reclaim_locks(struct nfs4_state *state, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct file_lock *fl;\n\tint status = 0;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tstruct list_head *list;\n\n\tif (flctx == NULL)\n\t\treturn 0;\n\n\tlist = &flctx->flc_posix;\n\n\t/* Guard against delegation returns and new lock/unlock calls */\n\tdown_write(&nfsi->rwsem);\n\tspin_lock(&flctx->flc_lock);\nrestart:\n\tlist_for_each_entry(fl, list, fl_list) {\n\t\tif (nfs_file_open_context(fl->fl_file)->state != state)\n\t\t\tcontinue;\n\t\tspin_unlock(&flctx->flc_lock);\n\t\tstatus = ops->recover_lock(state, fl);\n\t\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -ESTALE:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\tcase -NFS4ERR_NO_GRACE:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tpr_err(\"NFS: %s: unhandled error %d\\n\",\n\t\t\t\t\t__func__, status);\n\t\tcase -ENOMEM:\n\t\tcase -NFS4ERR_DENIED:\n\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t/* kill_proc(fl->fl_pid, SIGLOST, 1); */\n\t\t\tstatus = 0;\n\t\t}\n\t\tspin_lock(&flctx->flc_lock);\n\t}\n\tif (list == &flctx->flc_posix) {\n\t\tlist = &flctx->flc_flock;\n\t\tgoto restart;\n\t}\n\tspin_unlock(&flctx->flc_lock);\nout:\n\tup_write(&nfsi->rwsem);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_state_mark_recovery_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1377-1381",
    "snippet": "static void nfs4_state_mark_recovery_failed(struct nfs4_state *state, int error)\n{\n\tset_bit(NFS_STATE_RECOVERY_FAILED, &state->flags);\n\tnfs4_state_mark_open_context_bad(state);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_state_mark_open_context_bad",
          "args": [
            "state"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_mark_open_context_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1362-1375",
          "snippet": "static void nfs4_state_mark_open_context_bad(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *ctx;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(ctx, &nfsi->open_files, list) {\n\t\tif (ctx->state != state)\n\t\t\tcontinue;\n\t\tset_bit(NFS_CONTEXT_BAD, &ctx->flags);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_mark_open_context_bad(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *ctx;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(ctx, &nfsi->open_files, list) {\n\t\tif (ctx->state != state)\n\t\t\tcontinue;\n\t\tset_bit(NFS_CONTEXT_BAD, &ctx->flags);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_STATE_RECOVERY_FAILED",
            "&state->flags"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_mark_recovery_failed(struct nfs4_state *state, int error)\n{\n\tset_bit(NFS_STATE_RECOVERY_FAILED, &state->flags);\n\tnfs4_state_mark_open_context_bad(state);\n}"
  },
  {
    "function_name": "nfs4_state_mark_open_context_bad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1362-1375",
    "snippet": "static void nfs4_state_mark_open_context_bad(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *ctx;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(ctx, &nfsi->open_files, list) {\n\t\tif (ctx->state != state)\n\t\t\tcontinue;\n\t\tset_bit(NFS_CONTEXT_BAD, &ctx->flags);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_CONTEXT_BAD",
            "&ctx->flags"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ctx",
            "&nfsi->open_files",
            "list"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_state_mark_open_context_bad(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *ctx;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(ctx, &nfsi->open_files, list) {\n\t\tif (ctx->state != state)\n\t\t\tcontinue;\n\t\tset_bit(NFS_CONTEXT_BAD, &ctx->flags);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "nfs_inode_find_state_and_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1336-1360",
    "snippet": "void nfs_inode_find_state_and_recover(struct inode *inode,\n\t\tconst nfs4_stateid *stateid)\n{\n\tstruct nfs_client *clp = NFS_SERVER(inode)->nfs_client;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tbool found = false;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(ctx, &nfsi->open_files, list) {\n\t\tstate = ctx->state;\n\t\tif (state == NULL)\n\t\t\tcontinue;\n\t\tif (!test_bit(NFS_DELEGATED_STATE, &state->flags))\n\t\t\tcontinue;\n\t\tif (!nfs4_stateid_match(&state->stateid, stateid))\n\t\t\tcontinue;\n\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\tfound = true;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tif (found)\n\t\tnfs4_schedule_state_manager(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_mark_reclaim_nograce",
          "args": [
            "clp",
            "state"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_mark_reclaim_nograce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1313-1320",
          "snippet": "int nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_match",
          "args": [
            "&state->stateid",
            "stateid"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_match_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "506-509",
          "snippet": "static inline bool nfs4_stateid_match_other(const nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\treturn memcmp(dst->other, src->other, NFS4_STATEID_OTHER_SIZE) == 0;\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline bool nfs4_stateid_match_other(const nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\treturn memcmp(dst->other, src->other, NFS4_STATEID_OTHER_SIZE) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_DELEGATED_STATE",
            "&state->flags"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ctx",
            "&nfsi->open_files",
            "list"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs_inode_find_state_and_recover(struct inode *inode,\n\t\tconst nfs4_stateid *stateid)\n{\n\tstruct nfs_client *clp = NFS_SERVER(inode)->nfs_client;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tbool found = false;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(ctx, &nfsi->open_files, list) {\n\t\tstate = ctx->state;\n\t\tif (state == NULL)\n\t\t\tcontinue;\n\t\tif (!test_bit(NFS_DELEGATED_STATE, &state->flags))\n\t\t\tcontinue;\n\t\tif (!nfs4_stateid_match(&state->stateid, stateid))\n\t\t\tcontinue;\n\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n\t\tfound = true;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tif (found)\n\t\tnfs4_schedule_state_manager(clp);\n}"
  },
  {
    "function_name": "nfs4_schedule_stateid_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1322-1333",
    "snippet": "int nfs4_schedule_stateid_recovery(const struct nfs_server *server, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!nfs4_valid_open_stateid(state))\n\t\treturn -EBADF;\n\tnfs4_state_mark_reclaim_nograce(clp, state);\n\tdprintk(\"%s: scheduling stateid recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: scheduling stateid recovery for server %s\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_state_mark_reclaim_nograce",
          "args": [
            "clp",
            "state"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_mark_reclaim_nograce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1313-1320",
          "snippet": "int nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_valid_open_stateid",
          "args": [
            "state"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_valid_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "516-519",
          "snippet": "static inline bool nfs4_valid_open_stateid(const struct nfs4_state *state)\n{\n\treturn test_bit(NFS_STATE_RECOVERY_FAILED, &state->flags) == 0;\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline bool nfs4_valid_open_stateid(const struct nfs4_state *state)\n{\n\treturn test_bit(NFS_STATE_RECOVERY_FAILED, &state->flags) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_schedule_stateid_recovery(const struct nfs_server *server, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!nfs4_valid_open_stateid(state))\n\t\treturn -EBADF;\n\tnfs4_state_mark_reclaim_nograce(clp, state);\n\tdprintk(\"%s: scheduling stateid recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_state_mark_reclaim_nograce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1313-1320",
    "snippet": "int nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_RECLAIM_NOGRACE",
            "&clp->cl_state"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_STATE_RECLAIM_REBOOT",
            "&state->flags"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state)\n{\n\tset_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags);\n\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\tset_bit(NFS_OWNER_RECLAIM_NOGRACE, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs4_state_mark_reclaim_reboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1299-1311",
    "snippet": "static int nfs4_state_mark_reclaim_reboot(struct nfs_client *clp, struct nfs4_state *state)\n{\n\n\tset_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\t/* Don't recover state that expired before the reboot */\n\tif (test_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags)) {\n\t\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\t\treturn 0;\n\t}\n\tset_bit(NFS_OWNER_RECLAIM_REBOOT, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\n\treturn 1;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_RECLAIM_REBOOT",
            "&clp->cl_state"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_STATE_RECLAIM_REBOOT",
            "&state->flags"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_STATE_RECLAIM_NOGRACE",
            "&state->flags"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_state_mark_reclaim_reboot(struct nfs_client *clp, struct nfs4_state *state)\n{\n\n\tset_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\t/* Don't recover state that expired before the reboot */\n\tif (test_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags)) {\n\t\tclear_bit(NFS_STATE_RECLAIM_REBOOT, &state->flags);\n\t\treturn 0;\n\t}\n\tset_bit(NFS_OWNER_RECLAIM_REBOOT, &state->owner->so_flags);\n\tset_bit(NFS4CLNT_RECLAIM_REBOOT, &clp->cl_state);\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs4_schedule_path_down_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1293-1297",
    "snippet": "void nfs4_schedule_path_down_recovery(struct nfs_client *clp)\n{\n\tnfs40_handle_cb_pathdown(clp);\n\tnfs4_schedule_state_manager(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs40_handle_cb_pathdown",
          "args": [
            "clp"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "nfs40_handle_cb_pathdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1285-1291",
          "snippet": "static void nfs40_handle_cb_pathdown(struct nfs_client *clp)\n{\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tnfs_expire_all_delegations(clp);\n\tdprintk(\"%s: handling CB_PATHDOWN recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs40_handle_cb_pathdown(struct nfs_client *clp)\n{\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tnfs_expire_all_delegations(clp);\n\tdprintk(\"%s: handling CB_PATHDOWN recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_schedule_path_down_recovery(struct nfs_client *clp)\n{\n\tnfs40_handle_cb_pathdown(clp);\n\tnfs4_schedule_state_manager(clp);\n}"
  },
  {
    "function_name": "nfs40_handle_cb_pathdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1285-1291",
    "snippet": "static void nfs40_handle_cb_pathdown(struct nfs_client *clp)\n{\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tnfs_expire_all_delegations(clp);\n\tdprintk(\"%s: handling CB_PATHDOWN recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: handling CB_PATHDOWN recovery for server %s\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_expire_all_delegations",
          "args": [
            "clp"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_expire_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "590-594",
          "snippet": "void nfs_expire_all_delegations(struct nfs_client *clp)\n{\n\tnfs_client_mark_return_all_delegations(clp);\n\tnfs_delegation_run_state_manager(clp);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nvoid nfs_expire_all_delegations(struct nfs_client *clp)\n{\n\tnfs_client_mark_return_all_delegations(clp);\n\tnfs_delegation_run_state_manager(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_LEASE_EXPIRED",
            "&clp->cl_state"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs40_handle_cb_pathdown(struct nfs_client *clp)\n{\n\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\tnfs_expire_all_delegations(clp);\n\tdprintk(\"%s: handling CB_PATHDOWN recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n}"
  },
  {
    "function_name": "nfs4_client_recover_expired_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1259-1275",
    "snippet": "int nfs4_client_recover_expired_lease(struct nfs_client *clp)\n{\n\tunsigned int loop;\n\tint ret;\n\n\tfor (loop = NFS4_MAX_LOOP_ON_RECOVER; loop != 0; loop--) {\n\t\tret = nfs4_wait_clnt_recover(clp);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) &&\n\t\t    !test_bit(NFS4CLNT_CHECK_LEASE,&clp->cl_state))\n\t\t\tbreak;\n\t\tnfs4_schedule_state_manager(clp);\n\t\tret = -EIO;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS4CLNT_CHECK_LEASE",
            "&clp->cl_state"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_wait_clnt_recover",
          "args": [
            "clp"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_clnt_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1241-1257",
          "snippet": "int nfs4_wait_clnt_recover(struct nfs_client *clp)\n{\n\tint res;\n\n\tmight_sleep();\n\n\tatomic_inc(&clp->cl_count);\n\tres = wait_on_bit_action(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING,\n\t\t\t\t nfs_wait_bit_killable, TASK_KILLABLE);\n\tif (res)\n\t\tgoto out;\n\tif (clp->cl_cons_state < 0)\n\t\tres = clp->cl_cons_state;\nout:\n\tnfs_put_client(clp);\n\treturn res;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_wait_clnt_recover(struct nfs_client *clp)\n{\n\tint res;\n\n\tmight_sleep();\n\n\tatomic_inc(&clp->cl_count);\n\tres = wait_on_bit_action(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING,\n\t\t\t\t nfs_wait_bit_killable, TASK_KILLABLE);\n\tif (res)\n\t\tgoto out;\n\tif (clp->cl_cons_state < 0)\n\t\tres = clp->cl_cons_state;\nout:\n\tnfs_put_client(clp);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_client_recover_expired_lease(struct nfs_client *clp)\n{\n\tunsigned int loop;\n\tint ret;\n\n\tfor (loop = NFS4_MAX_LOOP_ON_RECOVER; loop != 0; loop--) {\n\t\tret = nfs4_wait_clnt_recover(clp);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) &&\n\t\t    !test_bit(NFS4CLNT_CHECK_LEASE,&clp->cl_state))\n\t\t\tbreak;\n\t\tnfs4_schedule_state_manager(clp);\n\t\tret = -EIO;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4_wait_clnt_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1241-1257",
    "snippet": "int nfs4_wait_clnt_recover(struct nfs_client *clp)\n{\n\tint res;\n\n\tmight_sleep();\n\n\tatomic_inc(&clp->cl_count);\n\tres = wait_on_bit_action(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING,\n\t\t\t\t nfs_wait_bit_killable, TASK_KILLABLE);\n\tif (res)\n\t\tgoto out;\n\tif (clp->cl_cons_state < 0)\n\t\tres = clp->cl_cons_state;\nout:\n\tnfs_put_client(clp);\n\treturn res;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_put_client",
          "args": [
            "clp"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/client.c",
          "lines": "267-286",
          "snippet": "void nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <net/ipv6.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs_xdr.h>\n#include <net/ipv6.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit_action",
          "args": [
            "&clp->cl_state",
            "NFS4CLNT_MANAGER_RUNNING",
            "nfs_wait_bit_killable",
            "TASK_KILLABLE"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&clp->cl_count"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_wait_clnt_recover(struct nfs_client *clp)\n{\n\tint res;\n\n\tmight_sleep();\n\n\tatomic_inc(&clp->cl_count);\n\tres = wait_on_bit_action(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING,\n\t\t\t\t nfs_wait_bit_killable, TASK_KILLABLE);\n\tif (res)\n\t\tgoto out;\n\tif (clp->cl_cons_state < 0)\n\t\tres = clp->cl_cons_state;\nout:\n\tnfs_put_client(clp);\n\treturn res;\n}"
  },
  {
    "function_name": "nfs4_schedule_lease_moved_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1231-1238",
    "snippet": "void nfs4_schedule_lease_moved_recovery(struct nfs_client *clp)\n{\n\tdprintk(\"%s: scheduling lease-moved recovery for client ID %llx on %s\\n\",\n\t\t__func__, clp->cl_clientid, clp->cl_hostname);\n\n\tset_bit(NFS4CLNT_LEASE_MOVED, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_LEASE_MOVED",
            "&clp->cl_state"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: scheduling lease-moved recovery for client ID %llx on %s\\n\"",
            "__func__",
            "clp->cl_clientid",
            "clp->cl_hostname"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_schedule_lease_moved_recovery(struct nfs_client *clp)\n{\n\tdprintk(\"%s: scheduling lease-moved recovery for client ID %llx on %s\\n\",\n\t\t__func__, clp->cl_clientid, clp->cl_hostname);\n\n\tset_bit(NFS4CLNT_LEASE_MOVED, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n}"
  },
  {
    "function_name": "nfs4_schedule_migration_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1197-1222",
    "snippet": "int nfs4_schedule_migration_recovery(const struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (server->fh_expire_type != NFS4_FH_PERSISTENT) {\n\t\tpr_err(\"NFS: volatile file handles not supported (server %s)\\n\",\n\t\t\t\tclp->cl_hostname);\n\t\treturn -NFS4ERR_IO;\n\t}\n\n\tif (test_bit(NFS_MIG_FAILED, &server->mig_status))\n\t\treturn -NFS4ERR_IO;\n\n\tdprintk(\"%s: scheduling migration recovery for (%llx:%llx) on %s\\n\",\n\t\t\t__func__,\n\t\t\t(unsigned long long)server->fsid.major,\n\t\t\t(unsigned long long)server->fsid.minor,\n\t\t\tclp->cl_hostname);\n\n\tset_bit(NFS_MIG_IN_TRANSITION,\n\t\t\t&((struct nfs_server *)server)->mig_status);\n\tset_bit(NFS4CLNT_MOVED, &clp->cl_state);\n\n\tnfs4_schedule_state_manager(clp);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_MOVED",
            "&clp->cl_state"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: scheduling migration recovery for (%llx:%llx) on %s\\n\"",
            "__func__",
            "(unsigned long long)server->fsid.major",
            "(unsigned long long)server->fsid.minor",
            "clp->cl_hostname"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_MIG_FAILED",
            "&server->mig_status"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"NFS: volatile file handles not supported (server %s)\\n\"",
            "clp->cl_hostname"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_schedule_migration_recovery(const struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (server->fh_expire_type != NFS4_FH_PERSISTENT) {\n\t\tpr_err(\"NFS: volatile file handles not supported (server %s)\\n\",\n\t\t\t\tclp->cl_hostname);\n\t\treturn -NFS4ERR_IO;\n\t}\n\n\tif (test_bit(NFS_MIG_FAILED, &server->mig_status))\n\t\treturn -NFS4ERR_IO;\n\n\tdprintk(\"%s: scheduling migration recovery for (%llx:%llx) on %s\\n\",\n\t\t\t__func__,\n\t\t\t(unsigned long long)server->fsid.major,\n\t\t\t(unsigned long long)server->fsid.minor,\n\t\t\tclp->cl_hostname);\n\n\tset_bit(NFS_MIG_IN_TRANSITION,\n\t\t\t&((struct nfs_server *)server)->mig_status);\n\tset_bit(NFS4CLNT_MOVED, &clp->cl_state);\n\n\tnfs4_schedule_state_manager(clp);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_schedule_lease_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1177-1186",
    "snippet": "void nfs4_schedule_lease_recovery(struct nfs_client *clp)\n{\n\tif (!clp)\n\t\treturn;\n\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tdprintk(\"%s: scheduling lease recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: scheduling lease recovery for server %s\\n\"",
            "__func__",
            "clp->cl_hostname"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_CHECK_LEASE",
            "&clp->cl_state"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS4CLNT_LEASE_EXPIRED",
            "&clp->cl_state"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_schedule_lease_recovery(struct nfs_client *clp)\n{\n\tif (!clp)\n\t\treturn;\n\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tdprintk(\"%s: scheduling lease recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n}"
  },
  {
    "function_name": "nfs4_schedule_state_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1147-1172",
    "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs4_run_state_manager(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "THIS_MODULE"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_put_client",
          "args": [
            "clp"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/client.c",
          "lines": "267-286",
          "snippet": "void nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <net/ipv6.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs_xdr.h>\n#include <net/ipv6.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_clear_state_manager_bit",
          "args": [
            "clp"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_clear_state_manager_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1135-1142",
          "snippet": "static void nfs4_clear_state_manager_bit(struct nfs_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING);\n\trpc_wake_up(&clp->cl_rpcwaitq);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_clear_state_manager_bit(struct nfs_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING);\n\trpc_wake_up(&clp->cl_rpcwaitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: kthread_run: %ld\\n\"",
            "__func__",
            "PTR_ERR(task)"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "task"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "task"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "nfs4_run_state_manager",
            "clp",
            "\"%s\"",
            "buf"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%s-manager\"",
            "rpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR)"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_peeraddr2str",
          "args": [
            "clp->cl_rpcclient",
            "RPC_DISPLAY_ADDR"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&clp->cl_count"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__module_get",
          "args": [
            "THIS_MODULE"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS4CLNT_MANAGER_RUNNING",
            "&clp->cl_state"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
  },
  {
    "function_name": "nfs4_clear_state_manager_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1135-1142",
    "snippet": "static void nfs4_clear_state_manager_bit(struct nfs_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING);\n\trpc_wake_up(&clp->cl_rpcwaitq);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_wake_up",
          "args": [
            "&clp->cl_rpcwaitq"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&clp->cl_state",
            "NFS4CLNT_MANAGER_RUNNING"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS4CLNT_MANAGER_RUNNING",
            "&clp->cl_state"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_clear_state_manager_bit(struct nfs_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING);\n\trpc_wake_up(&clp->cl_rpcwaitq);\n}"
  },
  {
    "function_name": "nfs_wait_on_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1111-1131",
    "snippet": "int nfs_wait_on_sequence(struct nfs_seqid *seqid, struct rpc_task *task)\n{\n\tstruct nfs_seqid_counter *sequence;\n\tint status = 0;\n\n\tif (seqid == NULL)\n\t\tgoto out;\n\tsequence = seqid->sequence;\n\tspin_lock(&sequence->lock);\n\tseqid->task = task;\n\tif (list_empty(&seqid->list))\n\t\tlist_add_tail(&seqid->list, &sequence->list);\n\tif (list_first_entry(&sequence->list, struct nfs_seqid, list) == seqid)\n\t\tgoto unlock;\n\trpc_sleep_on(&sequence->wait, task, NULL);\n\tstatus = -EAGAIN;\nunlock:\n\tspin_unlock(&sequence->lock);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sequence->lock"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_sleep_on",
          "args": [
            "&sequence->wait",
            "task",
            "NULL"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&sequence->list",
            "structnfs_seqid",
            "list"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&seqid->list",
            "&sequence->list"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&seqid->list"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sequence->lock"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs_wait_on_sequence(struct nfs_seqid *seqid, struct rpc_task *task)\n{\n\tstruct nfs_seqid_counter *sequence;\n\tint status = 0;\n\n\tif (seqid == NULL)\n\t\tgoto out;\n\tsequence = seqid->sequence;\n\tspin_lock(&sequence->lock);\n\tseqid->task = task;\n\tif (list_empty(&seqid->list))\n\t\tlist_add_tail(&seqid->list, &sequence->list);\n\tif (list_first_entry(&sequence->list, struct nfs_seqid, list) == seqid)\n\t\tgoto unlock;\n\trpc_sleep_on(&sequence->wait, task, NULL);\n\tstatus = -EAGAIN;\nunlock:\n\tspin_unlock(&sequence->lock);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfs_increment_lock_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1105-1109",
    "snippet": "void nfs_increment_lock_seqid(int status, struct nfs_seqid *seqid)\n{\n\tif (seqid != NULL)\n\t\tnfs_increment_seqid(status, seqid);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_increment_seqid",
          "args": [
            "status",
            "seqid"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_increment_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1058-1084",
          "snippet": "static void nfs_increment_seqid(int status, struct nfs_seqid *seqid)\n{\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_SEQID:\n\t\t\tif (seqid->sequence->flags & NFS_SEQID_CONFIRMED)\n\t\t\t\treturn;\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server returned a bad\"\n\t\t\t\t\t\" sequence-id error on an\"\n\t\t\t\t\t\" unconfirmed sequence %p!\\n\",\n\t\t\t\t\tseqid->sequence);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_BADXDR:\n\t\tcase -NFS4ERR_RESOURCE:\n\t\tcase -NFS4ERR_NOFILEHANDLE:\n\t\t\t/* Non-seqid mutating errors */\n\t\t\treturn;\n\t};\n\t/*\n\t * Note: no locking needed as we are guaranteed to be first\n\t * on the sequence list\n\t */\n\tseqid->sequence->counter++;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs_increment_seqid(int status, struct nfs_seqid *seqid)\n{\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_SEQID:\n\t\t\tif (seqid->sequence->flags & NFS_SEQID_CONFIRMED)\n\t\t\t\treturn;\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server returned a bad\"\n\t\t\t\t\t\" sequence-id error on an\"\n\t\t\t\t\t\" unconfirmed sequence %p!\\n\",\n\t\t\t\t\tseqid->sequence);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_BADXDR:\n\t\tcase -NFS4ERR_RESOURCE:\n\t\tcase -NFS4ERR_NOFILEHANDLE:\n\t\t\t/* Non-seqid mutating errors */\n\t\t\treturn;\n\t};\n\t/*\n\t * Note: no locking needed as we are guaranteed to be first\n\t * on the sequence list\n\t */\n\tseqid->sequence->counter++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs_increment_lock_seqid(int status, struct nfs_seqid *seqid)\n{\n\tif (seqid != NULL)\n\t\tnfs_increment_seqid(status, seqid);\n}"
  },
  {
    "function_name": "nfs_increment_open_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1086-1098",
    "snippet": "void nfs_increment_open_seqid(int status, struct nfs_seqid *seqid)\n{\n\tstruct nfs4_state_owner *sp;\n\n\tif (seqid == NULL)\n\t\treturn;\n\n\tsp = container_of(seqid->sequence, struct nfs4_state_owner, so_seqid);\n\tif (status == -NFS4ERR_BAD_SEQID)\n\t\tnfs4_drop_state_owner(sp);\n\tif (!nfs4_has_session(sp->so_server->nfs_client))\n\t\tnfs_increment_seqid(status, seqid);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_increment_seqid",
          "args": [
            "status",
            "seqid"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_increment_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1058-1084",
          "snippet": "static void nfs_increment_seqid(int status, struct nfs_seqid *seqid)\n{\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_SEQID:\n\t\t\tif (seqid->sequence->flags & NFS_SEQID_CONFIRMED)\n\t\t\t\treturn;\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server returned a bad\"\n\t\t\t\t\t\" sequence-id error on an\"\n\t\t\t\t\t\" unconfirmed sequence %p!\\n\",\n\t\t\t\t\tseqid->sequence);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_BADXDR:\n\t\tcase -NFS4ERR_RESOURCE:\n\t\tcase -NFS4ERR_NOFILEHANDLE:\n\t\t\t/* Non-seqid mutating errors */\n\t\t\treturn;\n\t};\n\t/*\n\t * Note: no locking needed as we are guaranteed to be first\n\t * on the sequence list\n\t */\n\tseqid->sequence->counter++;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs_increment_seqid(int status, struct nfs_seqid *seqid)\n{\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_SEQID:\n\t\t\tif (seqid->sequence->flags & NFS_SEQID_CONFIRMED)\n\t\t\t\treturn;\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server returned a bad\"\n\t\t\t\t\t\" sequence-id error on an\"\n\t\t\t\t\t\" unconfirmed sequence %p!\\n\",\n\t\t\t\t\tseqid->sequence);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_BADXDR:\n\t\tcase -NFS4ERR_RESOURCE:\n\t\tcase -NFS4ERR_NOFILEHANDLE:\n\t\t\t/* Non-seqid mutating errors */\n\t\t\treturn;\n\t};\n\t/*\n\t * Note: no locking needed as we are guaranteed to be first\n\t * on the sequence list\n\t */\n\tseqid->sequence->counter++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_has_session",
          "args": [
            "sp->so_server->nfs_client"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4session.h",
          "lines": "148-151",
          "snippet": "static inline int nfs4_has_session(const struct nfs_client *clp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nfs4_has_session(const struct nfs_client *clp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_drop_state_owner",
          "args": [
            "sp"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_drop_state_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "497-513",
          "snippet": "static void\nnfs4_drop_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct rb_node *rb_node = &sp->so_server_node;\n\n\tif (!RB_EMPTY_NODE(rb_node)) {\n\t\tstruct nfs_server *server = sp->so_server;\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (!RB_EMPTY_NODE(rb_node)) {\n\t\t\trb_erase(rb_node, &server->state_owners);\n\t\t\tRB_CLEAR_NODE(rb_node);\n\t\t}\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_drop_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct rb_node *rb_node = &sp->so_server_node;\n\n\tif (!RB_EMPTY_NODE(rb_node)) {\n\t\tstruct nfs_server *server = sp->so_server;\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (!RB_EMPTY_NODE(rb_node)) {\n\t\t\trb_erase(rb_node, &server->state_owners);\n\t\t\tRB_CLEAR_NODE(rb_node);\n\t\t}\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "seqid->sequence",
            "structnfs4_state_owner",
            "so_seqid"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs_increment_open_seqid(int status, struct nfs_seqid *seqid)\n{\n\tstruct nfs4_state_owner *sp;\n\n\tif (seqid == NULL)\n\t\treturn;\n\n\tsp = container_of(seqid->sequence, struct nfs4_state_owner, so_seqid);\n\tif (status == -NFS4ERR_BAD_SEQID)\n\t\tnfs4_drop_state_owner(sp);\n\tif (!nfs4_has_session(sp->so_server->nfs_client))\n\t\tnfs_increment_seqid(status, seqid);\n}"
  },
  {
    "function_name": "nfs_increment_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1058-1084",
    "snippet": "static void nfs_increment_seqid(int status, struct nfs_seqid *seqid)\n{\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_SEQID:\n\t\t\tif (seqid->sequence->flags & NFS_SEQID_CONFIRMED)\n\t\t\t\treturn;\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server returned a bad\"\n\t\t\t\t\t\" sequence-id error on an\"\n\t\t\t\t\t\" unconfirmed sequence %p!\\n\",\n\t\t\t\t\tseqid->sequence);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_BADXDR:\n\t\tcase -NFS4ERR_RESOURCE:\n\t\tcase -NFS4ERR_NOFILEHANDLE:\n\t\t\t/* Non-seqid mutating errors */\n\t\t\treturn;\n\t};\n\t/*\n\t * Note: no locking needed as we are guaranteed to be first\n\t * on the sequence list\n\t */\n\tseqid->sequence->counter++;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"NFS: v4 server returned a bad\"\n\t\t\t\t\t\" sequence-id error on an\"\n\t\t\t\t\t\" unconfirmed sequence %p!\\n\"",
            "seqid->sequence"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs_increment_seqid(int status, struct nfs_seqid *seqid)\n{\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_SEQID:\n\t\t\tif (seqid->sequence->flags & NFS_SEQID_CONFIRMED)\n\t\t\t\treturn;\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server returned a bad\"\n\t\t\t\t\t\" sequence-id error on an\"\n\t\t\t\t\t\" unconfirmed sequence %p!\\n\",\n\t\t\t\t\tseqid->sequence);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_BADXDR:\n\t\tcase -NFS4ERR_RESOURCE:\n\t\tcase -NFS4ERR_NOFILEHANDLE:\n\t\t\t/* Non-seqid mutating errors */\n\t\t\treturn;\n\t};\n\t/*\n\t * Note: no locking needed as we are guaranteed to be first\n\t * on the sequence list\n\t */\n\tseqid->sequence->counter++;\n}"
  },
  {
    "function_name": "nfs_free_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1047-1051",
    "snippet": "void nfs_free_seqid(struct nfs_seqid *seqid)\n{\n\tnfs_release_seqid(seqid);\n\tkfree(seqid);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "seqid"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_release_seqid",
          "args": [
            "seqid"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_release_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1028-1045",
          "snippet": "void nfs_release_seqid(struct nfs_seqid *seqid)\n{\n\tstruct nfs_seqid_counter *sequence;\n\n\tif (seqid == NULL || list_empty(&seqid->list))\n\t\treturn;\n\tsequence = seqid->sequence;\n\tspin_lock(&sequence->lock);\n\tlist_del_init(&seqid->list);\n\tif (!list_empty(&sequence->list)) {\n\t\tstruct nfs_seqid *next;\n\n\t\tnext = list_first_entry(&sequence->list,\n\t\t\t\tstruct nfs_seqid, list);\n\t\trpc_wake_up_queued_task(&sequence->wait, next->task);\n\t}\n\tspin_unlock(&sequence->lock);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs_release_seqid(struct nfs_seqid *seqid)\n{\n\tstruct nfs_seqid_counter *sequence;\n\n\tif (seqid == NULL || list_empty(&seqid->list))\n\t\treturn;\n\tsequence = seqid->sequence;\n\tspin_lock(&sequence->lock);\n\tlist_del_init(&seqid->list);\n\tif (!list_empty(&sequence->list)) {\n\t\tstruct nfs_seqid *next;\n\n\t\tnext = list_first_entry(&sequence->list,\n\t\t\t\tstruct nfs_seqid, list);\n\t\trpc_wake_up_queued_task(&sequence->wait, next->task);\n\t}\n\tspin_unlock(&sequence->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs_free_seqid(struct nfs_seqid *seqid)\n{\n\tnfs_release_seqid(seqid);\n\tkfree(seqid);\n}"
  },
  {
    "function_name": "nfs_release_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1028-1045",
    "snippet": "void nfs_release_seqid(struct nfs_seqid *seqid)\n{\n\tstruct nfs_seqid_counter *sequence;\n\n\tif (seqid == NULL || list_empty(&seqid->list))\n\t\treturn;\n\tsequence = seqid->sequence;\n\tspin_lock(&sequence->lock);\n\tlist_del_init(&seqid->list);\n\tif (!list_empty(&sequence->list)) {\n\t\tstruct nfs_seqid *next;\n\n\t\tnext = list_first_entry(&sequence->list,\n\t\t\t\tstruct nfs_seqid, list);\n\t\trpc_wake_up_queued_task(&sequence->wait, next->task);\n\t}\n\tspin_unlock(&sequence->lock);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sequence->lock"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_wake_up_queued_task",
          "args": [
            "&sequence->wait",
            "next->task"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&sequence->list",
            "structnfs_seqid",
            "list"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sequence->list"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&seqid->list"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sequence->lock"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs_release_seqid(struct nfs_seqid *seqid)\n{\n\tstruct nfs_seqid_counter *sequence;\n\n\tif (seqid == NULL || list_empty(&seqid->list))\n\t\treturn;\n\tsequence = seqid->sequence;\n\tspin_lock(&sequence->lock);\n\tlist_del_init(&seqid->list);\n\tif (!list_empty(&sequence->list)) {\n\t\tstruct nfs_seqid *next;\n\n\t\tnext = list_first_entry(&sequence->list,\n\t\t\t\tstruct nfs_seqid, list);\n\t\trpc_wake_up_queued_task(&sequence->wait, next->task);\n\t}\n\tspin_unlock(&sequence->lock);\n}"
  },
  {
    "function_name": "nfs_alloc_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "1015-1026",
    "snippet": "struct nfs_seqid *nfs_alloc_seqid(struct nfs_seqid_counter *counter, gfp_t gfp_mask)\n{\n\tstruct nfs_seqid *new;\n\n\tnew = kmalloc(sizeof(*new), gfp_mask);\n\tif (new == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tnew->sequence = counter;\n\tINIT_LIST_HEAD(&new->list);\n\tnew->task = NULL;\n\treturn new;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->list"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*new)",
            "gfp_mask"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct nfs_seqid *nfs_alloc_seqid(struct nfs_seqid_counter *counter, gfp_t gfp_mask)\n{\n\tstruct nfs_seqid *new;\n\n\tnew = kmalloc(sizeof(*new), gfp_mask);\n\tif (new == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tnew->sequence = counter;\n\tINIT_LIST_HEAD(&new->list);\n\tnew->task = NULL;\n\treturn new;\n}"
  },
  {
    "function_name": "nfs4_select_rw_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "989-1013",
    "snippet": "int nfs4_select_rw_stateid(nfs4_stateid *dst, struct nfs4_state *state,\n\t\tfmode_t fmode, const struct nfs_lockowner *lockowner)\n{\n\tint ret = nfs4_copy_lock_stateid(dst, state, lockowner);\n\tif (ret == -EIO)\n\t\t/* A lost lock - don't even consider delegations */\n\t\tgoto out;\n\t/* returns true if delegation stateid found and copied */\n\tif (nfs4_copy_delegation_stateid(dst, state->inode, fmode)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOENT)\n\t\t/* nfs4_copy_delegation_stateid() didn't over-write\n\t\t * dst, so it still has the lock stateid which we now\n\t\t * choose to use.\n\t\t */\n\t\tgoto out;\n\tnfs4_copy_open_stateid(dst, state);\n\tret = 0;\nout:\n\tif (nfs_server_capable(state->inode, NFS_CAP_STATEID_NFSV41))\n\t\tdst->seqid = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_server_capable",
          "args": [
            "state->inode",
            "NFS_CAP_STATEID_NFSV41"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_copy_open_stateid",
          "args": [
            "dst",
            "state"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_copy_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "971-983",
          "snippet": "static void nfs4_copy_open_stateid(nfs4_stateid *dst, struct nfs4_state *state)\n{\n\tconst nfs4_stateid *src;\n\tint seq;\n\n\tdo {\n\t\tsrc = &zero_stateid;\n\t\tseq = read_seqbegin(&state->seqlock);\n\t\tif (test_bit(NFS_OPEN_STATE, &state->flags))\n\t\t\tsrc = &state->open_stateid;\n\t\tnfs4_stateid_copy(dst, src);\n\t} while (read_seqretry(&state->seqlock, seq));\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const nfs4_stateid zero_stateid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nconst nfs4_stateid zero_stateid;\n\nstatic void nfs4_copy_open_stateid(nfs4_stateid *dst, struct nfs4_state *state)\n{\n\tconst nfs4_stateid *src;\n\tint seq;\n\n\tdo {\n\t\tsrc = &zero_stateid;\n\t\tseq = read_seqbegin(&state->seqlock);\n\t\tif (test_bit(NFS_OPEN_STATE, &state->flags))\n\t\t\tsrc = &state->open_stateid;\n\t\tnfs4_stateid_copy(dst, src);\n\t} while (read_seqretry(&state->seqlock, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_copy_delegation_stateid",
          "args": [
            "dst",
            "state->inode",
            "fmode"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_copy_delegation_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "885-902",
          "snippet": "bool nfs4_copy_delegation_stateid(nfs4_stateid *dst, struct inode *inode,\n\t\tfmode_t flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_delegation *delegation;\n\tbool ret;\n\n\tflags &= FMODE_READ|FMODE_WRITE;\n\trcu_read_lock();\n\tdelegation = rcu_dereference(nfsi->delegation);\n\tret = (delegation != NULL && (delegation->type & flags) == flags);\n\tif (ret) {\n\t\tnfs4_stateid_copy(dst, &delegation->stateid);\n\t\tnfs_mark_delegation_referenced(delegation);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nbool nfs4_copy_delegation_stateid(nfs4_stateid *dst, struct inode *inode,\n\t\tfmode_t flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_delegation *delegation;\n\tbool ret;\n\n\tflags &= FMODE_READ|FMODE_WRITE;\n\trcu_read_lock();\n\tdelegation = rcu_dereference(nfsi->delegation);\n\tret = (delegation != NULL && (delegation->type & flags) == flags);\n\tif (ret) {\n\t\tnfs4_stateid_copy(dst, &delegation->stateid);\n\t\tnfs_mark_delegation_referenced(delegation);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_copy_lock_stateid",
          "args": [
            "dst",
            "state",
            "lockowner"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_copy_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "941-969",
          "snippet": "static int nfs4_copy_lock_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_state *state,\n\t\tconst struct nfs_lockowner *lockowner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tfl_owner_t fl_owner;\n\tint ret = -ENOENT;\n\n\n\tif (lockowner == NULL)\n\t\tgoto out;\n\n\tif (test_bit(LK_STATE_IN_USE, &state->flags) == 0)\n\t\tgoto out;\n\n\tfl_owner = lockowner->l_owner;\n\tspin_lock(&state->state_lock);\n\tlsp = __nfs4_find_lock_state(state, fl_owner);\n\tif (lsp && test_bit(NFS_LOCK_LOST, &lsp->ls_flags))\n\t\tret = -EIO;\n\telse if (lsp != NULL && test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0) {\n\t\tnfs4_stateid_copy(dst, &lsp->ls_stateid);\n\t\tret = 0;\n\t}\n\tspin_unlock(&state->state_lock);\n\tnfs4_put_lock_state(lsp);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_copy_lock_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_state *state,\n\t\tconst struct nfs_lockowner *lockowner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tfl_owner_t fl_owner;\n\tint ret = -ENOENT;\n\n\n\tif (lockowner == NULL)\n\t\tgoto out;\n\n\tif (test_bit(LK_STATE_IN_USE, &state->flags) == 0)\n\t\tgoto out;\n\n\tfl_owner = lockowner->l_owner;\n\tspin_lock(&state->state_lock);\n\tlsp = __nfs4_find_lock_state(state, fl_owner);\n\tif (lsp && test_bit(NFS_LOCK_LOST, &lsp->ls_flags))\n\t\tret = -EIO;\n\telse if (lsp != NULL && test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0) {\n\t\tnfs4_stateid_copy(dst, &lsp->ls_stateid);\n\t\tret = 0;\n\t}\n\tspin_unlock(&state->state_lock);\n\tnfs4_put_lock_state(lsp);\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_select_rw_stateid(nfs4_stateid *dst, struct nfs4_state *state,\n\t\tfmode_t fmode, const struct nfs_lockowner *lockowner)\n{\n\tint ret = nfs4_copy_lock_stateid(dst, state, lockowner);\n\tif (ret == -EIO)\n\t\t/* A lost lock - don't even consider delegations */\n\t\tgoto out;\n\t/* returns true if delegation stateid found and copied */\n\tif (nfs4_copy_delegation_stateid(dst, state->inode, fmode)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOENT)\n\t\t/* nfs4_copy_delegation_stateid() didn't over-write\n\t\t * dst, so it still has the lock stateid which we now\n\t\t * choose to use.\n\t\t */\n\t\tgoto out;\n\tnfs4_copy_open_stateid(dst, state);\n\tret = 0;\nout:\n\tif (nfs_server_capable(state->inode, NFS_CAP_STATEID_NFSV41))\n\t\tdst->seqid = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4_copy_open_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "971-983",
    "snippet": "static void nfs4_copy_open_stateid(nfs4_stateid *dst, struct nfs4_state *state)\n{\n\tconst nfs4_stateid *src;\n\tint seq;\n\n\tdo {\n\t\tsrc = &zero_stateid;\n\t\tseq = read_seqbegin(&state->seqlock);\n\t\tif (test_bit(NFS_OPEN_STATE, &state->flags))\n\t\t\tsrc = &state->open_stateid;\n\t\tnfs4_stateid_copy(dst, src);\n\t} while (read_seqretry(&state->seqlock, seq));\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const nfs4_stateid zero_stateid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&state->seqlock",
            "seq"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_copy",
          "args": [
            "dst",
            "src"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "496-499",
          "snippet": "static inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_OPEN_STATE",
            "&state->flags"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&state->seqlock"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nconst nfs4_stateid zero_stateid;\n\nstatic void nfs4_copy_open_stateid(nfs4_stateid *dst, struct nfs4_state *state)\n{\n\tconst nfs4_stateid *src;\n\tint seq;\n\n\tdo {\n\t\tsrc = &zero_stateid;\n\t\tseq = read_seqbegin(&state->seqlock);\n\t\tif (test_bit(NFS_OPEN_STATE, &state->flags))\n\t\t\tsrc = &state->open_stateid;\n\t\tnfs4_stateid_copy(dst, src);\n\t} while (read_seqretry(&state->seqlock, seq));\n}"
  },
  {
    "function_name": "nfs4_copy_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "941-969",
    "snippet": "static int nfs4_copy_lock_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_state *state,\n\t\tconst struct nfs_lockowner *lockowner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tfl_owner_t fl_owner;\n\tint ret = -ENOENT;\n\n\n\tif (lockowner == NULL)\n\t\tgoto out;\n\n\tif (test_bit(LK_STATE_IN_USE, &state->flags) == 0)\n\t\tgoto out;\n\n\tfl_owner = lockowner->l_owner;\n\tspin_lock(&state->state_lock);\n\tlsp = __nfs4_find_lock_state(state, fl_owner);\n\tif (lsp && test_bit(NFS_LOCK_LOST, &lsp->ls_flags))\n\t\tret = -EIO;\n\telse if (lsp != NULL && test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0) {\n\t\tnfs4_stateid_copy(dst, &lsp->ls_stateid);\n\t\tret = 0;\n\t}\n\tspin_unlock(&state->state_lock);\n\tnfs4_put_lock_state(lsp);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_lock_state",
          "args": [
            "lsp"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_lock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "886-907",
          "snippet": "void nfs4_put_lock_state(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_server *server;\n\tstruct nfs4_state *state;\n\n\tif (lsp == NULL)\n\t\treturn;\n\tstate = lsp->ls_state;\n\tif (!atomic_dec_and_lock(&lsp->ls_count, &state->state_lock))\n\t\treturn;\n\tlist_del(&lsp->ls_locks);\n\tif (list_empty(&state->lock_states))\n\t\tclear_bit(LK_STATE_IN_USE, &state->flags);\n\tspin_unlock(&state->state_lock);\n\tserver = state->owner->so_server;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tclp->cl_mvops->free_lock_state(server, lsp);\n\t} else\n\t\tnfs4_free_lock_state(server, lsp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_put_lock_state(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_server *server;\n\tstruct nfs4_state *state;\n\n\tif (lsp == NULL)\n\t\treturn;\n\tstate = lsp->ls_state;\n\tif (!atomic_dec_and_lock(&lsp->ls_count, &state->state_lock))\n\t\treturn;\n\tlist_del(&lsp->ls_locks);\n\tif (list_empty(&state->lock_states))\n\t\tclear_bit(LK_STATE_IN_USE, &state->flags);\n\tspin_unlock(&state->state_lock);\n\tserver = state->owner->so_server;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tclp->cl_mvops->free_lock_state(server, lsp);\n\t} else\n\t\tnfs4_free_lock_state(server, lsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state->state_lock"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_copy",
          "args": [
            "dst",
            "&lsp->ls_stateid"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "496-499",
          "snippet": "static inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline void nfs4_stateid_copy(nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LOCK_INITIALIZED",
            "&lsp->ls_flags"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nfs4_find_lock_state",
          "args": [
            "state",
            "fl_owner"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_find_lock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "803-814",
          "snippet": "static struct nfs4_lock_state *\n__nfs4_find_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *pos;\n\tlist_for_each_entry(pos, &state->lock_states, ls_locks) {\n\t\tif (pos->ls_owner != fl_owner)\n\t\t\tcontinue;\n\t\tatomic_inc(&pos->ls_count);\n\t\treturn pos;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_lock_state *\n__nfs4_find_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *pos;\n\tlist_for_each_entry(pos, &state->lock_states, ls_locks) {\n\t\tif (pos->ls_owner != fl_owner)\n\t\t\tcontinue;\n\t\tatomic_inc(&pos->ls_count);\n\t\treturn pos;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state->state_lock"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_copy_lock_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_state *state,\n\t\tconst struct nfs_lockowner *lockowner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tfl_owner_t fl_owner;\n\tint ret = -ENOENT;\n\n\n\tif (lockowner == NULL)\n\t\tgoto out;\n\n\tif (test_bit(LK_STATE_IN_USE, &state->flags) == 0)\n\t\tgoto out;\n\n\tfl_owner = lockowner->l_owner;\n\tspin_lock(&state->state_lock);\n\tlsp = __nfs4_find_lock_state(state, fl_owner);\n\tif (lsp && test_bit(NFS_LOCK_LOST, &lsp->ls_flags))\n\t\tret = -EIO;\n\telse if (lsp != NULL && test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0) {\n\t\tnfs4_stateid_copy(dst, &lsp->ls_stateid);\n\t\tret = 0;\n\t}\n\tspin_unlock(&state->state_lock);\n\tnfs4_put_lock_state(lsp);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4_set_lock_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "927-939",
    "snippet": "int nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs4_lock_state *lsp;\n\n\tif (fl->fl_ops != NULL)\n\t\treturn 0;\n\tlsp = nfs4_get_lock_state(state, fl->fl_owner);\n\tif (lsp == NULL)\n\t\treturn -ENOMEM;\n\tfl->fl_u.nfs4_fl.owner = lsp;\n\tfl->fl_ops = &nfs4_fl_lock_ops;\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_lock_operations nfs4_fl_lock_ops = {\n\t.fl_copy_lock = nfs4_fl_copy_lock,\n\t.fl_release_private = nfs4_fl_release_lock,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_get_lock_state",
          "args": [
            "state",
            "fl->fl_owner"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_lock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "855-880",
          "snippet": "static struct nfs4_lock_state *nfs4_get_lock_state(struct nfs4_state *state, fl_owner_t owner)\n{\n\tstruct nfs4_lock_state *lsp, *new = NULL;\n\t\n\tfor(;;) {\n\t\tspin_lock(&state->state_lock);\n\t\tlsp = __nfs4_find_lock_state(state, owner);\n\t\tif (lsp != NULL)\n\t\t\tbreak;\n\t\tif (new != NULL) {\n\t\t\tlist_add(&new->ls_locks, &state->lock_states);\n\t\t\tset_bit(LK_STATE_IN_USE, &state->flags);\n\t\t\tlsp = new;\n\t\t\tnew = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&state->state_lock);\n\t\tnew = nfs4_alloc_lock_state(state, owner);\n\t\tif (new == NULL)\n\t\t\treturn NULL;\n\t}\n\tspin_unlock(&state->state_lock);\n\tif (new != NULL)\n\t\tnfs4_free_lock_state(state->owner->so_server, new);\n\treturn lsp;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_lock_state *nfs4_get_lock_state(struct nfs4_state *state, fl_owner_t owner)\n{\n\tstruct nfs4_lock_state *lsp, *new = NULL;\n\t\n\tfor(;;) {\n\t\tspin_lock(&state->state_lock);\n\t\tlsp = __nfs4_find_lock_state(state, owner);\n\t\tif (lsp != NULL)\n\t\t\tbreak;\n\t\tif (new != NULL) {\n\t\t\tlist_add(&new->ls_locks, &state->lock_states);\n\t\t\tset_bit(LK_STATE_IN_USE, &state->flags);\n\t\t\tlsp = new;\n\t\t\tnew = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&state->state_lock);\n\t\tnew = nfs4_alloc_lock_state(state, owner);\n\t\tif (new == NULL)\n\t\t\treturn NULL;\n\t}\n\tspin_unlock(&state->state_lock);\n\tif (new != NULL)\n\t\tnfs4_free_lock_state(state->owner->so_server, new);\n\treturn lsp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic const struct file_lock_operations nfs4_fl_lock_ops = {\n\t.fl_copy_lock = nfs4_fl_copy_lock,\n\t.fl_release_private = nfs4_fl_release_lock,\n};\n\nint nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs4_lock_state *lsp;\n\n\tif (fl->fl_ops != NULL)\n\t\treturn 0;\n\tlsp = nfs4_get_lock_state(state, fl->fl_owner);\n\tif (lsp == NULL)\n\t\treturn -ENOMEM;\n\tfl->fl_u.nfs4_fl.owner = lsp;\n\tfl->fl_ops = &nfs4_fl_lock_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_fl_release_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "917-920",
    "snippet": "static void nfs4_fl_release_lock(struct file_lock *fl)\n{\n\tnfs4_put_lock_state(fl->fl_u.nfs4_fl.owner);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_lock_state",
          "args": [
            "fl->fl_u.nfs4_fl.owner"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_lock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "886-907",
          "snippet": "void nfs4_put_lock_state(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_server *server;\n\tstruct nfs4_state *state;\n\n\tif (lsp == NULL)\n\t\treturn;\n\tstate = lsp->ls_state;\n\tif (!atomic_dec_and_lock(&lsp->ls_count, &state->state_lock))\n\t\treturn;\n\tlist_del(&lsp->ls_locks);\n\tif (list_empty(&state->lock_states))\n\t\tclear_bit(LK_STATE_IN_USE, &state->flags);\n\tspin_unlock(&state->state_lock);\n\tserver = state->owner->so_server;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tclp->cl_mvops->free_lock_state(server, lsp);\n\t} else\n\t\tnfs4_free_lock_state(server, lsp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_put_lock_state(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_server *server;\n\tstruct nfs4_state *state;\n\n\tif (lsp == NULL)\n\t\treturn;\n\tstate = lsp->ls_state;\n\tif (!atomic_dec_and_lock(&lsp->ls_count, &state->state_lock))\n\t\treturn;\n\tlist_del(&lsp->ls_locks);\n\tif (list_empty(&state->lock_states))\n\t\tclear_bit(LK_STATE_IN_USE, &state->flags);\n\tspin_unlock(&state->state_lock);\n\tserver = state->owner->so_server;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tclp->cl_mvops->free_lock_state(server, lsp);\n\t} else\n\t\tnfs4_free_lock_state(server, lsp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_fl_release_lock(struct file_lock *fl)\n{\n\tnfs4_put_lock_state(fl->fl_u.nfs4_fl.owner);\n}"
  },
  {
    "function_name": "nfs4_fl_copy_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "909-915",
    "snippet": "static void nfs4_fl_copy_lock(struct file_lock *dst, struct file_lock *src)\n{\n\tstruct nfs4_lock_state *lsp = src->fl_u.nfs4_fl.owner;\n\n\tdst->fl_u.nfs4_fl.owner = lsp;\n\tatomic_inc(&lsp->ls_count);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&lsp->ls_count"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_fl_copy_lock(struct file_lock *dst, struct file_lock *src)\n{\n\tstruct nfs4_lock_state *lsp = src->fl_u.nfs4_fl.owner;\n\n\tdst->fl_u.nfs4_fl.owner = lsp;\n\tatomic_inc(&lsp->ls_count);\n}"
  },
  {
    "function_name": "nfs4_put_lock_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "886-907",
    "snippet": "void nfs4_put_lock_state(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_server *server;\n\tstruct nfs4_state *state;\n\n\tif (lsp == NULL)\n\t\treturn;\n\tstate = lsp->ls_state;\n\tif (!atomic_dec_and_lock(&lsp->ls_count, &state->state_lock))\n\t\treturn;\n\tlist_del(&lsp->ls_locks);\n\tif (list_empty(&state->lock_states))\n\t\tclear_bit(LK_STATE_IN_USE, &state->flags);\n\tspin_unlock(&state->state_lock);\n\tserver = state->owner->so_server;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tclp->cl_mvops->free_lock_state(server, lsp);\n\t} else\n\t\tnfs4_free_lock_state(server, lsp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_free_lock_state",
          "args": [
            "server",
            "lsp"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "843-848",
          "snippet": "void nfs4_free_lock_state(struct nfs_server *server, struct nfs4_lock_state *lsp)\n{\n\tida_simple_remove(&server->lockowner_id, lsp->ls_seqid.owner_id);\n\tnfs4_destroy_seqid_counter(&lsp->ls_seqid);\n\tkfree(lsp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_free_lock_state(struct nfs_server *server, struct nfs4_lock_state *lsp)\n{\n\tida_simple_remove(&server->lockowner_id, lsp->ls_seqid.owner_id);\n\tnfs4_destroy_seqid_counter(&lsp->ls_seqid);\n\tkfree(lsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clp->cl_mvops->free_lock_state",
          "args": [
            "server",
            "lsp"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LOCK_INITIALIZED",
            "&lsp->ls_flags"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state->state_lock"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "LK_STATE_IN_USE",
            "&state->flags"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&state->lock_states"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&lsp->ls_locks"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&lsp->ls_count",
            "&state->state_lock"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_put_lock_state(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_server *server;\n\tstruct nfs4_state *state;\n\n\tif (lsp == NULL)\n\t\treturn;\n\tstate = lsp->ls_state;\n\tif (!atomic_dec_and_lock(&lsp->ls_count, &state->state_lock))\n\t\treturn;\n\tlist_del(&lsp->ls_locks);\n\tif (list_empty(&state->lock_states))\n\t\tclear_bit(LK_STATE_IN_USE, &state->flags);\n\tspin_unlock(&state->state_lock);\n\tserver = state->owner->so_server;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags)) {\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tclp->cl_mvops->free_lock_state(server, lsp);\n\t} else\n\t\tnfs4_free_lock_state(server, lsp);\n}"
  },
  {
    "function_name": "nfs4_get_lock_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "855-880",
    "snippet": "static struct nfs4_lock_state *nfs4_get_lock_state(struct nfs4_state *state, fl_owner_t owner)\n{\n\tstruct nfs4_lock_state *lsp, *new = NULL;\n\t\n\tfor(;;) {\n\t\tspin_lock(&state->state_lock);\n\t\tlsp = __nfs4_find_lock_state(state, owner);\n\t\tif (lsp != NULL)\n\t\t\tbreak;\n\t\tif (new != NULL) {\n\t\t\tlist_add(&new->ls_locks, &state->lock_states);\n\t\t\tset_bit(LK_STATE_IN_USE, &state->flags);\n\t\t\tlsp = new;\n\t\t\tnew = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&state->state_lock);\n\t\tnew = nfs4_alloc_lock_state(state, owner);\n\t\tif (new == NULL)\n\t\t\treturn NULL;\n\t}\n\tspin_unlock(&state->state_lock);\n\tif (new != NULL)\n\t\tnfs4_free_lock_state(state->owner->so_server, new);\n\treturn lsp;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_free_lock_state",
          "args": [
            "state->owner->so_server",
            "new"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "843-848",
          "snippet": "void nfs4_free_lock_state(struct nfs_server *server, struct nfs4_lock_state *lsp)\n{\n\tida_simple_remove(&server->lockowner_id, lsp->ls_seqid.owner_id);\n\tnfs4_destroy_seqid_counter(&lsp->ls_seqid);\n\tkfree(lsp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_free_lock_state(struct nfs_server *server, struct nfs4_lock_state *lsp)\n{\n\tida_simple_remove(&server->lockowner_id, lsp->ls_seqid.owner_id);\n\tnfs4_destroy_seqid_counter(&lsp->ls_seqid);\n\tkfree(lsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state->state_lock"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_lock_state",
          "args": [
            "state",
            "owner"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_lock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "821-841",
          "snippet": "static struct nfs4_lock_state *nfs4_alloc_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_server *server = state->owner->so_server;\n\n\tlsp = kzalloc(sizeof(*lsp), GFP_NOFS);\n\tif (lsp == NULL)\n\t\treturn NULL;\n\tnfs4_init_seqid_counter(&lsp->ls_seqid);\n\tatomic_set(&lsp->ls_count, 1);\n\tlsp->ls_state = state;\n\tlsp->ls_owner = fl_owner;\n\tlsp->ls_seqid.owner_id = ida_simple_get(&server->lockowner_id, 0, 0, GFP_NOFS);\n\tif (lsp->ls_seqid.owner_id < 0)\n\t\tgoto out_free;\n\tINIT_LIST_HEAD(&lsp->ls_locks);\n\treturn lsp;\nout_free:\n\tkfree(lsp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_lock_state *nfs4_alloc_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_server *server = state->owner->so_server;\n\n\tlsp = kzalloc(sizeof(*lsp), GFP_NOFS);\n\tif (lsp == NULL)\n\t\treturn NULL;\n\tnfs4_init_seqid_counter(&lsp->ls_seqid);\n\tatomic_set(&lsp->ls_count, 1);\n\tlsp->ls_state = state;\n\tlsp->ls_owner = fl_owner;\n\tlsp->ls_seqid.owner_id = ida_simple_get(&server->lockowner_id, 0, 0, GFP_NOFS);\n\tif (lsp->ls_seqid.owner_id < 0)\n\t\tgoto out_free;\n\tINIT_LIST_HEAD(&lsp->ls_locks);\n\treturn lsp;\nout_free:\n\tkfree(lsp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "LK_STATE_IN_USE",
            "&state->flags"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new->ls_locks",
            "&state->lock_states"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nfs4_find_lock_state",
          "args": [
            "state",
            "owner"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_find_lock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "803-814",
          "snippet": "static struct nfs4_lock_state *\n__nfs4_find_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *pos;\n\tlist_for_each_entry(pos, &state->lock_states, ls_locks) {\n\t\tif (pos->ls_owner != fl_owner)\n\t\t\tcontinue;\n\t\tatomic_inc(&pos->ls_count);\n\t\treturn pos;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_lock_state *\n__nfs4_find_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *pos;\n\tlist_for_each_entry(pos, &state->lock_states, ls_locks) {\n\t\tif (pos->ls_owner != fl_owner)\n\t\t\tcontinue;\n\t\tatomic_inc(&pos->ls_count);\n\t\treturn pos;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state->state_lock"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_lock_state *nfs4_get_lock_state(struct nfs4_state *state, fl_owner_t owner)\n{\n\tstruct nfs4_lock_state *lsp, *new = NULL;\n\t\n\tfor(;;) {\n\t\tspin_lock(&state->state_lock);\n\t\tlsp = __nfs4_find_lock_state(state, owner);\n\t\tif (lsp != NULL)\n\t\t\tbreak;\n\t\tif (new != NULL) {\n\t\t\tlist_add(&new->ls_locks, &state->lock_states);\n\t\t\tset_bit(LK_STATE_IN_USE, &state->flags);\n\t\t\tlsp = new;\n\t\t\tnew = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&state->state_lock);\n\t\tnew = nfs4_alloc_lock_state(state, owner);\n\t\tif (new == NULL)\n\t\t\treturn NULL;\n\t}\n\tspin_unlock(&state->state_lock);\n\tif (new != NULL)\n\t\tnfs4_free_lock_state(state->owner->so_server, new);\n\treturn lsp;\n}"
  },
  {
    "function_name": "nfs4_free_lock_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "843-848",
    "snippet": "void nfs4_free_lock_state(struct nfs_server *server, struct nfs4_lock_state *lsp)\n{\n\tida_simple_remove(&server->lockowner_id, lsp->ls_seqid.owner_id);\n\tnfs4_destroy_seqid_counter(&lsp->ls_seqid);\n\tkfree(lsp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lsp"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_destroy_seqid_counter",
          "args": [
            "&lsp->ls_seqid"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_simple_remove",
          "args": [
            "&server->lockowner_id",
            "lsp->ls_seqid.owner_id"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_free_lock_state(struct nfs_server *server, struct nfs4_lock_state *lsp)\n{\n\tida_simple_remove(&server->lockowner_id, lsp->ls_seqid.owner_id);\n\tnfs4_destroy_seqid_counter(&lsp->ls_seqid);\n\tkfree(lsp);\n}"
  },
  {
    "function_name": "nfs4_alloc_lock_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "821-841",
    "snippet": "static struct nfs4_lock_state *nfs4_alloc_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_server *server = state->owner->so_server;\n\n\tlsp = kzalloc(sizeof(*lsp), GFP_NOFS);\n\tif (lsp == NULL)\n\t\treturn NULL;\n\tnfs4_init_seqid_counter(&lsp->ls_seqid);\n\tatomic_set(&lsp->ls_count, 1);\n\tlsp->ls_state = state;\n\tlsp->ls_owner = fl_owner;\n\tlsp->ls_seqid.owner_id = ida_simple_get(&server->lockowner_id, 0, 0, GFP_NOFS);\n\tif (lsp->ls_seqid.owner_id < 0)\n\t\tgoto out_free;\n\tINIT_LIST_HEAD(&lsp->ls_locks);\n\treturn lsp;\nout_free:\n\tkfree(lsp);\n\treturn NULL;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lsp"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lsp->ls_locks"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_simple_get",
          "args": [
            "&server->lockowner_id",
            "0",
            "0",
            "GFP_NOFS"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&lsp->ls_count",
            "1"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_init_seqid_counter",
          "args": [
            "&lsp->ls_seqid"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_init_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "453-462",
          "snippet": "static void\nnfs4_init_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\tsc->create_time = ktime_get();\n\tsc->flags = 0;\n\tsc->counter = 0;\n\tspin_lock_init(&sc->lock);\n\tINIT_LIST_HEAD(&sc->list);\n\trpc_init_wait_queue(&sc->wait, \"Seqid_waitqueue\");\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_init_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\tsc->create_time = ktime_get();\n\tsc->flags = 0;\n\tsc->counter = 0;\n\tspin_lock_init(&sc->lock);\n\tINIT_LIST_HEAD(&sc->list);\n\trpc_init_wait_queue(&sc->wait, \"Seqid_waitqueue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*lsp)",
            "GFP_NOFS"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_lock_state *nfs4_alloc_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_server *server = state->owner->so_server;\n\n\tlsp = kzalloc(sizeof(*lsp), GFP_NOFS);\n\tif (lsp == NULL)\n\t\treturn NULL;\n\tnfs4_init_seqid_counter(&lsp->ls_seqid);\n\tatomic_set(&lsp->ls_count, 1);\n\tlsp->ls_state = state;\n\tlsp->ls_owner = fl_owner;\n\tlsp->ls_seqid.owner_id = ida_simple_get(&server->lockowner_id, 0, 0, GFP_NOFS);\n\tif (lsp->ls_seqid.owner_id < 0)\n\t\tgoto out_free;\n\tINIT_LIST_HEAD(&lsp->ls_locks);\n\treturn lsp;\nout_free:\n\tkfree(lsp);\n\treturn NULL;\n}"
  },
  {
    "function_name": "__nfs4_find_lock_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "803-814",
    "snippet": "static struct nfs4_lock_state *\n__nfs4_find_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *pos;\n\tlist_for_each_entry(pos, &state->lock_states, ls_locks) {\n\t\tif (pos->ls_owner != fl_owner)\n\t\t\tcontinue;\n\t\tatomic_inc(&pos->ls_count);\n\t\treturn pos;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&pos->ls_count"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pos",
            "&state->lock_states",
            "ls_locks"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_lock_state *\n__nfs4_find_lock_state(struct nfs4_state *state, fl_owner_t fl_owner)\n{\n\tstruct nfs4_lock_state *pos;\n\tlist_for_each_entry(pos, &state->lock_states, ls_locks) {\n\t\tif (pos->ls_owner != fl_owner)\n\t\t\tcontinue;\n\t\tatomic_inc(&pos->ls_count);\n\t\treturn pos;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_close_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "794-797",
    "snippet": "void nfs4_close_sync(struct nfs4_state *state, fmode_t fmode)\n{\n\t__nfs4_close(state, fmode, GFP_KERNEL, 1);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs4_close",
          "args": [
            "state",
            "fmode",
            "GFP_KERNEL",
            "1"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "744-787",
          "snippet": "static void __nfs4_close(struct nfs4_state *state,\n\t\tfmode_t fmode, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tfmode_t newstate;\n\n\tatomic_inc(&owner->so_count);\n\t/* Protect against nfs4_find_state() */\n\tspin_lock(&owner->so_lock);\n\tswitch (fmode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(state, gfp_mask, wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __nfs4_close(struct nfs4_state *state,\n\t\tfmode_t fmode, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tfmode_t newstate;\n\n\tatomic_inc(&owner->so_count);\n\t/* Protect against nfs4_find_state() */\n\tspin_lock(&owner->so_lock);\n\tswitch (fmode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(state, gfp_mask, wait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_close_sync(struct nfs4_state *state, fmode_t fmode)\n{\n\t__nfs4_close(state, fmode, GFP_KERNEL, 1);\n}"
  },
  {
    "function_name": "nfs4_close_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "789-792",
    "snippet": "void nfs4_close_state(struct nfs4_state *state, fmode_t fmode)\n{\n\t__nfs4_close(state, fmode, GFP_NOFS, 0);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs4_close",
          "args": [
            "state",
            "fmode",
            "GFP_NOFS",
            "0"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "744-787",
          "snippet": "static void __nfs4_close(struct nfs4_state *state,\n\t\tfmode_t fmode, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tfmode_t newstate;\n\n\tatomic_inc(&owner->so_count);\n\t/* Protect against nfs4_find_state() */\n\tspin_lock(&owner->so_lock);\n\tswitch (fmode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(state, gfp_mask, wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __nfs4_close(struct nfs4_state *state,\n\t\tfmode_t fmode, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tfmode_t newstate;\n\n\tatomic_inc(&owner->so_count);\n\t/* Protect against nfs4_find_state() */\n\tspin_lock(&owner->so_lock);\n\tswitch (fmode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(state, gfp_mask, wait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_close_state(struct nfs4_state *state, fmode_t fmode)\n{\n\t__nfs4_close(state, fmode, GFP_NOFS, 0);\n}"
  },
  {
    "function_name": "__nfs4_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "744-787",
    "snippet": "static void __nfs4_close(struct nfs4_state *state,\n\t\tfmode_t fmode, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tfmode_t newstate;\n\n\tatomic_inc(&owner->so_count);\n\t/* Protect against nfs4_find_state() */\n\tspin_lock(&owner->so_lock);\n\tswitch (fmode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(state, gfp_mask, wait);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_do_close",
          "args": [
            "state",
            "gfp_mask",
            "wait"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_do_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "2772-2832",
          "snippet": "int nfs4_do_close(struct nfs4_state *state, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\tstruct nfs4_closedata *calldata;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_close_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = -ENOMEM;\n\n\tnfs4_state_protect(server->nfs_client, NFS_SP4_MACH_CRED_CLEANUP,\n\t\t&task_setup_data.rpc_client, &msg);\n\n\tcalldata = kzalloc(sizeof(*calldata), gfp_mask);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tnfs4_init_sequence(&calldata->arg.seq_args, &calldata->res.seq_res, 1);\n\tcalldata->inode = state->inode;\n\tcalldata->state = state;\n\tcalldata->arg.fh = NFS_FH(state->inode);\n\t/* Serialization for the sequence id */\n\talloc_seqid = server->nfs_client->cl_mvops->alloc_seqid;\n\tcalldata->arg.seqid = alloc_seqid(&state->owner->so_seqid, gfp_mask);\n\tif (IS_ERR(calldata->arg.seqid))\n\t\tgoto out_free_calldata;\n\tcalldata->arg.fmode = 0;\n\tcalldata->arg.bitmask = server->cache_consistency_bitmask;\n\tcalldata->res.fattr = &calldata->fattr;\n\tcalldata->res.seqid = calldata->arg.seqid;\n\tcalldata->res.server = server;\n\tcalldata->roc = nfs4_roc(state->inode);\n\tnfs_sb_active(calldata->inode->i_sb);\n\n\tmsg.rpc_argp = &calldata->arg;\n\tmsg.rpc_resp = &calldata->res;\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = 0;\n\tif (wait)\n\t\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn status;\nout_free_calldata:\n\tkfree(calldata);\nout:\n\tnfs4_put_open_state(state);\n\tnfs4_put_state_owner(sp);\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_async_handle_error(struct rpc_task *, const struct nfs_server *, struct nfs4_state *, long *);",
            "static void nfs_fixup_referral_attributes(struct nfs_fattr *fattr);",
            "static const struct rpc_call_ops nfs4_close_ops = {\n\t.rpc_call_prepare = nfs4_close_prepare,\n\t.rpc_call_done = nfs4_close_done,\n\t.rpc_release = nfs4_free_closedata,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_async_handle_error(struct rpc_task *, const struct nfs_server *, struct nfs4_state *, long *);\nstatic void nfs_fixup_referral_attributes(struct nfs_fattr *fattr);\nstatic const struct rpc_call_ops nfs4_close_ops = {\n\t.rpc_call_prepare = nfs4_close_prepare,\n\t.rpc_call_done = nfs4_close_done,\n\t.rpc_release = nfs4_free_closedata,\n};\n\nint nfs4_do_close(struct nfs4_state *state, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\tstruct nfs4_closedata *calldata;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_close_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = -ENOMEM;\n\n\tnfs4_state_protect(server->nfs_client, NFS_SP4_MACH_CRED_CLEANUP,\n\t\t&task_setup_data.rpc_client, &msg);\n\n\tcalldata = kzalloc(sizeof(*calldata), gfp_mask);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tnfs4_init_sequence(&calldata->arg.seq_args, &calldata->res.seq_res, 1);\n\tcalldata->inode = state->inode;\n\tcalldata->state = state;\n\tcalldata->arg.fh = NFS_FH(state->inode);\n\t/* Serialization for the sequence id */\n\talloc_seqid = server->nfs_client->cl_mvops->alloc_seqid;\n\tcalldata->arg.seqid = alloc_seqid(&state->owner->so_seqid, gfp_mask);\n\tif (IS_ERR(calldata->arg.seqid))\n\t\tgoto out_free_calldata;\n\tcalldata->arg.fmode = 0;\n\tcalldata->arg.bitmask = server->cache_consistency_bitmask;\n\tcalldata->res.fattr = &calldata->fattr;\n\tcalldata->res.seqid = calldata->arg.seqid;\n\tcalldata->res.server = server;\n\tcalldata->roc = nfs4_roc(state->inode);\n\tnfs_sb_active(calldata->inode->i_sb);\n\n\tmsg.rpc_argp = &calldata->arg;\n\tmsg.rpc_resp = &calldata->res;\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = 0;\n\tif (wait)\n\t\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn status;\nout_free_calldata:\n\tkfree(calldata);\nout:\n\tnfs4_put_open_state(state);\n\tnfs4_put_state_owner(sp);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_state_owner",
          "args": [
            "owner"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_state_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "595-606",
          "snippet": "void nfs4_put_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!atomic_dec_and_lock(&sp->so_count, &clp->cl_lock))\n\t\treturn;\n\n\tsp->so_expires = jiffies;\n\tlist_add_tail(&sp->so_lru, &server->state_owners_lru);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_put_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!atomic_dec_and_lock(&sp->so_count, &clp->cl_lock))\n\t\treturn;\n\n\tsp->so_expires = jiffies;\n\tlist_add_tail(&sp->so_lru, &server->state_owners_lru);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_open_state",
          "args": [
            "state"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_open_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "724-739",
          "snippet": "void nfs4_put_open_state(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs4_state_owner *owner = state->owner;\n\n\tif (!atomic_dec_and_lock(&state->count, &owner->so_lock))\n\t\treturn;\n\tspin_lock(&inode->i_lock);\n\tlist_del(&state->inode_states);\n\tlist_del(&state->open_states);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&owner->so_lock);\n\tiput(inode);\n\tnfs4_free_open_state(state);\n\tnfs4_put_state_owner(owner);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_put_open_state(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs4_state_owner *owner = state->owner;\n\n\tif (!atomic_dec_and_lock(&state->count, &owner->so_lock))\n\t\treturn;\n\tspin_lock(&inode->i_lock);\n\tlist_del(&state->inode_states);\n\tlist_del(&state->open_states);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&owner->so_lock);\n\tiput(inode);\n\tnfs4_free_open_state(state);\n\tnfs4_put_state_owner(owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&owner->so_lock"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_set_mode_locked",
          "args": [
            "state",
            "newstate"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_set_mode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "649-662",
          "snippet": "void\nnfs4_state_set_mode_locked(struct nfs4_state *state, fmode_t fmode)\n{\n\tif (state->state == fmode)\n\t\treturn;\n\t/* NB! List reordering - see the reclaim code for why.  */\n\tif ((fmode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (fmode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = fmode;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid\nnfs4_state_set_mode_locked(struct nfs4_state *state, fmode_t fmode)\n{\n\tif (state->state == fmode)\n\t\treturn;\n\t/* NB! List reordering - see the reclaim code for why.  */\n\tif ((fmode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (fmode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = fmode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_DELEGATED_STATE",
            "&state->flags"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_O_RDWR_STATE",
            "&state->flags"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&owner->so_lock"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&owner->so_count"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __nfs4_close(struct nfs4_state *state,\n\t\tfmode_t fmode, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tfmode_t newstate;\n\n\tatomic_inc(&owner->so_count);\n\t/* Protect against nfs4_find_state() */\n\tspin_lock(&owner->so_lock);\n\tswitch (fmode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(state, gfp_mask, wait);\n}"
  },
  {
    "function_name": "nfs4_put_open_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "724-739",
    "snippet": "void nfs4_put_open_state(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs4_state_owner *owner = state->owner;\n\n\tif (!atomic_dec_and_lock(&state->count, &owner->so_lock))\n\t\treturn;\n\tspin_lock(&inode->i_lock);\n\tlist_del(&state->inode_states);\n\tlist_del(&state->open_states);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&owner->so_lock);\n\tiput(inode);\n\tnfs4_free_open_state(state);\n\tnfs4_put_state_owner(owner);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_state_owner",
          "args": [
            "owner"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_state_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "595-606",
          "snippet": "void nfs4_put_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!atomic_dec_and_lock(&sp->so_count, &clp->cl_lock))\n\t\treturn;\n\n\tsp->so_expires = jiffies;\n\tlist_add_tail(&sp->so_lru, &server->state_owners_lru);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_put_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!atomic_dec_and_lock(&sp->so_count, &clp->cl_lock))\n\t\treturn;\n\n\tsp->so_expires = jiffies;\n\tlist_add_tail(&sp->so_lru, &server->state_owners_lru);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_free_open_state",
          "args": [
            "state"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_open_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "681-685",
          "snippet": "static void\nnfs4_free_open_state(struct nfs4_state *state)\n{\n\tkfree(state);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_free_open_state(struct nfs4_state *state)\n{\n\tkfree(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iput_and_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "527-535",
          "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "void nfs_initialise_sb(struct super_block *);",
            "void nfs_kill_super(struct super_block *);",
            "extern bool nfs_sb_active(struct super_block *sb);",
            "extern void nfs_sb_deactive(struct super_block *sb);",
            "void nfs_umount_begin(struct super_block *);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&owner->so_lock"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&state->open_states"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&state->count",
            "&owner->so_lock"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_put_open_state(struct nfs4_state *state)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs4_state_owner *owner = state->owner;\n\n\tif (!atomic_dec_and_lock(&state->count, &owner->so_lock))\n\t\treturn;\n\tspin_lock(&inode->i_lock);\n\tlist_del(&state->inode_states);\n\tlist_del(&state->open_states);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&owner->so_lock);\n\tiput(inode);\n\tnfs4_free_open_state(state);\n\tnfs4_put_state_owner(owner);\n}"
  },
  {
    "function_name": "nfs4_get_open_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "687-722",
    "snippet": "struct nfs4_state *\nnfs4_get_open_state(struct inode *inode, struct nfs4_state_owner *owner)\n{\n\tstruct nfs4_state *state, *new;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tstate = __nfs4_find_state_byowner(inode, owner);\n\tspin_unlock(&inode->i_lock);\n\tif (state)\n\t\tgoto out;\n\tnew = nfs4_alloc_open_state();\n\tspin_lock(&owner->so_lock);\n\tspin_lock(&inode->i_lock);\n\tstate = __nfs4_find_state_byowner(inode, owner);\n\tif (state == NULL && new != NULL) {\n\t\tstate = new;\n\t\tstate->owner = owner;\n\t\tatomic_inc(&owner->so_count);\n\t\tlist_add(&state->inode_states, &nfsi->open_states);\n\t\tihold(inode);\n\t\tstate->inode = inode;\n\t\tspin_unlock(&inode->i_lock);\n\t\t/* Note: The reclaim code dictates that we add stateless\n\t\t * and read-only stateids to the end of the list */\n\t\tlist_add_tail(&state->open_states, &owner->so_states);\n\t\tspin_unlock(&owner->so_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&owner->so_lock);\n\t\tif (new)\n\t\t\tnfs4_free_open_state(new);\n\t}\nout:\n\treturn state;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_free_open_state",
          "args": [
            "new"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_open_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "681-685",
          "snippet": "static void\nnfs4_free_open_state(struct nfs4_state *state)\n{\n\tkfree(state);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_free_open_state(struct nfs4_state *state)\n{\n\tkfree(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&owner->so_lock"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&state->open_states",
            "&owner->so_states"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&state->inode_states",
            "&nfsi->open_states"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&owner->so_count"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nfs4_find_state_byowner",
          "args": [
            "inode",
            "owner"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_find_state_byowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "664-679",
          "snippet": "static struct nfs4_state *\n__nfs4_find_state_byowner(struct inode *inode, struct nfs4_state_owner *owner)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_state *state;\n\n\tlist_for_each_entry(state, &nfsi->open_states, inode_states) {\n\t\tif (state->owner != owner)\n\t\t\tcontinue;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tcontinue;\n\t\tif (atomic_inc_not_zero(&state->count))\n\t\t\treturn state;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_state *\n__nfs4_find_state_byowner(struct inode *inode, struct nfs4_state_owner *owner)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_state *state;\n\n\tlist_for_each_entry(state, &nfsi->open_states, inode_states) {\n\t\tif (state->owner != owner)\n\t\t\tcontinue;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tcontinue;\n\t\tif (atomic_inc_not_zero(&state->count))\n\t\t\treturn state;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_open_state",
          "args": [],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_open_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "634-647",
          "snippet": "static struct nfs4_state *\nnfs4_alloc_open_state(void)\n{\n\tstruct nfs4_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_NOFS);\n\tif (!state)\n\t\treturn NULL;\n\tatomic_set(&state->count, 1);\n\tINIT_LIST_HEAD(&state->lock_states);\n\tspin_lock_init(&state->state_lock);\n\tseqlock_init(&state->seqlock);\n\treturn state;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_state *\nnfs4_alloc_open_state(void)\n{\n\tstruct nfs4_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_NOFS);\n\tif (!state)\n\t\treturn NULL;\n\tatomic_set(&state->count, 1);\n\tINIT_LIST_HEAD(&state->lock_states);\n\tspin_lock_init(&state->state_lock);\n\tseqlock_init(&state->seqlock);\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct nfs4_state *\nnfs4_get_open_state(struct inode *inode, struct nfs4_state_owner *owner)\n{\n\tstruct nfs4_state *state, *new;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tstate = __nfs4_find_state_byowner(inode, owner);\n\tspin_unlock(&inode->i_lock);\n\tif (state)\n\t\tgoto out;\n\tnew = nfs4_alloc_open_state();\n\tspin_lock(&owner->so_lock);\n\tspin_lock(&inode->i_lock);\n\tstate = __nfs4_find_state_byowner(inode, owner);\n\tif (state == NULL && new != NULL) {\n\t\tstate = new;\n\t\tstate->owner = owner;\n\t\tatomic_inc(&owner->so_count);\n\t\tlist_add(&state->inode_states, &nfsi->open_states);\n\t\tihold(inode);\n\t\tstate->inode = inode;\n\t\tspin_unlock(&inode->i_lock);\n\t\t/* Note: The reclaim code dictates that we add stateless\n\t\t * and read-only stateids to the end of the list */\n\t\tlist_add_tail(&state->open_states, &owner->so_states);\n\t\tspin_unlock(&owner->so_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&owner->so_lock);\n\t\tif (new)\n\t\t\tnfs4_free_open_state(new);\n\t}\nout:\n\treturn state;\n}"
  },
  {
    "function_name": "nfs4_free_open_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "681-685",
    "snippet": "static void\nnfs4_free_open_state(struct nfs4_state *state)\n{\n\tkfree(state);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "state"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_free_open_state(struct nfs4_state *state)\n{\n\tkfree(state);\n}"
  },
  {
    "function_name": "__nfs4_find_state_byowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "664-679",
    "snippet": "static struct nfs4_state *\n__nfs4_find_state_byowner(struct inode *inode, struct nfs4_state_owner *owner)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_state *state;\n\n\tlist_for_each_entry(state, &nfsi->open_states, inode_states) {\n\t\tif (state->owner != owner)\n\t\t\tcontinue;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tcontinue;\n\t\tif (atomic_inc_not_zero(&state->count))\n\t\t\treturn state;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&state->count"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_valid_open_stateid",
          "args": [
            "state"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_valid_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "516-519",
          "snippet": "static inline bool nfs4_valid_open_stateid(const struct nfs4_state *state)\n{\n\treturn test_bit(NFS_STATE_RECOVERY_FAILED, &state->flags) == 0;\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline bool nfs4_valid_open_stateid(const struct nfs4_state *state)\n{\n\treturn test_bit(NFS_STATE_RECOVERY_FAILED, &state->flags) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "state",
            "&nfsi->open_states",
            "inode_states"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_state *\n__nfs4_find_state_byowner(struct inode *inode, struct nfs4_state_owner *owner)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_state *state;\n\n\tlist_for_each_entry(state, &nfsi->open_states, inode_states) {\n\t\tif (state->owner != owner)\n\t\t\tcontinue;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tcontinue;\n\t\tif (atomic_inc_not_zero(&state->count))\n\t\t\treturn state;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_state_set_mode_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "649-662",
    "snippet": "void\nnfs4_state_set_mode_locked(struct nfs4_state *state, fmode_t fmode)\n{\n\tif (state->state == fmode)\n\t\treturn;\n\t/* NB! List reordering - see the reclaim code for why.  */\n\tif ((fmode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (fmode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = fmode;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&state->open_states",
            "&state->owner->so_states"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&state->open_states",
            "&state->owner->so_states"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid\nnfs4_state_set_mode_locked(struct nfs4_state *state, fmode_t fmode)\n{\n\tif (state->state == fmode)\n\t\treturn;\n\t/* NB! List reordering - see the reclaim code for why.  */\n\tif ((fmode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (fmode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = fmode;\n}"
  },
  {
    "function_name": "nfs4_alloc_open_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "634-647",
    "snippet": "static struct nfs4_state *\nnfs4_alloc_open_state(void)\n{\n\tstruct nfs4_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_NOFS);\n\tif (!state)\n\t\treturn NULL;\n\tatomic_set(&state->count, 1);\n\tINIT_LIST_HEAD(&state->lock_states);\n\tspin_lock_init(&state->state_lock);\n\tseqlock_init(&state->seqlock);\n\treturn state;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seqlock_init",
          "args": [
            "&state->seqlock"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&state->state_lock"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&state->lock_states"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&state->count",
            "1"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*state)",
            "GFP_NOFS"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_state *\nnfs4_alloc_open_state(void)\n{\n\tstruct nfs4_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_NOFS);\n\tif (!state)\n\t\treturn NULL;\n\tatomic_set(&state->count, 1);\n\tINIT_LIST_HEAD(&state->lock_states);\n\tspin_lock_init(&state->state_lock);\n\tseqlock_init(&state->seqlock);\n\treturn state;\n}"
  },
  {
    "function_name": "nfs4_purge_state_owners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "615-632",
    "snippet": "void nfs4_purge_state_owners(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *tmp;\n\tLIST_HEAD(doomed);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(sp, tmp, &server->state_owners_lru, so_lru) {\n\t\tlist_move(&sp->so_lru, &doomed);\n\t\tnfs4_remove_state_owner_locked(sp);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tlist_for_each_entry_safe(sp, tmp, &doomed, so_lru) {\n\t\tlist_del(&sp->so_lru);\n\t\tnfs4_free_state_owner(sp);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_free_state_owner",
          "args": [
            "sp"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_state_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "515-520",
          "snippet": "static void nfs4_free_state_owner(struct nfs4_state_owner *sp)\n{\n\tnfs4_destroy_seqid_counter(&sp->so_seqid);\n\tput_rpccred(sp->so_cred);\n\tkfree(sp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_free_state_owner(struct nfs4_state_owner *sp)\n{\n\tnfs4_destroy_seqid_counter(&sp->so_seqid);\n\tput_rpccred(sp->so_cred);\n\tkfree(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sp->so_lru"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "sp",
            "tmp",
            "&doomed",
            "so_lru"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_remove_state_owner_locked",
          "args": [
            "sp"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_remove_state_owner_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "443-451",
          "snippet": "static void\nnfs4_remove_state_owner_locked(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\n\tif (!RB_EMPTY_NODE(&sp->so_server_node))\n\t\trb_erase(&sp->so_server_node, &server->state_owners);\n\tida_remove(&server->openowner_id, sp->so_seqid.owner_id);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_remove_state_owner_locked(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\n\tif (!RB_EMPTY_NODE(&sp->so_server_node))\n\t\trb_erase(&sp->so_server_node, &server->state_owners);\n\tida_remove(&server->openowner_id, sp->so_seqid.owner_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&sp->so_lru",
            "&doomed"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "sp",
            "tmp",
            "&server->state_owners_lru",
            "so_lru"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "doomed"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_purge_state_owners(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *tmp;\n\tLIST_HEAD(doomed);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(sp, tmp, &server->state_owners_lru, so_lru) {\n\t\tlist_move(&sp->so_lru, &doomed);\n\t\tnfs4_remove_state_owner_locked(sp);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tlist_for_each_entry_safe(sp, tmp, &doomed, so_lru) {\n\t\tlist_del(&sp->so_lru);\n\t\tnfs4_free_state_owner(sp);\n\t}\n}"
  },
  {
    "function_name": "nfs4_put_state_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "595-606",
    "snippet": "void nfs4_put_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!atomic_dec_and_lock(&sp->so_count, &clp->cl_lock))\n\t\treturn;\n\n\tsp->so_expires = jiffies;\n\tlist_add_tail(&sp->so_lru, &server->state_owners_lru);\n\tspin_unlock(&clp->cl_lock);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&sp->so_lru",
            "&server->state_owners_lru"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&sp->so_count",
            "&clp->cl_lock"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_put_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!atomic_dec_and_lock(&sp->so_count, &clp->cl_lock))\n\t\treturn;\n\n\tsp->so_expires = jiffies;\n\tlist_add_tail(&sp->so_lru, &server->state_owners_lru);\n\tspin_unlock(&clp->cl_lock);\n}"
  },
  {
    "function_name": "nfs4_get_state_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "554-581",
    "snippet": "struct nfs4_state_owner *nfs4_get_state_owner(struct nfs_server *server,\n\t\t\t\t\t      struct rpc_cred *cred,\n\t\t\t\t\t      gfp_t gfp_flags)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *new;\n\n\tspin_lock(&clp->cl_lock);\n\tsp = nfs4_find_state_owner_locked(server, cred);\n\tspin_unlock(&clp->cl_lock);\n\tif (sp != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_state_owner(server, cred, gfp_flags);\n\tif (new == NULL)\n\t\tgoto out;\n\tdo {\n\t\tif (ida_pre_get(&server->openowner_id, gfp_flags) == 0)\n\t\t\tbreak;\n\t\tspin_lock(&clp->cl_lock);\n\t\tsp = nfs4_insert_state_owner_locked(new);\n\t\tspin_unlock(&clp->cl_lock);\n\t} while (sp == ERR_PTR(-EAGAIN));\n\tif (sp != new)\n\t\tnfs4_free_state_owner(new);\nout:\n\tnfs4_gc_state_owners(server);\n\treturn sp;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_gc_state_owners",
          "args": [
            "server"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_gc_state_owners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "522-545",
          "snippet": "static void nfs4_gc_state_owners(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *tmp;\n\tunsigned long time_min, time_max;\n\tLIST_HEAD(doomed);\n\n\tspin_lock(&clp->cl_lock);\n\ttime_max = jiffies;\n\ttime_min = (long)time_max - (long)clp->cl_lease_time;\n\tlist_for_each_entry_safe(sp, tmp, &server->state_owners_lru, so_lru) {\n\t\t/* NB: LRU is sorted so that oldest is at the head */\n\t\tif (time_in_range(sp->so_expires, time_min, time_max))\n\t\t\tbreak;\n\t\tlist_move(&sp->so_lru, &doomed);\n\t\tnfs4_remove_state_owner_locked(sp);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tlist_for_each_entry_safe(sp, tmp, &doomed, so_lru) {\n\t\tlist_del(&sp->so_lru);\n\t\tnfs4_free_state_owner(sp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_gc_state_owners(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *tmp;\n\tunsigned long time_min, time_max;\n\tLIST_HEAD(doomed);\n\n\tspin_lock(&clp->cl_lock);\n\ttime_max = jiffies;\n\ttime_min = (long)time_max - (long)clp->cl_lease_time;\n\tlist_for_each_entry_safe(sp, tmp, &server->state_owners_lru, so_lru) {\n\t\t/* NB: LRU is sorted so that oldest is at the head */\n\t\tif (time_in_range(sp->so_expires, time_min, time_max))\n\t\t\tbreak;\n\t\tlist_move(&sp->so_lru, &doomed);\n\t\tnfs4_remove_state_owner_locked(sp);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tlist_for_each_entry_safe(sp, tmp, &doomed, so_lru) {\n\t\tlist_del(&sp->so_lru);\n\t\tnfs4_free_state_owner(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_free_state_owner",
          "args": [
            "new"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_state_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "515-520",
          "snippet": "static void nfs4_free_state_owner(struct nfs4_state_owner *sp)\n{\n\tnfs4_destroy_seqid_counter(&sp->so_seqid);\n\tput_rpccred(sp->so_cred);\n\tkfree(sp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_free_state_owner(struct nfs4_state_owner *sp)\n{\n\tnfs4_destroy_seqid_counter(&sp->so_seqid);\n\tput_rpccred(sp->so_cred);\n\tkfree(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EAGAIN"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_insert_state_owner_locked",
          "args": [
            "new"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_insert_state_owner_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "411-441",
          "snippet": "static struct nfs4_state_owner *\nnfs4_insert_state_owner_locked(struct nfs4_state_owner *new)\n{\n\tstruct nfs_server *server = new->so_server;\n\tstruct rb_node **p = &server->state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp;\n\tint err;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_server_node);\n\n\t\tif (new->so_cred < sp->so_cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (new->so_cred > sp->so_cred)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tif (!list_empty(&sp->so_lru))\n\t\t\t\tlist_del_init(&sp->so_lru);\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\treturn sp;\n\t\t}\n\t}\n\terr = ida_get_new(&server->openowner_id, &new->so_seqid.owner_id);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\trb_link_node(&new->so_server_node, parent, p);\n\trb_insert_color(&new->so_server_node, &server->state_owners);\n\treturn new;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_state_owner *\nnfs4_insert_state_owner_locked(struct nfs4_state_owner *new)\n{\n\tstruct nfs_server *server = new->so_server;\n\tstruct rb_node **p = &server->state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp;\n\tint err;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_server_node);\n\n\t\tif (new->so_cred < sp->so_cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (new->so_cred > sp->so_cred)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tif (!list_empty(&sp->so_lru))\n\t\t\t\tlist_del_init(&sp->so_lru);\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\treturn sp;\n\t\t}\n\t}\n\terr = ida_get_new(&server->openowner_id, &new->so_seqid.owner_id);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\trb_link_node(&new->so_server_node, parent, p);\n\trb_insert_color(&new->so_server_node, &server->state_owners);\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_pre_get",
          "args": [
            "&server->openowner_id",
            "gfp_flags"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_state_owner",
          "args": [
            "server",
            "cred",
            "gfp_flags"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_state_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "475-495",
          "snippet": "static struct nfs4_state_owner *\nnfs4_alloc_state_owner(struct nfs_server *server,\n\t\tstruct rpc_cred *cred,\n\t\tgfp_t gfp_flags)\n{\n\tstruct nfs4_state_owner *sp;\n\n\tsp = kzalloc(sizeof(*sp), gfp_flags);\n\tif (!sp)\n\t\treturn NULL;\n\tsp->so_server = server;\n\tsp->so_cred = get_rpccred(cred);\n\tspin_lock_init(&sp->so_lock);\n\tINIT_LIST_HEAD(&sp->so_states);\n\tnfs4_init_seqid_counter(&sp->so_seqid);\n\tatomic_set(&sp->so_count, 1);\n\tINIT_LIST_HEAD(&sp->so_lru);\n\tseqcount_init(&sp->so_reclaim_seqcount);\n\tmutex_init(&sp->so_delegreturn_mutex);\n\treturn sp;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_state_owner *\nnfs4_alloc_state_owner(struct nfs_server *server,\n\t\tstruct rpc_cred *cred,\n\t\tgfp_t gfp_flags)\n{\n\tstruct nfs4_state_owner *sp;\n\n\tsp = kzalloc(sizeof(*sp), gfp_flags);\n\tif (!sp)\n\t\treturn NULL;\n\tsp->so_server = server;\n\tsp->so_cred = get_rpccred(cred);\n\tspin_lock_init(&sp->so_lock);\n\tINIT_LIST_HEAD(&sp->so_states);\n\tnfs4_init_seqid_counter(&sp->so_seqid);\n\tatomic_set(&sp->so_count, 1);\n\tINIT_LIST_HEAD(&sp->so_lru);\n\tseqcount_init(&sp->so_reclaim_seqcount);\n\tmutex_init(&sp->so_delegreturn_mutex);\n\treturn sp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_find_state_owner_locked",
          "args": [
            "server",
            "cred"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_find_state_owner_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "386-409",
          "snippet": "static struct nfs4_state_owner *\nnfs4_find_state_owner_locked(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct rb_node **p = &server->state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_server_node);\n\n\t\tif (cred < sp->so_cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (cred > sp->so_cred)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tif (!list_empty(&sp->so_lru))\n\t\t\t\tlist_del_init(&sp->so_lru);\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\treturn sp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_state_owner *\nnfs4_find_state_owner_locked(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct rb_node **p = &server->state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_server_node);\n\n\t\tif (cred < sp->so_cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (cred > sp->so_cred)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tif (!list_empty(&sp->so_lru))\n\t\t\t\tlist_del_init(&sp->so_lru);\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\treturn sp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct nfs4_state_owner *nfs4_get_state_owner(struct nfs_server *server,\n\t\t\t\t\t      struct rpc_cred *cred,\n\t\t\t\t\t      gfp_t gfp_flags)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *new;\n\n\tspin_lock(&clp->cl_lock);\n\tsp = nfs4_find_state_owner_locked(server, cred);\n\tspin_unlock(&clp->cl_lock);\n\tif (sp != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_state_owner(server, cred, gfp_flags);\n\tif (new == NULL)\n\t\tgoto out;\n\tdo {\n\t\tif (ida_pre_get(&server->openowner_id, gfp_flags) == 0)\n\t\t\tbreak;\n\t\tspin_lock(&clp->cl_lock);\n\t\tsp = nfs4_insert_state_owner_locked(new);\n\t\tspin_unlock(&clp->cl_lock);\n\t} while (sp == ERR_PTR(-EAGAIN));\n\tif (sp != new)\n\t\tnfs4_free_state_owner(new);\nout:\n\tnfs4_gc_state_owners(server);\n\treturn sp;\n}"
  },
  {
    "function_name": "nfs4_gc_state_owners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "522-545",
    "snippet": "static void nfs4_gc_state_owners(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *tmp;\n\tunsigned long time_min, time_max;\n\tLIST_HEAD(doomed);\n\n\tspin_lock(&clp->cl_lock);\n\ttime_max = jiffies;\n\ttime_min = (long)time_max - (long)clp->cl_lease_time;\n\tlist_for_each_entry_safe(sp, tmp, &server->state_owners_lru, so_lru) {\n\t\t/* NB: LRU is sorted so that oldest is at the head */\n\t\tif (time_in_range(sp->so_expires, time_min, time_max))\n\t\t\tbreak;\n\t\tlist_move(&sp->so_lru, &doomed);\n\t\tnfs4_remove_state_owner_locked(sp);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tlist_for_each_entry_safe(sp, tmp, &doomed, so_lru) {\n\t\tlist_del(&sp->so_lru);\n\t\tnfs4_free_state_owner(sp);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_free_state_owner",
          "args": [
            "sp"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_state_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "515-520",
          "snippet": "static void nfs4_free_state_owner(struct nfs4_state_owner *sp)\n{\n\tnfs4_destroy_seqid_counter(&sp->so_seqid);\n\tput_rpccred(sp->so_cred);\n\tkfree(sp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_free_state_owner(struct nfs4_state_owner *sp)\n{\n\tnfs4_destroy_seqid_counter(&sp->so_seqid);\n\tput_rpccred(sp->so_cred);\n\tkfree(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sp->so_lru"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "sp",
            "tmp",
            "&doomed",
            "so_lru"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_remove_state_owner_locked",
          "args": [
            "sp"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_remove_state_owner_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "443-451",
          "snippet": "static void\nnfs4_remove_state_owner_locked(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\n\tif (!RB_EMPTY_NODE(&sp->so_server_node))\n\t\trb_erase(&sp->so_server_node, &server->state_owners);\n\tida_remove(&server->openowner_id, sp->so_seqid.owner_id);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_remove_state_owner_locked(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\n\tif (!RB_EMPTY_NODE(&sp->so_server_node))\n\t\trb_erase(&sp->so_server_node, &server->state_owners);\n\tida_remove(&server->openowner_id, sp->so_seqid.owner_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&sp->so_lru",
            "&doomed"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_in_range",
          "args": [
            "sp->so_expires",
            "time_min",
            "time_max"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "sp",
            "tmp",
            "&server->state_owners_lru",
            "so_lru"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "doomed"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_gc_state_owners(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state_owner *sp, *tmp;\n\tunsigned long time_min, time_max;\n\tLIST_HEAD(doomed);\n\n\tspin_lock(&clp->cl_lock);\n\ttime_max = jiffies;\n\ttime_min = (long)time_max - (long)clp->cl_lease_time;\n\tlist_for_each_entry_safe(sp, tmp, &server->state_owners_lru, so_lru) {\n\t\t/* NB: LRU is sorted so that oldest is at the head */\n\t\tif (time_in_range(sp->so_expires, time_min, time_max))\n\t\t\tbreak;\n\t\tlist_move(&sp->so_lru, &doomed);\n\t\tnfs4_remove_state_owner_locked(sp);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tlist_for_each_entry_safe(sp, tmp, &doomed, so_lru) {\n\t\tlist_del(&sp->so_lru);\n\t\tnfs4_free_state_owner(sp);\n\t}\n}"
  },
  {
    "function_name": "nfs4_free_state_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "515-520",
    "snippet": "static void nfs4_free_state_owner(struct nfs4_state_owner *sp)\n{\n\tnfs4_destroy_seqid_counter(&sp->so_seqid);\n\tput_rpccred(sp->so_cred);\n\tkfree(sp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sp"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "sp->so_cred"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_destroy_seqid_counter",
          "args": [
            "&sp->so_seqid"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_free_state_owner(struct nfs4_state_owner *sp)\n{\n\tnfs4_destroy_seqid_counter(&sp->so_seqid);\n\tput_rpccred(sp->so_cred);\n\tkfree(sp);\n}"
  },
  {
    "function_name": "nfs4_drop_state_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "497-513",
    "snippet": "static void\nnfs4_drop_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct rb_node *rb_node = &sp->so_server_node;\n\n\tif (!RB_EMPTY_NODE(rb_node)) {\n\t\tstruct nfs_server *server = sp->so_server;\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (!RB_EMPTY_NODE(rb_node)) {\n\t\t\trb_erase(rb_node, &server->state_owners);\n\t\t\tRB_CLEAR_NODE(rb_node);\n\t\t}\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "rb_node"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "rb_node",
            "&server->state_owners"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "rb_node"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "rb_node"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_drop_state_owner(struct nfs4_state_owner *sp)\n{\n\tstruct rb_node *rb_node = &sp->so_server_node;\n\n\tif (!RB_EMPTY_NODE(rb_node)) {\n\t\tstruct nfs_server *server = sp->so_server;\n\t\tstruct nfs_client *clp = server->nfs_client;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (!RB_EMPTY_NODE(rb_node)) {\n\t\t\trb_erase(rb_node, &server->state_owners);\n\t\t\tRB_CLEAR_NODE(rb_node);\n\t\t}\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}"
  },
  {
    "function_name": "nfs4_alloc_state_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "475-495",
    "snippet": "static struct nfs4_state_owner *\nnfs4_alloc_state_owner(struct nfs_server *server,\n\t\tstruct rpc_cred *cred,\n\t\tgfp_t gfp_flags)\n{\n\tstruct nfs4_state_owner *sp;\n\n\tsp = kzalloc(sizeof(*sp), gfp_flags);\n\tif (!sp)\n\t\treturn NULL;\n\tsp->so_server = server;\n\tsp->so_cred = get_rpccred(cred);\n\tspin_lock_init(&sp->so_lock);\n\tINIT_LIST_HEAD(&sp->so_states);\n\tnfs4_init_seqid_counter(&sp->so_seqid);\n\tatomic_set(&sp->so_count, 1);\n\tINIT_LIST_HEAD(&sp->so_lru);\n\tseqcount_init(&sp->so_reclaim_seqcount);\n\tmutex_init(&sp->so_delegreturn_mutex);\n\treturn sp;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sp->so_delegreturn_mutex"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seqcount_init",
          "args": [
            "&sp->so_reclaim_seqcount"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sp->so_lru"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sp->so_count",
            "1"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_init_seqid_counter",
          "args": [
            "&sp->so_seqid"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_init_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "453-462",
          "snippet": "static void\nnfs4_init_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\tsc->create_time = ktime_get();\n\tsc->flags = 0;\n\tsc->counter = 0;\n\tspin_lock_init(&sc->lock);\n\tINIT_LIST_HEAD(&sc->list);\n\trpc_init_wait_queue(&sc->wait, \"Seqid_waitqueue\");\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_init_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\tsc->create_time = ktime_get();\n\tsc->flags = 0;\n\tsc->counter = 0;\n\tspin_lock_init(&sc->lock);\n\tINIT_LIST_HEAD(&sc->list);\n\trpc_init_wait_queue(&sc->wait, \"Seqid_waitqueue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sp->so_states"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sp->so_lock"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rpccred",
          "args": [
            "cred"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sp)",
            "gfp_flags"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_state_owner *\nnfs4_alloc_state_owner(struct nfs_server *server,\n\t\tstruct rpc_cred *cred,\n\t\tgfp_t gfp_flags)\n{\n\tstruct nfs4_state_owner *sp;\n\n\tsp = kzalloc(sizeof(*sp), gfp_flags);\n\tif (!sp)\n\t\treturn NULL;\n\tsp->so_server = server;\n\tsp->so_cred = get_rpccred(cred);\n\tspin_lock_init(&sp->so_lock);\n\tINIT_LIST_HEAD(&sp->so_states);\n\tnfs4_init_seqid_counter(&sp->so_seqid);\n\tatomic_set(&sp->so_count, 1);\n\tINIT_LIST_HEAD(&sp->so_lru);\n\tseqcount_init(&sp->so_reclaim_seqcount);\n\tmutex_init(&sp->so_delegreturn_mutex);\n\treturn sp;\n}"
  },
  {
    "function_name": "nfs4_destroy_seqid_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "464-468",
    "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_destroy_wait_queue",
          "args": [
            "&sc->wait"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
  },
  {
    "function_name": "nfs4_init_seqid_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "453-462",
    "snippet": "static void\nnfs4_init_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\tsc->create_time = ktime_get();\n\tsc->flags = 0;\n\tsc->counter = 0;\n\tspin_lock_init(&sc->lock);\n\tINIT_LIST_HEAD(&sc->list);\n\trpc_init_wait_queue(&sc->wait, \"Seqid_waitqueue\");\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_init_wait_queue",
          "args": [
            "&sc->wait",
            "\"Seqid_waitqueue\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sc->list"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sc->lock"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_init_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\tsc->create_time = ktime_get();\n\tsc->flags = 0;\n\tsc->counter = 0;\n\tspin_lock_init(&sc->lock);\n\tINIT_LIST_HEAD(&sc->list);\n\trpc_init_wait_queue(&sc->wait, \"Seqid_waitqueue\");\n}"
  },
  {
    "function_name": "nfs4_remove_state_owner_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "443-451",
    "snippet": "static void\nnfs4_remove_state_owner_locked(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\n\tif (!RB_EMPTY_NODE(&sp->so_server_node))\n\t\trb_erase(&sp->so_server_node, &server->state_owners);\n\tida_remove(&server->openowner_id, sp->so_seqid.owner_id);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ida_remove",
          "args": [
            "&server->openowner_id",
            "sp->so_seqid.owner_id"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&sp->so_server_node",
            "&server->state_owners"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&sp->so_server_node"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_remove_state_owner_locked(struct nfs4_state_owner *sp)\n{\n\tstruct nfs_server *server = sp->so_server;\n\n\tif (!RB_EMPTY_NODE(&sp->so_server_node))\n\t\trb_erase(&sp->so_server_node, &server->state_owners);\n\tida_remove(&server->openowner_id, sp->so_seqid.owner_id);\n}"
  },
  {
    "function_name": "nfs4_insert_state_owner_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "411-441",
    "snippet": "static struct nfs4_state_owner *\nnfs4_insert_state_owner_locked(struct nfs4_state_owner *new)\n{\n\tstruct nfs_server *server = new->so_server;\n\tstruct rb_node **p = &server->state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp;\n\tint err;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_server_node);\n\n\t\tif (new->so_cred < sp->so_cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (new->so_cred > sp->so_cred)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tif (!list_empty(&sp->so_lru))\n\t\t\t\tlist_del_init(&sp->so_lru);\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\treturn sp;\n\t\t}\n\t}\n\terr = ida_get_new(&server->openowner_id, &new->so_seqid.owner_id);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\trb_link_node(&new->so_server_node, parent, p);\n\trb_insert_color(&new->so_server_node, &server->state_owners);\n\treturn new;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new->so_server_node",
            "&server->state_owners"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new->so_server_node",
            "parent",
            "p"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_get_new",
          "args": [
            "&server->openowner_id",
            "&new->so_seqid.owner_id"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sp->so_count"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&sp->so_lru"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sp->so_lru"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structnfs4_state_owner",
            "so_server_node"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_state_owner *\nnfs4_insert_state_owner_locked(struct nfs4_state_owner *new)\n{\n\tstruct nfs_server *server = new->so_server;\n\tstruct rb_node **p = &server->state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp;\n\tint err;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_server_node);\n\n\t\tif (new->so_cred < sp->so_cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (new->so_cred > sp->so_cred)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tif (!list_empty(&sp->so_lru))\n\t\t\t\tlist_del_init(&sp->so_lru);\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\treturn sp;\n\t\t}\n\t}\n\terr = ida_get_new(&server->openowner_id, &new->so_seqid.owner_id);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\trb_link_node(&new->so_server_node, parent, p);\n\trb_insert_color(&new->so_server_node, &server->state_owners);\n\treturn new;\n}"
  },
  {
    "function_name": "nfs4_find_state_owner_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "386-409",
    "snippet": "static struct nfs4_state_owner *\nnfs4_find_state_owner_locked(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct rb_node **p = &server->state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_server_node);\n\n\t\tif (cred < sp->so_cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (cred > sp->so_cred)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tif (!list_empty(&sp->so_lru))\n\t\t\t\tlist_del_init(&sp->so_lru);\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\treturn sp;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sp->so_count"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&sp->so_lru"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sp->so_lru"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structnfs4_state_owner",
            "so_server_node"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct nfs4_state_owner *\nnfs4_find_state_owner_locked(struct nfs_server *server, struct rpc_cred *cred)\n{\n\tstruct rb_node **p = &server->state_owners.rb_node,\n\t\t       *parent = NULL;\n\tstruct nfs4_state_owner *sp;\n\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tsp = rb_entry(parent, struct nfs4_state_owner, so_server_node);\n\n\t\tif (cred < sp->so_cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (cred > sp->so_cred)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\tif (!list_empty(&sp->so_lru))\n\t\t\t\tlist_del_init(&sp->so_lru);\n\t\t\tatomic_inc(&sp->so_count);\n\t\t\treturn sp;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_get_clid_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "376-384",
    "snippet": "struct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_machine_cred_locked",
          "args": [
            "clp"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_machine_cred_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "148-155",
          "snippet": "struct rpc_cred *nfs4_get_machine_cred_locked(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred = NULL;\n\n\tif (clp->cl_machine_cred != NULL)\n\t\tcred = get_rpccred(clp->cl_machine_cred);\n\treturn cred;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct rpc_cred *nfs4_get_machine_cred_locked(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred = NULL;\n\n\tif (clp->cl_machine_cred != NULL)\n\t\tcred = get_rpccred(clp->cl_machine_cred);\n\treturn cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct rpc_cred *nfs4_get_clid_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn cred;\n}"
  },
  {
    "function_name": "nfs41_discover_server_trunking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "340-366",
    "snippet": "int nfs41_discover_server_trunking(struct nfs_client *clp,\n\t\t\t\t   struct nfs_client **result,\n\t\t\t\t   struct rpc_cred *cred)\n{\n\tint status;\n\n\tstatus = nfs4_proc_exchange_id(clp, cred);\n\tif (status != NFS4_OK)\n\t\treturn status;\n\n\tstatus = nfs41_walk_client_list(clp, result, cred);\n\tif (status < 0)\n\t\treturn status;\n\tif (clp != *result)\n\t\treturn 0;\n\n\t/* Purge state if the client id was established in a prior instance */\n\tif (clp->cl_exchange_flags & EXCHGID4_FLAG_CONFIRMED_R)\n\t\tset_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\telse\n\t\tset_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n\tstatus = nfs_wait_client_init_complete(clp);\n\tif (status < 0)\n\t\tnfs_put_client(clp);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_put_client",
          "args": [
            "clp"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/client.c",
          "lines": "267-286",
          "snippet": "void nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <net/ipv6.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs_xdr.h>\n#include <net/ipv6.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_wait_client_init_complete",
          "args": [
            "clp"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wait_client_init_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/client.c",
          "lines": "439-443",
          "snippet": "int nfs_wait_client_init_complete(const struct nfs_client *clp)\n{\n\treturn wait_event_killable(nfs_client_active_wq,\n\t\t\tnfs_client_init_is_complete(clp));\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <net/ipv6.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(nfs_client_active_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs_xdr.h>\n#include <net/ipv6.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(nfs_client_active_wq);\n\nint nfs_wait_client_init_complete(const struct nfs_client *clp)\n{\n\treturn wait_event_killable(nfs_client_active_wq,\n\t\t\tnfs_client_init_is_complete(clp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_schedule_state_manager",
          "args": [
            "clp"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1147-1172",
          "snippet": "void nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs4_run_state_manager(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_run_state_manager(void *);\n\nvoid nfs4_schedule_state_manager(struct nfs_client *clp)\n{\n\tstruct task_struct *task;\n\tchar buf[INET6_ADDRSTRLEN + sizeof(\"-manager\") + 1];\n\n\tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)\n\t\treturn;\n\t__module_get(THIS_MODULE);\n\tatomic_inc(&clp->cl_count);\n\n\t/* The rcu_read_lock() is not strictly necessary, as the state\n\t * manager is the only thread that ever changes the rpc_xprt\n\t * after it's initialized.  At this point, we're single threaded. */\n\trcu_read_lock();\n\tsnprintf(buf, sizeof(buf), \"%s-manager\",\n\t\t\trpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\ttask = kthread_run(nfs4_run_state_manager, clp, \"%s\", buf);\n\tif (IS_ERR(task)) {\n\t\tprintk(KERN_ERR \"%s: kthread_run: %ld\\n\",\n\t\t\t__func__, PTR_ERR(task));\n\t\tnfs4_clear_state_manager_bit(clp);\n\t\tnfs_put_client(clp);\n\t\tmodule_put(THIS_MODULE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_LEASE_CONFIRM",
            "&clp->cl_state"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_walk_client_list",
          "args": [
            "clp",
            "result",
            "cred"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_walk_client_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4client.c",
          "lines": "613-684",
          "snippet": "int nfs41_walk_client_list(struct nfs_client *new,\n\t\t\t   struct nfs_client **result,\n\t\t\t   struct rpc_cred *cred)\n{\n\tstruct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);\n\tstruct nfs_client *pos, *prev = NULL;\n\tint status = -NFS4ERR_STALE_CLIENTID;\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {\n\n\t\tif (pos == new)\n\t\t\tgoto found;\n\n\t\tif (pos->rpc_ops != new->rpc_ops)\n\t\t\tcontinue;\n\n\t\tif (pos->cl_minorversion != new->cl_minorversion)\n\t\t\tcontinue;\n\n\t\t/* If \"pos\" isn't marked ready, we can't trust the\n\t\t * remaining fields in \"pos\", especially the client\n\t\t * ID and serverowner fields.  Wait for CREATE_SESSION\n\t\t * to finish. */\n\t\tif (pos->cl_cons_state > NFS_CS_READY) {\n\t\t\tatomic_inc(&pos->cl_count);\n\t\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\t\tnfs_put_client(prev);\n\t\t\tprev = pos;\n\n\t\t\tstatus = nfs_wait_client_init_complete(pos);\n\t\t\tspin_lock(&nn->nfs_client_lock);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = -NFS4ERR_STALE_CLIENTID;\n\t\t}\n\t\tif (pos->cl_cons_state != NFS_CS_READY)\n\t\t\tcontinue;\n\n\t\tif (!nfs4_match_clientids(pos, new))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Note that session trunking is just a special subcase of\n\t\t * client id trunking. In either case, we want to fall back\n\t\t * to using the existing nfs_client.\n\t\t */\n\t\tif (!nfs4_check_clientid_trunking(pos, new))\n\t\t\tcontinue;\n\n\t\t/* Unlike NFSv4.0, we know that NFSv4.1 always uses the\n\t\t * uniform string, however someone might switch the\n\t\t * uniquifier string on us.\n\t\t */\n\t\tif (!nfs4_match_client_owner_id(pos, new))\n\t\t\tcontinue;\nfound:\n\t\tatomic_inc(&pos->cl_count);\n\t\t*result = pos;\n\t\tstatus = 0;\n\t\tdprintk(\"NFS: <-- %s using nfs_client = %p ({%d})\\n\",\n\t\t\t__func__, pos, atomic_read(&pos->cl_count));\n\t\tbreak;\n\t}\n\n\t/* No matching nfs_client found. */\n\tspin_unlock(&nn->nfs_client_lock);\n\tdprintk(\"NFS: <-- %s status = %d\\n\", __func__, status);\n\tnfs_put_client(prev);\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"internal.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/auth.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"internal.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n\nint nfs41_walk_client_list(struct nfs_client *new,\n\t\t\t   struct nfs_client **result,\n\t\t\t   struct rpc_cred *cred)\n{\n\tstruct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);\n\tstruct nfs_client *pos, *prev = NULL;\n\tint status = -NFS4ERR_STALE_CLIENTID;\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {\n\n\t\tif (pos == new)\n\t\t\tgoto found;\n\n\t\tif (pos->rpc_ops != new->rpc_ops)\n\t\t\tcontinue;\n\n\t\tif (pos->cl_minorversion != new->cl_minorversion)\n\t\t\tcontinue;\n\n\t\t/* If \"pos\" isn't marked ready, we can't trust the\n\t\t * remaining fields in \"pos\", especially the client\n\t\t * ID and serverowner fields.  Wait for CREATE_SESSION\n\t\t * to finish. */\n\t\tif (pos->cl_cons_state > NFS_CS_READY) {\n\t\t\tatomic_inc(&pos->cl_count);\n\t\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\t\tnfs_put_client(prev);\n\t\t\tprev = pos;\n\n\t\t\tstatus = nfs_wait_client_init_complete(pos);\n\t\t\tspin_lock(&nn->nfs_client_lock);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = -NFS4ERR_STALE_CLIENTID;\n\t\t}\n\t\tif (pos->cl_cons_state != NFS_CS_READY)\n\t\t\tcontinue;\n\n\t\tif (!nfs4_match_clientids(pos, new))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Note that session trunking is just a special subcase of\n\t\t * client id trunking. In either case, we want to fall back\n\t\t * to using the existing nfs_client.\n\t\t */\n\t\tif (!nfs4_check_clientid_trunking(pos, new))\n\t\t\tcontinue;\n\n\t\t/* Unlike NFSv4.0, we know that NFSv4.1 always uses the\n\t\t * uniform string, however someone might switch the\n\t\t * uniquifier string on us.\n\t\t */\n\t\tif (!nfs4_match_client_owner_id(pos, new))\n\t\t\tcontinue;\nfound:\n\t\tatomic_inc(&pos->cl_count);\n\t\t*result = pos;\n\t\tstatus = 0;\n\t\tdprintk(\"NFS: <-- %s using nfs_client = %p ({%d})\\n\",\n\t\t\t__func__, pos, atomic_read(&pos->cl_count));\n\t\tbreak;\n\t}\n\n\t/* No matching nfs_client found. */\n\tspin_unlock(&nn->nfs_client_lock);\n\tdprintk(\"NFS: <-- %s status = %d\\n\", __func__, status);\n\tnfs_put_client(prev);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_proc_exchange_id",
          "args": [
            "clp",
            "cred"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_exchange_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "6960-6975",
          "snippet": "int nfs4_proc_exchange_id(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\trpc_authflavor_t authflavor = clp->cl_rpcclient->cl_auth->au_flavor;\n\tint status;\n\n\t/* try SP4_MACH_CRED if krb5i/p\t*/\n\tif (authflavor == RPC_AUTH_GSS_KRB5I ||\n\t    authflavor == RPC_AUTH_GSS_KRB5P) {\n\t\tstatus = _nfs4_proc_exchange_id(clp, cred, SP4_MACH_CRED);\n\t\tif (!status)\n\t\t\treturn 0;\n\t}\n\n\t/* try SP4_NONE */\n\treturn _nfs4_proc_exchange_id(clp, cred, SP4_NONE);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_proc_exchange_id(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\trpc_authflavor_t authflavor = clp->cl_rpcclient->cl_auth->au_flavor;\n\tint status;\n\n\t/* try SP4_MACH_CRED if krb5i/p\t*/\n\tif (authflavor == RPC_AUTH_GSS_KRB5I ||\n\t    authflavor == RPC_AUTH_GSS_KRB5P) {\n\t\tstatus = _nfs4_proc_exchange_id(clp, cred, SP4_MACH_CRED);\n\t\tif (!status)\n\t\t\treturn 0;\n\t}\n\n\t/* try SP4_NONE */\n\treturn _nfs4_proc_exchange_id(clp, cred, SP4_NONE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs41_discover_server_trunking(struct nfs_client *clp,\n\t\t\t\t   struct nfs_client **result,\n\t\t\t\t   struct rpc_cred *cred)\n{\n\tint status;\n\n\tstatus = nfs4_proc_exchange_id(clp, cred);\n\tif (status != NFS4_OK)\n\t\treturn status;\n\n\tstatus = nfs41_walk_client_list(clp, result, cred);\n\tif (status < 0)\n\t\treturn status;\n\tif (clp != *result)\n\t\treturn 0;\n\n\t/* Purge state if the client id was established in a prior instance */\n\tif (clp->cl_exchange_flags & EXCHGID4_FLAG_CONFIRMED_R)\n\t\tset_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state);\n\telse\n\t\tset_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\tnfs4_schedule_state_manager(clp);\n\tstatus = nfs_wait_client_init_complete(clp);\n\tif (status < 0)\n\t\tnfs_put_client(clp);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs41_init_clientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "306-325",
    "snippet": "int nfs41_init_clientid(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status;\n\n\tif (test_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state))\n\t\tgoto do_confirm;\n\tnfs4_begin_drain_session(clp);\n\tstatus = nfs4_proc_exchange_id(clp, cred);\n\tif (status != 0)\n\t\tgoto out;\n\tset_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\ndo_confirm:\n\tstatus = nfs4_proc_create_session(clp, cred);\n\tif (status != 0)\n\t\tgoto out;\n\tnfs41_finish_session_reset(clp);\n\tnfs_mark_client_ready(clp, NFS_CS_READY);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_mark_client_ready",
          "args": [
            "clp",
            "NFS_CS_READY"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_mark_client_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/client.c",
          "lines": "529-534",
          "snippet": "void nfs_mark_client_ready(struct nfs_client *clp, int state)\n{\n\tsmp_wmb();\n\tclp->cl_cons_state = state;\n\twake_up_all(&nfs_client_active_wq);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <net/ipv6.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(nfs_client_active_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs_xdr.h>\n#include <net/ipv6.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(nfs_client_active_wq);\n\nvoid nfs_mark_client_ready(struct nfs_client *clp, int state)\n{\n\tsmp_wmb();\n\tclp->cl_cons_state = state;\n\twake_up_all(&nfs_client_active_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_finish_session_reset",
          "args": [
            "clp"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_finish_session_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "297-304",
          "snippet": "static void nfs41_finish_session_reset(struct nfs_client *clp)\n{\n\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\tclear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t/* create_session negotiated new slot table */\n\tclear_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\tnfs41_setup_state_renewal(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_finish_session_reset(struct nfs_client *clp)\n{\n\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\tclear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t/* create_session negotiated new slot table */\n\tclear_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\tnfs41_setup_state_renewal(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_proc_create_session",
          "args": [
            "clp",
            "cred"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_create_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "7293-7317",
          "snippet": "int nfs4_proc_create_session(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status;\n\tunsigned *ptr;\n\tstruct nfs4_session *session = clp->cl_session;\n\n\tdprintk(\"--> %s clp=%p session=%p\\n\", __func__, clp, session);\n\n\tstatus = _nfs4_proc_create_session(clp, cred);\n\tif (status)\n\t\tgoto out;\n\n\t/* Init or reset the session slot tables */\n\tstatus = nfs4_setup_session_slot_tables(session);\n\tdprintk(\"slot table setup returned %d\\n\", status);\n\tif (status)\n\t\tgoto out;\n\n\tptr = (unsigned *)&session->sess_id.data[0];\n\tdprintk(\"%s client>seqid %d sessionid %u:%u:%u:%u\\n\", __func__,\n\t\tclp->cl_seqid, ptr[0], ptr[1], ptr[2], ptr[3]);\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _nfs4_proc_open(struct nfs4_opendata *data);",
            "static int _nfs4_recover_proc_open(struct nfs4_opendata *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int _nfs4_proc_open(struct nfs4_opendata *data);\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data);\n\nint nfs4_proc_create_session(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status;\n\tunsigned *ptr;\n\tstruct nfs4_session *session = clp->cl_session;\n\n\tdprintk(\"--> %s clp=%p session=%p\\n\", __func__, clp, session);\n\n\tstatus = _nfs4_proc_create_session(clp, cred);\n\tif (status)\n\t\tgoto out;\n\n\t/* Init or reset the session slot tables */\n\tstatus = nfs4_setup_session_slot_tables(session);\n\tdprintk(\"slot table setup returned %d\\n\", status);\n\tif (status)\n\t\tgoto out;\n\n\tptr = (unsigned *)&session->sess_id.data[0];\n\tdprintk(\"%s client>seqid %d sessionid %u:%u:%u:%u\\n\", __func__,\n\t\tclp->cl_seqid, ptr[0], ptr[1], ptr[2], ptr[3]);\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_LEASE_CONFIRM",
            "&clp->cl_state"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_proc_exchange_id",
          "args": [
            "clp",
            "cred"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_exchange_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "6960-6975",
          "snippet": "int nfs4_proc_exchange_id(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\trpc_authflavor_t authflavor = clp->cl_rpcclient->cl_auth->au_flavor;\n\tint status;\n\n\t/* try SP4_MACH_CRED if krb5i/p\t*/\n\tif (authflavor == RPC_AUTH_GSS_KRB5I ||\n\t    authflavor == RPC_AUTH_GSS_KRB5P) {\n\t\tstatus = _nfs4_proc_exchange_id(clp, cred, SP4_MACH_CRED);\n\t\tif (!status)\n\t\t\treturn 0;\n\t}\n\n\t/* try SP4_NONE */\n\treturn _nfs4_proc_exchange_id(clp, cred, SP4_NONE);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_proc_exchange_id(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\trpc_authflavor_t authflavor = clp->cl_rpcclient->cl_auth->au_flavor;\n\tint status;\n\n\t/* try SP4_MACH_CRED if krb5i/p\t*/\n\tif (authflavor == RPC_AUTH_GSS_KRB5I ||\n\t    authflavor == RPC_AUTH_GSS_KRB5P) {\n\t\tstatus = _nfs4_proc_exchange_id(clp, cred, SP4_MACH_CRED);\n\t\tif (!status)\n\t\t\treturn 0;\n\t}\n\n\t/* try SP4_NONE */\n\treturn _nfs4_proc_exchange_id(clp, cred, SP4_NONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_begin_drain_session",
          "args": [
            "clp"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_begin_drain_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "255-269",
          "snippet": "static int nfs4_begin_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\tint ret = 0;\n\n\tif (clp->cl_slot_tbl)\n\t\treturn nfs4_drain_slot_tbl(clp->cl_slot_tbl);\n\n\t/* back channel */\n\tret = nfs4_drain_slot_tbl(&ses->bc_slot_table);\n\tif (ret)\n\t\treturn ret;\n\t/* fore channel */\n\treturn nfs4_drain_slot_tbl(&ses->fc_slot_table);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_begin_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\tint ret = 0;\n\n\tif (clp->cl_slot_tbl)\n\t\treturn nfs4_drain_slot_tbl(clp->cl_slot_tbl);\n\n\t/* back channel */\n\tret = nfs4_drain_slot_tbl(&ses->bc_slot_table);\n\tif (ret)\n\t\treturn ret;\n\t/* fore channel */\n\treturn nfs4_drain_slot_tbl(&ses->fc_slot_table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS4CLNT_LEASE_CONFIRM",
            "&clp->cl_state"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs41_init_clientid(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status;\n\n\tif (test_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state))\n\t\tgoto do_confirm;\n\tnfs4_begin_drain_session(clp);\n\tstatus = nfs4_proc_exchange_id(clp, cred);\n\tif (status != 0)\n\t\tgoto out;\n\tset_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\ndo_confirm:\n\tstatus = nfs4_proc_create_session(clp, cred);\n\tif (status != 0)\n\t\tgoto out;\n\tnfs41_finish_session_reset(clp);\n\tnfs_mark_client_ready(clp, NFS_CS_READY);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfs41_finish_session_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "297-304",
    "snippet": "static void nfs41_finish_session_reset(struct nfs_client *clp)\n{\n\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\tclear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t/* create_session negotiated new slot table */\n\tclear_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\tnfs41_setup_state_renewal(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs41_setup_state_renewal",
          "args": [
            "clp"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_setup_state_renewal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "273-295",
          "snippet": "static int nfs41_setup_state_renewal(struct nfs_client *clp)\n{\n\tint status;\n\tstruct nfs_fsinfo fsinfo;\n\n\tif (!test_bit(NFS_CS_CHECK_LEASE_TIME, &clp->cl_res_state)) {\n\t\tnfs4_schedule_state_renewal(clp);\n\t\treturn 0;\n\t}\n\n\tstatus = nfs4_proc_get_lease_time(clp, &fsinfo);\n\tif (status == 0) {\n\t\t/* Update lease time and schedule renewal */\n\t\tspin_lock(&clp->cl_lock);\n\t\tclp->cl_lease_time = fsinfo.lease_time * HZ;\n\t\tclp->cl_last_renewal = jiffies;\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tnfs4_schedule_state_renewal(clp);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs41_setup_state_renewal(struct nfs_client *clp)\n{\n\tint status;\n\tstruct nfs_fsinfo fsinfo;\n\n\tif (!test_bit(NFS_CS_CHECK_LEASE_TIME, &clp->cl_res_state)) {\n\t\tnfs4_schedule_state_renewal(clp);\n\t\treturn 0;\n\t}\n\n\tstatus = nfs4_proc_get_lease_time(clp, &fsinfo);\n\tif (status == 0) {\n\t\t/* Update lease time and schedule renewal */\n\t\tspin_lock(&clp->cl_lock);\n\t\tclp->cl_lease_time = fsinfo.lease_time * HZ;\n\t\tclp->cl_last_renewal = jiffies;\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tnfs4_schedule_state_renewal(clp);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS4CLNT_BIND_CONN_TO_SESSION",
            "&clp->cl_state"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs41_finish_session_reset(struct nfs_client *clp)\n{\n\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\tclear_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t/* create_session negotiated new slot table */\n\tclear_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\tnfs41_setup_state_renewal(clp);\n}"
  },
  {
    "function_name": "nfs41_setup_state_renewal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "273-295",
    "snippet": "static int nfs41_setup_state_renewal(struct nfs_client *clp)\n{\n\tint status;\n\tstruct nfs_fsinfo fsinfo;\n\n\tif (!test_bit(NFS_CS_CHECK_LEASE_TIME, &clp->cl_res_state)) {\n\t\tnfs4_schedule_state_renewal(clp);\n\t\treturn 0;\n\t}\n\n\tstatus = nfs4_proc_get_lease_time(clp, &fsinfo);\n\tif (status == 0) {\n\t\t/* Update lease time and schedule renewal */\n\t\tspin_lock(&clp->cl_lock);\n\t\tclp->cl_lease_time = fsinfo.lease_time * HZ;\n\t\tclp->cl_last_renewal = jiffies;\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tnfs4_schedule_state_renewal(clp);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_renewal",
          "args": [
            "clp"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_renewal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4renewd.c",
          "lines": "116-131",
          "snippet": "void\nnfs4_schedule_state_renewal(struct nfs_client *clp)\n{\n\tlong timeout;\n\n\tspin_lock(&clp->cl_lock);\n\ttimeout = (2 * clp->cl_lease_time) / 3 + (long)clp->cl_last_renewal\n\t\t- (long)jiffies;\n\tif (timeout < 5 * HZ)\n\t\ttimeout = 5 * HZ;\n\tdprintk(\"%s: requeueing work. Lease period = %ld\\n\",\n\t\t\t__func__, (timeout + HZ - 1) / HZ);\n\tmod_delayed_work(system_wq, &clp->cl_renewd, timeout);\n\tset_bit(NFS_CS_RENEWD, &clp->cl_res_state);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n\nvoid\nnfs4_schedule_state_renewal(struct nfs_client *clp)\n{\n\tlong timeout;\n\n\tspin_lock(&clp->cl_lock);\n\ttimeout = (2 * clp->cl_lease_time) / 3 + (long)clp->cl_last_renewal\n\t\t- (long)jiffies;\n\tif (timeout < 5 * HZ)\n\t\ttimeout = 5 * HZ;\n\tdprintk(\"%s: requeueing work. Lease period = %ld\\n\",\n\t\t\t__func__, (timeout + HZ - 1) / HZ);\n\tmod_delayed_work(system_wq, &clp->cl_renewd, timeout);\n\tset_bit(NFS_CS_RENEWD, &clp->cl_res_state);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_proc_get_lease_time",
          "args": [
            "clp",
            "&fsinfo"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_get_lease_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "7092-7132",
          "snippet": "int nfs4_proc_get_lease_time(struct nfs_client *clp, struct nfs_fsinfo *fsinfo)\n{\n\tstruct rpc_task *task;\n\tstruct nfs4_get_lease_time_args args;\n\tstruct nfs4_get_lease_time_res res = {\n\t\t.lr_fsinfo = fsinfo,\n\t};\n\tstruct nfs4_get_lease_time_data data = {\n\t\t.args = &args,\n\t\t.res = &res,\n\t\t.clp = clp,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GET_LEASE_TIME],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_get_lease_time_ops,\n\t\t.callback_data = &data,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\tint status;\n\n\tnfs4_init_sequence(&args.la_seq_args, &res.lr_seq_res, 0);\n\tnfs4_set_sequence_privileged(&args.la_seq_args);\n\tdprintk(\"--> %s\\n\", __func__);\n\ttask = rpc_run_task(&task_setup);\n\n\tif (IS_ERR(task))\n\t\tstatus = PTR_ERR(task);\n\telse {\n\t\tstatus = task->tk_status;\n\t\trpc_put_task(task);\n\t}\n\tdprintk(\"<-- %s return %d\\n\", __func__, status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _nfs4_proc_open(struct nfs4_opendata *data);",
            "static int _nfs4_recover_proc_open(struct nfs4_opendata *data);",
            "static int nfs4_do_fsinfo(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int _nfs4_proc_open(struct nfs4_opendata *data);\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data);\nstatic int nfs4_do_fsinfo(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);\n\nint nfs4_proc_get_lease_time(struct nfs_client *clp, struct nfs_fsinfo *fsinfo)\n{\n\tstruct rpc_task *task;\n\tstruct nfs4_get_lease_time_args args;\n\tstruct nfs4_get_lease_time_res res = {\n\t\t.lr_fsinfo = fsinfo,\n\t};\n\tstruct nfs4_get_lease_time_data data = {\n\t\t.args = &args,\n\t\t.res = &res,\n\t\t.clp = clp,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GET_LEASE_TIME],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_get_lease_time_ops,\n\t\t.callback_data = &data,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\tint status;\n\n\tnfs4_init_sequence(&args.la_seq_args, &res.lr_seq_res, 0);\n\tnfs4_set_sequence_privileged(&args.la_seq_args);\n\tdprintk(\"--> %s\\n\", __func__);\n\ttask = rpc_run_task(&task_setup);\n\n\tif (IS_ERR(task))\n\t\tstatus = PTR_ERR(task);\n\telse {\n\t\tstatus = task->tk_status;\n\t\trpc_put_task(task);\n\t}\n\tdprintk(\"<-- %s return %d\\n\", __func__, status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_CS_CHECK_LEASE_TIME",
            "&clp->cl_res_state"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs41_setup_state_renewal(struct nfs_client *clp)\n{\n\tint status;\n\tstruct nfs_fsinfo fsinfo;\n\n\tif (!test_bit(NFS_CS_CHECK_LEASE_TIME, &clp->cl_res_state)) {\n\t\tnfs4_schedule_state_renewal(clp);\n\t\treturn 0;\n\t}\n\n\tstatus = nfs4_proc_get_lease_time(clp, &fsinfo);\n\tif (status == 0) {\n\t\t/* Update lease time and schedule renewal */\n\t\tspin_lock(&clp->cl_lock);\n\t\tclp->cl_lease_time = fsinfo.lease_time * HZ;\n\t\tclp->cl_last_renewal = jiffies;\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tnfs4_schedule_state_renewal(clp);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_begin_drain_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "255-269",
    "snippet": "static int nfs4_begin_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\tint ret = 0;\n\n\tif (clp->cl_slot_tbl)\n\t\treturn nfs4_drain_slot_tbl(clp->cl_slot_tbl);\n\n\t/* back channel */\n\tret = nfs4_drain_slot_tbl(&ses->bc_slot_table);\n\tif (ret)\n\t\treturn ret;\n\t/* fore channel */\n\treturn nfs4_drain_slot_tbl(&ses->fc_slot_table);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_drain_slot_tbl",
          "args": [
            "&ses->fc_slot_table"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_drain_slot_tbl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "242-253",
          "snippet": "static int nfs4_drain_slot_tbl(struct nfs4_slot_table *tbl)\n{\n\tset_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state);\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (tbl->highest_used_slotid != NFS4_NO_SLOT) {\n\t\treinit_completion(&tbl->complete);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\treturn wait_for_completion_interruptible(&tbl->complete);\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_drain_slot_tbl(struct nfs4_slot_table *tbl)\n{\n\tset_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state);\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (tbl->highest_used_slotid != NFS4_NO_SLOT) {\n\t\treinit_completion(&tbl->complete);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\treturn wait_for_completion_interruptible(&tbl->complete);\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_begin_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\tint ret = 0;\n\n\tif (clp->cl_slot_tbl)\n\t\treturn nfs4_drain_slot_tbl(clp->cl_slot_tbl);\n\n\t/* back channel */\n\tret = nfs4_drain_slot_tbl(&ses->bc_slot_table);\n\tif (ret)\n\t\treturn ret;\n\t/* fore channel */\n\treturn nfs4_drain_slot_tbl(&ses->fc_slot_table);\n}"
  },
  {
    "function_name": "nfs4_drain_slot_tbl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "242-253",
    "snippet": "static int nfs4_drain_slot_tbl(struct nfs4_slot_table *tbl)\n{\n\tset_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state);\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (tbl->highest_used_slotid != NFS4_NO_SLOT) {\n\t\treinit_completion(&tbl->complete);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\treturn wait_for_completion_interruptible(&tbl->complete);\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tbl->slot_tbl_lock"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion_interruptible",
          "args": [
            "&tbl->complete"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinit_completion",
          "args": [
            "&tbl->complete"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tbl->slot_tbl_lock"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4_SLOT_TBL_DRAINING",
            "&tbl->slot_tbl_state"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_drain_slot_tbl(struct nfs4_slot_table *tbl)\n{\n\tset_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state);\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (tbl->highest_used_slotid != NFS4_NO_SLOT) {\n\t\treinit_completion(&tbl->complete);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\treturn wait_for_completion_interruptible(&tbl->complete);\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_end_drain_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "227-240",
    "snippet": "static void nfs4_end_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\n\tif (clp->cl_slot_tbl) {\n\t\tnfs4_end_drain_slot_table(clp->cl_slot_tbl);\n\t\treturn;\n\t}\n\n\tif (ses != NULL) {\n\t\tnfs4_end_drain_slot_table(&ses->bc_slot_table);\n\t\tnfs4_end_drain_slot_table(&ses->fc_slot_table);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_end_drain_slot_table",
          "args": [
            "&ses->fc_slot_table"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_end_drain_slot_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "218-225",
          "snippet": "static void nfs4_end_drain_slot_table(struct nfs4_slot_table *tbl)\n{\n\tif (test_and_clear_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state)) {\n\t\tspin_lock(&tbl->slot_tbl_lock);\n\t\tnfs41_wake_slot_table(tbl);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_end_drain_slot_table(struct nfs4_slot_table *tbl)\n{\n\tif (test_and_clear_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state)) {\n\t\tspin_lock(&tbl->slot_tbl_lock);\n\t\tnfs41_wake_slot_table(tbl);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_end_drain_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *ses = clp->cl_session;\n\n\tif (clp->cl_slot_tbl) {\n\t\tnfs4_end_drain_slot_table(clp->cl_slot_tbl);\n\t\treturn;\n\t}\n\n\tif (ses != NULL) {\n\t\tnfs4_end_drain_slot_table(&ses->bc_slot_table);\n\t\tnfs4_end_drain_slot_table(&ses->fc_slot_table);\n\t}\n}"
  },
  {
    "function_name": "nfs4_end_drain_slot_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "218-225",
    "snippet": "static void nfs4_end_drain_slot_table(struct nfs4_slot_table *tbl)\n{\n\tif (test_and_clear_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state)) {\n\t\tspin_lock(&tbl->slot_tbl_lock);\n\t\tnfs41_wake_slot_table(tbl);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tbl->slot_tbl_lock"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_wake_slot_table",
          "args": [
            "tbl"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_wake_slot_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4session.c",
          "lines": "314-320",
          "snippet": "void nfs41_wake_slot_table(struct nfs4_slot_table *tbl)\n{\n\tfor (;;) {\n\t\tif (!nfs41_try_wake_next_slot_table_entry(tbl))\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"callback.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"callback.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nvoid nfs41_wake_slot_table(struct nfs4_slot_table *tbl)\n{\n\tfor (;;) {\n\t\tif (!nfs41_try_wake_next_slot_table_entry(tbl))\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tbl->slot_tbl_lock"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS4_SLOT_TBL_DRAINING",
            "&tbl->slot_tbl_state"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_end_drain_slot_table(struct nfs4_slot_table *tbl)\n{\n\tif (test_and_clear_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state)) {\n\t\tspin_lock(&tbl->slot_tbl_lock);\n\t\tnfs41_wake_slot_table(tbl);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t}\n}"
  },
  {
    "function_name": "nfs4_get_renew_cred_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "196-216",
    "snippet": "struct rpc_cred *nfs4_get_renew_cred_locked(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred = NULL;\n\tstruct nfs_server *server;\n\n\t/* Use machine credentials if available */\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tif (cred != NULL)\n\t\tgoto out;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tcred = nfs4_get_renew_cred_server_locked(server);\n\t\tif (cred != NULL)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\nout:\n\treturn cred;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_get_renew_cred_server_locked",
          "args": [
            "server"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_renew_cred_server_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "170-187",
          "snippet": "static struct rpc_cred *\nnfs4_get_renew_cred_server_locked(struct nfs_server *server)\n{\n\tstruct rpc_cred *cred = NULL;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tif (list_empty(&sp->so_states))\n\t\t\tcontinue;\n\t\tcred = get_rpccred(sp->so_cred);\n\t\tbreak;\n\t}\n\treturn cred;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct rpc_cred *\nnfs4_get_renew_cred_server_locked(struct nfs_server *server)\n{\n\tstruct rpc_cred *cred = NULL;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tif (list_empty(&sp->so_states))\n\t\t\tcontinue;\n\t\tcred = get_rpccred(sp->so_cred);\n\t\tbreak;\n\t}\n\treturn cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "server",
            "&clp->cl_superblocks",
            "client_link"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_get_machine_cred_locked",
          "args": [
            "clp"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_machine_cred_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "148-155",
          "snippet": "struct rpc_cred *nfs4_get_machine_cred_locked(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred = NULL;\n\n\tif (clp->cl_machine_cred != NULL)\n\t\tcred = get_rpccred(clp->cl_machine_cred);\n\treturn cred;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct rpc_cred *nfs4_get_machine_cred_locked(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred = NULL;\n\n\tif (clp->cl_machine_cred != NULL)\n\t\tcred = get_rpccred(clp->cl_machine_cred);\n\treturn cred;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct rpc_cred *nfs4_get_renew_cred_locked(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred = NULL;\n\tstruct nfs_server *server;\n\n\t/* Use machine credentials if available */\n\tcred = nfs4_get_machine_cred_locked(clp);\n\tif (cred != NULL)\n\t\tgoto out;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tcred = nfs4_get_renew_cred_server_locked(server);\n\t\tif (cred != NULL)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\nout:\n\treturn cred;\n}"
  },
  {
    "function_name": "nfs4_get_renew_cred_server_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "170-187",
    "snippet": "static struct rpc_cred *\nnfs4_get_renew_cred_server_locked(struct nfs_server *server)\n{\n\tstruct rpc_cred *cred = NULL;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tif (list_empty(&sp->so_states))\n\t\t\tcontinue;\n\t\tcred = get_rpccred(sp->so_cred);\n\t\tbreak;\n\t}\n\treturn cred;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_rpccred",
          "args": [
            "sp->so_cred"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sp->so_states"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "pos",
            "structnfs4_state_owner",
            "so_server_node"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "pos"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&server->state_owners"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct rpc_cred *\nnfs4_get_renew_cred_server_locked(struct nfs_server *server)\n{\n\tstruct rpc_cred *cred = NULL;\n\tstruct nfs4_state_owner *sp;\n\tstruct rb_node *pos;\n\n\tfor (pos = rb_first(&server->state_owners);\n\t     pos != NULL;\n\t     pos = rb_next(pos)) {\n\t\tsp = rb_entry(pos, struct nfs4_state_owner, so_server_node);\n\t\tif (list_empty(&sp->so_states))\n\t\t\tcontinue;\n\t\tcred = get_rpccred(sp->so_cred);\n\t\tbreak;\n\t}\n\treturn cred;\n}"
  },
  {
    "function_name": "nfs4_root_machine_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "157-168",
    "snippet": "static void nfs4_root_machine_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred, *new;\n\n\tnew = rpc_lookup_machine_cred(NULL);\n\tspin_lock(&clp->cl_lock);\n\tcred = clp->cl_machine_cred;\n\tclp->cl_machine_cred = new;\n\tspin_unlock(&clp->cl_lock);\n\tif (cred != NULL)\n\t\tput_rpccred(cred);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_lookup_machine_cred",
          "args": [
            "NULL"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_root_machine_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred, *new;\n\n\tnew = rpc_lookup_machine_cred(NULL);\n\tspin_lock(&clp->cl_lock);\n\tcred = clp->cl_machine_cred;\n\tclp->cl_machine_cred = new;\n\tspin_unlock(&clp->cl_lock);\n\tif (cred != NULL)\n\t\tput_rpccred(cred);\n}"
  },
  {
    "function_name": "nfs4_get_machine_cred_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "148-155",
    "snippet": "struct rpc_cred *nfs4_get_machine_cred_locked(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred = NULL;\n\n\tif (clp->cl_machine_cred != NULL)\n\t\tcred = get_rpccred(clp->cl_machine_cred);\n\treturn cred;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_rpccred",
          "args": [
            "clp->cl_machine_cred"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct rpc_cred *nfs4_get_machine_cred_locked(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred = NULL;\n\n\tif (clp->cl_machine_cred != NULL)\n\t\tcred = get_rpccred(clp->cl_machine_cred);\n\treturn cred;\n}"
  },
  {
    "function_name": "nfs40_discover_server_trunking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "116-146",
    "snippet": "int nfs40_discover_server_trunking(struct nfs_client *clp,\n\t\t\t\t   struct nfs_client **result,\n\t\t\t\t   struct rpc_cred *cred)\n{\n\tstruct nfs4_setclientid_res clid = {\n\t\t.clientid = clp->cl_clientid,\n\t\t.confirm = clp->cl_confirm,\n\t};\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\tunsigned short port;\n\tint status;\n\n\tport = nn->nfs_callback_tcpport;\n\tif (clp->cl_addr.ss_family == AF_INET6)\n\t\tport = nn->nfs_callback_tcpport6;\n\n\tstatus = nfs4_proc_setclientid(clp, NFS4_CALLBACK, port, cred, &clid);\n\tif (status != 0)\n\t\tgoto out;\n\tclp->cl_clientid = clid.clientid;\n\tclp->cl_confirm = clid.confirm;\n\n\tstatus = nfs40_walk_client_list(clp, result, cred);\n\tif (status == 0) {\n\t\t/* Sustain the lease, even if it's empty.  If the clientid4\n\t\t * goes stale it's of no use for trunking discovery. */\n\t\tnfs4_schedule_state_renewal(*result);\n\t}\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_renewal",
          "args": [
            "*result"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_renewal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4renewd.c",
          "lines": "116-131",
          "snippet": "void\nnfs4_schedule_state_renewal(struct nfs_client *clp)\n{\n\tlong timeout;\n\n\tspin_lock(&clp->cl_lock);\n\ttimeout = (2 * clp->cl_lease_time) / 3 + (long)clp->cl_last_renewal\n\t\t- (long)jiffies;\n\tif (timeout < 5 * HZ)\n\t\ttimeout = 5 * HZ;\n\tdprintk(\"%s: requeueing work. Lease period = %ld\\n\",\n\t\t\t__func__, (timeout + HZ - 1) / HZ);\n\tmod_delayed_work(system_wq, &clp->cl_renewd, timeout);\n\tset_bit(NFS_CS_RENEWD, &clp->cl_res_state);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n\nvoid\nnfs4_schedule_state_renewal(struct nfs_client *clp)\n{\n\tlong timeout;\n\n\tspin_lock(&clp->cl_lock);\n\ttimeout = (2 * clp->cl_lease_time) / 3 + (long)clp->cl_last_renewal\n\t\t- (long)jiffies;\n\tif (timeout < 5 * HZ)\n\t\ttimeout = 5 * HZ;\n\tdprintk(\"%s: requeueing work. Lease period = %ld\\n\",\n\t\t\t__func__, (timeout + HZ - 1) / HZ);\n\tmod_delayed_work(system_wq, &clp->cl_renewd, timeout);\n\tset_bit(NFS_CS_RENEWD, &clp->cl_res_state);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs40_walk_client_list",
          "args": [
            "clp",
            "result",
            "cred"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "nfs40_walk_client_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4client.c",
          "lines": "477-559",
          "snippet": "int nfs40_walk_client_list(struct nfs_client *new,\n\t\t\t   struct nfs_client **result,\n\t\t\t   struct rpc_cred *cred)\n{\n\tstruct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);\n\tstruct nfs_client *pos, *prev = NULL;\n\tstruct nfs4_setclientid_res clid = {\n\t\t.clientid\t= new->cl_clientid,\n\t\t.confirm\t= new->cl_confirm,\n\t};\n\tint status = -NFS4ERR_STALE_CLIENTID;\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {\n\n\t\tif (pos->rpc_ops != new->rpc_ops)\n\t\t\tcontinue;\n\n\t\tif (pos->cl_minorversion != new->cl_minorversion)\n\t\t\tcontinue;\n\n\t\t/* If \"pos\" isn't marked ready, we can't trust the\n\t\t * remaining fields in \"pos\" */\n\t\tif (pos->cl_cons_state > NFS_CS_READY) {\n\t\t\tatomic_inc(&pos->cl_count);\n\t\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\t\tnfs_put_client(prev);\n\t\t\tprev = pos;\n\n\t\t\tstatus = nfs_wait_client_init_complete(pos);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out;\n\t\t\tstatus = -NFS4ERR_STALE_CLIENTID;\n\t\t\tspin_lock(&nn->nfs_client_lock);\n\t\t}\n\t\tif (pos->cl_cons_state != NFS_CS_READY)\n\t\t\tcontinue;\n\n\t\tif (pos->cl_clientid != new->cl_clientid)\n\t\t\tcontinue;\n\n\t\tif (!nfs4_match_client_owner_id(pos, new))\n\t\t\tcontinue;\n\n\t\tatomic_inc(&pos->cl_count);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tnfs_put_client(prev);\n\t\tprev = pos;\n\n\t\tstatus = nfs4_proc_setclientid_confirm(pos, &clid, cred);\n\t\tswitch (status) {\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tnfs4_swap_callback_idents(pos, new);\n\n\t\t\tprev = NULL;\n\t\t\t*result = pos;\n\t\t\tdprintk(\"NFS: <-- %s using nfs_client = %p ({%d})\\n\",\n\t\t\t\t__func__, pos, atomic_read(&pos->cl_count));\n\t\t\tgoto out;\n\t\tcase -ERESTARTSYS:\n\t\tcase -ETIMEDOUT:\n\t\t\t/* The callback path may have been inadvertently\n\t\t\t * changed. Schedule recovery!\n\t\t\t */\n\t\t\tnfs4_schedule_path_down_recovery(pos);\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&nn->nfs_client_lock);\n\t}\n\tspin_unlock(&nn->nfs_client_lock);\n\n\t/* No match found. The server lost our clientid */\nout:\n\tnfs_put_client(prev);\n\tdprintk(\"NFS: <-- %s status = %d\\n\", __func__, status);\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"internal.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/auth.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"internal.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n\nint nfs40_walk_client_list(struct nfs_client *new,\n\t\t\t   struct nfs_client **result,\n\t\t\t   struct rpc_cred *cred)\n{\n\tstruct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);\n\tstruct nfs_client *pos, *prev = NULL;\n\tstruct nfs4_setclientid_res clid = {\n\t\t.clientid\t= new->cl_clientid,\n\t\t.confirm\t= new->cl_confirm,\n\t};\n\tint status = -NFS4ERR_STALE_CLIENTID;\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {\n\n\t\tif (pos->rpc_ops != new->rpc_ops)\n\t\t\tcontinue;\n\n\t\tif (pos->cl_minorversion != new->cl_minorversion)\n\t\t\tcontinue;\n\n\t\t/* If \"pos\" isn't marked ready, we can't trust the\n\t\t * remaining fields in \"pos\" */\n\t\tif (pos->cl_cons_state > NFS_CS_READY) {\n\t\t\tatomic_inc(&pos->cl_count);\n\t\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\t\tnfs_put_client(prev);\n\t\t\tprev = pos;\n\n\t\t\tstatus = nfs_wait_client_init_complete(pos);\n\t\t\tif (status < 0)\n\t\t\t\tgoto out;\n\t\t\tstatus = -NFS4ERR_STALE_CLIENTID;\n\t\t\tspin_lock(&nn->nfs_client_lock);\n\t\t}\n\t\tif (pos->cl_cons_state != NFS_CS_READY)\n\t\t\tcontinue;\n\n\t\tif (pos->cl_clientid != new->cl_clientid)\n\t\t\tcontinue;\n\n\t\tif (!nfs4_match_client_owner_id(pos, new))\n\t\t\tcontinue;\n\n\t\tatomic_inc(&pos->cl_count);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tnfs_put_client(prev);\n\t\tprev = pos;\n\n\t\tstatus = nfs4_proc_setclientid_confirm(pos, &clid, cred);\n\t\tswitch (status) {\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tnfs4_swap_callback_idents(pos, new);\n\n\t\t\tprev = NULL;\n\t\t\t*result = pos;\n\t\t\tdprintk(\"NFS: <-- %s using nfs_client = %p ({%d})\\n\",\n\t\t\t\t__func__, pos, atomic_read(&pos->cl_count));\n\t\t\tgoto out;\n\t\tcase -ERESTARTSYS:\n\t\tcase -ETIMEDOUT:\n\t\t\t/* The callback path may have been inadvertently\n\t\t\t * changed. Schedule recovery!\n\t\t\t */\n\t\t\tnfs4_schedule_path_down_recovery(pos);\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&nn->nfs_client_lock);\n\t}\n\tspin_unlock(&nn->nfs_client_lock);\n\n\t/* No match found. The server lost our clientid */\nout:\n\tnfs_put_client(prev);\n\tdprintk(\"NFS: <-- %s status = %d\\n\", __func__, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_proc_setclientid",
          "args": [
            "clp",
            "NFS4_CALLBACK",
            "port",
            "cred",
            "&clid"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_setclientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "5040-5105",
          "snippet": "int nfs4_proc_setclientid(struct nfs_client *clp, u32 program,\n\t\tunsigned short port, struct rpc_cred *cred,\n\t\tstruct nfs4_setclientid_res *res)\n{\n\tnfs4_verifier sc_verifier;\n\tstruct nfs4_setclientid setclientid = {\n\t\t.sc_verifier = &sc_verifier,\n\t\t.sc_prog = program,\n\t\t.sc_cb_ident = clp->cl_cb_ident,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID],\n\t\t.rpc_argp = &setclientid,\n\t\t.rpc_resp = res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task *task;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_setclientid_ops,\n\t\t.callback_data = &setclientid,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\tint status;\n\n\t/* nfs_client_id4 */\n\tnfs4_init_boot_verifier(clp, &sc_verifier);\n\tif (test_bit(NFS_CS_MIGRATION, &clp->cl_flags))\n\t\tsetclientid.sc_name_len =\n\t\t\t\tnfs4_init_uniform_client_string(clp,\n\t\t\t\t\t\tsetclientid.sc_name,\n\t\t\t\t\t\tsizeof(setclientid.sc_name));\n\telse\n\t\tsetclientid.sc_name_len =\n\t\t\t\tnfs4_init_nonuniform_client_string(clp,\n\t\t\t\t\t\tsetclientid.sc_name,\n\t\t\t\t\t\tsizeof(setclientid.sc_name));\n\t/* cb_client4 */\n\tsetclientid.sc_netid_len =\n\t\t\t\tnfs4_init_callback_netid(clp,\n\t\t\t\t\t\tsetclientid.sc_netid,\n\t\t\t\t\t\tsizeof(setclientid.sc_netid));\n\tsetclientid.sc_uaddr_len = scnprintf(setclientid.sc_uaddr,\n\t\t\t\tsizeof(setclientid.sc_uaddr), \"%s.%u.%u\",\n\t\t\t\tclp->cl_ipaddr, port >> 8, port & 255);\n\n\tdprintk(\"NFS call  setclientid auth=%s, '%.*s'\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tsetclientid.sc_name_len, setclientid.sc_name);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tstatus = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tstatus = task->tk_status;\n\tif (setclientid.sc_cred) {\n\t\tclp->cl_acceptor = rpcauth_stringify_acceptor(setclientid.sc_cred);\n\t\tput_rpccred(setclientid.sc_cred);\n\t}\n\trpc_put_task(task);\nout:\n\ttrace_nfs4_setclientid(clp, status);\n\tdprintk(\"NFS reply setclientid: %d\\n\", status);\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nfs4_setclientid_ops = {\n\t.rpc_call_done = nfs4_setclientid_done,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic const struct rpc_call_ops nfs4_setclientid_ops = {\n\t.rpc_call_done = nfs4_setclientid_done,\n};\n\nint nfs4_proc_setclientid(struct nfs_client *clp, u32 program,\n\t\tunsigned short port, struct rpc_cred *cred,\n\t\tstruct nfs4_setclientid_res *res)\n{\n\tnfs4_verifier sc_verifier;\n\tstruct nfs4_setclientid setclientid = {\n\t\t.sc_verifier = &sc_verifier,\n\t\t.sc_prog = program,\n\t\t.sc_cb_ident = clp->cl_cb_ident,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID],\n\t\t.rpc_argp = &setclientid,\n\t\t.rpc_resp = res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task *task;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_setclientid_ops,\n\t\t.callback_data = &setclientid,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\tint status;\n\n\t/* nfs_client_id4 */\n\tnfs4_init_boot_verifier(clp, &sc_verifier);\n\tif (test_bit(NFS_CS_MIGRATION, &clp->cl_flags))\n\t\tsetclientid.sc_name_len =\n\t\t\t\tnfs4_init_uniform_client_string(clp,\n\t\t\t\t\t\tsetclientid.sc_name,\n\t\t\t\t\t\tsizeof(setclientid.sc_name));\n\telse\n\t\tsetclientid.sc_name_len =\n\t\t\t\tnfs4_init_nonuniform_client_string(clp,\n\t\t\t\t\t\tsetclientid.sc_name,\n\t\t\t\t\t\tsizeof(setclientid.sc_name));\n\t/* cb_client4 */\n\tsetclientid.sc_netid_len =\n\t\t\t\tnfs4_init_callback_netid(clp,\n\t\t\t\t\t\tsetclientid.sc_netid,\n\t\t\t\t\t\tsizeof(setclientid.sc_netid));\n\tsetclientid.sc_uaddr_len = scnprintf(setclientid.sc_uaddr,\n\t\t\t\tsizeof(setclientid.sc_uaddr), \"%s.%u.%u\",\n\t\t\t\tclp->cl_ipaddr, port >> 8, port & 255);\n\n\tdprintk(\"NFS call  setclientid auth=%s, '%.*s'\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tsetclientid.sc_name_len, setclientid.sc_name);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tstatus = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tstatus = task->tk_status;\n\tif (setclientid.sc_cred) {\n\t\tclp->cl_acceptor = rpcauth_stringify_acceptor(setclientid.sc_cred);\n\t\tput_rpccred(setclientid.sc_cred);\n\t}\n\trpc_put_task(task);\nout:\n\ttrace_nfs4_setclientid(clp, status);\n\tdprintk(\"NFS reply setclientid: %d\\n\", status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->cl_net",
            "nfs_net_id"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs40_discover_server_trunking(struct nfs_client *clp,\n\t\t\t\t   struct nfs_client **result,\n\t\t\t\t   struct rpc_cred *cred)\n{\n\tstruct nfs4_setclientid_res clid = {\n\t\t.clientid = clp->cl_clientid,\n\t\t.confirm = clp->cl_confirm,\n\t};\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\tunsigned short port;\n\tint status;\n\n\tport = nn->nfs_callback_tcpport;\n\tif (clp->cl_addr.ss_family == AF_INET6)\n\t\tport = nn->nfs_callback_tcpport6;\n\n\tstatus = nfs4_proc_setclientid(clp, NFS4_CALLBACK, port, cred, &clid);\n\tif (status != 0)\n\t\tgoto out;\n\tclp->cl_clientid = clid.clientid;\n\tclp->cl_confirm = clid.confirm;\n\n\tstatus = nfs40_walk_client_list(clp, result, cred);\n\tif (status == 0) {\n\t\t/* Sustain the lease, even if it's empty.  If the clientid4\n\t\t * goes stale it's of no use for trunking discovery. */\n\t\tnfs4_schedule_state_renewal(*result);\n\t}\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_init_clientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
    "lines": "71-101",
    "snippet": "int nfs4_init_clientid(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct nfs4_setclientid_res clid = {\n\t\t.clientid = clp->cl_clientid,\n\t\t.confirm = clp->cl_confirm,\n\t};\n\tunsigned short port;\n\tint status;\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (test_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state))\n\t\tgoto do_confirm;\n\tport = nn->nfs_callback_tcpport;\n\tif (clp->cl_addr.ss_family == AF_INET6)\n\t\tport = nn->nfs_callback_tcpport6;\n\n\tstatus = nfs4_proc_setclientid(clp, NFS4_CALLBACK, port, cred, &clid);\n\tif (status != 0)\n\t\tgoto out;\n\tclp->cl_clientid = clid.clientid;\n\tclp->cl_confirm = clid.confirm;\n\tset_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\ndo_confirm:\n\tstatus = nfs4_proc_setclientid_confirm(clp, &clid, cred);\n\tif (status != 0)\n\t\tgoto out;\n\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\tnfs4_schedule_state_renewal(clp);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/bitops.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_schedule_state_renewal",
          "args": [
            "clp"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_state_renewal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4renewd.c",
          "lines": "116-131",
          "snippet": "void\nnfs4_schedule_state_renewal(struct nfs_client *clp)\n{\n\tlong timeout;\n\n\tspin_lock(&clp->cl_lock);\n\ttimeout = (2 * clp->cl_lease_time) / 3 + (long)clp->cl_last_renewal\n\t\t- (long)jiffies;\n\tif (timeout < 5 * HZ)\n\t\ttimeout = 5 * HZ;\n\tdprintk(\"%s: requeueing work. Lease period = %ld\\n\",\n\t\t\t__func__, (timeout + HZ - 1) / HZ);\n\tmod_delayed_work(system_wq, &clp->cl_renewd, timeout);\n\tset_bit(NFS_CS_RENEWD, &clp->cl_res_state);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n\nvoid\nnfs4_schedule_state_renewal(struct nfs_client *clp)\n{\n\tlong timeout;\n\n\tspin_lock(&clp->cl_lock);\n\ttimeout = (2 * clp->cl_lease_time) / 3 + (long)clp->cl_last_renewal\n\t\t- (long)jiffies;\n\tif (timeout < 5 * HZ)\n\t\ttimeout = 5 * HZ;\n\tdprintk(\"%s: requeueing work. Lease period = %ld\\n\",\n\t\t\t__func__, (timeout + HZ - 1) / HZ);\n\tmod_delayed_work(system_wq, &clp->cl_renewd, timeout);\n\tset_bit(NFS_CS_RENEWD, &clp->cl_res_state);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS4CLNT_LEASE_CONFIRM",
            "&clp->cl_state"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_proc_setclientid_confirm",
          "args": [
            "clp",
            "&clid",
            "cred"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_setclientid_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "5115-5133",
          "snippet": "int nfs4_proc_setclientid_confirm(struct nfs_client *clp,\n\t\tstruct nfs4_setclientid_res *arg,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID_CONFIRM],\n\t\t.rpc_argp = arg,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tdprintk(\"NFS call  setclientid_confirm auth=%s, (client ID %llx)\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tclp->cl_clientid);\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\ttrace_nfs4_setclientid_confirm(clp, status);\n\tdprintk(\"NFS reply setclientid_confirm: %d\\n\", status);\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_proc_setclientid_confirm(struct nfs_client *clp,\n\t\tstruct nfs4_setclientid_res *arg,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID_CONFIRM],\n\t\t.rpc_argp = arg,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tdprintk(\"NFS call  setclientid_confirm auth=%s, (client ID %llx)\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tclp->cl_clientid);\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\ttrace_nfs4_setclientid_confirm(clp, status);\n\tdprintk(\"NFS reply setclientid_confirm: %d\\n\", status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS4CLNT_LEASE_CONFIRM",
            "&clp->cl_state"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_proc_setclientid",
          "args": [
            "clp",
            "NFS4_CALLBACK",
            "port",
            "cred",
            "&clid"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_setclientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "5040-5105",
          "snippet": "int nfs4_proc_setclientid(struct nfs_client *clp, u32 program,\n\t\tunsigned short port, struct rpc_cred *cred,\n\t\tstruct nfs4_setclientid_res *res)\n{\n\tnfs4_verifier sc_verifier;\n\tstruct nfs4_setclientid setclientid = {\n\t\t.sc_verifier = &sc_verifier,\n\t\t.sc_prog = program,\n\t\t.sc_cb_ident = clp->cl_cb_ident,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID],\n\t\t.rpc_argp = &setclientid,\n\t\t.rpc_resp = res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task *task;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_setclientid_ops,\n\t\t.callback_data = &setclientid,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\tint status;\n\n\t/* nfs_client_id4 */\n\tnfs4_init_boot_verifier(clp, &sc_verifier);\n\tif (test_bit(NFS_CS_MIGRATION, &clp->cl_flags))\n\t\tsetclientid.sc_name_len =\n\t\t\t\tnfs4_init_uniform_client_string(clp,\n\t\t\t\t\t\tsetclientid.sc_name,\n\t\t\t\t\t\tsizeof(setclientid.sc_name));\n\telse\n\t\tsetclientid.sc_name_len =\n\t\t\t\tnfs4_init_nonuniform_client_string(clp,\n\t\t\t\t\t\tsetclientid.sc_name,\n\t\t\t\t\t\tsizeof(setclientid.sc_name));\n\t/* cb_client4 */\n\tsetclientid.sc_netid_len =\n\t\t\t\tnfs4_init_callback_netid(clp,\n\t\t\t\t\t\tsetclientid.sc_netid,\n\t\t\t\t\t\tsizeof(setclientid.sc_netid));\n\tsetclientid.sc_uaddr_len = scnprintf(setclientid.sc_uaddr,\n\t\t\t\tsizeof(setclientid.sc_uaddr), \"%s.%u.%u\",\n\t\t\t\tclp->cl_ipaddr, port >> 8, port & 255);\n\n\tdprintk(\"NFS call  setclientid auth=%s, '%.*s'\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tsetclientid.sc_name_len, setclientid.sc_name);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tstatus = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tstatus = task->tk_status;\n\tif (setclientid.sc_cred) {\n\t\tclp->cl_acceptor = rpcauth_stringify_acceptor(setclientid.sc_cred);\n\t\tput_rpccred(setclientid.sc_cred);\n\t}\n\trpc_put_task(task);\nout:\n\ttrace_nfs4_setclientid(clp, status);\n\tdprintk(\"NFS reply setclientid: %d\\n\", status);\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nfs4_setclientid_ops = {\n\t.rpc_call_done = nfs4_setclientid_done,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic const struct rpc_call_ops nfs4_setclientid_ops = {\n\t.rpc_call_done = nfs4_setclientid_done,\n};\n\nint nfs4_proc_setclientid(struct nfs_client *clp, u32 program,\n\t\tunsigned short port, struct rpc_cred *cred,\n\t\tstruct nfs4_setclientid_res *res)\n{\n\tnfs4_verifier sc_verifier;\n\tstruct nfs4_setclientid setclientid = {\n\t\t.sc_verifier = &sc_verifier,\n\t\t.sc_prog = program,\n\t\t.sc_cb_ident = clp->cl_cb_ident,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID],\n\t\t.rpc_argp = &setclientid,\n\t\t.rpc_resp = res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task *task;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_setclientid_ops,\n\t\t.callback_data = &setclientid,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\tint status;\n\n\t/* nfs_client_id4 */\n\tnfs4_init_boot_verifier(clp, &sc_verifier);\n\tif (test_bit(NFS_CS_MIGRATION, &clp->cl_flags))\n\t\tsetclientid.sc_name_len =\n\t\t\t\tnfs4_init_uniform_client_string(clp,\n\t\t\t\t\t\tsetclientid.sc_name,\n\t\t\t\t\t\tsizeof(setclientid.sc_name));\n\telse\n\t\tsetclientid.sc_name_len =\n\t\t\t\tnfs4_init_nonuniform_client_string(clp,\n\t\t\t\t\t\tsetclientid.sc_name,\n\t\t\t\t\t\tsizeof(setclientid.sc_name));\n\t/* cb_client4 */\n\tsetclientid.sc_netid_len =\n\t\t\t\tnfs4_init_callback_netid(clp,\n\t\t\t\t\t\tsetclientid.sc_netid,\n\t\t\t\t\t\tsizeof(setclientid.sc_netid));\n\tsetclientid.sc_uaddr_len = scnprintf(setclientid.sc_uaddr,\n\t\t\t\tsizeof(setclientid.sc_uaddr), \"%s.%u.%u\",\n\t\t\t\tclp->cl_ipaddr, port >> 8, port & 255);\n\n\tdprintk(\"NFS call  setclientid auth=%s, '%.*s'\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tsetclientid.sc_name_len, setclientid.sc_name);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tstatus = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tstatus = task->tk_status;\n\tif (setclientid.sc_cred) {\n\t\tclp->cl_acceptor = rpcauth_stringify_acceptor(setclientid.sc_cred);\n\t\tput_rpccred(setclientid.sc_cred);\n\t}\n\trpc_put_task(task);\nout:\n\ttrace_nfs4_setclientid(clp, status);\n\tdprintk(\"NFS reply setclientid: %d\\n\", status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS4CLNT_LEASE_CONFIRM",
            "&clp->cl_state"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->cl_net",
            "nfs_net_id"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_init_clientid(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct nfs4_setclientid_res clid = {\n\t\t.clientid = clp->cl_clientid,\n\t\t.confirm = clp->cl_confirm,\n\t};\n\tunsigned short port;\n\tint status;\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (test_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state))\n\t\tgoto do_confirm;\n\tport = nn->nfs_callback_tcpport;\n\tif (clp->cl_addr.ss_family == AF_INET6)\n\t\tport = nn->nfs_callback_tcpport6;\n\n\tstatus = nfs4_proc_setclientid(clp, NFS4_CALLBACK, port, cred, &clid);\n\tif (status != 0)\n\t\tgoto out;\n\tclp->cl_clientid = clid.clientid;\n\tclp->cl_confirm = clid.confirm;\n\tset_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\ndo_confirm:\n\tstatus = nfs4_proc_setclientid_confirm(clp, &clid, cred);\n\tif (status != 0)\n\t\tgoto out;\n\tclear_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);\n\tnfs4_schedule_state_renewal(clp);\nout:\n\treturn status;\n}"
  }
]