[
  {
    "function_name": "logfs_cleanup_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2292-2298",
    "snippet": "void logfs_cleanup_rw(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tlogfs_mempool_destroy(super->s_block_pool);\n\tlogfs_mempool_destroy(super->s_shadow_pool);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_mempool_destroy",
          "args": [
            "super->s_shadow_pool"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mempool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "730-734",
          "snippet": "static inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_cleanup_rw(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tlogfs_mempool_destroy(super->s_block_pool);\n\tlogfs_mempool_destroy(super->s_shadow_pool);\n}"
  },
  {
    "function_name": "logfs_init_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2277-2290",
    "snippet": "int logfs_init_rw(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint min_fill = 3 * super->s_no_blocks;\n\n\tINIT_LIST_HEAD(&super->s_object_alias);\n\tINIT_LIST_HEAD(&super->s_writeback_list);\n\tmutex_init(&super->s_write_mutex);\n\tsuper->s_block_pool = mempool_create_kmalloc_pool(min_fill,\n\t\t\tsizeof(struct logfs_block));\n\tsuper->s_shadow_pool = mempool_create_kmalloc_pool(min_fill,\n\t\t\tsizeof(struct logfs_shadow));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_create_kmalloc_pool",
          "args": [
            "min_fill",
            "sizeof(struct logfs_shadow)"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_create_kmalloc_pool",
          "args": [
            "min_fill",
            "sizeof(struct logfs_block)"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&super->s_write_mutex"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&super->s_writeback_list"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&super->s_object_alias"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_init_rw(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint min_fill = 3 * super->s_no_blocks;\n\n\tINIT_LIST_HEAD(&super->s_object_alias);\n\tINIT_LIST_HEAD(&super->s_writeback_list);\n\tmutex_init(&super->s_write_mutex);\n\tsuper->s_block_pool = mempool_create_kmalloc_pool(min_fill,\n\t\t\tsizeof(struct logfs_block));\n\tsuper->s_shadow_pool = mempool_create_kmalloc_pool(min_fill,\n\t\t\tsizeof(struct logfs_shadow));\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_open_segfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2265-2275",
    "snippet": "int logfs_open_segfile(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\n\tinode = logfs_read_meta_inode(sb, LOGFS_INO_SEGFILE);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\tsuper->s_segfile_inode = inode;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_read_meta_inode",
          "args": [
            "sb",
            "LOGFS_INO_SEGFILE"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_meta_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "278-294",
          "snippet": "struct inode *logfs_read_meta_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tinode = logfs_new_meta_inode(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\terr = logfs_read_inode(inode);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tlogfs_inode_setops(inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_read_meta_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tinode = logfs_new_meta_inode(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\terr = logfs_read_inode(inode);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tlogfs_inode_setops(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_open_segfile(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\n\tinode = logfs_read_meta_inode(sb, LOGFS_INO_SEGFILE);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\tsuper->s_segfile_inode = inode;\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_inode_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2238-2263",
    "snippet": "int logfs_inode_write(struct inode *inode, const void *buf, size_t count,\n\t\tloff_t bix, long flags, struct shadow_tree *shadow_tree)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\tint err;\n\tstruct page *page;\n\tvoid *pagebuf;\n\n\tBUG_ON(pos & (LOGFS_BLOCKSIZE-1));\n\tBUG_ON(count > LOGFS_BLOCKSIZE);\n\tpage = logfs_get_write_page(inode, bix, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tpagebuf = kmap_atomic(page);\n\tmemcpy(pagebuf, buf, count);\n\tflush_dcache_page(page);\n\tkunmap_atomic(pagebuf);\n\n\tif (i_size_read(inode) < pos + LOGFS_BLOCKSIZE)\n\t\ti_size_write(inode, pos + LOGFS_BLOCKSIZE);\n\n\terr = logfs_write_buf(inode, page, flags);\n\tlogfs_put_write_page(page);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_buf",
          "args": [
            "inode",
            "page",
            "flags"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1565-1574",
          "snippet": "int logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = __logfs_write_buf(inode, page, flags);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = __logfs_write_buf(inode, page, flags);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos + LOGFS_BLOCKSIZE"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "pagebuf"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pagebuf",
            "buf",
            "count"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "inode",
            "bix",
            "0"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "count > LOGFS_BLOCKSIZE"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pos & (LOGFS_BLOCKSIZE-1)"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_inode_write(struct inode *inode, const void *buf, size_t count,\n\t\tloff_t bix, long flags, struct shadow_tree *shadow_tree)\n{\n\tloff_t pos = bix << inode->i_sb->s_blocksize_bits;\n\tint err;\n\tstruct page *page;\n\tvoid *pagebuf;\n\n\tBUG_ON(pos & (LOGFS_BLOCKSIZE-1));\n\tBUG_ON(count > LOGFS_BLOCKSIZE);\n\tpage = logfs_get_write_page(inode, bix, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tpagebuf = kmap_atomic(page);\n\tmemcpy(pagebuf, buf, count);\n\tflush_dcache_page(page);\n\tkunmap_atomic(pagebuf);\n\n\tif (i_size_read(inode) < pos + LOGFS_BLOCKSIZE)\n\t\ti_size_write(inode, pos + LOGFS_BLOCKSIZE);\n\n\terr = logfs_write_buf(inode, page, flags);\n\tlogfs_put_write_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "btree_write_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2203-2222",
    "snippet": "void btree_write_block(struct logfs_block *block)\n{\n\tstruct inode *inode;\n\tstruct page *page;\n\tint err, cookie;\n\n\tinode = logfs_safe_iget(block->sb, block->ino, &cookie);\n\tpage = logfs_get_write_page(inode, block->bix, block->level);\n\n\terr = logfs_readpage_nolock(page);\n\tBUG_ON(err);\n\tBUG_ON(!PagePrivate(page));\n\tBUG_ON(logfs_block(page) != block);\n\terr = __logfs_write_buf(inode, page, 0);\n\tBUG_ON(err);\n\tBUG_ON(PagePrivate(page) || page->private);\n\n\tlogfs_put_write_page(page);\n\tlogfs_safe_iput(inode, cookie);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_safe_iput",
          "args": [
            "inode",
            "cookie"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_safe_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "187-200",
          "snippet": "void logfs_safe_iput(struct inode *inode, int is_cached)\n{\n\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\treturn;\n\tif (inode->i_ino == LOGFS_INO_SEGFILE)\n\t\treturn;\n\n\tif (is_cached) {\n\t\tlogfs_destroy_inode(inode);\n\t\treturn;\n\t}\n\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_safe_iput(struct inode *inode, int is_cached)\n{\n\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\treturn;\n\tif (inode->i_ino == LOGFS_INO_SEGFILE)\n\t\treturn;\n\n\tif (is_cached) {\n\t\tlogfs_destroy_inode(inode);\n\t\treturn;\n\t}\n\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PagePrivate(page) || page->private"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__logfs_write_buf",
          "args": [
            "inode",
            "page",
            "0"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_write_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1540-1563",
          "snippet": "static int __logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tpgoff_t index = page->index;\n\tu64 bix;\n\tlevel_t level;\n\tint err;\n\n\tflags |= WF_WRITE | WF_DELETE;\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tlogfs_unpack_index(index, &bix, &level);\n\tif (logfs_block(page) && logfs_block(page)->reserved_bytes)\n\t\tsuper->s_dirty_pages -= logfs_block(page)->reserved_bytes;\n\n\tif (index < I0_BLOCKS)\n\t\treturn logfs_write_direct(inode, page, flags);\n\n\tbix = adjust_bix(bix, level);\n\terr = grow_inode(inode, bix, level);\n\tif (err)\n\t\treturn err;\n\treturn logfs_write_rec(inode, page, bix, level, flags);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tpgoff_t index = page->index;\n\tu64 bix;\n\tlevel_t level;\n\tint err;\n\n\tflags |= WF_WRITE | WF_DELETE;\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tlogfs_unpack_index(index, &bix, &level);\n\tif (logfs_block(page) && logfs_block(page)->reserved_bytes)\n\t\tsuper->s_dirty_pages -= logfs_block(page)->reserved_bytes;\n\n\tif (index < I0_BLOCKS)\n\t\treturn logfs_write_direct(inode, page, flags);\n\n\tbix = adjust_bix(bix, level);\n\terr = grow_inode(inode, bix, level);\n\tif (err)\n\t\treturn err;\n\treturn logfs_write_rec(inode, page, bix, level, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "logfs_block(page) != block"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "page"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PagePrivate(page)"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_readpage_nolock",
          "args": [
            "page"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_readpage_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1063-1080",
          "snippet": "int logfs_readpage_nolock(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EIO;\n\n\tret = logfs_read_block(inode, page, READ);\n\n\tif (ret) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t} else {\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\tflush_dcache_page(page);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_readpage_nolock(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EIO;\n\n\tret = logfs_read_block(inode, page, READ);\n\n\tif (ret) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t} else {\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\tflush_dcache_page(page);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "inode",
            "block->bix",
            "block->level"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_safe_iget",
          "args": [
            "block->sb",
            "block->ino",
            "&cookie"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_safe_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "120-142",
          "snippet": "struct inode *logfs_safe_iget(struct super_block *sb, ino_t ino, int *is_cached)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_inode *li;\n\n\tif (ino == LOGFS_INO_MASTER)\n\t\treturn super->s_master_inode;\n\tif (ino == LOGFS_INO_SEGFILE)\n\t\treturn super->s_segfile_inode;\n\n\tspin_lock(&logfs_inode_lock);\n\tlist_for_each_entry(li, &super->s_freeing_list, li_freeing_list)\n\t\tif (li->vfs_inode.i_ino == ino) {\n\t\t\tli->li_refcount++;\n\t\t\tspin_unlock(&logfs_inode_lock);\n\t\t\t*is_cached = 1;\n\t\t\treturn &li->vfs_inode;\n\t\t}\n\tspin_unlock(&logfs_inode_lock);\n\n\t*is_cached = 0;\n\treturn __logfs_iget(sb, ino);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(logfs_inode_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic DEFINE_SPINLOCK(logfs_inode_lock);\n\nstruct inode *logfs_safe_iget(struct super_block *sb, ino_t ino, int *is_cached)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_inode *li;\n\n\tif (ino == LOGFS_INO_MASTER)\n\t\treturn super->s_master_inode;\n\tif (ino == LOGFS_INO_SEGFILE)\n\t\treturn super->s_segfile_inode;\n\n\tspin_lock(&logfs_inode_lock);\n\tlist_for_each_entry(li, &super->s_freeing_list, li_freeing_list)\n\t\tif (li->vfs_inode.i_ino == ino) {\n\t\t\tli->li_refcount++;\n\t\t\tspin_unlock(&logfs_inode_lock);\n\t\t\t*is_cached = 1;\n\t\t\treturn &li->vfs_inode;\n\t\t}\n\tspin_unlock(&logfs_inode_lock);\n\n\t*is_cached = 0;\n\treturn __logfs_iget(sb, ino);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid btree_write_block(struct logfs_block *block)\n{\n\tstruct inode *inode;\n\tstruct page *page;\n\tint err, cookie;\n\n\tinode = logfs_safe_iget(block->sb, block->ino, &cookie);\n\tpage = logfs_get_write_page(inode, block->bix, block->level);\n\n\terr = logfs_readpage_nolock(page);\n\tBUG_ON(err);\n\tBUG_ON(!PagePrivate(page));\n\tBUG_ON(logfs_block(page) != block);\n\terr = __logfs_write_buf(inode, page, 0);\n\tBUG_ON(err);\n\tBUG_ON(PagePrivate(page) || page->private);\n\n\tlogfs_put_write_page(page);\n\tlogfs_safe_iput(inode, cookie);\n}"
  },
  {
    "function_name": "logfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2168-2201",
    "snippet": "void logfs_evict_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = li->li_block;\n\tstruct page *page;\n\n\tif (!inode->i_nlink) {\n\t\tif (!(li->li_flags & LOGFS_IF_ZOMBIE)) {\n\t\t\tli->li_flags |= LOGFS_IF_ZOMBIE;\n\t\t\tif (i_size_read(inode) > 0)\n\t\t\t\tlogfs_truncate(inode, 0);\n\t\t\tdo_delete_inode(inode);\n\t\t}\n\t}\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\n\t/* Cheaper version of write_inode.  All changes are concealed in\n\t * aliases, which are moved back.  No write to the medium happens.\n\t */\n\t/* Only deleted files may be dirty at this point */\n\tBUG_ON(inode->i_state & I_DIRTY && inode->i_nlink);\n\tif (!block)\n\t\treturn;\n\tif ((logfs_super(sb)->s_flags & LOGFS_SB_FLAG_SHUTDOWN)) {\n\t\tblock->ops->free_block(inode->i_sb, block);\n\t\treturn;\n\t}\n\n\tpage = inode_to_page(inode);\n\tBUG_ON(!page); /* FIXME: Use emergency page */\n\tlogfs_put_write_page(page);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_page",
          "args": [
            "inode"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1979-1996",
          "snippet": "static struct page *inode_to_page(struct inode *inode)\n{\n\tstruct inode *master_inode = logfs_super(inode->i_sb)->s_master_inode;\n\tstruct logfs_disk_inode *di;\n\tstruct page *page;\n\n\tBUG_ON(inode->i_ino == LOGFS_INO_MASTER);\n\n\tpage = logfs_get_write_page(master_inode, inode->i_ino, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\tdi = kmap_atomic(page);\n\tlogfs_inode_to_disk(inode, di);\n\tkunmap_atomic(di);\n\tmove_inode_to_page(page, inode);\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *inode_to_page(struct inode *inode)\n{\n\tstruct inode *master_inode = logfs_super(inode->i_sb)->s_master_inode;\n\tstruct logfs_disk_inode *di;\n\tstruct page *page;\n\n\tBUG_ON(inode->i_ino == LOGFS_INO_MASTER);\n\n\tpage = logfs_get_write_page(master_inode, inode->i_ino, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\tdi = kmap_atomic(page);\n\tlogfs_inode_to_disk(inode, di);\n\tkunmap_atomic(di);\n\tmove_inode_to_page(page, inode);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block->ops->free_block",
          "args": [
            "inode->i_sb",
            "block"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_state & I_DIRTY && inode->i_nlink"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_delete_inode",
          "args": [
            "inode"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "do_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2143-2162",
          "snippet": "static int do_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct inode *master_inode = logfs_super(sb)->s_master_inode;\n\tstruct page *page;\n\tint ret;\n\n\tpage = logfs_get_write_page(master_inode, inode->i_ino, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tmove_inode_to_page(page, inode);\n\n\tlogfs_get_wblocks(sb, page, 1);\n\tret = __logfs_delete(master_inode, page);\n\tlogfs_put_wblocks(sb, page, 1);\n\n\tlogfs_put_write_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int do_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct inode *master_inode = logfs_super(sb)->s_master_inode;\n\tstruct page *page;\n\tint ret;\n\n\tpage = logfs_get_write_page(master_inode, inode->i_ino, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tmove_inode_to_page(page, inode);\n\n\tlogfs_get_wblocks(sb, page, 1);\n\tret = __logfs_delete(master_inode, page);\n\tlogfs_put_wblocks(sb, page, 1);\n\n\tlogfs_put_write_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_truncate",
          "args": [
            "inode",
            "0"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1868-1902",
          "snippet": "int logfs_truncate(struct inode *inode, u64 target)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu64 size = i_size_read(inode);\n\tint err = 0;\n\n\tsize = ALIGN(size, TRUNCATE_STEP);\n\twhile (size > target) {\n\t\tif (size > TRUNCATE_STEP)\n\t\t\tsize -= TRUNCATE_STEP;\n\t\telse\n\t\t\tsize = 0;\n\t\tif (size < target)\n\t\t\tsize = target;\n\n\t\tlogfs_get_wblocks(sb, NULL, 1);\n\t\terr = __logfs_truncate(inode, size);\n\t\tif (!err)\n\t\t\terr = __logfs_write_inode(inode, NULL, 0);\n\t\tlogfs_put_wblocks(sb, NULL, 1);\n\t}\n\n\tif (!err) {\n\t\terr = inode_newsize_ok(inode, target);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttruncate_setsize(inode, target);\n\t}\n\n out:\n\t/* I don't trust error recovery yet. */\n\tWARN_ON(err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define TRUNCATE_STEP\t(8 * 1024 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define TRUNCATE_STEP\t(8 * 1024 * 1024)\n\nint logfs_truncate(struct inode *inode, u64 target)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu64 size = i_size_read(inode);\n\tint err = 0;\n\n\tsize = ALIGN(size, TRUNCATE_STEP);\n\twhile (size > target) {\n\t\tif (size > TRUNCATE_STEP)\n\t\t\tsize -= TRUNCATE_STEP;\n\t\telse\n\t\t\tsize = 0;\n\t\tif (size < target)\n\t\t\tsize = target;\n\n\t\tlogfs_get_wblocks(sb, NULL, 1);\n\t\terr = __logfs_truncate(inode, size);\n\t\tif (!err)\n\t\t\terr = __logfs_write_inode(inode, NULL, 0);\n\t\tlogfs_put_wblocks(sb, NULL, 1);\n\t}\n\n\tif (!err) {\n\t\terr = inode_newsize_ok(inode, target);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttruncate_setsize(inode, target);\n\t}\n\n out:\n\t/* I don't trust error recovery yet. */\n\tWARN_ON(err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_evict_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = li->li_block;\n\tstruct page *page;\n\n\tif (!inode->i_nlink) {\n\t\tif (!(li->li_flags & LOGFS_IF_ZOMBIE)) {\n\t\t\tli->li_flags |= LOGFS_IF_ZOMBIE;\n\t\t\tif (i_size_read(inode) > 0)\n\t\t\t\tlogfs_truncate(inode, 0);\n\t\t\tdo_delete_inode(inode);\n\t\t}\n\t}\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\n\t/* Cheaper version of write_inode.  All changes are concealed in\n\t * aliases, which are moved back.  No write to the medium happens.\n\t */\n\t/* Only deleted files may be dirty at this point */\n\tBUG_ON(inode->i_state & I_DIRTY && inode->i_nlink);\n\tif (!block)\n\t\treturn;\n\tif ((logfs_super(sb)->s_flags & LOGFS_SB_FLAG_SHUTDOWN)) {\n\t\tblock->ops->free_block(inode->i_sb, block);\n\t\treturn;\n\t}\n\n\tpage = inode_to_page(inode);\n\tBUG_ON(!page); /* FIXME: Use emergency page */\n\tlogfs_put_write_page(page);\n}"
  },
  {
    "function_name": "do_delete_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2143-2162",
    "snippet": "static int do_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct inode *master_inode = logfs_super(sb)->s_master_inode;\n\tstruct page *page;\n\tint ret;\n\n\tpage = logfs_get_write_page(master_inode, inode->i_ino, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tmove_inode_to_page(page, inode);\n\n\tlogfs_get_wblocks(sb, page, 1);\n\tret = __logfs_delete(master_inode, page);\n\tlogfs_put_wblocks(sb, page, 1);\n\n\tlogfs_put_write_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_put_wblocks",
          "args": [
            "sb",
            "page",
            "1"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "262-272",
          "snippet": "void logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_delete",
          "args": [
            "master_inode",
            "page"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1576-1589",
          "snippet": "static int __logfs_delete(struct inode *inode, struct page *page)\n{\n\tlong flags = WF_DELETE;\n\tint err;\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tif (page->index < I0_BLOCKS)\n\t\treturn logfs_write_direct(inode, page, flags);\n\terr = grow_inode(inode, page->index, 0);\n\tif (err)\n\t\treturn err;\n\treturn logfs_write_rec(inode, page, page->index, 0, flags);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_delete(struct inode *inode, struct page *page)\n{\n\tlong flags = WF_DELETE;\n\tint err;\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tif (page->index < I0_BLOCKS)\n\t\treturn logfs_write_direct(inode, page, flags);\n\terr = grow_inode(inode, page->index, 0);\n\tif (err)\n\t\treturn err;\n\treturn logfs_write_rec(inode, page, page->index, 0, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_wblocks",
          "args": [
            "sb",
            "page",
            "1"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "247-260",
          "snippet": "void logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_inode_to_page",
          "args": [
            "page",
            "inode"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "move_inode_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1927-1949",
          "snippet": "static void move_inode_to_page(struct page *page, struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = li->li_block;\n\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_inode_to_page(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tBUG_ON(PagePrivate(page));\n\tblock->ops = &indirect_block_ops;\n\tblock->page = page;\n\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long) block);\n\t}\n\n\tblock->inode = NULL;\n\tli->li_block = NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct logfs_block_ops indirect_block_ops = {\n\t.write_block = indirect_write_block,\n\t.free_block = indirect_free_block,\n\t.write_alias = indirect_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstruct logfs_block_ops indirect_block_ops = {\n\t.write_block = indirect_write_block,\n\t.free_block = indirect_free_block,\n\t.write_alias = indirect_write_alias,\n};\n\nstatic void move_inode_to_page(struct page *page, struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = li->li_block;\n\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_inode_to_page(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tBUG_ON(PagePrivate(page));\n\tblock->ops = &indirect_block_ops;\n\tblock->page = page;\n\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long) block);\n\t}\n\n\tblock->inode = NULL;\n\tli->li_block = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "master_inode",
            "inode->i_ino",
            "0"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int do_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct inode *master_inode = logfs_super(sb)->s_master_inode;\n\tstruct page *page;\n\tint ret;\n\n\tpage = logfs_get_write_page(master_inode, inode->i_ino, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tmove_inode_to_page(page, inode);\n\n\tlogfs_get_wblocks(sb, page, 1);\n\tret = __logfs_delete(master_inode, page);\n\tlogfs_put_wblocks(sb, page, 1);\n\n\tlogfs_put_write_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "__logfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2132-2141",
    "snippet": "int __logfs_write_inode(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = do_write_inode(inode);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_wblocks",
          "args": [
            "sb",
            "page",
            "flags & WF_LOCK"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "262-272",
          "snippet": "void logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_write_inode",
          "args": [
            "inode"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "do_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1998-2025",
          "snippet": "static int do_write_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct inode *master_inode = logfs_super(sb)->s_master_inode;\n\tloff_t size = (inode->i_ino + 1) << inode->i_sb->s_blocksize_bits;\n\tstruct page *page;\n\tint err;\n\n\tBUG_ON(inode->i_ino == LOGFS_INO_MASTER);\n\t/* FIXME: lock inode */\n\n\tif (i_size_read(master_inode) < size)\n\t\ti_size_write(master_inode, size);\n\n\t/* TODO: Tell vfs this inode is clean now */\n\n\tpage = inode_to_page(inode);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\t/* FIXME: transaction is part of logfs_block now.  Is that enough? */\n\terr = logfs_write_buf(master_inode, page, 0);\n\tif (err)\n\t\tmove_page_to_inode(inode, page);\n\n\tlogfs_put_write_page(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int do_write_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct inode *master_inode = logfs_super(sb)->s_master_inode;\n\tloff_t size = (inode->i_ino + 1) << inode->i_sb->s_blocksize_bits;\n\tstruct page *page;\n\tint err;\n\n\tBUG_ON(inode->i_ino == LOGFS_INO_MASTER);\n\t/* FIXME: lock inode */\n\n\tif (i_size_read(master_inode) < size)\n\t\ti_size_write(master_inode, size);\n\n\t/* TODO: Tell vfs this inode is clean now */\n\n\tpage = inode_to_page(inode);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\t/* FIXME: transaction is part of logfs_block now.  Is that enough? */\n\terr = logfs_write_buf(master_inode, page, 0);\n\tif (err)\n\t\tmove_page_to_inode(inode, page);\n\n\tlogfs_put_write_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_wblocks",
          "args": [
            "sb",
            "page",
            "flags & WF_LOCK"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "247-260",
          "snippet": "void logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint __logfs_write_inode(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = do_write_inode(inode);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}"
  },
  {
    "function_name": "logfs_set_segment_unreserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2124-2130",
    "snippet": "void logfs_set_segment_unreserved(struct super_block *sb, u32 segno, u32 ec)\n{\n\tu32 ec_level = ec << 4;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_unreserved,\n\t\t\tec_level);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_mod_segment_entry",
          "args": [
            "sb",
            "segno",
            "1",
            "__set_segment_unreserved",
            "ec_level"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mod_segment_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2027-2059",
          "snippet": "static void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\n\t\tint write,\n\t\tvoid (*change_se)(struct logfs_segment_entry *, long),\n\t\tlong arg)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct logfs_segment_entry *se;\n\tpgoff_t page_no;\n\tint child_no;\n\n\tpage_no = segno >> (sb->s_blocksize_bits - 3);\n\tchild_no = segno & ((sb->s_blocksize >> 3) - 1);\n\n\tinode = super->s_segfile_inode;\n\tpage = logfs_get_write_page(inode, page_no, 0);\n\tBUG_ON(!page); /* FIXME: We need some reserve page for this case */\n\tif (!PageUptodate(page))\n\t\tlogfs_read_block(inode, page, WRITE);\n\n\tif (write)\n\t\talloc_indirect_block(inode, page, 0);\n\tse = kmap_atomic(page);\n\tchange_se(se + child_no, arg);\n\tif (write) {\n\t\tlogfs_set_alias(sb, logfs_block(page), child_no);\n\t\tBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\n\t}\n\tkunmap_atomic(se);\n\n\tlogfs_put_write_page(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\n\t\tint write,\n\t\tvoid (*change_se)(struct logfs_segment_entry *, long),\n\t\tlong arg)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct logfs_segment_entry *se;\n\tpgoff_t page_no;\n\tint child_no;\n\n\tpage_no = segno >> (sb->s_blocksize_bits - 3);\n\tchild_no = segno & ((sb->s_blocksize >> 3) - 1);\n\n\tinode = super->s_segfile_inode;\n\tpage = logfs_get_write_page(inode, page_no, 0);\n\tBUG_ON(!page); /* FIXME: We need some reserve page for this case */\n\tif (!PageUptodate(page))\n\t\tlogfs_read_block(inode, page, WRITE);\n\n\tif (write)\n\t\talloc_indirect_block(inode, page, 0);\n\tse = kmap_atomic(page);\n\tchange_se(se + child_no, arg);\n\tif (write) {\n\t\tlogfs_set_alias(sb, logfs_block(page), child_no);\n\t\tBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\n\t}\n\tkunmap_atomic(se);\n\n\tlogfs_put_write_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_set_segment_unreserved(struct super_block *sb, u32 segno, u32 ec)\n{\n\tu32 ec_level = ec << 4;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_unreserved,\n\t\t\tec_level);\n}"
  },
  {
    "function_name": "__set_segment_unreserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2117-2122",
    "snippet": "static void __set_segment_unreserved(struct logfs_segment_entry *se,\n\t\tlong ec_level)\n{\n\tse->valid = 0;\n\tse->ec_level = cpu_to_be32(ec_level);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ec_level"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void __set_segment_unreserved(struct logfs_segment_entry *se,\n\t\tlong ec_level)\n{\n\tse->valid = 0;\n\tse->ec_level = cpu_to_be32(ec_level);\n}"
  },
  {
    "function_name": "logfs_set_segment_reserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2112-2115",
    "snippet": "void logfs_set_segment_reserved(struct super_block *sb, u32 segno)\n{\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_reserved, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_mod_segment_entry",
          "args": [
            "sb",
            "segno",
            "1",
            "__set_segment_reserved",
            "0"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mod_segment_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2027-2059",
          "snippet": "static void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\n\t\tint write,\n\t\tvoid (*change_se)(struct logfs_segment_entry *, long),\n\t\tlong arg)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct logfs_segment_entry *se;\n\tpgoff_t page_no;\n\tint child_no;\n\n\tpage_no = segno >> (sb->s_blocksize_bits - 3);\n\tchild_no = segno & ((sb->s_blocksize >> 3) - 1);\n\n\tinode = super->s_segfile_inode;\n\tpage = logfs_get_write_page(inode, page_no, 0);\n\tBUG_ON(!page); /* FIXME: We need some reserve page for this case */\n\tif (!PageUptodate(page))\n\t\tlogfs_read_block(inode, page, WRITE);\n\n\tif (write)\n\t\talloc_indirect_block(inode, page, 0);\n\tse = kmap_atomic(page);\n\tchange_se(se + child_no, arg);\n\tif (write) {\n\t\tlogfs_set_alias(sb, logfs_block(page), child_no);\n\t\tBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\n\t}\n\tkunmap_atomic(se);\n\n\tlogfs_put_write_page(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\n\t\tint write,\n\t\tvoid (*change_se)(struct logfs_segment_entry *, long),\n\t\tlong arg)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct logfs_segment_entry *se;\n\tpgoff_t page_no;\n\tint child_no;\n\n\tpage_no = segno >> (sb->s_blocksize_bits - 3);\n\tchild_no = segno & ((sb->s_blocksize >> 3) - 1);\n\n\tinode = super->s_segfile_inode;\n\tpage = logfs_get_write_page(inode, page_no, 0);\n\tBUG_ON(!page); /* FIXME: We need some reserve page for this case */\n\tif (!PageUptodate(page))\n\t\tlogfs_read_block(inode, page, WRITE);\n\n\tif (write)\n\t\talloc_indirect_block(inode, page, 0);\n\tse = kmap_atomic(page);\n\tchange_se(se + child_no, arg);\n\tif (write) {\n\t\tlogfs_set_alias(sb, logfs_block(page), child_no);\n\t\tBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\n\t}\n\tkunmap_atomic(se);\n\n\tlogfs_put_write_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_set_segment_reserved(struct super_block *sb, u32 segno)\n{\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_reserved, 0);\n}"
  },
  {
    "function_name": "__set_segment_reserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2107-2110",
    "snippet": "static void __set_segment_reserved(struct logfs_segment_entry *se, long ignore)\n{\n\tse->valid = cpu_to_be32(RESERVED);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "RESERVED"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void __set_segment_reserved(struct logfs_segment_entry *se, long ignore)\n{\n\tse->valid = cpu_to_be32(RESERVED);\n}"
  },
  {
    "function_name": "logfs_set_segment_erased",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2099-2105",
    "snippet": "void logfs_set_segment_erased(struct super_block *sb, u32 segno, u32 ec,\n\t\tgc_level_t gc_level)\n{\n\tu32 ec_level = ec << 4 | (__force u8)gc_level;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_erased, ec_level);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_mod_segment_entry",
          "args": [
            "sb",
            "segno",
            "1",
            "__set_segment_erased",
            "ec_level"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mod_segment_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2027-2059",
          "snippet": "static void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\n\t\tint write,\n\t\tvoid (*change_se)(struct logfs_segment_entry *, long),\n\t\tlong arg)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct logfs_segment_entry *se;\n\tpgoff_t page_no;\n\tint child_no;\n\n\tpage_no = segno >> (sb->s_blocksize_bits - 3);\n\tchild_no = segno & ((sb->s_blocksize >> 3) - 1);\n\n\tinode = super->s_segfile_inode;\n\tpage = logfs_get_write_page(inode, page_no, 0);\n\tBUG_ON(!page); /* FIXME: We need some reserve page for this case */\n\tif (!PageUptodate(page))\n\t\tlogfs_read_block(inode, page, WRITE);\n\n\tif (write)\n\t\talloc_indirect_block(inode, page, 0);\n\tse = kmap_atomic(page);\n\tchange_se(se + child_no, arg);\n\tif (write) {\n\t\tlogfs_set_alias(sb, logfs_block(page), child_no);\n\t\tBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\n\t}\n\tkunmap_atomic(se);\n\n\tlogfs_put_write_page(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\n\t\tint write,\n\t\tvoid (*change_se)(struct logfs_segment_entry *, long),\n\t\tlong arg)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct logfs_segment_entry *se;\n\tpgoff_t page_no;\n\tint child_no;\n\n\tpage_no = segno >> (sb->s_blocksize_bits - 3);\n\tchild_no = segno & ((sb->s_blocksize >> 3) - 1);\n\n\tinode = super->s_segfile_inode;\n\tpage = logfs_get_write_page(inode, page_no, 0);\n\tBUG_ON(!page); /* FIXME: We need some reserve page for this case */\n\tif (!PageUptodate(page))\n\t\tlogfs_read_block(inode, page, WRITE);\n\n\tif (write)\n\t\talloc_indirect_block(inode, page, 0);\n\tse = kmap_atomic(page);\n\tchange_se(se + child_no, arg);\n\tif (write) {\n\t\tlogfs_set_alias(sb, logfs_block(page), child_no);\n\t\tBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\n\t}\n\tkunmap_atomic(se);\n\n\tlogfs_put_write_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_set_segment_erased(struct super_block *sb, u32 segno, u32 ec,\n\t\tgc_level_t gc_level)\n{\n\tu32 ec_level = ec << 4 | (__force u8)gc_level;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_erased, ec_level);\n}"
  },
  {
    "function_name": "__set_segment_erased",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2094-2097",
    "snippet": "static void __set_segment_erased(struct logfs_segment_entry *se, long ec_level)\n{\n\tse->ec_level = cpu_to_be32(ec_level);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ec_level"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void __set_segment_erased(struct logfs_segment_entry *se, long ec_level)\n{\n\tse->ec_level = cpu_to_be32(ec_level);\n}"
  },
  {
    "function_name": "logfs_set_segment_used",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2083-2092",
    "snippet": "void logfs_set_segment_used(struct super_block *sb, u64 ofs, int increment)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu32 segno = ofs >> super->s_segshift;\n\n\tif (!increment)\n\t\treturn;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_used, increment);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_mod_segment_entry",
          "args": [
            "sb",
            "segno",
            "1",
            "__set_segment_used",
            "increment"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mod_segment_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2027-2059",
          "snippet": "static void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\n\t\tint write,\n\t\tvoid (*change_se)(struct logfs_segment_entry *, long),\n\t\tlong arg)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct logfs_segment_entry *se;\n\tpgoff_t page_no;\n\tint child_no;\n\n\tpage_no = segno >> (sb->s_blocksize_bits - 3);\n\tchild_no = segno & ((sb->s_blocksize >> 3) - 1);\n\n\tinode = super->s_segfile_inode;\n\tpage = logfs_get_write_page(inode, page_no, 0);\n\tBUG_ON(!page); /* FIXME: We need some reserve page for this case */\n\tif (!PageUptodate(page))\n\t\tlogfs_read_block(inode, page, WRITE);\n\n\tif (write)\n\t\talloc_indirect_block(inode, page, 0);\n\tse = kmap_atomic(page);\n\tchange_se(se + child_no, arg);\n\tif (write) {\n\t\tlogfs_set_alias(sb, logfs_block(page), child_no);\n\t\tBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\n\t}\n\tkunmap_atomic(se);\n\n\tlogfs_put_write_page(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\n\t\tint write,\n\t\tvoid (*change_se)(struct logfs_segment_entry *, long),\n\t\tlong arg)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct logfs_segment_entry *se;\n\tpgoff_t page_no;\n\tint child_no;\n\n\tpage_no = segno >> (sb->s_blocksize_bits - 3);\n\tchild_no = segno & ((sb->s_blocksize >> 3) - 1);\n\n\tinode = super->s_segfile_inode;\n\tpage = logfs_get_write_page(inode, page_no, 0);\n\tBUG_ON(!page); /* FIXME: We need some reserve page for this case */\n\tif (!PageUptodate(page))\n\t\tlogfs_read_block(inode, page, WRITE);\n\n\tif (write)\n\t\talloc_indirect_block(inode, page, 0);\n\tse = kmap_atomic(page);\n\tchange_se(se + child_no, arg);\n\tif (write) {\n\t\tlogfs_set_alias(sb, logfs_block(page), child_no);\n\t\tBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\n\t}\n\tkunmap_atomic(se);\n\n\tlogfs_put_write_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_set_segment_used(struct super_block *sb, u64 ofs, int increment)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu32 segno = ofs >> super->s_segshift;\n\n\tif (!increment)\n\t\treturn;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_used, increment);\n}"
  },
  {
    "function_name": "__set_segment_used",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2074-2081",
    "snippet": "static void __set_segment_used(struct logfs_segment_entry *se, long increment)\n{\n\tu32 valid;\n\n\tvalid = be32_to_cpu(se->valid);\n\tvalid += increment;\n\tse->valid = cpu_to_be32(valid);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "valid"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se->valid"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void __set_segment_used(struct logfs_segment_entry *se, long increment)\n{\n\tu32 valid;\n\n\tvalid = be32_to_cpu(se->valid);\n\tvalid += increment;\n\tse->valid = cpu_to_be32(valid);\n}"
  },
  {
    "function_name": "logfs_get_segment_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2068-2072",
    "snippet": "void logfs_get_segment_entry(struct super_block *sb, u32 segno,\n\t\tstruct logfs_segment_entry *se)\n{\n\tlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_mod_segment_entry",
          "args": [
            "sb",
            "segno",
            "0",
            "__get_segment_entry",
            "(long)se"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mod_segment_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2027-2059",
          "snippet": "static void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\n\t\tint write,\n\t\tvoid (*change_se)(struct logfs_segment_entry *, long),\n\t\tlong arg)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct logfs_segment_entry *se;\n\tpgoff_t page_no;\n\tint child_no;\n\n\tpage_no = segno >> (sb->s_blocksize_bits - 3);\n\tchild_no = segno & ((sb->s_blocksize >> 3) - 1);\n\n\tinode = super->s_segfile_inode;\n\tpage = logfs_get_write_page(inode, page_no, 0);\n\tBUG_ON(!page); /* FIXME: We need some reserve page for this case */\n\tif (!PageUptodate(page))\n\t\tlogfs_read_block(inode, page, WRITE);\n\n\tif (write)\n\t\talloc_indirect_block(inode, page, 0);\n\tse = kmap_atomic(page);\n\tchange_se(se + child_no, arg);\n\tif (write) {\n\t\tlogfs_set_alias(sb, logfs_block(page), child_no);\n\t\tBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\n\t}\n\tkunmap_atomic(se);\n\n\tlogfs_put_write_page(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\n\t\tint write,\n\t\tvoid (*change_se)(struct logfs_segment_entry *, long),\n\t\tlong arg)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct logfs_segment_entry *se;\n\tpgoff_t page_no;\n\tint child_no;\n\n\tpage_no = segno >> (sb->s_blocksize_bits - 3);\n\tchild_no = segno & ((sb->s_blocksize >> 3) - 1);\n\n\tinode = super->s_segfile_inode;\n\tpage = logfs_get_write_page(inode, page_no, 0);\n\tBUG_ON(!page); /* FIXME: We need some reserve page for this case */\n\tif (!PageUptodate(page))\n\t\tlogfs_read_block(inode, page, WRITE);\n\n\tif (write)\n\t\talloc_indirect_block(inode, page, 0);\n\tse = kmap_atomic(page);\n\tchange_se(se + child_no, arg);\n\tif (write) {\n\t\tlogfs_set_alias(sb, logfs_block(page), child_no);\n\t\tBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\n\t}\n\tkunmap_atomic(se);\n\n\tlogfs_put_write_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_segment_entry(struct super_block *sb, u32 segno,\n\t\tstruct logfs_segment_entry *se)\n{\n\tlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\n}"
  },
  {
    "function_name": "__get_segment_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2061-2066",
    "snippet": "static void __get_segment_entry(struct logfs_segment_entry *se, long _target)\n{\n\tstruct logfs_segment_entry *target = (void *)_target;\n\n\t*target = *se;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void __get_segment_entry(struct logfs_segment_entry *se, long _target)\n{\n\tstruct logfs_segment_entry *target = (void *)_target;\n\n\t*target = *se;\n}"
  },
  {
    "function_name": "logfs_mod_segment_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "2027-2059",
    "snippet": "static void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\n\t\tint write,\n\t\tvoid (*change_se)(struct logfs_segment_entry *, long),\n\t\tlong arg)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct logfs_segment_entry *se;\n\tpgoff_t page_no;\n\tint child_no;\n\n\tpage_no = segno >> (sb->s_blocksize_bits - 3);\n\tchild_no = segno & ((sb->s_blocksize >> 3) - 1);\n\n\tinode = super->s_segfile_inode;\n\tpage = logfs_get_write_page(inode, page_no, 0);\n\tBUG_ON(!page); /* FIXME: We need some reserve page for this case */\n\tif (!PageUptodate(page))\n\t\tlogfs_read_block(inode, page, WRITE);\n\n\tif (write)\n\t\talloc_indirect_block(inode, page, 0);\n\tse = kmap_atomic(page);\n\tchange_se(se + child_no, arg);\n\tif (write) {\n\t\tlogfs_set_alias(sb, logfs_block(page), child_no);\n\t\tBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\n\t}\n\tkunmap_atomic(se);\n\n\tlogfs_put_write_page(page);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "se"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(int)be32_to_cpu(se[child_no].valid) > super->s_segsize"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se[child_no].valid"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_set_alias",
          "args": [
            "sb",
            "logfs_block(page)",
            "child_no"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1303-1318",
          "snippet": "static void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "page"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "change_se",
          "args": [
            "se + child_no",
            "arg"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_indirect_block",
          "args": [
            "inode",
            "page",
            "0"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_indirect_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "664-679",
          "snippet": "static void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_read_block",
          "args": [
            "inode",
            "page",
            "WRITE"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "767-775",
          "snippet": "static int logfs_read_block(struct inode *inode, struct page *page,\n\t\tint rw_context)\n{\n\tpgoff_t index = page->index;\n\n\tif (index < I0_BLOCKS)\n\t\treturn logfs_read_direct(inode, page);\n\treturn logfs_read_loop(inode, page, rw_context);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_block(struct inode *inode, struct page *page,\n\t\tint rw_context)\n{\n\tpgoff_t index = page->index;\n\n\tif (index < I0_BLOCKS)\n\t\treturn logfs_read_direct(inode, page);\n\treturn logfs_read_loop(inode, page, rw_context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "inode",
            "page_no",
            "0"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\n\t\tint write,\n\t\tvoid (*change_se)(struct logfs_segment_entry *, long),\n\t\tlong arg)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tstruct page *page;\n\tstruct logfs_segment_entry *se;\n\tpgoff_t page_no;\n\tint child_no;\n\n\tpage_no = segno >> (sb->s_blocksize_bits - 3);\n\tchild_no = segno & ((sb->s_blocksize >> 3) - 1);\n\n\tinode = super->s_segfile_inode;\n\tpage = logfs_get_write_page(inode, page_no, 0);\n\tBUG_ON(!page); /* FIXME: We need some reserve page for this case */\n\tif (!PageUptodate(page))\n\t\tlogfs_read_block(inode, page, WRITE);\n\n\tif (write)\n\t\talloc_indirect_block(inode, page, 0);\n\tse = kmap_atomic(page);\n\tchange_se(se + child_no, arg);\n\tif (write) {\n\t\tlogfs_set_alias(sb, logfs_block(page), child_no);\n\t\tBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\n\t}\n\tkunmap_atomic(se);\n\n\tlogfs_put_write_page(page);\n}"
  },
  {
    "function_name": "do_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1998-2025",
    "snippet": "static int do_write_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct inode *master_inode = logfs_super(sb)->s_master_inode;\n\tloff_t size = (inode->i_ino + 1) << inode->i_sb->s_blocksize_bits;\n\tstruct page *page;\n\tint err;\n\n\tBUG_ON(inode->i_ino == LOGFS_INO_MASTER);\n\t/* FIXME: lock inode */\n\n\tif (i_size_read(master_inode) < size)\n\t\ti_size_write(master_inode, size);\n\n\t/* TODO: Tell vfs this inode is clean now */\n\n\tpage = inode_to_page(inode);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\t/* FIXME: transaction is part of logfs_block now.  Is that enough? */\n\terr = logfs_write_buf(master_inode, page, 0);\n\tif (err)\n\t\tmove_page_to_inode(inode, page);\n\n\tlogfs_put_write_page(page);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_page_to_inode",
          "args": [
            "inode",
            "page"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "move_page_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1904-1925",
          "snippet": "static void move_page_to_inode(struct inode *inode, struct page *page)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = logfs_block(page);\n\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_page_to_inode(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tBUG_ON(li->li_block);\n\tblock->ops = &inode_block_ops;\n\tblock->inode = inode;\n\tli->li_block = block;\n\n\tblock->page = NULL;\n\tif (PagePrivate(page)) {\n\t\tClearPagePrivate(page);\n\t\tpage_cache_release(page);\n\t\tset_page_private(page, 0);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};\n\nstatic void move_page_to_inode(struct inode *inode, struct page *page)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = logfs_block(page);\n\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_page_to_inode(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tBUG_ON(li->li_block);\n\tblock->ops = &inode_block_ops;\n\tblock->inode = inode;\n\tli->li_block = block;\n\n\tblock->page = NULL;\n\tif (PagePrivate(page)) {\n\t\tClearPagePrivate(page);\n\t\tpage_cache_release(page);\n\t\tset_page_private(page, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_buf",
          "args": [
            "master_inode",
            "page",
            "0"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1565-1574",
          "snippet": "int logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = __logfs_write_buf(inode, page, flags);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = __logfs_write_buf(inode, page, flags);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_page",
          "args": [
            "inode"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1979-1996",
          "snippet": "static struct page *inode_to_page(struct inode *inode)\n{\n\tstruct inode *master_inode = logfs_super(inode->i_sb)->s_master_inode;\n\tstruct logfs_disk_inode *di;\n\tstruct page *page;\n\n\tBUG_ON(inode->i_ino == LOGFS_INO_MASTER);\n\n\tpage = logfs_get_write_page(master_inode, inode->i_ino, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\tdi = kmap_atomic(page);\n\tlogfs_inode_to_disk(inode, di);\n\tkunmap_atomic(di);\n\tmove_inode_to_page(page, inode);\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *inode_to_page(struct inode *inode)\n{\n\tstruct inode *master_inode = logfs_super(inode->i_sb)->s_master_inode;\n\tstruct logfs_disk_inode *di;\n\tstruct page *page;\n\n\tBUG_ON(inode->i_ino == LOGFS_INO_MASTER);\n\n\tpage = logfs_get_write_page(master_inode, inode->i_ino, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\tdi = kmap_atomic(page);\n\tlogfs_inode_to_disk(inode, di);\n\tkunmap_atomic(di);\n\tmove_inode_to_page(page, inode);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "master_inode",
            "size"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "master_inode"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_ino == LOGFS_INO_MASTER"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int do_write_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct inode *master_inode = logfs_super(sb)->s_master_inode;\n\tloff_t size = (inode->i_ino + 1) << inode->i_sb->s_blocksize_bits;\n\tstruct page *page;\n\tint err;\n\n\tBUG_ON(inode->i_ino == LOGFS_INO_MASTER);\n\t/* FIXME: lock inode */\n\n\tif (i_size_read(master_inode) < size)\n\t\ti_size_write(master_inode, size);\n\n\t/* TODO: Tell vfs this inode is clean now */\n\n\tpage = inode_to_page(inode);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\t/* FIXME: transaction is part of logfs_block now.  Is that enough? */\n\terr = logfs_write_buf(master_inode, page, 0);\n\tif (err)\n\t\tmove_page_to_inode(inode, page);\n\n\tlogfs_put_write_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "inode_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1979-1996",
    "snippet": "static struct page *inode_to_page(struct inode *inode)\n{\n\tstruct inode *master_inode = logfs_super(inode->i_sb)->s_master_inode;\n\tstruct logfs_disk_inode *di;\n\tstruct page *page;\n\n\tBUG_ON(inode->i_ino == LOGFS_INO_MASTER);\n\n\tpage = logfs_get_write_page(master_inode, inode->i_ino, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\tdi = kmap_atomic(page);\n\tlogfs_inode_to_disk(inode, di);\n\tkunmap_atomic(di);\n\tmove_inode_to_page(page, inode);\n\treturn page;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "move_inode_to_page",
          "args": [
            "page",
            "inode"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "move_inode_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1927-1949",
          "snippet": "static void move_inode_to_page(struct page *page, struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = li->li_block;\n\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_inode_to_page(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tBUG_ON(PagePrivate(page));\n\tblock->ops = &indirect_block_ops;\n\tblock->page = page;\n\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long) block);\n\t}\n\n\tblock->inode = NULL;\n\tli->li_block = NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct logfs_block_ops indirect_block_ops = {\n\t.write_block = indirect_write_block,\n\t.free_block = indirect_free_block,\n\t.write_alias = indirect_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstruct logfs_block_ops indirect_block_ops = {\n\t.write_block = indirect_write_block,\n\t.free_block = indirect_free_block,\n\t.write_alias = indirect_write_alias,\n};\n\nstatic void move_inode_to_page(struct page *page, struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = li->li_block;\n\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_inode_to_page(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tBUG_ON(PagePrivate(page));\n\tblock->ops = &indirect_block_ops;\n\tblock->page = page;\n\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long) block);\n\t}\n\n\tblock->inode = NULL;\n\tli->li_block = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "di"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode_to_disk",
          "args": [
            "inode",
            "di"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "150-185",
          "snippet": "static void logfs_inode_to_disk(struct inode *inode, struct logfs_disk_inode*di)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tdi->di_mode\t= cpu_to_be16(inode->i_mode);\n\tdi->di_height\t= li->li_height;\n\tdi->di_pad\t= 0;\n\tdi->di_flags\t= cpu_to_be32(li->li_flags);\n\tdi->di_uid\t= cpu_to_be32(i_uid_read(inode));\n\tdi->di_gid\t= cpu_to_be32(i_gid_read(inode));\n\tdi->di_size\t= cpu_to_be64(i_size_read(inode));\n\tdi->di_used_bytes = cpu_to_be64(li->li_used_bytes);\n\tdi->di_atime\t= timespec_to_be64(inode->i_atime);\n\tdi->di_ctime\t= timespec_to_be64(inode->i_ctime);\n\tdi->di_mtime\t= timespec_to_be64(inode->i_mtime);\n\tdi->di_refcount\t= cpu_to_be32(inode->i_nlink);\n\tdi->di_generation = cpu_to_be32(inode->i_generation);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tdi->di_data[0] = cpu_to_be64(inode->i_rdev);\n\t\tbreak;\n\tcase S_IFDIR:\t/* fall through */\n\tcase S_IFREG:\t/* fall through */\n\tcase S_IFLNK:\n\t\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\t\tdi->di_data[i] = cpu_to_be64(li->li_data[i]);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_to_disk(struct inode *inode, struct logfs_disk_inode*di)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tdi->di_mode\t= cpu_to_be16(inode->i_mode);\n\tdi->di_height\t= li->li_height;\n\tdi->di_pad\t= 0;\n\tdi->di_flags\t= cpu_to_be32(li->li_flags);\n\tdi->di_uid\t= cpu_to_be32(i_uid_read(inode));\n\tdi->di_gid\t= cpu_to_be32(i_gid_read(inode));\n\tdi->di_size\t= cpu_to_be64(i_size_read(inode));\n\tdi->di_used_bytes = cpu_to_be64(li->li_used_bytes);\n\tdi->di_atime\t= timespec_to_be64(inode->i_atime);\n\tdi->di_ctime\t= timespec_to_be64(inode->i_ctime);\n\tdi->di_mtime\t= timespec_to_be64(inode->i_mtime);\n\tdi->di_refcount\t= cpu_to_be32(inode->i_nlink);\n\tdi->di_generation = cpu_to_be32(inode->i_generation);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tdi->di_data[0] = cpu_to_be64(inode->i_rdev);\n\t\tbreak;\n\tcase S_IFDIR:\t/* fall through */\n\tcase S_IFREG:\t/* fall through */\n\tcase S_IFLNK:\n\t\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\t\tdi->di_data[i] = cpu_to_be64(li->li_data[i]);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "master_inode",
            "inode->i_ino",
            "0"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_ino == LOGFS_INO_MASTER"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "inode->i_sb"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *inode_to_page(struct inode *inode)\n{\n\tstruct inode *master_inode = logfs_super(inode->i_sb)->s_master_inode;\n\tstruct logfs_disk_inode *di;\n\tstruct page *page;\n\n\tBUG_ON(inode->i_ino == LOGFS_INO_MASTER);\n\n\tpage = logfs_get_write_page(master_inode, inode->i_ino, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\tdi = kmap_atomic(page);\n\tlogfs_inode_to_disk(inode, di);\n\tkunmap_atomic(di);\n\tmove_inode_to_page(page, inode);\n\treturn page;\n}"
  },
  {
    "function_name": "logfs_read_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1951-1976",
    "snippet": "int logfs_read_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *master_inode = super->s_master_inode;\n\tstruct page *page;\n\tstruct logfs_disk_inode *di;\n\tu64 ino = inode->i_ino;\n\n\tif (ino << sb->s_blocksize_bits > i_size_read(master_inode))\n\t\treturn -ENODATA;\n\tif (!logfs_exist_block(master_inode, ino))\n\t\treturn -ENODATA;\n\n\tpage = read_cache_page(master_inode->i_mapping, ino,\n\t\t\t(filler_t *)logfs_readpage, NULL);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tdi = kmap_atomic(page);\n\tlogfs_disk_to_inode(di, inode);\n\tkunmap_atomic(di);\n\tmove_page_to_inode(inode, page);\n\tpage_cache_release(page);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_page_to_inode",
          "args": [
            "inode",
            "page"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "move_page_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1904-1925",
          "snippet": "static void move_page_to_inode(struct inode *inode, struct page *page)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = logfs_block(page);\n\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_page_to_inode(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tBUG_ON(li->li_block);\n\tblock->ops = &inode_block_ops;\n\tblock->inode = inode;\n\tli->li_block = block;\n\n\tblock->page = NULL;\n\tif (PagePrivate(page)) {\n\t\tClearPagePrivate(page);\n\t\tpage_cache_release(page);\n\t\tset_page_private(page, 0);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};\n\nstatic void move_page_to_inode(struct inode *inode, struct page *page)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = logfs_block(page);\n\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_page_to_inode(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tBUG_ON(li->li_block);\n\tblock->ops = &inode_block_ops;\n\tblock->inode = inode;\n\tli->li_block = block;\n\n\tblock->page = NULL;\n\tif (PagePrivate(page)) {\n\t\tClearPagePrivate(page);\n\t\tpage_cache_release(page);\n\t\tset_page_private(page, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "di"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_disk_to_inode",
          "args": [
            "di",
            "inode"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_disk_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "114-148",
          "snippet": "static void logfs_disk_to_inode(struct logfs_disk_inode *di, struct inode*inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tinode->i_mode\t= be16_to_cpu(di->di_mode);\n\tli->li_height\t= di->di_height;\n\tli->li_flags\t= be32_to_cpu(di->di_flags);\n\ti_uid_write(inode, be32_to_cpu(di->di_uid));\n\ti_gid_write(inode, be32_to_cpu(di->di_gid));\n\tinode->i_size\t= be64_to_cpu(di->di_size);\n\tlogfs_set_blocks(inode, be64_to_cpu(di->di_used_bytes));\n\tinode->i_atime\t= be64_to_timespec(di->di_atime);\n\tinode->i_ctime\t= be64_to_timespec(di->di_ctime);\n\tinode->i_mtime\t= be64_to_timespec(di->di_mtime);\n\tset_nlink(inode, be32_to_cpu(di->di_refcount));\n\tinode->i_generation = be32_to_cpu(di->di_generation);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinode->i_rdev = be64_to_cpu(di->di_data[0]);\n\t\tbreak;\n\tcase S_IFDIR:\t/* fall through */\n\tcase S_IFREG:\t/* fall through */\n\tcase S_IFLNK:\n\t\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\t\tli->li_data[i] = be64_to_cpu(di->di_data[i]);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_disk_to_inode(struct logfs_disk_inode *di, struct inode*inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tinode->i_mode\t= be16_to_cpu(di->di_mode);\n\tli->li_height\t= di->di_height;\n\tli->li_flags\t= be32_to_cpu(di->di_flags);\n\ti_uid_write(inode, be32_to_cpu(di->di_uid));\n\ti_gid_write(inode, be32_to_cpu(di->di_gid));\n\tinode->i_size\t= be64_to_cpu(di->di_size);\n\tlogfs_set_blocks(inode, be64_to_cpu(di->di_used_bytes));\n\tinode->i_atime\t= be64_to_timespec(di->di_atime);\n\tinode->i_ctime\t= be64_to_timespec(di->di_ctime);\n\tinode->i_mtime\t= be64_to_timespec(di->di_mtime);\n\tset_nlink(inode, be32_to_cpu(di->di_refcount));\n\tinode->i_generation = be32_to_cpu(di->di_generation);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinode->i_rdev = be64_to_cpu(di->di_data[0]);\n\t\tbreak;\n\tcase S_IFDIR:\t/* fall through */\n\tcase S_IFREG:\t/* fall through */\n\tcase S_IFLNK:\n\t\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\t\tli->li_data[i] = be64_to_cpu(di->di_data[i]);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "master_inode->i_mapping",
            "ino",
            "(filler_t *)logfs_readpage",
            "NULL"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_exist_block",
          "args": [
            "master_inode",
            "ino"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_exist_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "810-817",
          "snippet": "int logfs_exist_block(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS)\n\t\treturn !!li->li_data[bix];\n\treturn logfs_exist_loop(inode, bix);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_exist_block(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS)\n\t\treturn !!li->li_data[bix];\n\treturn logfs_exist_loop(inode, bix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "master_inode"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_read_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *master_inode = super->s_master_inode;\n\tstruct page *page;\n\tstruct logfs_disk_inode *di;\n\tu64 ino = inode->i_ino;\n\n\tif (ino << sb->s_blocksize_bits > i_size_read(master_inode))\n\t\treturn -ENODATA;\n\tif (!logfs_exist_block(master_inode, ino))\n\t\treturn -ENODATA;\n\n\tpage = read_cache_page(master_inode->i_mapping, ino,\n\t\t\t(filler_t *)logfs_readpage, NULL);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tdi = kmap_atomic(page);\n\tlogfs_disk_to_inode(di, inode);\n\tkunmap_atomic(di);\n\tmove_page_to_inode(inode, page);\n\tpage_cache_release(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "move_inode_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1927-1949",
    "snippet": "static void move_inode_to_page(struct page *page, struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = li->li_block;\n\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_inode_to_page(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tBUG_ON(PagePrivate(page));\n\tblock->ops = &indirect_block_ops;\n\tblock->page = page;\n\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long) block);\n\t}\n\n\tblock->inode = NULL;\n\tli->li_block = NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct logfs_block_ops indirect_block_ops = {\n\t.write_block = indirect_write_block,\n\t.free_block = indirect_free_block,\n\t.write_alias = indirect_write_alias,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "(unsigned long) block"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PagePrivate(page)"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_blockmove",
          "args": [
            "\"move_inode_to_page(%llx, %llx, %x)\\n\"",
            "block->ino",
            "block->bix",
            "block->level"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstruct logfs_block_ops indirect_block_ops = {\n\t.write_block = indirect_write_block,\n\t.free_block = indirect_free_block,\n\t.write_alias = indirect_write_alias,\n};\n\nstatic void move_inode_to_page(struct page *page, struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = li->li_block;\n\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_inode_to_page(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tBUG_ON(PagePrivate(page));\n\tblock->ops = &indirect_block_ops;\n\tblock->page = page;\n\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long) block);\n\t}\n\n\tblock->inode = NULL;\n\tli->li_block = NULL;\n}"
  },
  {
    "function_name": "move_page_to_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1904-1925",
    "snippet": "static void move_page_to_inode(struct inode *inode, struct page *page)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = logfs_block(page);\n\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_page_to_inode(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tBUG_ON(li->li_block);\n\tblock->ops = &inode_block_ops;\n\tblock->inode = inode;\n\tli->li_block = block;\n\n\tblock->page = NULL;\n\tif (PagePrivate(page)) {\n\t\tClearPagePrivate(page);\n\t\tpage_cache_release(page);\n\t\tset_page_private(page, 0);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "li->li_block"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_blockmove",
          "args": [
            "\"move_page_to_inode(%llx, %llx, %x)\\n\"",
            "block->ino",
            "block->bix",
            "block->level"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "page"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};\n\nstatic void move_page_to_inode(struct inode *inode, struct page *page)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block = logfs_block(page);\n\n\tif (!block)\n\t\treturn;\n\n\tlog_blockmove(\"move_page_to_inode(%llx, %llx, %x)\\n\",\n\t\t\tblock->ino, block->bix, block->level);\n\tBUG_ON(li->li_block);\n\tblock->ops = &inode_block_ops;\n\tblock->inode = inode;\n\tli->li_block = block;\n\n\tblock->page = NULL;\n\tif (PagePrivate(page)) {\n\t\tClearPagePrivate(page);\n\t\tpage_cache_release(page);\n\t\tset_page_private(page, 0);\n\t}\n}"
  },
  {
    "function_name": "logfs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1868-1902",
    "snippet": "int logfs_truncate(struct inode *inode, u64 target)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu64 size = i_size_read(inode);\n\tint err = 0;\n\n\tsize = ALIGN(size, TRUNCATE_STEP);\n\twhile (size > target) {\n\t\tif (size > TRUNCATE_STEP)\n\t\t\tsize -= TRUNCATE_STEP;\n\t\telse\n\t\t\tsize = 0;\n\t\tif (size < target)\n\t\t\tsize = target;\n\n\t\tlogfs_get_wblocks(sb, NULL, 1);\n\t\terr = __logfs_truncate(inode, size);\n\t\tif (!err)\n\t\t\terr = __logfs_write_inode(inode, NULL, 0);\n\t\tlogfs_put_wblocks(sb, NULL, 1);\n\t}\n\n\tif (!err) {\n\t\terr = inode_newsize_ok(inode, target);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttruncate_setsize(inode, target);\n\t}\n\n out:\n\t/* I don't trust error recovery yet. */\n\tWARN_ON(err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [
      "#define TRUNCATE_STEP\t(8 * 1024 * 1024)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "err"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "target"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "target"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "99-124",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_put_wblocks",
          "args": [
            "sb",
            "NULL",
            "1"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "262-272",
          "snippet": "void logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_write_inode",
          "args": [
            "inode",
            "NULL",
            "0"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2132-2141",
          "snippet": "int __logfs_write_inode(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = do_write_inode(inode);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint __logfs_write_inode(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = do_write_inode(inode);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_truncate",
          "args": [
            "inode",
            "size"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1847-1859",
          "snippet": "static int __logfs_truncate(struct inode *inode, u64 size)\n{\n\tint ret;\n\n\tif (size >= logfs_factor(logfs_inode(inode)->li_height))\n\t\treturn 0;\n\n\tret = logfs_truncate_rec(inode, size);\n\tif (ret)\n\t\treturn ret;\n\n\treturn logfs_truncate_direct(inode, size);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_truncate(struct inode *inode, u64 size)\n{\n\tint ret;\n\n\tif (size >= logfs_factor(logfs_inode(inode)->li_height))\n\t\treturn 0;\n\n\tret = logfs_truncate_rec(inode, size);\n\tif (ret)\n\t\treturn ret;\n\n\treturn logfs_truncate_direct(inode, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_wblocks",
          "args": [
            "sb",
            "NULL",
            "1"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "247-260",
          "snippet": "void logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "TRUNCATE_STEP"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define TRUNCATE_STEP\t(8 * 1024 * 1024)\n\nint logfs_truncate(struct inode *inode, u64 target)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu64 size = i_size_read(inode);\n\tint err = 0;\n\n\tsize = ALIGN(size, TRUNCATE_STEP);\n\twhile (size > target) {\n\t\tif (size > TRUNCATE_STEP)\n\t\t\tsize -= TRUNCATE_STEP;\n\t\telse\n\t\t\tsize = 0;\n\t\tif (size < target)\n\t\t\tsize = target;\n\n\t\tlogfs_get_wblocks(sb, NULL, 1);\n\t\terr = __logfs_truncate(inode, size);\n\t\tif (!err)\n\t\t\terr = __logfs_write_inode(inode, NULL, 0);\n\t\tlogfs_put_wblocks(sb, NULL, 1);\n\t}\n\n\tif (!err) {\n\t\terr = inode_newsize_ok(inode, target);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttruncate_setsize(inode, target);\n\t}\n\n out:\n\t/* I don't trust error recovery yet. */\n\tWARN_ON(err);\n\treturn err;\n}"
  },
  {
    "function_name": "__logfs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1847-1859",
    "snippet": "static int __logfs_truncate(struct inode *inode, u64 size)\n{\n\tint ret;\n\n\tif (size >= logfs_factor(logfs_inode(inode)->li_height))\n\t\treturn 0;\n\n\tret = logfs_truncate_rec(inode, size);\n\tif (ret)\n\t\treturn ret;\n\n\treturn logfs_truncate_direct(inode, size);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_truncate_direct",
          "args": [
            "inode",
            "size"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_truncate_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1692-1726",
          "snippet": "static int logfs_truncate_direct(struct inode *inode, u64 size)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc;\n\tstruct page *page;\n\tint e;\n\tint err;\n\n\talloc_inode_block(inode);\n\n\tfor (e = I0_BLOCKS - 1; e >= 0; e--) {\n\t\tif (size > (e+1) * LOGFS_BLOCKSIZE)\n\t\t\tbreak;\n\n\t\twc.ofs = li->li_data[e];\n\t\tif (!wc.ofs)\n\t\t\tcontinue;\n\n\t\tpage = logfs_get_write_page(inode, e, 0);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\terr = logfs_segment_read(inode, page, wc.ofs, e, 0);\n\t\tif (err) {\n\t\t\tlogfs_put_write_page(page);\n\t\t\treturn err;\n\t\t}\n\t\terr = logfs_truncate_i0(inode, page, &wc, size);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tli->li_data[e] = wc.ofs;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_truncate_direct(struct inode *inode, u64 size)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc;\n\tstruct page *page;\n\tint e;\n\tint err;\n\n\talloc_inode_block(inode);\n\n\tfor (e = I0_BLOCKS - 1; e >= 0; e--) {\n\t\tif (size > (e+1) * LOGFS_BLOCKSIZE)\n\t\t\tbreak;\n\n\t\twc.ofs = li->li_data[e];\n\t\tif (!wc.ofs)\n\t\t\tcontinue;\n\n\t\tpage = logfs_get_write_page(inode, e, 0);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\terr = logfs_segment_read(inode, page, wc.ofs, e, 0);\n\t\tif (err) {\n\t\t\tlogfs_put_write_page(page);\n\t\t\treturn err;\n\t\t}\n\t\terr = logfs_truncate_i0(inode, page, &wc, size);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tli->li_data[e] = wc.ofs;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_truncate_rec",
          "args": [
            "inode",
            "size"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_truncate_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1819-1845",
          "snippet": "static int logfs_truncate_rec(struct inode *inode, u64 size)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[INDIRECT_INDEX],\n\t};\n\tstruct page *page;\n\tint err;\n\n\talloc_inode_block(inode);\n\n\tif (!wc.ofs)\n\t\treturn 0;\n\n\tpage = logfs_get_write_page(inode, 0, LEVEL(li->li_height));\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = __logfs_truncate_rec(inode, page, &wc, size);\n\tlogfs_put_write_page(page);\n\tif (err)\n\t\treturn err;\n\n\tif (li->li_data[INDIRECT_INDEX] != wc.ofs)\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_truncate_rec(struct inode *inode, u64 size)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[INDIRECT_INDEX],\n\t};\n\tstruct page *page;\n\tint err;\n\n\talloc_inode_block(inode);\n\n\tif (!wc.ofs)\n\t\treturn 0;\n\n\tpage = logfs_get_write_page(inode, 0, LEVEL(li->li_height));\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = __logfs_truncate_rec(inode, page, &wc, size);\n\tlogfs_put_write_page(page);\n\tif (err)\n\t\treturn err;\n\n\tif (li->li_data[INDIRECT_INDEX] != wc.ofs)\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_factor",
          "args": [
            "logfs_inode(inode)->li_height"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_factor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1748-1751",
          "snippet": "static inline u64 logfs_factor(u8 level)\n{\n\treturn __logfs_step[level] * LOGFS_BLOCKSIZE;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __logfs_step[] = {\n\t1,\n\tI1_BLOCKS,\n\tI2_BLOCKS,\n\tI3_BLOCKS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 __logfs_step[] = {\n\t1,\n\tI1_BLOCKS,\n\tI2_BLOCKS,\n\tI3_BLOCKS,\n};\n\nstatic inline u64 logfs_factor(u8 level)\n{\n\treturn __logfs_step[level] * LOGFS_BLOCKSIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_truncate(struct inode *inode, u64 size)\n{\n\tint ret;\n\n\tif (size >= logfs_factor(logfs_inode(inode)->li_height))\n\t\treturn 0;\n\n\tret = logfs_truncate_rec(inode, size);\n\tif (ret)\n\t\treturn ret;\n\n\treturn logfs_truncate_direct(inode, size);\n}"
  },
  {
    "function_name": "logfs_truncate_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1819-1845",
    "snippet": "static int logfs_truncate_rec(struct inode *inode, u64 size)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[INDIRECT_INDEX],\n\t};\n\tstruct page *page;\n\tint err;\n\n\talloc_inode_block(inode);\n\n\tif (!wc.ofs)\n\t\treturn 0;\n\n\tpage = logfs_get_write_page(inode, 0, LEVEL(li->li_height));\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = __logfs_truncate_rec(inode, page, &wc, size);\n\tlogfs_put_write_page(page);\n\tif (err)\n\t\treturn err;\n\n\tif (li->li_data[INDIRECT_INDEX] != wc.ofs)\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_truncate_rec",
          "args": [
            "inode",
            "page",
            "&wc",
            "size"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_truncate_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1765-1817",
          "snippet": "static int __logfs_truncate_rec(struct inode *inode, struct page *ipage,\n\t\tstruct write_control *this_wc, u64 size)\n{\n\tint truncate_happened = 0;\n\tint e, err = 0;\n\tu64 bix, child_bix, next_bix;\n\tlevel_t level;\n\tstruct page *page;\n\tstruct write_control child_wc = { /* FIXME: flags */ };\n\n\tlogfs_unpack_raw_index(ipage->index, &bix, &level);\n\terr = logfs_segment_read(inode, ipage, this_wc->ofs, bix, level);\n\tif (err)\n\t\treturn err;\n\n\tfor (e = LOGFS_BLOCK_FACTOR - 1; e >= 0; e--) {\n\t\tchild_bix = bix + e * logfs_step(SUBLEVEL(level));\n\t\tnext_bix = child_bix + logfs_step(SUBLEVEL(level));\n\t\tif (size > next_bix * LOGFS_BLOCKSIZE)\n\t\t\tbreak;\n\n\t\tchild_wc.ofs = pure_ofs(block_get_pointer(ipage, e));\n\t\tif (!child_wc.ofs)\n\t\t\tcontinue;\n\n\t\tpage = logfs_get_write_page(inode, child_bix, SUBLEVEL(level));\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tif ((__force u8)level > 1)\n\t\t\terr = __logfs_truncate_rec(inode, page, &child_wc, size);\n\t\telse\n\t\t\terr = logfs_truncate_i0(inode, page, &child_wc, size);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttruncate_happened = 1;\n\t\talloc_indirect_block(inode, ipage, 0);\n\t\tblock_set_pointer(ipage, e, child_wc.ofs);\n\t}\n\n\tif (!truncate_happened) {\n\t\tprintk(\"ineffectual truncate (%lx, %lx, %llx)\\n\", inode->i_ino, ipage->index, size);\n\t\treturn 0;\n\t}\n\n\tthis_wc->flags = WF_DELETE;\n\tif (logfs_block(ipage)->partial)\n\t\tthis_wc->flags |= WF_WRITE;\n\n\treturn logfs_write_i0(inode, ipage, this_wc);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_truncate_rec(struct inode *inode, struct page *ipage,\n\t\tstruct write_control *this_wc, u64 size)\n{\n\tint truncate_happened = 0;\n\tint e, err = 0;\n\tu64 bix, child_bix, next_bix;\n\tlevel_t level;\n\tstruct page *page;\n\tstruct write_control child_wc = { /* FIXME: flags */ };\n\n\tlogfs_unpack_raw_index(ipage->index, &bix, &level);\n\terr = logfs_segment_read(inode, ipage, this_wc->ofs, bix, level);\n\tif (err)\n\t\treturn err;\n\n\tfor (e = LOGFS_BLOCK_FACTOR - 1; e >= 0; e--) {\n\t\tchild_bix = bix + e * logfs_step(SUBLEVEL(level));\n\t\tnext_bix = child_bix + logfs_step(SUBLEVEL(level));\n\t\tif (size > next_bix * LOGFS_BLOCKSIZE)\n\t\t\tbreak;\n\n\t\tchild_wc.ofs = pure_ofs(block_get_pointer(ipage, e));\n\t\tif (!child_wc.ofs)\n\t\t\tcontinue;\n\n\t\tpage = logfs_get_write_page(inode, child_bix, SUBLEVEL(level));\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tif ((__force u8)level > 1)\n\t\t\terr = __logfs_truncate_rec(inode, page, &child_wc, size);\n\t\telse\n\t\t\terr = logfs_truncate_i0(inode, page, &child_wc, size);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttruncate_happened = 1;\n\t\talloc_indirect_block(inode, ipage, 0);\n\t\tblock_set_pointer(ipage, e, child_wc.ofs);\n\t}\n\n\tif (!truncate_happened) {\n\t\tprintk(\"ineffectual truncate (%lx, %lx, %llx)\\n\", inode->i_ino, ipage->index, size);\n\t\treturn 0;\n\t}\n\n\tthis_wc->flags = WF_DELETE;\n\tif (logfs_block(ipage)->partial)\n\t\tthis_wc->flags |= WF_WRITE;\n\n\treturn logfs_write_i0(inode, ipage, this_wc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "inode",
            "0",
            "LEVEL(li->li_height)"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "li->li_height"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_inode_block",
          "args": [
            "inode"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "601-613",
          "snippet": "static void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};\n\nstatic void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_truncate_rec(struct inode *inode, u64 size)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[INDIRECT_INDEX],\n\t};\n\tstruct page *page;\n\tint err;\n\n\talloc_inode_block(inode);\n\n\tif (!wc.ofs)\n\t\treturn 0;\n\n\tpage = logfs_get_write_page(inode, 0, LEVEL(li->li_height));\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = __logfs_truncate_rec(inode, page, &wc, size);\n\tlogfs_put_write_page(page);\n\tif (err)\n\t\treturn err;\n\n\tif (li->li_data[INDIRECT_INDEX] != wc.ofs)\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\treturn 0;\n}"
  },
  {
    "function_name": "__logfs_truncate_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1765-1817",
    "snippet": "static int __logfs_truncate_rec(struct inode *inode, struct page *ipage,\n\t\tstruct write_control *this_wc, u64 size)\n{\n\tint truncate_happened = 0;\n\tint e, err = 0;\n\tu64 bix, child_bix, next_bix;\n\tlevel_t level;\n\tstruct page *page;\n\tstruct write_control child_wc = { /* FIXME: flags */ };\n\n\tlogfs_unpack_raw_index(ipage->index, &bix, &level);\n\terr = logfs_segment_read(inode, ipage, this_wc->ofs, bix, level);\n\tif (err)\n\t\treturn err;\n\n\tfor (e = LOGFS_BLOCK_FACTOR - 1; e >= 0; e--) {\n\t\tchild_bix = bix + e * logfs_step(SUBLEVEL(level));\n\t\tnext_bix = child_bix + logfs_step(SUBLEVEL(level));\n\t\tif (size > next_bix * LOGFS_BLOCKSIZE)\n\t\t\tbreak;\n\n\t\tchild_wc.ofs = pure_ofs(block_get_pointer(ipage, e));\n\t\tif (!child_wc.ofs)\n\t\t\tcontinue;\n\n\t\tpage = logfs_get_write_page(inode, child_bix, SUBLEVEL(level));\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tif ((__force u8)level > 1)\n\t\t\terr = __logfs_truncate_rec(inode, page, &child_wc, size);\n\t\telse\n\t\t\terr = logfs_truncate_i0(inode, page, &child_wc, size);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttruncate_happened = 1;\n\t\talloc_indirect_block(inode, ipage, 0);\n\t\tblock_set_pointer(ipage, e, child_wc.ofs);\n\t}\n\n\tif (!truncate_happened) {\n\t\tprintk(\"ineffectual truncate (%lx, %lx, %llx)\\n\", inode->i_ino, ipage->index, size);\n\t\treturn 0;\n\t}\n\n\tthis_wc->flags = WF_DELETE;\n\tif (logfs_block(ipage)->partial)\n\t\tthis_wc->flags |= WF_WRITE;\n\n\treturn logfs_write_i0(inode, ipage, this_wc);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_write_i0",
          "args": [
            "inode",
            "ipage",
            "this_wc"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_i0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1340-1374",
          "snippet": "static int logfs_write_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint full, err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tif (wc->ofs == 0)\n\t\tif (logfs_reserve_blocks(inode, 1))\n\t\t\treturn -ENOSPC;\n\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\tif (wc->flags & WF_WRITE)\n\t\terr = logfs_segment_write(inode, page, shadow);\n\tif (wc->flags & WF_DELETE)\n\t\tlogfs_segment_delete(inode, shadow);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tset_iused(inode, shadow);\n\tfull = 1;\n\tif (level != 0) {\n\t\talloc_indirect_block(inode, page, 0);\n\t\tfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\n\t}\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\tif (wc->ofs && full)\n\t\twc->ofs |= LOGFS_FULLY_POPULATED;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint full, err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tif (wc->ofs == 0)\n\t\tif (logfs_reserve_blocks(inode, 1))\n\t\t\treturn -ENOSPC;\n\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\tif (wc->flags & WF_WRITE)\n\t\terr = logfs_segment_write(inode, page, shadow);\n\tif (wc->flags & WF_DELETE)\n\t\tlogfs_segment_delete(inode, shadow);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tset_iused(inode, shadow);\n\tfull = 1;\n\tif (level != 0) {\n\t\talloc_indirect_block(inode, page, 0);\n\t\tfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\n\t}\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\tif (wc->ofs && full)\n\t\twc->ofs |= LOGFS_FULLY_POPULATED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "ipage"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ineffectual truncate (%lx, %lx, %llx)\\n\"",
            "inode->i_ino",
            "ipage->index",
            "size"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_set_pointer",
          "args": [
            "ipage",
            "e",
            "child_wc.ofs"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "block_set_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "681-697",
          "snippet": "static void block_set_pointer(struct page *page, int index, u64 ptr)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\t__be64 *array;\n\tu64 oldptr;\n\n\tBUG_ON(!block);\n\tarray = kmap_atomic(page);\n\toldptr = be64_to_cpu(array[index]);\n\tarray[index] = cpu_to_be64(ptr);\n\tkunmap_atomic(array);\n\tSetPageUptodate(page);\n\n\tblock->full += !!(ptr & LOGFS_FULLY_POPULATED)\n\t\t- !!(oldptr & LOGFS_FULLY_POPULATED);\n\tblock->partial += !!ptr - !!oldptr;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void block_set_pointer(struct page *page, int index, u64 ptr)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\t__be64 *array;\n\tu64 oldptr;\n\n\tBUG_ON(!block);\n\tarray = kmap_atomic(page);\n\toldptr = be64_to_cpu(array[index]);\n\tarray[index] = cpu_to_be64(ptr);\n\tkunmap_atomic(array);\n\tSetPageUptodate(page);\n\n\tblock->full += !!(ptr & LOGFS_FULLY_POPULATED)\n\t\t- !!(oldptr & LOGFS_FULLY_POPULATED);\n\tblock->partial += !!ptr - !!oldptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_indirect_block",
          "args": [
            "inode",
            "ipage",
            "0"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_indirect_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "664-679",
          "snippet": "static void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_truncate_i0",
          "args": [
            "inode",
            "page",
            "&child_wc",
            "size"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_truncate_i0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1667-1690",
          "snippet": "static int logfs_truncate_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc, u64 size)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tBUG_ON(level != 0);\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\n\terr = truncate_data_block(inode, page, wc->ofs, shadow, size);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tlogfs_segment_delete(inode, shadow);\n\tset_iused(inode, shadow);\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_truncate_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc, u64 size)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tBUG_ON(level != 0);\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\n\terr = truncate_data_block(inode, page, wc->ofs, shadow, size);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tlogfs_segment_delete(inode, shadow);\n\tset_iused(inode, shadow);\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_truncate_rec",
          "args": [
            "inode",
            "page",
            "&child_wc",
            "size"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_truncate_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1765-1817",
          "snippet": "static int __logfs_truncate_rec(struct inode *inode, struct page *ipage,\n\t\tstruct write_control *this_wc, u64 size)\n{\n\tint truncate_happened = 0;\n\tint e, err = 0;\n\tu64 bix, child_bix, next_bix;\n\tlevel_t level;\n\tstruct page *page;\n\tstruct write_control child_wc = { /* FIXME: flags */ };\n\n\tlogfs_unpack_raw_index(ipage->index, &bix, &level);\n\terr = logfs_segment_read(inode, ipage, this_wc->ofs, bix, level);\n\tif (err)\n\t\treturn err;\n\n\tfor (e = LOGFS_BLOCK_FACTOR - 1; e >= 0; e--) {\n\t\tchild_bix = bix + e * logfs_step(SUBLEVEL(level));\n\t\tnext_bix = child_bix + logfs_step(SUBLEVEL(level));\n\t\tif (size > next_bix * LOGFS_BLOCKSIZE)\n\t\t\tbreak;\n\n\t\tchild_wc.ofs = pure_ofs(block_get_pointer(ipage, e));\n\t\tif (!child_wc.ofs)\n\t\t\tcontinue;\n\n\t\tpage = logfs_get_write_page(inode, child_bix, SUBLEVEL(level));\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tif ((__force u8)level > 1)\n\t\t\terr = __logfs_truncate_rec(inode, page, &child_wc, size);\n\t\telse\n\t\t\terr = logfs_truncate_i0(inode, page, &child_wc, size);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttruncate_happened = 1;\n\t\talloc_indirect_block(inode, ipage, 0);\n\t\tblock_set_pointer(ipage, e, child_wc.ofs);\n\t}\n\n\tif (!truncate_happened) {\n\t\tprintk(\"ineffectual truncate (%lx, %lx, %llx)\\n\", inode->i_ino, ipage->index, size);\n\t\treturn 0;\n\t}\n\n\tthis_wc->flags = WF_DELETE;\n\tif (logfs_block(ipage)->partial)\n\t\tthis_wc->flags |= WF_WRITE;\n\n\treturn logfs_write_i0(inode, ipage, this_wc);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "inode",
            "child_bix",
            "SUBLEVEL(level)"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pure_ofs",
          "args": [
            "block_get_pointer(ipage, e)"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_get_pointer",
          "args": [
            "ipage",
            "e"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "block_get_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "699-708",
          "snippet": "static u64 block_get_pointer(struct page *page, int index)\n{\n\t__be64 *block;\n\tu64 ptr;\n\n\tblock = kmap_atomic(page);\n\tptr = be64_to_cpu(block[index]);\n\tkunmap_atomic(block);\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 block_get_pointer(struct page *page, int index)\n{\n\t__be64 *block;\n\tu64 ptr;\n\n\tblock = kmap_atomic(page);\n\tptr = be64_to_cpu(block[index]);\n\tkunmap_atomic(block);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_step",
          "args": [
            "SUBLEVEL(level)"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1743-1746",
          "snippet": "static inline u64 logfs_step(level_t level)\n{\n\treturn __logfs_step[(__force u8)level];\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __logfs_step[] = {\n\t1,\n\tI1_BLOCKS,\n\tI2_BLOCKS,\n\tI3_BLOCKS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 __logfs_step[] = {\n\t1,\n\tI1_BLOCKS,\n\tI2_BLOCKS,\n\tI3_BLOCKS,\n};\n\nstatic inline u64 logfs_step(level_t level)\n{\n\treturn __logfs_step[(__force u8)level];\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_segment_read",
          "args": [
            "inode",
            "ipage",
            "this_wc->ofs",
            "bix",
            "level"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "656-677",
          "snippet": "int logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_unpack_raw_index",
          "args": [
            "ipage->index",
            "&bix",
            "&level"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_unpack_raw_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1758-1763",
          "snippet": "static void logfs_unpack_raw_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tlogfs_unpack_index(index, bix, level);\n\tif (*bix <= logfs_start_index(SUBLEVEL(*level)))\n\t\t*bix = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_unpack_raw_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tlogfs_unpack_index(index, bix, level);\n\tif (*bix <= logfs_start_index(SUBLEVEL(*level)))\n\t\t*bix = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_truncate_rec(struct inode *inode, struct page *ipage,\n\t\tstruct write_control *this_wc, u64 size)\n{\n\tint truncate_happened = 0;\n\tint e, err = 0;\n\tu64 bix, child_bix, next_bix;\n\tlevel_t level;\n\tstruct page *page;\n\tstruct write_control child_wc = { /* FIXME: flags */ };\n\n\tlogfs_unpack_raw_index(ipage->index, &bix, &level);\n\terr = logfs_segment_read(inode, ipage, this_wc->ofs, bix, level);\n\tif (err)\n\t\treturn err;\n\n\tfor (e = LOGFS_BLOCK_FACTOR - 1; e >= 0; e--) {\n\t\tchild_bix = bix + e * logfs_step(SUBLEVEL(level));\n\t\tnext_bix = child_bix + logfs_step(SUBLEVEL(level));\n\t\tif (size > next_bix * LOGFS_BLOCKSIZE)\n\t\t\tbreak;\n\n\t\tchild_wc.ofs = pure_ofs(block_get_pointer(ipage, e));\n\t\tif (!child_wc.ofs)\n\t\t\tcontinue;\n\n\t\tpage = logfs_get_write_page(inode, child_bix, SUBLEVEL(level));\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tif ((__force u8)level > 1)\n\t\t\terr = __logfs_truncate_rec(inode, page, &child_wc, size);\n\t\telse\n\t\t\terr = logfs_truncate_i0(inode, page, &child_wc, size);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttruncate_happened = 1;\n\t\talloc_indirect_block(inode, ipage, 0);\n\t\tblock_set_pointer(ipage, e, child_wc.ofs);\n\t}\n\n\tif (!truncate_happened) {\n\t\tprintk(\"ineffectual truncate (%lx, %lx, %llx)\\n\", inode->i_ino, ipage->index, size);\n\t\treturn 0;\n\t}\n\n\tthis_wc->flags = WF_DELETE;\n\tif (logfs_block(ipage)->partial)\n\t\tthis_wc->flags |= WF_WRITE;\n\n\treturn logfs_write_i0(inode, ipage, this_wc);\n}"
  },
  {
    "function_name": "logfs_unpack_raw_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1758-1763",
    "snippet": "static void logfs_unpack_raw_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tlogfs_unpack_index(index, bix, level);\n\tif (*bix <= logfs_start_index(SUBLEVEL(*level)))\n\t\t*bix = 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_start_index",
          "args": [
            "SUBLEVEL(*level)"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_start_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1753-1756",
          "snippet": "static inline u64 logfs_start_index(level_t level)\n{\n\treturn __logfs_start_index[(__force u8)level];\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __logfs_start_index[] = {\n\tI0_BLOCKS,\n\tI1_BLOCKS,\n\tI2_BLOCKS,\n\tI3_BLOCKS\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 __logfs_start_index[] = {\n\tI0_BLOCKS,\n\tI1_BLOCKS,\n\tI2_BLOCKS,\n\tI3_BLOCKS\n};\n\nstatic inline u64 logfs_start_index(level_t level)\n{\n\treturn __logfs_start_index[(__force u8)level];\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "*level"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_unpack_index",
          "args": [
            "index",
            "bix",
            "level"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_unpack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "81-96",
          "snippet": "void logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\nvoid logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_unpack_raw_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tlogfs_unpack_index(index, bix, level);\n\tif (*bix <= logfs_start_index(SUBLEVEL(*level)))\n\t\t*bix = 0;\n}"
  },
  {
    "function_name": "logfs_start_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1753-1756",
    "snippet": "static inline u64 logfs_start_index(level_t level)\n{\n\treturn __logfs_start_index[(__force u8)level];\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __logfs_start_index[] = {\n\tI0_BLOCKS,\n\tI1_BLOCKS,\n\tI2_BLOCKS,\n\tI3_BLOCKS\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 __logfs_start_index[] = {\n\tI0_BLOCKS,\n\tI1_BLOCKS,\n\tI2_BLOCKS,\n\tI3_BLOCKS\n};\n\nstatic inline u64 logfs_start_index(level_t level)\n{\n\treturn __logfs_start_index[(__force u8)level];\n}"
  },
  {
    "function_name": "logfs_factor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1748-1751",
    "snippet": "static inline u64 logfs_factor(u8 level)\n{\n\treturn __logfs_step[level] * LOGFS_BLOCKSIZE;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __logfs_step[] = {\n\t1,\n\tI1_BLOCKS,\n\tI2_BLOCKS,\n\tI3_BLOCKS,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 __logfs_step[] = {\n\t1,\n\tI1_BLOCKS,\n\tI2_BLOCKS,\n\tI3_BLOCKS,\n};\n\nstatic inline u64 logfs_factor(u8 level)\n{\n\treturn __logfs_step[level] * LOGFS_BLOCKSIZE;\n}"
  },
  {
    "function_name": "logfs_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1743-1746",
    "snippet": "static inline u64 logfs_step(level_t level)\n{\n\treturn __logfs_step[(__force u8)level];\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 __logfs_step[] = {\n\t1,\n\tI1_BLOCKS,\n\tI2_BLOCKS,\n\tI3_BLOCKS,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 __logfs_step[] = {\n\t1,\n\tI1_BLOCKS,\n\tI2_BLOCKS,\n\tI3_BLOCKS,\n};\n\nstatic inline u64 logfs_step(level_t level)\n{\n\treturn __logfs_step[(__force u8)level];\n}"
  },
  {
    "function_name": "logfs_truncate_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1692-1726",
    "snippet": "static int logfs_truncate_direct(struct inode *inode, u64 size)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc;\n\tstruct page *page;\n\tint e;\n\tint err;\n\n\talloc_inode_block(inode);\n\n\tfor (e = I0_BLOCKS - 1; e >= 0; e--) {\n\t\tif (size > (e+1) * LOGFS_BLOCKSIZE)\n\t\t\tbreak;\n\n\t\twc.ofs = li->li_data[e];\n\t\tif (!wc.ofs)\n\t\t\tcontinue;\n\n\t\tpage = logfs_get_write_page(inode, e, 0);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\terr = logfs_segment_read(inode, page, wc.ofs, e, 0);\n\t\tif (err) {\n\t\t\tlogfs_put_write_page(page);\n\t\t\treturn err;\n\t\t}\n\t\terr = logfs_truncate_i0(inode, page, &wc, size);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tli->li_data[e] = wc.ofs;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_truncate_i0",
          "args": [
            "inode",
            "page",
            "&wc",
            "size"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_truncate_i0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1667-1690",
          "snippet": "static int logfs_truncate_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc, u64 size)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tBUG_ON(level != 0);\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\n\terr = truncate_data_block(inode, page, wc->ofs, shadow, size);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tlogfs_segment_delete(inode, shadow);\n\tset_iused(inode, shadow);\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_truncate_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc, u64 size)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tBUG_ON(level != 0);\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\n\terr = truncate_data_block(inode, page, wc->ofs, shadow, size);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tlogfs_segment_delete(inode, shadow);\n\tset_iused(inode, shadow);\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_segment_read",
          "args": [
            "inode",
            "page",
            "wc.ofs",
            "e",
            "0"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "656-677",
          "snippet": "int logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "inode",
            "e",
            "0"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_inode_block",
          "args": [
            "inode"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "601-613",
          "snippet": "static void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};\n\nstatic void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_truncate_direct(struct inode *inode, u64 size)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc;\n\tstruct page *page;\n\tint e;\n\tint err;\n\n\talloc_inode_block(inode);\n\n\tfor (e = I0_BLOCKS - 1; e >= 0; e--) {\n\t\tif (size > (e+1) * LOGFS_BLOCKSIZE)\n\t\t\tbreak;\n\n\t\twc.ofs = li->li_data[e];\n\t\tif (!wc.ofs)\n\t\t\tcontinue;\n\n\t\tpage = logfs_get_write_page(inode, e, 0);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\terr = logfs_segment_read(inode, page, wc.ofs, e, 0);\n\t\tif (err) {\n\t\t\tlogfs_put_write_page(page);\n\t\t\treturn err;\n\t\t}\n\t\terr = logfs_truncate_i0(inode, page, &wc, size);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tli->li_data[e] = wc.ofs;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_truncate_i0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1667-1690",
    "snippet": "static int logfs_truncate_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc, u64 size)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tBUG_ON(level != 0);\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\n\terr = truncate_data_block(inode, page, wc->ofs, shadow, size);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tlogfs_segment_delete(inode, shadow);\n\tset_iused(inode, shadow);\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill_shadow_tree",
          "args": [
            "inode",
            "page",
            "shadow"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "fill_shadow_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1274-1301",
          "snippet": "static void fill_shadow_tree(struct inode *inode, struct page *page,\n\t\tstruct logfs_shadow *shadow)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_block *block = logfs_block(page);\n\tstruct shadow_tree *tree = &super->s_shadow_tree;\n\n\tif (PagePrivate(page)) {\n\t\tif (block->alias_map)\n\t\t\tsuper->s_no_object_aliases -= bitmap_weight(\n\t\t\t\t\tblock->alias_map, LOGFS_BLOCK_FACTOR);\n\t\tlogfs_handle_transaction(inode, block->ta);\n\t\tblock->ops->free_block(inode->i_sb, block);\n\t}\n\tif (shadow) {\n\t\tif (shadow->old_ofs)\n\t\t\tbtree_insert64(&tree->old, shadow->old_ofs, shadow,\n\t\t\t\t\tGFP_NOFS);\n\t\telse\n\t\t\tbtree_insert64(&tree->new, shadow->new_ofs, shadow,\n\t\t\t\t\tGFP_NOFS);\n\n\t\tsuper->s_dirty_used_bytes += shadow->new_len;\n\t\tsuper->s_dirty_free_bytes += shadow->old_len;\n\t\tmark_segment(tree, shadow->old_ofs >> super->s_segshift);\n\t\tmark_segment(tree, shadow->new_ofs >> super->s_segshift);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void fill_shadow_tree(struct inode *inode, struct page *page,\n\t\tstruct logfs_shadow *shadow)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_block *block = logfs_block(page);\n\tstruct shadow_tree *tree = &super->s_shadow_tree;\n\n\tif (PagePrivate(page)) {\n\t\tif (block->alias_map)\n\t\t\tsuper->s_no_object_aliases -= bitmap_weight(\n\t\t\t\t\tblock->alias_map, LOGFS_BLOCK_FACTOR);\n\t\tlogfs_handle_transaction(inode, block->ta);\n\t\tblock->ops->free_block(inode->i_sb, block);\n\t}\n\tif (shadow) {\n\t\tif (shadow->old_ofs)\n\t\t\tbtree_insert64(&tree->old, shadow->old_ofs, shadow,\n\t\t\t\t\tGFP_NOFS);\n\t\telse\n\t\t\tbtree_insert64(&tree->new, shadow->new_ofs, shadow,\n\t\t\t\t\tGFP_NOFS);\n\n\t\tsuper->s_dirty_used_bytes += shadow->new_len;\n\t\tsuper->s_dirty_free_bytes += shadow->old_len;\n\t\tmark_segment(tree, shadow->old_ofs >> super->s_segshift);\n\t\tmark_segment(tree, shadow->new_ofs >> super->s_segshift);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_iused",
          "args": [
            "inode",
            "shadow"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "set_iused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1326-1338",
          "snippet": "static void set_iused(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (shadow->new_len == shadow->old_len)\n\t\treturn;\n\n\talloc_inode_block(inode);\n\tli->li_used_bytes += shadow->new_len - shadow->old_len;\n\t__logfs_set_blocks(inode);\n\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_USED_OFS);\n\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_SIZE_OFS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void set_iused(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (shadow->new_len == shadow->old_len)\n\t\treturn;\n\n\talloc_inode_block(inode);\n\tli->li_used_bytes += shadow->new_len - shadow->old_len;\n\t__logfs_set_blocks(inode);\n\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_USED_OFS);\n\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_SIZE_OFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_segment_delete",
          "args": [
            "inode",
            "shadow"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "679-709",
          "snippet": "int logfs_segment_delete(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_object_header h;\n\tu16 len;\n\tint err;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_DIRTY;\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tBUG_ON(shadow->old_ofs & LOGFS_FULLY_POPULATED);\n\tif (!shadow->old_ofs)\n\t\treturn 0;\n\n\tlog_segment(\"logfs_segment_delete(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\terr = read_obj_header(sb, shadow->old_ofs, &h);\n\tLOGFS_BUG_ON(err, sb);\n\tLOGFS_BUG_ON(be64_to_cpu(h.ino) != inode->i_ino, sb);\n\tLOGFS_BUG_ON(check_pos(sb, shadow->bix, be64_to_cpu(h.bix),\n\t\t\t\tshrink_level(shadow->gc_level)), sb);\n\n\tif (shadow->gc_level == 0)\n\t\tlen = be16_to_cpu(h.len);\n\telse\n\t\tlen = obj_len(sb, h.type);\n\tshadow->old_len = len + sizeof(h);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_delete(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_object_header h;\n\tu16 len;\n\tint err;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_DIRTY;\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tBUG_ON(shadow->old_ofs & LOGFS_FULLY_POPULATED);\n\tif (!shadow->old_ofs)\n\t\treturn 0;\n\n\tlog_segment(\"logfs_segment_delete(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\terr = read_obj_header(sb, shadow->old_ofs, &h);\n\tLOGFS_BUG_ON(err, sb);\n\tLOGFS_BUG_ON(be64_to_cpu(h.ino) != inode->i_ino, sb);\n\tLOGFS_BUG_ON(check_pos(sb, shadow->bix, be64_to_cpu(h.bix),\n\t\t\t\tshrink_level(shadow->gc_level)), sb);\n\n\tif (shadow->gc_level == 0)\n\t\tlen = be16_to_cpu(h.len);\n\telse\n\t\tlen = obj_len(sb, h.type);\n\tshadow->old_len = len + sizeof(h);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_shadow",
          "args": [
            "inode",
            "shadow"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "free_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1232-1237",
          "snippet": "static void free_shadow(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\n\tmempool_free(shadow, super->s_shadow_pool);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void free_shadow(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\n\tmempool_free(shadow, super->s_shadow_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_data_block",
          "args": [
            "inode",
            "page",
            "wc->ofs",
            "shadow",
            "size"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_data_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1644-1665",
          "snippet": "static int truncate_data_block(struct inode *inode, struct page *page,\n\t\tu64 ofs, struct logfs_shadow *shadow, u64 size)\n{\n\tloff_t pageofs = page->index << inode->i_sb->s_blocksize_bits;\n\tu64 bix;\n\tlevel_t level;\n\tint err;\n\n\t/* Does truncation happen within this page? */\n\tif (size <= pageofs || size - pageofs >= PAGE_SIZE)\n\t\treturn 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tBUG_ON(level != 0);\n\n\terr = logfs_segment_read(inode, page, ofs, bix, level);\n\tif (err)\n\t\treturn err;\n\n\tzero_user_segment(page, size - pageofs, PAGE_CACHE_SIZE);\n\treturn logfs_segment_write(inode, page, shadow);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int truncate_data_block(struct inode *inode, struct page *page,\n\t\tu64 ofs, struct logfs_shadow *shadow, u64 size)\n{\n\tloff_t pageofs = page->index << inode->i_sb->s_blocksize_bits;\n\tu64 bix;\n\tlevel_t level;\n\tint err;\n\n\t/* Does truncation happen within this page? */\n\tif (size <= pageofs || size - pageofs >= PAGE_SIZE)\n\t\treturn 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tBUG_ON(level != 0);\n\n\terr = logfs_segment_read(inode, page, ofs, bix, level);\n\tif (err)\n\t\treturn err;\n\n\tzero_user_segment(page, size - pageofs, PAGE_CACHE_SIZE);\n\treturn logfs_segment_write(inode, page, shadow);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_shadow",
          "args": [
            "inode",
            "bix",
            "level",
            "wc->ofs"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1217-1230",
          "snippet": "static struct logfs_shadow *alloc_shadow(struct inode *inode, u64 bix,\n\t\tlevel_t level, u64 old_ofs)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_shadow *shadow;\n\n\tshadow = mempool_alloc(super->s_shadow_pool, GFP_NOFS);\n\tmemset(shadow, 0, sizeof(*shadow));\n\tshadow->ino = inode->i_ino;\n\tshadow->bix = bix;\n\tshadow->gc_level = expand_level(inode->i_ino, level);\n\tshadow->old_ofs = old_ofs & ~LOGFS_FULLY_POPULATED;\n\treturn shadow;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_shadow *alloc_shadow(struct inode *inode, u64 bix,\n\t\tlevel_t level, u64 old_ofs)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_shadow *shadow;\n\n\tshadow = mempool_alloc(super->s_shadow_pool, GFP_NOFS);\n\tmemset(shadow, 0, sizeof(*shadow));\n\tshadow->ino = inode->i_ino;\n\tshadow->bix = bix;\n\tshadow->gc_level = expand_level(inode->i_ino, level);\n\tshadow->old_ofs = old_ofs & ~LOGFS_FULLY_POPULATED;\n\treturn shadow;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level != 0"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_unpack_index",
          "args": [
            "page->index",
            "&bix",
            "&level"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_unpack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "81-96",
          "snippet": "void logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\nvoid logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_truncate_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc, u64 size)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tBUG_ON(level != 0);\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\n\terr = truncate_data_block(inode, page, wc->ofs, shadow, size);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tlogfs_segment_delete(inode, shadow);\n\tset_iused(inode, shadow);\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\treturn 0;\n}"
  },
  {
    "function_name": "truncate_data_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1644-1665",
    "snippet": "static int truncate_data_block(struct inode *inode, struct page *page,\n\t\tu64 ofs, struct logfs_shadow *shadow, u64 size)\n{\n\tloff_t pageofs = page->index << inode->i_sb->s_blocksize_bits;\n\tu64 bix;\n\tlevel_t level;\n\tint err;\n\n\t/* Does truncation happen within this page? */\n\tif (size <= pageofs || size - pageofs >= PAGE_SIZE)\n\t\treturn 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tBUG_ON(level != 0);\n\n\terr = logfs_segment_read(inode, page, ofs, bix, level);\n\tif (err)\n\t\treturn err;\n\n\tzero_user_segment(page, size - pageofs, PAGE_CACHE_SIZE);\n\treturn logfs_segment_write(inode, page, shadow);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_segment_write",
          "args": [
            "inode",
            "page",
            "shadow"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "363-398",
          "snippet": "int logfs_segment_write(struct inode *inode, struct page *page,\n\t\tstruct logfs_shadow *shadow)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tint do_compress, type, len;\n\tint ret;\n\tvoid *buf;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_DIRTY;\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tdo_compress = logfs_inode(inode)->li_flags & LOGFS_IF_COMPRESSED;\n\tif (shadow->gc_level != 0) {\n\t\t/* temporarily disable compression for indirect blocks */\n\t\tdo_compress = 0;\n\t}\n\n\ttype = obj_type(inode, shrink_level(shadow->gc_level));\n\tlen = obj_len(sb, type);\n\tbuf = kmap(page);\n\tif (do_compress)\n\t\tret = logfs_segment_write_compress(inode, buf, shadow, type,\n\t\t\t\tlen);\n\telse\n\t\tret = __logfs_segment_write(inode, buf, shadow, type, len,\n\t\t\t\tCOMPR_NONE);\n\tkunmap(page);\n\n\tlog_segment(\"logfs_segment_write(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\t/* this BUG_ON did catch a locking bug.  useful */\n\tBUG_ON(!(shadow->new_ofs & (super->s_segsize - 1)));\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_write(struct inode *inode, struct page *page,\n\t\tstruct logfs_shadow *shadow)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tint do_compress, type, len;\n\tint ret;\n\tvoid *buf;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_DIRTY;\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tdo_compress = logfs_inode(inode)->li_flags & LOGFS_IF_COMPRESSED;\n\tif (shadow->gc_level != 0) {\n\t\t/* temporarily disable compression for indirect blocks */\n\t\tdo_compress = 0;\n\t}\n\n\ttype = obj_type(inode, shrink_level(shadow->gc_level));\n\tlen = obj_len(sb, type);\n\tbuf = kmap(page);\n\tif (do_compress)\n\t\tret = logfs_segment_write_compress(inode, buf, shadow, type,\n\t\t\t\tlen);\n\telse\n\t\tret = __logfs_segment_write(inode, buf, shadow, type, len,\n\t\t\t\tCOMPR_NONE);\n\tkunmap(page);\n\n\tlog_segment(\"logfs_segment_write(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\t/* this BUG_ON did catch a locking bug.  useful */\n\tBUG_ON(!(shadow->new_ofs & (super->s_segsize - 1)));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "size - pageofs",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_segment_read",
          "args": [
            "inode",
            "page",
            "ofs",
            "bix",
            "level"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "656-677",
          "snippet": "int logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level != 0"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_unpack_index",
          "args": [
            "page->index",
            "&bix",
            "&level"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_unpack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "81-96",
          "snippet": "void logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\nvoid logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int truncate_data_block(struct inode *inode, struct page *page,\n\t\tu64 ofs, struct logfs_shadow *shadow, u64 size)\n{\n\tloff_t pageofs = page->index << inode->i_sb->s_blocksize_bits;\n\tu64 bix;\n\tlevel_t level;\n\tint err;\n\n\t/* Does truncation happen within this page? */\n\tif (size <= pageofs || size - pageofs >= PAGE_SIZE)\n\t\treturn 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tBUG_ON(level != 0);\n\n\terr = logfs_segment_read(inode, page, ofs, bix, level);\n\tif (err)\n\t\treturn err;\n\n\tzero_user_segment(page, size - pageofs, PAGE_CACHE_SIZE);\n\treturn logfs_segment_write(inode, page, shadow);\n}"
  },
  {
    "function_name": "logfs_rewrite_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1611-1642",
    "snippet": "int logfs_rewrite_block(struct inode *inode, u64 bix, u64 ofs,\n\t\tgc_level_t gc_level, long flags)\n{\n\tlevel_t level = shrink_level(gc_level);\n\tstruct page *page;\n\tint err;\n\n\tpage = logfs_get_write_page(inode, bix, level);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = logfs_segment_read(inode, page, ofs, bix, level);\n\tif (!err) {\n\t\tif (level != 0)\n\t\t\talloc_indirect_block(inode, page, 0);\n\t\terr = logfs_write_buf(inode, page, flags);\n\t\tif (!err && shrink_level(gc_level) == 0) {\n\t\t\t/* Rewrite cannot mark the inode dirty but has to\n\t\t\t * write it immediately.\n\t\t\t * Q: Can't we just create an alias for the inode\n\t\t\t * instead?  And if not, why not?\n\t\t\t */\n\t\t\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\t\t\tlogfs_write_anchor(inode->i_sb);\n\t\t\telse {\n\t\t\t\terr = __logfs_write_inode(inode, page, flags);\n\t\t\t}\n\t\t}\n\t}\n\tlogfs_put_write_page(page);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_write_inode",
          "args": [
            "inode",
            "page",
            "flags"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2132-2141",
          "snippet": "int __logfs_write_inode(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = do_write_inode(inode);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint __logfs_write_inode(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = do_write_inode(inode);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_anchor",
          "args": [
            "inode->i_sb"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_anchor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "734-803",
          "snippet": "void logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_level",
          "args": [
            "gc_level"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "693-700",
          "snippet": "static inline level_t shrink_level(gc_level_t __level)\n{\n\tu8 level = (__force u8)__level;\n\n\tif (level >= LOGFS_MAX_LEVELS)\n\t\tlevel -= LOGFS_MAX_LEVELS;\n\treturn (__force level_t)level;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline level_t shrink_level(gc_level_t __level)\n{\n\tu8 level = (__force u8)__level;\n\n\tif (level >= LOGFS_MAX_LEVELS)\n\t\tlevel -= LOGFS_MAX_LEVELS;\n\treturn (__force level_t)level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_buf",
          "args": [
            "inode",
            "page",
            "flags"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1565-1574",
          "snippet": "int logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = __logfs_write_buf(inode, page, flags);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = __logfs_write_buf(inode, page, flags);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_indirect_block",
          "args": [
            "inode",
            "page",
            "0"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_indirect_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "664-679",
          "snippet": "static void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_segment_read",
          "args": [
            "inode",
            "page",
            "ofs",
            "bix",
            "level"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "656-677",
          "snippet": "int logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "inode",
            "bix",
            "level"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_rewrite_block(struct inode *inode, u64 bix, u64 ofs,\n\t\tgc_level_t gc_level, long flags)\n{\n\tlevel_t level = shrink_level(gc_level);\n\tstruct page *page;\n\tint err;\n\n\tpage = logfs_get_write_page(inode, bix, level);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = logfs_segment_read(inode, page, ofs, bix, level);\n\tif (!err) {\n\t\tif (level != 0)\n\t\t\talloc_indirect_block(inode, page, 0);\n\t\terr = logfs_write_buf(inode, page, flags);\n\t\tif (!err && shrink_level(gc_level) == 0) {\n\t\t\t/* Rewrite cannot mark the inode dirty but has to\n\t\t\t * write it immediately.\n\t\t\t * Q: Can't we just create an alias for the inode\n\t\t\t * instead?  And if not, why not?\n\t\t\t */\n\t\t\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\t\t\tlogfs_write_anchor(inode->i_sb);\n\t\t\telse {\n\t\t\t\terr = __logfs_write_inode(inode, page, flags);\n\t\t\t}\n\t\t}\n\t}\n\tlogfs_put_write_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "logfs_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1591-1609",
    "snippet": "int logfs_delete(struct inode *inode, pgoff_t index,\n\t\tstruct shadow_tree *shadow_tree)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page;\n\tint ret;\n\n\tpage = logfs_get_read_page(inode, index, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlogfs_get_wblocks(sb, page, 1);\n\tret = __logfs_delete(inode, page);\n\tlogfs_put_wblocks(sb, page, 1);\n\n\tlogfs_put_read_page(page);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_read_page",
          "args": [
            "page"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "281-285",
          "snippet": "static void logfs_put_read_page(struct page *page)\n{\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_read_page(struct page *page)\n{\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_put_wblocks",
          "args": [
            "sb",
            "page",
            "1"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "262-272",
          "snippet": "void logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_delete",
          "args": [
            "inode",
            "page"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1576-1589",
          "snippet": "static int __logfs_delete(struct inode *inode, struct page *page)\n{\n\tlong flags = WF_DELETE;\n\tint err;\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tif (page->index < I0_BLOCKS)\n\t\treturn logfs_write_direct(inode, page, flags);\n\terr = grow_inode(inode, page->index, 0);\n\tif (err)\n\t\treturn err;\n\treturn logfs_write_rec(inode, page, page->index, 0, flags);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_delete(struct inode *inode, struct page *page)\n{\n\tlong flags = WF_DELETE;\n\tint err;\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tif (page->index < I0_BLOCKS)\n\t\treturn logfs_write_direct(inode, page, flags);\n\terr = grow_inode(inode, page->index, 0);\n\tif (err)\n\t\treturn err;\n\treturn logfs_write_rec(inode, page, page->index, 0, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_wblocks",
          "args": [
            "sb",
            "page",
            "1"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "247-260",
          "snippet": "void logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_read_page",
          "args": [
            "inode",
            "index",
            "0"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "274-279",
          "snippet": "static struct page *logfs_get_read_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\treturn find_or_create_page(inode->i_mapping,\n\t\t\tlogfs_pack_index(bix, level), GFP_NOFS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_read_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\treturn find_or_create_page(inode->i_mapping,\n\t\t\tlogfs_pack_index(bix, level), GFP_NOFS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_delete(struct inode *inode, pgoff_t index,\n\t\tstruct shadow_tree *shadow_tree)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page;\n\tint ret;\n\n\tpage = logfs_get_read_page(inode, index, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlogfs_get_wblocks(sb, page, 1);\n\tret = __logfs_delete(inode, page);\n\tlogfs_put_wblocks(sb, page, 1);\n\n\tlogfs_put_read_page(page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__logfs_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1576-1589",
    "snippet": "static int __logfs_delete(struct inode *inode, struct page *page)\n{\n\tlong flags = WF_DELETE;\n\tint err;\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tif (page->index < I0_BLOCKS)\n\t\treturn logfs_write_direct(inode, page, flags);\n\terr = grow_inode(inode, page->index, 0);\n\tif (err)\n\t\treturn err;\n\treturn logfs_write_rec(inode, page, page->index, 0, flags);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_write_rec",
          "args": [
            "inode",
            "page",
            "page->index",
            "0",
            "flags"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1467-1493",
          "snippet": "static int logfs_write_rec(struct inode *inode, struct page *page,\n\t\tpgoff_t bix, level_t target_level, long flags)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[INDIRECT_INDEX],\n\t\t.flags = flags,\n\t};\n\tint ret;\n\n\talloc_inode_block(inode);\n\n\tif (li->li_height > (__force u8)target_level)\n\t\tret = __logfs_write_rec(inode, page, &wc, bix, target_level,\n\t\t\t\tLEVEL(li->li_height));\n\telse\n\t\tret = logfs_write_i0(inode, page, &wc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (li->li_data[INDIRECT_INDEX] != wc.ofs) {\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\t\tlogfs_set_alias(inode->i_sb, li->li_block,\n\t\t\t\tINDIRECT_INDEX + INODE_POINTER_OFS);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_rec(struct inode *inode, struct page *page,\n\t\tpgoff_t bix, level_t target_level, long flags)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[INDIRECT_INDEX],\n\t\t.flags = flags,\n\t};\n\tint ret;\n\n\talloc_inode_block(inode);\n\n\tif (li->li_height > (__force u8)target_level)\n\t\tret = __logfs_write_rec(inode, page, &wc, bix, target_level,\n\t\t\t\tLEVEL(li->li_height));\n\telse\n\t\tret = logfs_write_i0(inode, page, &wc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (li->li_data[INDIRECT_INDEX] != wc.ofs) {\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\t\tlogfs_set_alias(inode->i_sb, li->li_block,\n\t\t\t\tINDIRECT_INDEX + INODE_POINTER_OFS);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grow_inode",
          "args": [
            "inode",
            "page->index",
            "0"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1509-1538",
          "snippet": "static int grow_inode(struct inode *inode, u64 bix, level_t level)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu8 height = (__force u8)level;\n\tstruct page *page;\n\tstruct write_control wc = {\n\t\t.flags = WF_WRITE,\n\t};\n\tint err;\n\n\tBUG_ON(height > 5 || li->li_height > 5);\n\twhile (height > li->li_height || bix >= maxbix(li->li_height)) {\n\t\tpage = logfs_get_write_page(inode, I0_BLOCKS + 1,\n\t\t\t\tLEVEL(li->li_height + 1));\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tlogfs_read_empty(page);\n\t\talloc_indirect_block(inode, page, 1);\n\t\tblock_set_pointer(page, 0, li->li_data[INDIRECT_INDEX]);\n\t\terr = logfs_write_i0(inode, page, &wc);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\t\twc.ofs = 0;\n\t\tli->li_height++;\n\t\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_HEIGHT_OFS);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int grow_inode(struct inode *inode, u64 bix, level_t level)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu8 height = (__force u8)level;\n\tstruct page *page;\n\tstruct write_control wc = {\n\t\t.flags = WF_WRITE,\n\t};\n\tint err;\n\n\tBUG_ON(height > 5 || li->li_height > 5);\n\twhile (height > li->li_height || bix >= maxbix(li->li_height)) {\n\t\tpage = logfs_get_write_page(inode, I0_BLOCKS + 1,\n\t\t\t\tLEVEL(li->li_height + 1));\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tlogfs_read_empty(page);\n\t\talloc_indirect_block(inode, page, 1);\n\t\tblock_set_pointer(page, 0, li->li_data[INDIRECT_INDEX]);\n\t\terr = logfs_write_i0(inode, page, &wc);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\t\twc.ofs = 0;\n\t\tli->li_height++;\n\t\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_HEIGHT_OFS);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_direct",
          "args": [
            "inode",
            "page",
            "flags"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1376-1396",
          "snippet": "static int logfs_write_direct(struct inode *inode, struct page *page,\n\t\tlong flags)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[page->index],\n\t\t.flags = flags,\n\t};\n\tint err;\n\n\talloc_inode_block(inode);\n\n\terr = logfs_write_i0(inode, page, &wc);\n\tif (err)\n\t\treturn err;\n\n\tli->li_data[page->index] = wc.ofs;\n\tlogfs_set_alias(inode->i_sb, li->li_block,\n\t\t\tpage->index + INODE_POINTER_OFS);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_direct(struct inode *inode, struct page *page,\n\t\tlong flags)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[page->index],\n\t\t.flags = flags,\n\t};\n\tint err;\n\n\talloc_inode_block(inode);\n\n\terr = logfs_write_i0(inode, page, &wc);\n\tif (err)\n\t\treturn err;\n\n\tli->li_data[page->index] = wc.ofs;\n\tlogfs_set_alias(inode->i_sb, li->li_block,\n\t\t\tpage->index + INODE_POINTER_OFS);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_delete(struct inode *inode, struct page *page)\n{\n\tlong flags = WF_DELETE;\n\tint err;\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tif (page->index < I0_BLOCKS)\n\t\treturn logfs_write_direct(inode, page, flags);\n\terr = grow_inode(inode, page->index, 0);\n\tif (err)\n\t\treturn err;\n\treturn logfs_write_rec(inode, page, page->index, 0, flags);\n}"
  },
  {
    "function_name": "logfs_write_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1565-1574",
    "snippet": "int logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = __logfs_write_buf(inode, page, flags);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_wblocks",
          "args": [
            "sb",
            "page",
            "flags & WF_LOCK"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "262-272",
          "snippet": "void logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_write_buf",
          "args": [
            "inode",
            "page",
            "flags"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_write_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1540-1563",
          "snippet": "static int __logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tpgoff_t index = page->index;\n\tu64 bix;\n\tlevel_t level;\n\tint err;\n\n\tflags |= WF_WRITE | WF_DELETE;\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tlogfs_unpack_index(index, &bix, &level);\n\tif (logfs_block(page) && logfs_block(page)->reserved_bytes)\n\t\tsuper->s_dirty_pages -= logfs_block(page)->reserved_bytes;\n\n\tif (index < I0_BLOCKS)\n\t\treturn logfs_write_direct(inode, page, flags);\n\n\tbix = adjust_bix(bix, level);\n\terr = grow_inode(inode, bix, level);\n\tif (err)\n\t\treturn err;\n\treturn logfs_write_rec(inode, page, bix, level, flags);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tpgoff_t index = page->index;\n\tu64 bix;\n\tlevel_t level;\n\tint err;\n\n\tflags |= WF_WRITE | WF_DELETE;\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tlogfs_unpack_index(index, &bix, &level);\n\tif (logfs_block(page) && logfs_block(page)->reserved_bytes)\n\t\tsuper->s_dirty_pages -= logfs_block(page)->reserved_bytes;\n\n\tif (index < I0_BLOCKS)\n\t\treturn logfs_write_direct(inode, page, flags);\n\n\tbix = adjust_bix(bix, level);\n\terr = grow_inode(inode, bix, level);\n\tif (err)\n\t\treturn err;\n\treturn logfs_write_rec(inode, page, bix, level, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_wblocks",
          "args": [
            "sb",
            "page",
            "flags & WF_LOCK"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "247-260",
          "snippet": "void logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = __logfs_write_buf(inode, page, flags);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}"
  },
  {
    "function_name": "__logfs_write_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1540-1563",
    "snippet": "static int __logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tpgoff_t index = page->index;\n\tu64 bix;\n\tlevel_t level;\n\tint err;\n\n\tflags |= WF_WRITE | WF_DELETE;\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tlogfs_unpack_index(index, &bix, &level);\n\tif (logfs_block(page) && logfs_block(page)->reserved_bytes)\n\t\tsuper->s_dirty_pages -= logfs_block(page)->reserved_bytes;\n\n\tif (index < I0_BLOCKS)\n\t\treturn logfs_write_direct(inode, page, flags);\n\n\tbix = adjust_bix(bix, level);\n\terr = grow_inode(inode, bix, level);\n\tif (err)\n\t\treturn err;\n\treturn logfs_write_rec(inode, page, bix, level, flags);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_write_rec",
          "args": [
            "inode",
            "page",
            "bix",
            "level",
            "flags"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1467-1493",
          "snippet": "static int logfs_write_rec(struct inode *inode, struct page *page,\n\t\tpgoff_t bix, level_t target_level, long flags)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[INDIRECT_INDEX],\n\t\t.flags = flags,\n\t};\n\tint ret;\n\n\talloc_inode_block(inode);\n\n\tif (li->li_height > (__force u8)target_level)\n\t\tret = __logfs_write_rec(inode, page, &wc, bix, target_level,\n\t\t\t\tLEVEL(li->li_height));\n\telse\n\t\tret = logfs_write_i0(inode, page, &wc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (li->li_data[INDIRECT_INDEX] != wc.ofs) {\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\t\tlogfs_set_alias(inode->i_sb, li->li_block,\n\t\t\t\tINDIRECT_INDEX + INODE_POINTER_OFS);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_rec(struct inode *inode, struct page *page,\n\t\tpgoff_t bix, level_t target_level, long flags)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[INDIRECT_INDEX],\n\t\t.flags = flags,\n\t};\n\tint ret;\n\n\talloc_inode_block(inode);\n\n\tif (li->li_height > (__force u8)target_level)\n\t\tret = __logfs_write_rec(inode, page, &wc, bix, target_level,\n\t\t\t\tLEVEL(li->li_height));\n\telse\n\t\tret = logfs_write_i0(inode, page, &wc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (li->li_data[INDIRECT_INDEX] != wc.ofs) {\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\t\tlogfs_set_alias(inode->i_sb, li->li_block,\n\t\t\t\tINDIRECT_INDEX + INODE_POINTER_OFS);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grow_inode",
          "args": [
            "inode",
            "bix",
            "level"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1509-1538",
          "snippet": "static int grow_inode(struct inode *inode, u64 bix, level_t level)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu8 height = (__force u8)level;\n\tstruct page *page;\n\tstruct write_control wc = {\n\t\t.flags = WF_WRITE,\n\t};\n\tint err;\n\n\tBUG_ON(height > 5 || li->li_height > 5);\n\twhile (height > li->li_height || bix >= maxbix(li->li_height)) {\n\t\tpage = logfs_get_write_page(inode, I0_BLOCKS + 1,\n\t\t\t\tLEVEL(li->li_height + 1));\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tlogfs_read_empty(page);\n\t\talloc_indirect_block(inode, page, 1);\n\t\tblock_set_pointer(page, 0, li->li_data[INDIRECT_INDEX]);\n\t\terr = logfs_write_i0(inode, page, &wc);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\t\twc.ofs = 0;\n\t\tli->li_height++;\n\t\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_HEIGHT_OFS);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int grow_inode(struct inode *inode, u64 bix, level_t level)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu8 height = (__force u8)level;\n\tstruct page *page;\n\tstruct write_control wc = {\n\t\t.flags = WF_WRITE,\n\t};\n\tint err;\n\n\tBUG_ON(height > 5 || li->li_height > 5);\n\twhile (height > li->li_height || bix >= maxbix(li->li_height)) {\n\t\tpage = logfs_get_write_page(inode, I0_BLOCKS + 1,\n\t\t\t\tLEVEL(li->li_height + 1));\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tlogfs_read_empty(page);\n\t\talloc_indirect_block(inode, page, 1);\n\t\tblock_set_pointer(page, 0, li->li_data[INDIRECT_INDEX]);\n\t\terr = logfs_write_i0(inode, page, &wc);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\t\twc.ofs = 0;\n\t\tli->li_height++;\n\t\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_HEIGHT_OFS);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adjust_bix",
          "args": [
            "bix",
            "level"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_bix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "23-42",
          "snippet": "static u64 adjust_bix(u64 bix, level_t level)\n{\n\tswitch (level) {\n\tcase 0:\n\t\treturn bix;\n\tcase LEVEL(1):\n\t\treturn max_t(u64, bix, I0_BLOCKS);\n\tcase LEVEL(2):\n\t\treturn max_t(u64, bix, I1_BLOCKS);\n\tcase LEVEL(3):\n\t\treturn max_t(u64, bix, I2_BLOCKS);\n\tcase LEVEL(4):\n\t\treturn max_t(u64, bix, I3_BLOCKS);\n\tcase LEVEL(5):\n\t\treturn max_t(u64, bix, I4_BLOCKS);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn bix;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 adjust_bix(u64 bix, level_t level)\n{\n\tswitch (level) {\n\tcase 0:\n\t\treturn bix;\n\tcase LEVEL(1):\n\t\treturn max_t(u64, bix, I0_BLOCKS);\n\tcase LEVEL(2):\n\t\treturn max_t(u64, bix, I1_BLOCKS);\n\tcase LEVEL(3):\n\t\treturn max_t(u64, bix, I2_BLOCKS);\n\tcase LEVEL(4):\n\t\treturn max_t(u64, bix, I3_BLOCKS);\n\tcase LEVEL(5):\n\t\treturn max_t(u64, bix, I4_BLOCKS);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn bix;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_direct",
          "args": [
            "inode",
            "page",
            "flags"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1376-1396",
          "snippet": "static int logfs_write_direct(struct inode *inode, struct page *page,\n\t\tlong flags)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[page->index],\n\t\t.flags = flags,\n\t};\n\tint err;\n\n\talloc_inode_block(inode);\n\n\terr = logfs_write_i0(inode, page, &wc);\n\tif (err)\n\t\treturn err;\n\n\tli->li_data[page->index] = wc.ofs;\n\tlogfs_set_alias(inode->i_sb, li->li_block,\n\t\t\tpage->index + INODE_POINTER_OFS);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_direct(struct inode *inode, struct page *page,\n\t\tlong flags)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[page->index],\n\t\t.flags = flags,\n\t};\n\tint err;\n\n\talloc_inode_block(inode);\n\n\terr = logfs_write_i0(inode, page, &wc);\n\tif (err)\n\t\treturn err;\n\n\tli->li_data[page->index] = wc.ofs;\n\tlogfs_set_alias(inode->i_sb, li->li_block,\n\t\t\tpage->index + INODE_POINTER_OFS);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "page"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_unpack_index",
          "args": [
            "index",
            "&bix",
            "&level"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_unpack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "81-96",
          "snippet": "void logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\nvoid logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "inode->i_sb"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tpgoff_t index = page->index;\n\tu64 bix;\n\tlevel_t level;\n\tint err;\n\n\tflags |= WF_WRITE | WF_DELETE;\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tlogfs_unpack_index(index, &bix, &level);\n\tif (logfs_block(page) && logfs_block(page)->reserved_bytes)\n\t\tsuper->s_dirty_pages -= logfs_block(page)->reserved_bytes;\n\n\tif (index < I0_BLOCKS)\n\t\treturn logfs_write_direct(inode, page, flags);\n\n\tbix = adjust_bix(bix, level);\n\terr = grow_inode(inode, bix, level);\n\tif (err)\n\t\treturn err;\n\treturn logfs_write_rec(inode, page, bix, level, flags);\n}"
  },
  {
    "function_name": "grow_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1509-1538",
    "snippet": "static int grow_inode(struct inode *inode, u64 bix, level_t level)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu8 height = (__force u8)level;\n\tstruct page *page;\n\tstruct write_control wc = {\n\t\t.flags = WF_WRITE,\n\t};\n\tint err;\n\n\tBUG_ON(height > 5 || li->li_height > 5);\n\twhile (height > li->li_height || bix >= maxbix(li->li_height)) {\n\t\tpage = logfs_get_write_page(inode, I0_BLOCKS + 1,\n\t\t\t\tLEVEL(li->li_height + 1));\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tlogfs_read_empty(page);\n\t\talloc_indirect_block(inode, page, 1);\n\t\tblock_set_pointer(page, 0, li->li_data[INDIRECT_INDEX]);\n\t\terr = logfs_write_i0(inode, page, &wc);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\t\twc.ofs = 0;\n\t\tli->li_height++;\n\t\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_HEIGHT_OFS);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_set_alias",
          "args": [
            "inode->i_sb",
            "li->li_block",
            "INODE_HEIGHT_OFS"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1303-1318",
          "snippet": "static void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_i0",
          "args": [
            "inode",
            "page",
            "&wc"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_i0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1340-1374",
          "snippet": "static int logfs_write_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint full, err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tif (wc->ofs == 0)\n\t\tif (logfs_reserve_blocks(inode, 1))\n\t\t\treturn -ENOSPC;\n\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\tif (wc->flags & WF_WRITE)\n\t\terr = logfs_segment_write(inode, page, shadow);\n\tif (wc->flags & WF_DELETE)\n\t\tlogfs_segment_delete(inode, shadow);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tset_iused(inode, shadow);\n\tfull = 1;\n\tif (level != 0) {\n\t\talloc_indirect_block(inode, page, 0);\n\t\tfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\n\t}\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\tif (wc->ofs && full)\n\t\twc->ofs |= LOGFS_FULLY_POPULATED;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint full, err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tif (wc->ofs == 0)\n\t\tif (logfs_reserve_blocks(inode, 1))\n\t\t\treturn -ENOSPC;\n\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\tif (wc->flags & WF_WRITE)\n\t\terr = logfs_segment_write(inode, page, shadow);\n\tif (wc->flags & WF_DELETE)\n\t\tlogfs_segment_delete(inode, shadow);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tset_iused(inode, shadow);\n\tfull = 1;\n\tif (level != 0) {\n\t\talloc_indirect_block(inode, page, 0);\n\t\tfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\n\t}\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\tif (wc->ofs && full)\n\t\twc->ofs |= LOGFS_FULLY_POPULATED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_set_pointer",
          "args": [
            "page",
            "0",
            "li->li_data[INDIRECT_INDEX]"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "block_set_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "681-697",
          "snippet": "static void block_set_pointer(struct page *page, int index, u64 ptr)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\t__be64 *array;\n\tu64 oldptr;\n\n\tBUG_ON(!block);\n\tarray = kmap_atomic(page);\n\toldptr = be64_to_cpu(array[index]);\n\tarray[index] = cpu_to_be64(ptr);\n\tkunmap_atomic(array);\n\tSetPageUptodate(page);\n\n\tblock->full += !!(ptr & LOGFS_FULLY_POPULATED)\n\t\t- !!(oldptr & LOGFS_FULLY_POPULATED);\n\tblock->partial += !!ptr - !!oldptr;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void block_set_pointer(struct page *page, int index, u64 ptr)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\t__be64 *array;\n\tu64 oldptr;\n\n\tBUG_ON(!block);\n\tarray = kmap_atomic(page);\n\toldptr = be64_to_cpu(array[index]);\n\tarray[index] = cpu_to_be64(ptr);\n\tkunmap_atomic(array);\n\tSetPageUptodate(page);\n\n\tblock->full += !!(ptr & LOGFS_FULLY_POPULATED)\n\t\t- !!(oldptr & LOGFS_FULLY_POPULATED);\n\tblock->partial += !!ptr - !!oldptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_indirect_block",
          "args": [
            "inode",
            "page",
            "1"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_indirect_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "664-679",
          "snippet": "static void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_read_empty",
          "args": [
            "page"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "710-714",
          "snippet": "static int logfs_read_empty(struct page *page)\n{\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_empty(struct page *page)\n{\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "inode",
            "I0_BLOCKS + 1",
            "LEVEL(li->li_height + 1)"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "li->li_height + 1"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maxbix",
          "args": [
            "li->li_height"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "maxbix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "44-47",
          "snippet": "static inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "height > 5 || li->li_height > 5"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int grow_inode(struct inode *inode, u64 bix, level_t level)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu8 height = (__force u8)level;\n\tstruct page *page;\n\tstruct write_control wc = {\n\t\t.flags = WF_WRITE,\n\t};\n\tint err;\n\n\tBUG_ON(height > 5 || li->li_height > 5);\n\twhile (height > li->li_height || bix >= maxbix(li->li_height)) {\n\t\tpage = logfs_get_write_page(inode, I0_BLOCKS + 1,\n\t\t\t\tLEVEL(li->li_height + 1));\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tlogfs_read_empty(page);\n\t\talloc_indirect_block(inode, page, 1);\n\t\tblock_set_pointer(page, 0, li->li_data[INDIRECT_INDEX]);\n\t\terr = logfs_write_i0(inode, page, &wc);\n\t\tlogfs_put_write_page(page);\n\t\tif (err)\n\t\t\treturn err;\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\t\twc.ofs = 0;\n\t\tli->li_height++;\n\t\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_HEIGHT_OFS);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_del_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1501-1507",
    "snippet": "void logfs_del_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tstruct logfs_block *block = logfs_inode(inode)->li_block;\n\n\tif (block && block->ta)\n\t\tblock->ta = NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_del_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\tstruct logfs_block *block = logfs_inode(inode)->li_block;\n\n\tif (block && block->ta)\n\t\tblock->ta = NULL;\n}"
  },
  {
    "function_name": "logfs_add_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1495-1499",
    "snippet": "void logfs_add_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\talloc_inode_block(inode);\n\tlogfs_inode(inode)->li_block->ta = ta;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_inode_block",
          "args": [
            "inode"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "601-613",
          "snippet": "static void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};\n\nstatic void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_add_transaction(struct inode *inode, struct logfs_transaction *ta)\n{\n\talloc_inode_block(inode);\n\tlogfs_inode(inode)->li_block->ta = ta;\n}"
  },
  {
    "function_name": "logfs_write_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1467-1493",
    "snippet": "static int logfs_write_rec(struct inode *inode, struct page *page,\n\t\tpgoff_t bix, level_t target_level, long flags)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[INDIRECT_INDEX],\n\t\t.flags = flags,\n\t};\n\tint ret;\n\n\talloc_inode_block(inode);\n\n\tif (li->li_height > (__force u8)target_level)\n\t\tret = __logfs_write_rec(inode, page, &wc, bix, target_level,\n\t\t\t\tLEVEL(li->li_height));\n\telse\n\t\tret = logfs_write_i0(inode, page, &wc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (li->li_data[INDIRECT_INDEX] != wc.ofs) {\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\t\tlogfs_set_alias(inode->i_sb, li->li_block,\n\t\t\t\tINDIRECT_INDEX + INODE_POINTER_OFS);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_set_alias",
          "args": [
            "inode->i_sb",
            "li->li_block",
            "INDIRECT_INDEX + INODE_POINTER_OFS"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1303-1318",
          "snippet": "static void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_i0",
          "args": [
            "inode",
            "page",
            "&wc"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_i0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1340-1374",
          "snippet": "static int logfs_write_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint full, err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tif (wc->ofs == 0)\n\t\tif (logfs_reserve_blocks(inode, 1))\n\t\t\treturn -ENOSPC;\n\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\tif (wc->flags & WF_WRITE)\n\t\terr = logfs_segment_write(inode, page, shadow);\n\tif (wc->flags & WF_DELETE)\n\t\tlogfs_segment_delete(inode, shadow);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tset_iused(inode, shadow);\n\tfull = 1;\n\tif (level != 0) {\n\t\talloc_indirect_block(inode, page, 0);\n\t\tfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\n\t}\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\tif (wc->ofs && full)\n\t\twc->ofs |= LOGFS_FULLY_POPULATED;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint full, err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tif (wc->ofs == 0)\n\t\tif (logfs_reserve_blocks(inode, 1))\n\t\t\treturn -ENOSPC;\n\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\tif (wc->flags & WF_WRITE)\n\t\terr = logfs_segment_write(inode, page, shadow);\n\tif (wc->flags & WF_DELETE)\n\t\tlogfs_segment_delete(inode, shadow);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tset_iused(inode, shadow);\n\tfull = 1;\n\tif (level != 0) {\n\t\talloc_indirect_block(inode, page, 0);\n\t\tfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\n\t}\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\tif (wc->ofs && full)\n\t\twc->ofs |= LOGFS_FULLY_POPULATED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_write_rec",
          "args": [
            "inode",
            "page",
            "&wc",
            "bix",
            "target_level",
            "LEVEL(li->li_height)"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_write_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1416-1465",
          "snippet": "static int __logfs_write_rec(struct inode *inode, struct page *page,\n\t\tstruct write_control *this_wc,\n\t\tpgoff_t bix, level_t target_level, level_t level)\n{\n\tint ret, page_empty = 0;\n\tint child_no = get_bits(bix, SUBLEVEL(level));\n\tstruct page *ipage;\n\tstruct write_control child_wc = {\n\t\t.flags = this_wc->flags,\n\t};\n\n\tipage = logfs_get_write_page(inode, bix, level);\n\tif (!ipage)\n\t\treturn -ENOMEM;\n\n\tif (this_wc->ofs) {\n\t\tret = logfs_segment_read(inode, ipage, this_wc->ofs, bix, level);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else if (!PageUptodate(ipage)) {\n\t\tpage_empty = 1;\n\t\tlogfs_read_empty(ipage);\n\t}\n\n\tchild_wc.ofs = block_get_pointer(ipage, child_no);\n\n\tif ((__force u8)level-1 > (__force u8)target_level)\n\t\tret = __logfs_write_rec(inode, page, &child_wc, bix,\n\t\t\t\ttarget_level, SUBLEVEL(level));\n\telse\n\t\tret = logfs_write_i0(inode, page, &child_wc);\n\n\tif (ret)\n\t\tgoto out;\n\n\talloc_indirect_block(inode, ipage, page_empty);\n\tblock_set_pointer(ipage, child_no, child_wc.ofs);\n\t/* FIXME: first condition seems superfluous */\n\tif (child_wc.ofs || logfs_block(ipage)->partial)\n\t\tthis_wc->flags |= WF_WRITE;\n\t/* the condition on this_wc->ofs ensures that we won't consume extra\n\t * space for indirect blocks in the future, which we cannot reserve */\n\tif (!this_wc->ofs || ptr_change(this_wc->ofs, ipage))\n\t\tret = logfs_write_i0(inode, ipage, this_wc);\n\telse\n\t\tlogfs_set_alias(inode->i_sb, logfs_block(ipage), child_no);\nout:\n\tlogfs_put_write_page(ipage);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_write_rec(struct inode *inode, struct page *page,\n\t\tstruct write_control *this_wc,\n\t\tpgoff_t bix, level_t target_level, level_t level)\n{\n\tint ret, page_empty = 0;\n\tint child_no = get_bits(bix, SUBLEVEL(level));\n\tstruct page *ipage;\n\tstruct write_control child_wc = {\n\t\t.flags = this_wc->flags,\n\t};\n\n\tipage = logfs_get_write_page(inode, bix, level);\n\tif (!ipage)\n\t\treturn -ENOMEM;\n\n\tif (this_wc->ofs) {\n\t\tret = logfs_segment_read(inode, ipage, this_wc->ofs, bix, level);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else if (!PageUptodate(ipage)) {\n\t\tpage_empty = 1;\n\t\tlogfs_read_empty(ipage);\n\t}\n\n\tchild_wc.ofs = block_get_pointer(ipage, child_no);\n\n\tif ((__force u8)level-1 > (__force u8)target_level)\n\t\tret = __logfs_write_rec(inode, page, &child_wc, bix,\n\t\t\t\ttarget_level, SUBLEVEL(level));\n\telse\n\t\tret = logfs_write_i0(inode, page, &child_wc);\n\n\tif (ret)\n\t\tgoto out;\n\n\talloc_indirect_block(inode, ipage, page_empty);\n\tblock_set_pointer(ipage, child_no, child_wc.ofs);\n\t/* FIXME: first condition seems superfluous */\n\tif (child_wc.ofs || logfs_block(ipage)->partial)\n\t\tthis_wc->flags |= WF_WRITE;\n\t/* the condition on this_wc->ofs ensures that we won't consume extra\n\t * space for indirect blocks in the future, which we cannot reserve */\n\tif (!this_wc->ofs || ptr_change(this_wc->ofs, ipage))\n\t\tret = logfs_write_i0(inode, ipage, this_wc);\n\telse\n\t\tlogfs_set_alias(inode->i_sb, logfs_block(ipage), child_no);\nout:\n\tlogfs_put_write_page(ipage);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "li->li_height"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_inode_block",
          "args": [
            "inode"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "601-613",
          "snippet": "static void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};\n\nstatic void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_rec(struct inode *inode, struct page *page,\n\t\tpgoff_t bix, level_t target_level, long flags)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[INDIRECT_INDEX],\n\t\t.flags = flags,\n\t};\n\tint ret;\n\n\talloc_inode_block(inode);\n\n\tif (li->li_height > (__force u8)target_level)\n\t\tret = __logfs_write_rec(inode, page, &wc, bix, target_level,\n\t\t\t\tLEVEL(li->li_height));\n\telse\n\t\tret = logfs_write_i0(inode, page, &wc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (li->li_data[INDIRECT_INDEX] != wc.ofs) {\n\t\tli->li_data[INDIRECT_INDEX] = wc.ofs;\n\t\tlogfs_set_alias(inode->i_sb, li->li_block,\n\t\t\t\tINDIRECT_INDEX + INODE_POINTER_OFS);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__logfs_write_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1416-1465",
    "snippet": "static int __logfs_write_rec(struct inode *inode, struct page *page,\n\t\tstruct write_control *this_wc,\n\t\tpgoff_t bix, level_t target_level, level_t level)\n{\n\tint ret, page_empty = 0;\n\tint child_no = get_bits(bix, SUBLEVEL(level));\n\tstruct page *ipage;\n\tstruct write_control child_wc = {\n\t\t.flags = this_wc->flags,\n\t};\n\n\tipage = logfs_get_write_page(inode, bix, level);\n\tif (!ipage)\n\t\treturn -ENOMEM;\n\n\tif (this_wc->ofs) {\n\t\tret = logfs_segment_read(inode, ipage, this_wc->ofs, bix, level);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else if (!PageUptodate(ipage)) {\n\t\tpage_empty = 1;\n\t\tlogfs_read_empty(ipage);\n\t}\n\n\tchild_wc.ofs = block_get_pointer(ipage, child_no);\n\n\tif ((__force u8)level-1 > (__force u8)target_level)\n\t\tret = __logfs_write_rec(inode, page, &child_wc, bix,\n\t\t\t\ttarget_level, SUBLEVEL(level));\n\telse\n\t\tret = logfs_write_i0(inode, page, &child_wc);\n\n\tif (ret)\n\t\tgoto out;\n\n\talloc_indirect_block(inode, ipage, page_empty);\n\tblock_set_pointer(ipage, child_no, child_wc.ofs);\n\t/* FIXME: first condition seems superfluous */\n\tif (child_wc.ofs || logfs_block(ipage)->partial)\n\t\tthis_wc->flags |= WF_WRITE;\n\t/* the condition on this_wc->ofs ensures that we won't consume extra\n\t * space for indirect blocks in the future, which we cannot reserve */\n\tif (!this_wc->ofs || ptr_change(this_wc->ofs, ipage))\n\t\tret = logfs_write_i0(inode, ipage, this_wc);\n\telse\n\t\tlogfs_set_alias(inode->i_sb, logfs_block(ipage), child_no);\nout:\n\tlogfs_put_write_page(ipage);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "ipage"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_set_alias",
          "args": [
            "inode->i_sb",
            "logfs_block(ipage)",
            "child_no"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1303-1318",
          "snippet": "static void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "ipage"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_i0",
          "args": [
            "inode",
            "ipage",
            "this_wc"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_i0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1340-1374",
          "snippet": "static int logfs_write_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint full, err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tif (wc->ofs == 0)\n\t\tif (logfs_reserve_blocks(inode, 1))\n\t\t\treturn -ENOSPC;\n\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\tif (wc->flags & WF_WRITE)\n\t\terr = logfs_segment_write(inode, page, shadow);\n\tif (wc->flags & WF_DELETE)\n\t\tlogfs_segment_delete(inode, shadow);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tset_iused(inode, shadow);\n\tfull = 1;\n\tif (level != 0) {\n\t\talloc_indirect_block(inode, page, 0);\n\t\tfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\n\t}\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\tif (wc->ofs && full)\n\t\twc->ofs |= LOGFS_FULLY_POPULATED;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint full, err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tif (wc->ofs == 0)\n\t\tif (logfs_reserve_blocks(inode, 1))\n\t\t\treturn -ENOSPC;\n\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\tif (wc->flags & WF_WRITE)\n\t\terr = logfs_segment_write(inode, page, shadow);\n\tif (wc->flags & WF_DELETE)\n\t\tlogfs_segment_delete(inode, shadow);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tset_iused(inode, shadow);\n\tfull = 1;\n\tif (level != 0) {\n\t\talloc_indirect_block(inode, page, 0);\n\t\tfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\n\t}\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\tif (wc->ofs && full)\n\t\twc->ofs |= LOGFS_FULLY_POPULATED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_change",
          "args": [
            "this_wc->ofs",
            "ipage"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "ptr_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1398-1414",
          "snippet": "static int ptr_change(u64 ofs, struct page *page)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\tint empty0, empty1, full0, full1;\n\n\tempty0 = ofs == 0;\n\tempty1 = block->partial == 0;\n\tif (empty0 != empty1)\n\t\treturn 1;\n\n\t/* The !! is necessary to shrink result to int */\n\tfull0 = !!(ofs & LOGFS_FULLY_POPULATED);\n\tfull1 = block->full == LOGFS_BLOCK_FACTOR;\n\tif (full0 != full1)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int ptr_change(u64 ofs, struct page *page)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\tint empty0, empty1, full0, full1;\n\n\tempty0 = ofs == 0;\n\tempty1 = block->partial == 0;\n\tif (empty0 != empty1)\n\t\treturn 1;\n\n\t/* The !! is necessary to shrink result to int */\n\tfull0 = !!(ofs & LOGFS_FULLY_POPULATED);\n\tfull1 = block->full == LOGFS_BLOCK_FACTOR;\n\tif (full0 != full1)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_set_pointer",
          "args": [
            "ipage",
            "child_no",
            "child_wc.ofs"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "block_set_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "681-697",
          "snippet": "static void block_set_pointer(struct page *page, int index, u64 ptr)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\t__be64 *array;\n\tu64 oldptr;\n\n\tBUG_ON(!block);\n\tarray = kmap_atomic(page);\n\toldptr = be64_to_cpu(array[index]);\n\tarray[index] = cpu_to_be64(ptr);\n\tkunmap_atomic(array);\n\tSetPageUptodate(page);\n\n\tblock->full += !!(ptr & LOGFS_FULLY_POPULATED)\n\t\t- !!(oldptr & LOGFS_FULLY_POPULATED);\n\tblock->partial += !!ptr - !!oldptr;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void block_set_pointer(struct page *page, int index, u64 ptr)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\t__be64 *array;\n\tu64 oldptr;\n\n\tBUG_ON(!block);\n\tarray = kmap_atomic(page);\n\toldptr = be64_to_cpu(array[index]);\n\tarray[index] = cpu_to_be64(ptr);\n\tkunmap_atomic(array);\n\tSetPageUptodate(page);\n\n\tblock->full += !!(ptr & LOGFS_FULLY_POPULATED)\n\t\t- !!(oldptr & LOGFS_FULLY_POPULATED);\n\tblock->partial += !!ptr - !!oldptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_indirect_block",
          "args": [
            "inode",
            "ipage",
            "page_empty"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_indirect_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "664-679",
          "snippet": "static void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_write_rec",
          "args": [
            "inode",
            "page",
            "&child_wc",
            "bix",
            "target_level",
            "SUBLEVEL(level)"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_write_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1416-1465",
          "snippet": "static int __logfs_write_rec(struct inode *inode, struct page *page,\n\t\tstruct write_control *this_wc,\n\t\tpgoff_t bix, level_t target_level, level_t level)\n{\n\tint ret, page_empty = 0;\n\tint child_no = get_bits(bix, SUBLEVEL(level));\n\tstruct page *ipage;\n\tstruct write_control child_wc = {\n\t\t.flags = this_wc->flags,\n\t};\n\n\tipage = logfs_get_write_page(inode, bix, level);\n\tif (!ipage)\n\t\treturn -ENOMEM;\n\n\tif (this_wc->ofs) {\n\t\tret = logfs_segment_read(inode, ipage, this_wc->ofs, bix, level);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else if (!PageUptodate(ipage)) {\n\t\tpage_empty = 1;\n\t\tlogfs_read_empty(ipage);\n\t}\n\n\tchild_wc.ofs = block_get_pointer(ipage, child_no);\n\n\tif ((__force u8)level-1 > (__force u8)target_level)\n\t\tret = __logfs_write_rec(inode, page, &child_wc, bix,\n\t\t\t\ttarget_level, SUBLEVEL(level));\n\telse\n\t\tret = logfs_write_i0(inode, page, &child_wc);\n\n\tif (ret)\n\t\tgoto out;\n\n\talloc_indirect_block(inode, ipage, page_empty);\n\tblock_set_pointer(ipage, child_no, child_wc.ofs);\n\t/* FIXME: first condition seems superfluous */\n\tif (child_wc.ofs || logfs_block(ipage)->partial)\n\t\tthis_wc->flags |= WF_WRITE;\n\t/* the condition on this_wc->ofs ensures that we won't consume extra\n\t * space for indirect blocks in the future, which we cannot reserve */\n\tif (!this_wc->ofs || ptr_change(this_wc->ofs, ipage))\n\t\tret = logfs_write_i0(inode, ipage, this_wc);\n\telse\n\t\tlogfs_set_alias(inode->i_sb, logfs_block(ipage), child_no);\nout:\n\tlogfs_put_write_page(ipage);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_get_pointer",
          "args": [
            "ipage",
            "child_no"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "block_get_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "699-708",
          "snippet": "static u64 block_get_pointer(struct page *page, int index)\n{\n\t__be64 *block;\n\tu64 ptr;\n\n\tblock = kmap_atomic(page);\n\tptr = be64_to_cpu(block[index]);\n\tkunmap_atomic(block);\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 block_get_pointer(struct page *page, int index)\n{\n\t__be64 *block;\n\tu64 ptr;\n\n\tblock = kmap_atomic(page);\n\tptr = be64_to_cpu(block[index]);\n\tkunmap_atomic(block);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_read_empty",
          "args": [
            "ipage"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "710-714",
          "snippet": "static int logfs_read_empty(struct page *page)\n{\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_empty(struct page *page)\n{\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "ipage"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_segment_read",
          "args": [
            "inode",
            "ipage",
            "this_wc->ofs",
            "bix",
            "level"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "656-677",
          "snippet": "int logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "inode",
            "bix",
            "level"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bits",
          "args": [
            "bix",
            "SUBLEVEL(level)"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "get_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "375-378",
          "snippet": "static unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_write_rec(struct inode *inode, struct page *page,\n\t\tstruct write_control *this_wc,\n\t\tpgoff_t bix, level_t target_level, level_t level)\n{\n\tint ret, page_empty = 0;\n\tint child_no = get_bits(bix, SUBLEVEL(level));\n\tstruct page *ipage;\n\tstruct write_control child_wc = {\n\t\t.flags = this_wc->flags,\n\t};\n\n\tipage = logfs_get_write_page(inode, bix, level);\n\tif (!ipage)\n\t\treturn -ENOMEM;\n\n\tif (this_wc->ofs) {\n\t\tret = logfs_segment_read(inode, ipage, this_wc->ofs, bix, level);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else if (!PageUptodate(ipage)) {\n\t\tpage_empty = 1;\n\t\tlogfs_read_empty(ipage);\n\t}\n\n\tchild_wc.ofs = block_get_pointer(ipage, child_no);\n\n\tif ((__force u8)level-1 > (__force u8)target_level)\n\t\tret = __logfs_write_rec(inode, page, &child_wc, bix,\n\t\t\t\ttarget_level, SUBLEVEL(level));\n\telse\n\t\tret = logfs_write_i0(inode, page, &child_wc);\n\n\tif (ret)\n\t\tgoto out;\n\n\talloc_indirect_block(inode, ipage, page_empty);\n\tblock_set_pointer(ipage, child_no, child_wc.ofs);\n\t/* FIXME: first condition seems superfluous */\n\tif (child_wc.ofs || logfs_block(ipage)->partial)\n\t\tthis_wc->flags |= WF_WRITE;\n\t/* the condition on this_wc->ofs ensures that we won't consume extra\n\t * space for indirect blocks in the future, which we cannot reserve */\n\tif (!this_wc->ofs || ptr_change(this_wc->ofs, ipage))\n\t\tret = logfs_write_i0(inode, ipage, this_wc);\n\telse\n\t\tlogfs_set_alias(inode->i_sb, logfs_block(ipage), child_no);\nout:\n\tlogfs_put_write_page(ipage);\n\treturn ret;\n}"
  },
  {
    "function_name": "ptr_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1398-1414",
    "snippet": "static int ptr_change(u64 ofs, struct page *page)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\tint empty0, empty1, full0, full1;\n\n\tempty0 = ofs == 0;\n\tempty1 = block->partial == 0;\n\tif (empty0 != empty1)\n\t\treturn 1;\n\n\t/* The !! is necessary to shrink result to int */\n\tfull0 = !!(ofs & LOGFS_FULLY_POPULATED);\n\tfull1 = block->full == LOGFS_BLOCK_FACTOR;\n\tif (full0 != full1)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "page"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int ptr_change(u64 ofs, struct page *page)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\tint empty0, empty1, full0, full1;\n\n\tempty0 = ofs == 0;\n\tempty1 = block->partial == 0;\n\tif (empty0 != empty1)\n\t\treturn 1;\n\n\t/* The !! is necessary to shrink result to int */\n\tfull0 = !!(ofs & LOGFS_FULLY_POPULATED);\n\tfull1 = block->full == LOGFS_BLOCK_FACTOR;\n\tif (full0 != full1)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_write_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1376-1396",
    "snippet": "static int logfs_write_direct(struct inode *inode, struct page *page,\n\t\tlong flags)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[page->index],\n\t\t.flags = flags,\n\t};\n\tint err;\n\n\talloc_inode_block(inode);\n\n\terr = logfs_write_i0(inode, page, &wc);\n\tif (err)\n\t\treturn err;\n\n\tli->li_data[page->index] = wc.ofs;\n\tlogfs_set_alias(inode->i_sb, li->li_block,\n\t\t\tpage->index + INODE_POINTER_OFS);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_set_alias",
          "args": [
            "inode->i_sb",
            "li->li_block",
            "page->index + INODE_POINTER_OFS"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1303-1318",
          "snippet": "static void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_i0",
          "args": [
            "inode",
            "page",
            "&wc"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_i0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1340-1374",
          "snippet": "static int logfs_write_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint full, err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tif (wc->ofs == 0)\n\t\tif (logfs_reserve_blocks(inode, 1))\n\t\t\treturn -ENOSPC;\n\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\tif (wc->flags & WF_WRITE)\n\t\terr = logfs_segment_write(inode, page, shadow);\n\tif (wc->flags & WF_DELETE)\n\t\tlogfs_segment_delete(inode, shadow);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tset_iused(inode, shadow);\n\tfull = 1;\n\tif (level != 0) {\n\t\talloc_indirect_block(inode, page, 0);\n\t\tfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\n\t}\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\tif (wc->ofs && full)\n\t\twc->ofs |= LOGFS_FULLY_POPULATED;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint full, err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tif (wc->ofs == 0)\n\t\tif (logfs_reserve_blocks(inode, 1))\n\t\t\treturn -ENOSPC;\n\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\tif (wc->flags & WF_WRITE)\n\t\terr = logfs_segment_write(inode, page, shadow);\n\tif (wc->flags & WF_DELETE)\n\t\tlogfs_segment_delete(inode, shadow);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tset_iused(inode, shadow);\n\tfull = 1;\n\tif (level != 0) {\n\t\talloc_indirect_block(inode, page, 0);\n\t\tfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\n\t}\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\tif (wc->ofs && full)\n\t\twc->ofs |= LOGFS_FULLY_POPULATED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_inode_block",
          "args": [
            "inode"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "601-613",
          "snippet": "static void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};\n\nstatic void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_direct(struct inode *inode, struct page *page,\n\t\tlong flags)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct write_control wc = {\n\t\t.ofs = li->li_data[page->index],\n\t\t.flags = flags,\n\t};\n\tint err;\n\n\talloc_inode_block(inode);\n\n\terr = logfs_write_i0(inode, page, &wc);\n\tif (err)\n\t\treturn err;\n\n\tli->li_data[page->index] = wc.ofs;\n\tlogfs_set_alias(inode->i_sb, li->li_block,\n\t\t\tpage->index + INODE_POINTER_OFS);\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_write_i0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1340-1374",
    "snippet": "static int logfs_write_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint full, err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tif (wc->ofs == 0)\n\t\tif (logfs_reserve_blocks(inode, 1))\n\t\t\treturn -ENOSPC;\n\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\tif (wc->flags & WF_WRITE)\n\t\terr = logfs_segment_write(inode, page, shadow);\n\tif (wc->flags & WF_DELETE)\n\t\tlogfs_segment_delete(inode, shadow);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tset_iused(inode, shadow);\n\tfull = 1;\n\tif (level != 0) {\n\t\talloc_indirect_block(inode, page, 0);\n\t\tfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\n\t}\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\tif (wc->ofs && full)\n\t\twc->ofs |= LOGFS_FULLY_POPULATED;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill_shadow_tree",
          "args": [
            "inode",
            "page",
            "shadow"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "fill_shadow_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1274-1301",
          "snippet": "static void fill_shadow_tree(struct inode *inode, struct page *page,\n\t\tstruct logfs_shadow *shadow)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_block *block = logfs_block(page);\n\tstruct shadow_tree *tree = &super->s_shadow_tree;\n\n\tif (PagePrivate(page)) {\n\t\tif (block->alias_map)\n\t\t\tsuper->s_no_object_aliases -= bitmap_weight(\n\t\t\t\t\tblock->alias_map, LOGFS_BLOCK_FACTOR);\n\t\tlogfs_handle_transaction(inode, block->ta);\n\t\tblock->ops->free_block(inode->i_sb, block);\n\t}\n\tif (shadow) {\n\t\tif (shadow->old_ofs)\n\t\t\tbtree_insert64(&tree->old, shadow->old_ofs, shadow,\n\t\t\t\t\tGFP_NOFS);\n\t\telse\n\t\t\tbtree_insert64(&tree->new, shadow->new_ofs, shadow,\n\t\t\t\t\tGFP_NOFS);\n\n\t\tsuper->s_dirty_used_bytes += shadow->new_len;\n\t\tsuper->s_dirty_free_bytes += shadow->old_len;\n\t\tmark_segment(tree, shadow->old_ofs >> super->s_segshift);\n\t\tmark_segment(tree, shadow->new_ofs >> super->s_segshift);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void fill_shadow_tree(struct inode *inode, struct page *page,\n\t\tstruct logfs_shadow *shadow)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_block *block = logfs_block(page);\n\tstruct shadow_tree *tree = &super->s_shadow_tree;\n\n\tif (PagePrivate(page)) {\n\t\tif (block->alias_map)\n\t\t\tsuper->s_no_object_aliases -= bitmap_weight(\n\t\t\t\t\tblock->alias_map, LOGFS_BLOCK_FACTOR);\n\t\tlogfs_handle_transaction(inode, block->ta);\n\t\tblock->ops->free_block(inode->i_sb, block);\n\t}\n\tif (shadow) {\n\t\tif (shadow->old_ofs)\n\t\t\tbtree_insert64(&tree->old, shadow->old_ofs, shadow,\n\t\t\t\t\tGFP_NOFS);\n\t\telse\n\t\t\tbtree_insert64(&tree->new, shadow->new_ofs, shadow,\n\t\t\t\t\tGFP_NOFS);\n\n\t\tsuper->s_dirty_used_bytes += shadow->new_len;\n\t\tsuper->s_dirty_free_bytes += shadow->old_len;\n\t\tmark_segment(tree, shadow->old_ofs >> super->s_segshift);\n\t\tmark_segment(tree, shadow->new_ofs >> super->s_segshift);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "page"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_indirect_block",
          "args": [
            "inode",
            "page",
            "0"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_indirect_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "664-679",
          "snippet": "static void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_iused",
          "args": [
            "inode",
            "shadow"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "set_iused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1326-1338",
          "snippet": "static void set_iused(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (shadow->new_len == shadow->old_len)\n\t\treturn;\n\n\talloc_inode_block(inode);\n\tli->li_used_bytes += shadow->new_len - shadow->old_len;\n\t__logfs_set_blocks(inode);\n\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_USED_OFS);\n\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_SIZE_OFS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void set_iused(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (shadow->new_len == shadow->old_len)\n\t\treturn;\n\n\talloc_inode_block(inode);\n\tli->li_used_bytes += shadow->new_len - shadow->old_len;\n\t__logfs_set_blocks(inode);\n\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_USED_OFS);\n\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_SIZE_OFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_shadow",
          "args": [
            "inode",
            "shadow"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "free_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1232-1237",
          "snippet": "static void free_shadow(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\n\tmempool_free(shadow, super->s_shadow_pool);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void free_shadow(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\n\tmempool_free(shadow, super->s_shadow_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_segment_delete",
          "args": [
            "inode",
            "shadow"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "679-709",
          "snippet": "int logfs_segment_delete(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_object_header h;\n\tu16 len;\n\tint err;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_DIRTY;\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tBUG_ON(shadow->old_ofs & LOGFS_FULLY_POPULATED);\n\tif (!shadow->old_ofs)\n\t\treturn 0;\n\n\tlog_segment(\"logfs_segment_delete(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\terr = read_obj_header(sb, shadow->old_ofs, &h);\n\tLOGFS_BUG_ON(err, sb);\n\tLOGFS_BUG_ON(be64_to_cpu(h.ino) != inode->i_ino, sb);\n\tLOGFS_BUG_ON(check_pos(sb, shadow->bix, be64_to_cpu(h.bix),\n\t\t\t\tshrink_level(shadow->gc_level)), sb);\n\n\tif (shadow->gc_level == 0)\n\t\tlen = be16_to_cpu(h.len);\n\telse\n\t\tlen = obj_len(sb, h.type);\n\tshadow->old_len = len + sizeof(h);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_delete(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_object_header h;\n\tu16 len;\n\tint err;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_DIRTY;\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tBUG_ON(shadow->old_ofs & LOGFS_FULLY_POPULATED);\n\tif (!shadow->old_ofs)\n\t\treturn 0;\n\n\tlog_segment(\"logfs_segment_delete(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\terr = read_obj_header(sb, shadow->old_ofs, &h);\n\tLOGFS_BUG_ON(err, sb);\n\tLOGFS_BUG_ON(be64_to_cpu(h.ino) != inode->i_ino, sb);\n\tLOGFS_BUG_ON(check_pos(sb, shadow->bix, be64_to_cpu(h.bix),\n\t\t\t\tshrink_level(shadow->gc_level)), sb);\n\n\tif (shadow->gc_level == 0)\n\t\tlen = be16_to_cpu(h.len);\n\telse\n\t\tlen = obj_len(sb, h.type);\n\tshadow->old_len = len + sizeof(h);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_segment_write",
          "args": [
            "inode",
            "page",
            "shadow"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "363-398",
          "snippet": "int logfs_segment_write(struct inode *inode, struct page *page,\n\t\tstruct logfs_shadow *shadow)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tint do_compress, type, len;\n\tint ret;\n\tvoid *buf;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_DIRTY;\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tdo_compress = logfs_inode(inode)->li_flags & LOGFS_IF_COMPRESSED;\n\tif (shadow->gc_level != 0) {\n\t\t/* temporarily disable compression for indirect blocks */\n\t\tdo_compress = 0;\n\t}\n\n\ttype = obj_type(inode, shrink_level(shadow->gc_level));\n\tlen = obj_len(sb, type);\n\tbuf = kmap(page);\n\tif (do_compress)\n\t\tret = logfs_segment_write_compress(inode, buf, shadow, type,\n\t\t\t\tlen);\n\telse\n\t\tret = __logfs_segment_write(inode, buf, shadow, type, len,\n\t\t\t\tCOMPR_NONE);\n\tkunmap(page);\n\n\tlog_segment(\"logfs_segment_write(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\t/* this BUG_ON did catch a locking bug.  useful */\n\tBUG_ON(!(shadow->new_ofs & (super->s_segsize - 1)));\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_write(struct inode *inode, struct page *page,\n\t\tstruct logfs_shadow *shadow)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tint do_compress, type, len;\n\tint ret;\n\tvoid *buf;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_DIRTY;\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tdo_compress = logfs_inode(inode)->li_flags & LOGFS_IF_COMPRESSED;\n\tif (shadow->gc_level != 0) {\n\t\t/* temporarily disable compression for indirect blocks */\n\t\tdo_compress = 0;\n\t}\n\n\ttype = obj_type(inode, shrink_level(shadow->gc_level));\n\tlen = obj_len(sb, type);\n\tbuf = kmap(page);\n\tif (do_compress)\n\t\tret = logfs_segment_write_compress(inode, buf, shadow, type,\n\t\t\t\tlen);\n\telse\n\t\tret = __logfs_segment_write(inode, buf, shadow, type, len,\n\t\t\t\tCOMPR_NONE);\n\tkunmap(page);\n\n\tlog_segment(\"logfs_segment_write(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\t/* this BUG_ON did catch a locking bug.  useful */\n\tBUG_ON(!(shadow->new_ofs & (super->s_segsize - 1)));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_shadow",
          "args": [
            "inode",
            "bix",
            "level",
            "wc->ofs"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1217-1230",
          "snippet": "static struct logfs_shadow *alloc_shadow(struct inode *inode, u64 bix,\n\t\tlevel_t level, u64 old_ofs)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_shadow *shadow;\n\n\tshadow = mempool_alloc(super->s_shadow_pool, GFP_NOFS);\n\tmemset(shadow, 0, sizeof(*shadow));\n\tshadow->ino = inode->i_ino;\n\tshadow->bix = bix;\n\tshadow->gc_level = expand_level(inode->i_ino, level);\n\tshadow->old_ofs = old_ofs & ~LOGFS_FULLY_POPULATED;\n\treturn shadow;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_shadow *alloc_shadow(struct inode *inode, u64 bix,\n\t\tlevel_t level, u64 old_ofs)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_shadow *shadow;\n\n\tshadow = mempool_alloc(super->s_shadow_pool, GFP_NOFS);\n\tmemset(shadow, 0, sizeof(*shadow));\n\tshadow->ino = inode->i_ino;\n\tshadow->bix = bix;\n\tshadow->gc_level = expand_level(inode->i_ino, level);\n\tshadow->old_ofs = old_ofs & ~LOGFS_FULLY_POPULATED;\n\treturn shadow;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_reserve_blocks",
          "args": [
            "inode",
            "1"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_reserve_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1207-1210",
          "snippet": "static int logfs_reserve_blocks(struct inode *inode, int blocks)\n{\n\treturn logfs_reserve_bytes(inode, blocks * LOGFS_MAX_OBJECTSIZE);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_reserve_blocks(struct inode *inode, int blocks)\n{\n\treturn logfs_reserve_bytes(inode, blocks * LOGFS_MAX_OBJECTSIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_unpack_index",
          "args": [
            "page->index",
            "&bix",
            "&level"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_unpack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "81-96",
          "snippet": "void logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\nvoid logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_i0(struct inode *inode, struct page *page,\n\t\tstruct write_control *wc)\n{\n\tstruct logfs_shadow *shadow;\n\tu64 bix;\n\tlevel_t level;\n\tint full, err = 0;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tif (wc->ofs == 0)\n\t\tif (logfs_reserve_blocks(inode, 1))\n\t\t\treturn -ENOSPC;\n\n\tshadow = alloc_shadow(inode, bix, level, wc->ofs);\n\tif (wc->flags & WF_WRITE)\n\t\terr = logfs_segment_write(inode, page, shadow);\n\tif (wc->flags & WF_DELETE)\n\t\tlogfs_segment_delete(inode, shadow);\n\tif (err) {\n\t\tfree_shadow(inode, shadow);\n\t\treturn err;\n\t}\n\n\tset_iused(inode, shadow);\n\tfull = 1;\n\tif (level != 0) {\n\t\talloc_indirect_block(inode, page, 0);\n\t\tfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\n\t}\n\tfill_shadow_tree(inode, page, shadow);\n\twc->ofs = shadow->new_ofs;\n\tif (wc->ofs && full)\n\t\twc->ofs |= LOGFS_FULLY_POPULATED;\n\treturn 0;\n}"
  },
  {
    "function_name": "set_iused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1326-1338",
    "snippet": "static void set_iused(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (shadow->new_len == shadow->old_len)\n\t\treturn;\n\n\talloc_inode_block(inode);\n\tli->li_used_bytes += shadow->new_len - shadow->old_len;\n\t__logfs_set_blocks(inode);\n\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_USED_OFS);\n\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_SIZE_OFS);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_set_alias",
          "args": [
            "inode->i_sb",
            "li->li_block",
            "INODE_SIZE_OFS"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1303-1318",
          "snippet": "static void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_set_blocks",
          "args": [
            "inode"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_set_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "187-195",
          "snippet": "static void __logfs_set_blocks(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tinode->i_blocks = ULONG_MAX;\n\tif (li->li_used_bytes >> sb->s_blocksize_bits < ULONG_MAX)\n\t\tinode->i_blocks = ALIGN(li->li_used_bytes, 512) >> 9;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void __logfs_set_blocks(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tinode->i_blocks = ULONG_MAX;\n\tif (li->li_used_bytes >> sb->s_blocksize_bits < ULONG_MAX)\n\t\tinode->i_blocks = ALIGN(li->li_used_bytes, 512) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_inode_block",
          "args": [
            "inode"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "601-613",
          "snippet": "static void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};\n\nstatic void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void set_iused(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (shadow->new_len == shadow->old_len)\n\t\treturn;\n\n\talloc_inode_block(inode);\n\tli->li_used_bytes += shadow->new_len - shadow->old_len;\n\t__logfs_set_blocks(inode);\n\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_USED_OFS);\n\tlogfs_set_alias(inode->i_sb, li->li_block, INODE_SIZE_OFS);\n}"
  },
  {
    "function_name": "logfs_set_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1303-1318",
    "snippet": "static void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&block->alias_list",
            "&super->s_object_alias"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "child_no",
            "block->alias_map"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "child_no",
            "block->alias_map"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\n\t\tlong child_no)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\n\t\t/* Aliases in the master inode are pointless. */\n\t\treturn;\n\t}\n\n\tif (!test_bit(child_no, block->alias_map)) {\n\t\tset_bit(child_no, block->alias_map);\n\t\tsuper->s_no_object_aliases++;\n\t}\n\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n}"
  },
  {
    "function_name": "fill_shadow_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1274-1301",
    "snippet": "static void fill_shadow_tree(struct inode *inode, struct page *page,\n\t\tstruct logfs_shadow *shadow)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_block *block = logfs_block(page);\n\tstruct shadow_tree *tree = &super->s_shadow_tree;\n\n\tif (PagePrivate(page)) {\n\t\tif (block->alias_map)\n\t\t\tsuper->s_no_object_aliases -= bitmap_weight(\n\t\t\t\t\tblock->alias_map, LOGFS_BLOCK_FACTOR);\n\t\tlogfs_handle_transaction(inode, block->ta);\n\t\tblock->ops->free_block(inode->i_sb, block);\n\t}\n\tif (shadow) {\n\t\tif (shadow->old_ofs)\n\t\t\tbtree_insert64(&tree->old, shadow->old_ofs, shadow,\n\t\t\t\t\tGFP_NOFS);\n\t\telse\n\t\t\tbtree_insert64(&tree->new, shadow->new_ofs, shadow,\n\t\t\t\t\tGFP_NOFS);\n\n\t\tsuper->s_dirty_used_bytes += shadow->new_len;\n\t\tsuper->s_dirty_free_bytes += shadow->old_len;\n\t\tmark_segment(tree, shadow->old_ofs >> super->s_segshift);\n\t\tmark_segment(tree, shadow->new_ofs >> super->s_segshift);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_segment",
          "args": [
            "tree",
            "shadow->new_ofs >> super->s_segshift"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "mark_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1239-1249",
          "snippet": "static void mark_segment(struct shadow_tree *tree, u32 segno)\n{\n\tint err;\n\n\tif (!btree_lookup32(&tree->segment_map, segno)) {\n\t\terr = btree_insert32(&tree->segment_map, segno, (void *)1,\n\t\t\t\tGFP_NOFS);\n\t\tBUG_ON(err);\n\t\ttree->no_shadowed_segments++;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void mark_segment(struct shadow_tree *tree, u32 segno)\n{\n\tint err;\n\n\tif (!btree_lookup32(&tree->segment_map, segno)) {\n\t\terr = btree_insert32(&tree->segment_map, segno, (void *)1,\n\t\t\t\tGFP_NOFS);\n\t\tBUG_ON(err);\n\t\ttree->no_shadowed_segments++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btree_insert64",
          "args": [
            "&tree->new",
            "shadow->new_ofs",
            "shadow",
            "GFP_NOFS"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_insert64",
          "args": [
            "&tree->old",
            "shadow->old_ofs",
            "shadow",
            "GFP_NOFS"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block->ops->free_block",
          "args": [
            "inode->i_sb",
            "block"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_handle_transaction",
          "args": [
            "inode",
            "block->ta"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_handle_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1133-1201",
          "snippet": "static void logfs_handle_transaction(struct inode *inode,\n\t\tstruct logfs_transaction *ta)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\n\tif (!ta)\n\t\treturn;\n\tlogfs_inode(inode)->li_block->ta = NULL;\n\n\tif (inode->i_ino != LOGFS_INO_MASTER) {\n\t\tBUG(); /* FIXME: Yes, this needs more thought */\n\t\t/* just remember the transaction until inode is written */\n\t\t//BUG_ON(logfs_inode(inode)->li_transaction);\n\t\t//logfs_inode(inode)->li_transaction = ta;\n\t\treturn;\n\t}\n\n\tswitch (ta->state) {\n\tcase CREATE_1: /* fall through */\n\tcase UNLINK_1:\n\t\tBUG_ON(super->s_victim_ino);\n\t\tsuper->s_victim_ino = ta->ino;\n\t\tbreak;\n\tcase CREATE_2: /* fall through */\n\tcase UNLINK_2:\n\t\tBUG_ON(super->s_victim_ino != ta->ino);\n\t\tsuper->s_victim_ino = 0;\n\t\t/* transaction ends here - free it */\n\t\tkfree(ta);\n\t\tbreak;\n\tcase CROSS_RENAME_1:\n\t\tBUG_ON(super->s_rename_dir);\n\t\tBUG_ON(super->s_rename_pos);\n\t\tsuper->s_rename_dir = ta->dir;\n\t\tsuper->s_rename_pos = ta->pos;\n\t\tbreak;\n\tcase CROSS_RENAME_2:\n\t\tBUG_ON(super->s_rename_dir != ta->dir);\n\t\tBUG_ON(super->s_rename_pos != ta->pos);\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tkfree(ta);\n\t\tbreak;\n\tcase TARGET_RENAME_1:\n\t\tBUG_ON(super->s_rename_dir);\n\t\tBUG_ON(super->s_rename_pos);\n\t\tBUG_ON(super->s_victim_ino);\n\t\tsuper->s_rename_dir = ta->dir;\n\t\tsuper->s_rename_pos = ta->pos;\n\t\tsuper->s_victim_ino = ta->ino;\n\t\tbreak;\n\tcase TARGET_RENAME_2:\n\t\tBUG_ON(super->s_rename_dir != ta->dir);\n\t\tBUG_ON(super->s_rename_pos != ta->pos);\n\t\tBUG_ON(super->s_victim_ino != ta->ino);\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tbreak;\n\tcase TARGET_RENAME_3:\n\t\tBUG_ON(super->s_rename_dir);\n\t\tBUG_ON(super->s_rename_pos);\n\t\tBUG_ON(super->s_victim_ino != ta->ino);\n\t\tsuper->s_victim_ino = 0;\n\t\tkfree(ta);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_handle_transaction(struct inode *inode,\n\t\tstruct logfs_transaction *ta)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\n\tif (!ta)\n\t\treturn;\n\tlogfs_inode(inode)->li_block->ta = NULL;\n\n\tif (inode->i_ino != LOGFS_INO_MASTER) {\n\t\tBUG(); /* FIXME: Yes, this needs more thought */\n\t\t/* just remember the transaction until inode is written */\n\t\t//BUG_ON(logfs_inode(inode)->li_transaction);\n\t\t//logfs_inode(inode)->li_transaction = ta;\n\t\treturn;\n\t}\n\n\tswitch (ta->state) {\n\tcase CREATE_1: /* fall through */\n\tcase UNLINK_1:\n\t\tBUG_ON(super->s_victim_ino);\n\t\tsuper->s_victim_ino = ta->ino;\n\t\tbreak;\n\tcase CREATE_2: /* fall through */\n\tcase UNLINK_2:\n\t\tBUG_ON(super->s_victim_ino != ta->ino);\n\t\tsuper->s_victim_ino = 0;\n\t\t/* transaction ends here - free it */\n\t\tkfree(ta);\n\t\tbreak;\n\tcase CROSS_RENAME_1:\n\t\tBUG_ON(super->s_rename_dir);\n\t\tBUG_ON(super->s_rename_pos);\n\t\tsuper->s_rename_dir = ta->dir;\n\t\tsuper->s_rename_pos = ta->pos;\n\t\tbreak;\n\tcase CROSS_RENAME_2:\n\t\tBUG_ON(super->s_rename_dir != ta->dir);\n\t\tBUG_ON(super->s_rename_pos != ta->pos);\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tkfree(ta);\n\t\tbreak;\n\tcase TARGET_RENAME_1:\n\t\tBUG_ON(super->s_rename_dir);\n\t\tBUG_ON(super->s_rename_pos);\n\t\tBUG_ON(super->s_victim_ino);\n\t\tsuper->s_rename_dir = ta->dir;\n\t\tsuper->s_rename_pos = ta->pos;\n\t\tsuper->s_victim_ino = ta->ino;\n\t\tbreak;\n\tcase TARGET_RENAME_2:\n\t\tBUG_ON(super->s_rename_dir != ta->dir);\n\t\tBUG_ON(super->s_rename_pos != ta->pos);\n\t\tBUG_ON(super->s_victim_ino != ta->ino);\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tbreak;\n\tcase TARGET_RENAME_3:\n\t\tBUG_ON(super->s_rename_dir);\n\t\tBUG_ON(super->s_rename_pos);\n\t\tBUG_ON(super->s_victim_ino != ta->ino);\n\t\tsuper->s_victim_ino = 0;\n\t\tkfree(ta);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "block->alias_map",
            "LOGFS_BLOCK_FACTOR"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "page"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "inode->i_sb"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void fill_shadow_tree(struct inode *inode, struct page *page,\n\t\tstruct logfs_shadow *shadow)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_block *block = logfs_block(page);\n\tstruct shadow_tree *tree = &super->s_shadow_tree;\n\n\tif (PagePrivate(page)) {\n\t\tif (block->alias_map)\n\t\t\tsuper->s_no_object_aliases -= bitmap_weight(\n\t\t\t\t\tblock->alias_map, LOGFS_BLOCK_FACTOR);\n\t\tlogfs_handle_transaction(inode, block->ta);\n\t\tblock->ops->free_block(inode->i_sb, block);\n\t}\n\tif (shadow) {\n\t\tif (shadow->old_ofs)\n\t\t\tbtree_insert64(&tree->old, shadow->old_ofs, shadow,\n\t\t\t\t\tGFP_NOFS);\n\t\telse\n\t\t\tbtree_insert64(&tree->new, shadow->new_ofs, shadow,\n\t\t\t\t\tGFP_NOFS);\n\n\t\tsuper->s_dirty_used_bytes += shadow->new_len;\n\t\tsuper->s_dirty_free_bytes += shadow->old_len;\n\t\tmark_segment(tree, shadow->old_ofs >> super->s_segshift);\n\t\tmark_segment(tree, shadow->new_ofs >> super->s_segshift);\n\t}\n}"
  },
  {
    "function_name": "mark_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1239-1249",
    "snippet": "static void mark_segment(struct shadow_tree *tree, u32 segno)\n{\n\tint err;\n\n\tif (!btree_lookup32(&tree->segment_map, segno)) {\n\t\terr = btree_insert32(&tree->segment_map, segno, (void *)1,\n\t\t\t\tGFP_NOFS);\n\t\tBUG_ON(err);\n\t\ttree->no_shadowed_segments++;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_insert32",
          "args": [
            "&tree->segment_map",
            "segno",
            "(void *)1",
            "GFP_NOFS"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_lookup32",
          "args": [
            "&tree->segment_map",
            "segno"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void mark_segment(struct shadow_tree *tree, u32 segno)\n{\n\tint err;\n\n\tif (!btree_lookup32(&tree->segment_map, segno)) {\n\t\terr = btree_insert32(&tree->segment_map, segno, (void *)1,\n\t\t\t\tGFP_NOFS);\n\t\tBUG_ON(err);\n\t\ttree->no_shadowed_segments++;\n\t}\n}"
  },
  {
    "function_name": "free_shadow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1232-1237",
    "snippet": "static void free_shadow(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\n\tmempool_free(shadow, super->s_shadow_pool);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "shadow",
            "super->s_shadow_pool"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "inode->i_sb"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void free_shadow(struct inode *inode, struct logfs_shadow *shadow)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\n\tmempool_free(shadow, super->s_shadow_pool);\n}"
  },
  {
    "function_name": "alloc_shadow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1217-1230",
    "snippet": "static struct logfs_shadow *alloc_shadow(struct inode *inode, u64 bix,\n\t\tlevel_t level, u64 old_ofs)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_shadow *shadow;\n\n\tshadow = mempool_alloc(super->s_shadow_pool, GFP_NOFS);\n\tmemset(shadow, 0, sizeof(*shadow));\n\tshadow->ino = inode->i_ino;\n\tshadow->bix = bix;\n\tshadow->gc_level = expand_level(inode->i_ino, level);\n\tshadow->old_ofs = old_ofs & ~LOGFS_FULLY_POPULATED;\n\treturn shadow;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expand_level",
          "args": [
            "inode->i_ino",
            "level"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "expand_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "702-711",
          "snippet": "static inline gc_level_t expand_level(u64 ino, level_t __level)\n{\n\tu8 level = (__force u8)__level;\n\n\tif (ino == LOGFS_INO_MASTER) {\n\t\t/* ifile has separate areas */\n\t\tlevel += LOGFS_MAX_LEVELS;\n\t}\n\treturn (__force gc_level_t)level;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline gc_level_t expand_level(u64 ino, level_t __level)\n{\n\tu8 level = (__force u8)__level;\n\n\tif (ino == LOGFS_INO_MASTER) {\n\t\t/* ifile has separate areas */\n\t\tlevel += LOGFS_MAX_LEVELS;\n\t}\n\treturn (__force gc_level_t)level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "shadow",
            "0",
            "sizeof(*shadow)"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_alloc",
          "args": [
            "super->s_shadow_pool",
            "GFP_NOFS"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "inode->i_sb"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_shadow *alloc_shadow(struct inode *inode, u64 bix,\n\t\tlevel_t level, u64 old_ofs)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_shadow *shadow;\n\n\tshadow = mempool_alloc(super->s_shadow_pool, GFP_NOFS);\n\tmemset(shadow, 0, sizeof(*shadow));\n\tshadow->ino = inode->i_ino;\n\tshadow->bix = bix;\n\tshadow->gc_level = expand_level(inode->i_ino, level);\n\tshadow->old_ofs = old_ofs & ~LOGFS_FULLY_POPULATED;\n\treturn shadow;\n}"
  },
  {
    "function_name": "logfs_reserve_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1207-1210",
    "snippet": "static int logfs_reserve_blocks(struct inode *inode, int blocks)\n{\n\treturn logfs_reserve_bytes(inode, blocks * LOGFS_MAX_OBJECTSIZE);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_reserve_bytes",
          "args": [
            "inode",
            "blocks * LOGFS_MAX_OBJECTSIZE"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_reserve_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1082-1099",
          "snippet": "static int logfs_reserve_bytes(struct inode *inode, int bytes)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tu64 available = super->s_free_bytes + super->s_dirty_free_bytes\n\t\t\t- super->s_dirty_used_bytes - super->s_dirty_pages;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tif (available < bytes)\n\t\treturn -ENOSPC;\n\n\tif (available < bytes + super->s_root_reserve &&\n\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_reserve_bytes(struct inode *inode, int bytes)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tu64 available = super->s_free_bytes + super->s_dirty_free_bytes\n\t\t\t- super->s_dirty_used_bytes - super->s_dirty_pages;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tif (available < bytes)\n\t\treturn -ENOSPC;\n\n\tif (available < bytes + super->s_root_reserve &&\n\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_reserve_blocks(struct inode *inode, int blocks)\n{\n\treturn logfs_reserve_bytes(inode, blocks * LOGFS_MAX_OBJECTSIZE);\n}"
  },
  {
    "function_name": "logfs_handle_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1133-1201",
    "snippet": "static void logfs_handle_transaction(struct inode *inode,\n\t\tstruct logfs_transaction *ta)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\n\tif (!ta)\n\t\treturn;\n\tlogfs_inode(inode)->li_block->ta = NULL;\n\n\tif (inode->i_ino != LOGFS_INO_MASTER) {\n\t\tBUG(); /* FIXME: Yes, this needs more thought */\n\t\t/* just remember the transaction until inode is written */\n\t\t//BUG_ON(logfs_inode(inode)->li_transaction);\n\t\t//logfs_inode(inode)->li_transaction = ta;\n\t\treturn;\n\t}\n\n\tswitch (ta->state) {\n\tcase CREATE_1: /* fall through */\n\tcase UNLINK_1:\n\t\tBUG_ON(super->s_victim_ino);\n\t\tsuper->s_victim_ino = ta->ino;\n\t\tbreak;\n\tcase CREATE_2: /* fall through */\n\tcase UNLINK_2:\n\t\tBUG_ON(super->s_victim_ino != ta->ino);\n\t\tsuper->s_victim_ino = 0;\n\t\t/* transaction ends here - free it */\n\t\tkfree(ta);\n\t\tbreak;\n\tcase CROSS_RENAME_1:\n\t\tBUG_ON(super->s_rename_dir);\n\t\tBUG_ON(super->s_rename_pos);\n\t\tsuper->s_rename_dir = ta->dir;\n\t\tsuper->s_rename_pos = ta->pos;\n\t\tbreak;\n\tcase CROSS_RENAME_2:\n\t\tBUG_ON(super->s_rename_dir != ta->dir);\n\t\tBUG_ON(super->s_rename_pos != ta->pos);\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tkfree(ta);\n\t\tbreak;\n\tcase TARGET_RENAME_1:\n\t\tBUG_ON(super->s_rename_dir);\n\t\tBUG_ON(super->s_rename_pos);\n\t\tBUG_ON(super->s_victim_ino);\n\t\tsuper->s_rename_dir = ta->dir;\n\t\tsuper->s_rename_pos = ta->pos;\n\t\tsuper->s_victim_ino = ta->ino;\n\t\tbreak;\n\tcase TARGET_RENAME_2:\n\t\tBUG_ON(super->s_rename_dir != ta->dir);\n\t\tBUG_ON(super->s_rename_pos != ta->pos);\n\t\tBUG_ON(super->s_victim_ino != ta->ino);\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tbreak;\n\tcase TARGET_RENAME_3:\n\t\tBUG_ON(super->s_rename_dir);\n\t\tBUG_ON(super->s_rename_pos);\n\t\tBUG_ON(super->s_victim_ino != ta->ino);\n\t\tsuper->s_victim_ino = 0;\n\t\tkfree(ta);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ta"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_victim_ino != ta->ino"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_rename_pos"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_rename_dir"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_victim_ino != ta->ino"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_rename_pos != ta->pos"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_rename_dir != ta->dir"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_victim_ino"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_rename_pos"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_rename_dir"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ta"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_rename_pos != ta->pos"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_rename_dir != ta->dir"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_rename_pos"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_rename_dir"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ta"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_victim_ino != ta->ino"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_victim_ino"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "inode->i_sb"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_handle_transaction(struct inode *inode,\n\t\tstruct logfs_transaction *ta)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\n\tif (!ta)\n\t\treturn;\n\tlogfs_inode(inode)->li_block->ta = NULL;\n\n\tif (inode->i_ino != LOGFS_INO_MASTER) {\n\t\tBUG(); /* FIXME: Yes, this needs more thought */\n\t\t/* just remember the transaction until inode is written */\n\t\t//BUG_ON(logfs_inode(inode)->li_transaction);\n\t\t//logfs_inode(inode)->li_transaction = ta;\n\t\treturn;\n\t}\n\n\tswitch (ta->state) {\n\tcase CREATE_1: /* fall through */\n\tcase UNLINK_1:\n\t\tBUG_ON(super->s_victim_ino);\n\t\tsuper->s_victim_ino = ta->ino;\n\t\tbreak;\n\tcase CREATE_2: /* fall through */\n\tcase UNLINK_2:\n\t\tBUG_ON(super->s_victim_ino != ta->ino);\n\t\tsuper->s_victim_ino = 0;\n\t\t/* transaction ends here - free it */\n\t\tkfree(ta);\n\t\tbreak;\n\tcase CROSS_RENAME_1:\n\t\tBUG_ON(super->s_rename_dir);\n\t\tBUG_ON(super->s_rename_pos);\n\t\tsuper->s_rename_dir = ta->dir;\n\t\tsuper->s_rename_pos = ta->pos;\n\t\tbreak;\n\tcase CROSS_RENAME_2:\n\t\tBUG_ON(super->s_rename_dir != ta->dir);\n\t\tBUG_ON(super->s_rename_pos != ta->pos);\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tkfree(ta);\n\t\tbreak;\n\tcase TARGET_RENAME_1:\n\t\tBUG_ON(super->s_rename_dir);\n\t\tBUG_ON(super->s_rename_pos);\n\t\tBUG_ON(super->s_victim_ino);\n\t\tsuper->s_rename_dir = ta->dir;\n\t\tsuper->s_rename_pos = ta->pos;\n\t\tsuper->s_victim_ino = ta->ino;\n\t\tbreak;\n\tcase TARGET_RENAME_2:\n\t\tBUG_ON(super->s_rename_dir != ta->dir);\n\t\tBUG_ON(super->s_rename_pos != ta->pos);\n\t\tBUG_ON(super->s_victim_ino != ta->ino);\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\tbreak;\n\tcase TARGET_RENAME_3:\n\t\tBUG_ON(super->s_rename_dir);\n\t\tBUG_ON(super->s_rename_pos);\n\t\tBUG_ON(super->s_victim_ino != ta->ino);\n\t\tsuper->s_victim_ino = 0;\n\t\tkfree(ta);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "get_page_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1101-1126",
    "snippet": "int get_page_reserve(struct inode *inode, struct page *page)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_block *block = logfs_block(page);\n\tint ret;\n\n\tif (block && block->reserved_bytes)\n\t\treturn 0;\n\n\tlogfs_get_wblocks(inode->i_sb, page, WF_LOCK);\n\twhile ((ret = logfs_reserve_bytes(inode, 6 * LOGFS_MAX_OBJECTSIZE)) &&\n\t\t\t!list_empty(&super->s_writeback_list)) {\n\t\tblock = list_entry(super->s_writeback_list.next,\n\t\t\t\tstruct logfs_block, alias_list);\n\t\tblock->ops->write_block(block);\n\t}\n\tif (!ret) {\n\t\talloc_data_block(inode, page);\n\t\tblock = logfs_block(page);\n\t\tblock->reserved_bytes += 6 * LOGFS_MAX_OBJECTSIZE;\n\t\tsuper->s_dirty_pages += 6 * LOGFS_MAX_OBJECTSIZE;\n\t\tlist_move_tail(&block->alias_list, &super->s_writeback_list);\n\t}\n\tlogfs_put_wblocks(inode->i_sb, page, WF_LOCK);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_wblocks",
          "args": [
            "inode->i_sb",
            "page",
            "WF_LOCK"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "262-272",
          "snippet": "void logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&block->alias_list",
            "&super->s_writeback_list"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "page"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_data_block",
          "args": [
            "inode",
            "page"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_data_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "644-662",
          "snippet": "static void alloc_data_block(struct inode *inode, struct page *page)\n{\n\tstruct logfs_block *block;\n\tu64 bix;\n\tlevel_t level;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tblock = __alloc_block(inode->i_sb, inode->i_ino, bix, level);\n\tblock->page = page;\n\n\tSetPagePrivate(page);\n\tpage_cache_get(page);\n\tset_page_private(page, (unsigned long) block);\n\n\tblock->ops = &indirect_block_ops;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct logfs_block_ops indirect_block_ops = {\n\t.write_block = indirect_write_block,\n\t.free_block = indirect_free_block,\n\t.write_alias = indirect_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstruct logfs_block_ops indirect_block_ops = {\n\t.write_block = indirect_write_block,\n\t.free_block = indirect_free_block,\n\t.write_alias = indirect_write_alias,\n};\n\nstatic void alloc_data_block(struct inode *inode, struct page *page)\n{\n\tstruct logfs_block *block;\n\tu64 bix;\n\tlevel_t level;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tblock = __alloc_block(inode->i_sb, inode->i_ino, bix, level);\n\tblock->page = page;\n\n\tSetPagePrivate(page);\n\tpage_cache_get(page);\n\tset_page_private(page, (unsigned long) block);\n\n\tblock->ops = &indirect_block_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block->ops->write_block",
          "args": [
            "block"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "super->s_writeback_list.next",
            "structlogfs_block",
            "alias_list"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&super->s_writeback_list"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_reserve_bytes",
          "args": [
            "inode",
            "6 * LOGFS_MAX_OBJECTSIZE"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_reserve_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1082-1099",
          "snippet": "static int logfs_reserve_bytes(struct inode *inode, int bytes)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tu64 available = super->s_free_bytes + super->s_dirty_free_bytes\n\t\t\t- super->s_dirty_used_bytes - super->s_dirty_pages;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tif (available < bytes)\n\t\treturn -ENOSPC;\n\n\tif (available < bytes + super->s_root_reserve &&\n\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_reserve_bytes(struct inode *inode, int bytes)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tu64 available = super->s_free_bytes + super->s_dirty_free_bytes\n\t\t\t- super->s_dirty_used_bytes - super->s_dirty_pages;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tif (available < bytes)\n\t\treturn -ENOSPC;\n\n\tif (available < bytes + super->s_root_reserve &&\n\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_wblocks",
          "args": [
            "inode->i_sb",
            "page",
            "WF_LOCK"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "247-260",
          "snippet": "void logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "inode->i_sb"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint get_page_reserve(struct inode *inode, struct page *page)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_block *block = logfs_block(page);\n\tint ret;\n\n\tif (block && block->reserved_bytes)\n\t\treturn 0;\n\n\tlogfs_get_wblocks(inode->i_sb, page, WF_LOCK);\n\twhile ((ret = logfs_reserve_bytes(inode, 6 * LOGFS_MAX_OBJECTSIZE)) &&\n\t\t\t!list_empty(&super->s_writeback_list)) {\n\t\tblock = list_entry(super->s_writeback_list.next,\n\t\t\t\tstruct logfs_block, alias_list);\n\t\tblock->ops->write_block(block);\n\t}\n\tif (!ret) {\n\t\talloc_data_block(inode, page);\n\t\tblock = logfs_block(page);\n\t\tblock->reserved_bytes += 6 * LOGFS_MAX_OBJECTSIZE;\n\t\tsuper->s_dirty_pages += 6 * LOGFS_MAX_OBJECTSIZE;\n\t\tlist_move_tail(&block->alias_list, &super->s_writeback_list);\n\t}\n\tlogfs_put_wblocks(inode->i_sb, page, WF_LOCK);\n\treturn ret;\n}"
  },
  {
    "function_name": "logfs_reserve_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1082-1099",
    "snippet": "static int logfs_reserve_bytes(struct inode *inode, int bytes)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tu64 available = super->s_free_bytes + super->s_dirty_free_bytes\n\t\t\t- super->s_dirty_used_bytes - super->s_dirty_pages;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tif (available < bytes)\n\t\treturn -ENOSPC;\n\n\tif (available < bytes + super->s_root_reserve &&\n\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "inode->i_sb"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_reserve_bytes(struct inode *inode, int bytes)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tu64 available = super->s_free_bytes + super->s_dirty_free_bytes\n\t\t\t- super->s_dirty_used_bytes - super->s_dirty_pages;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tif (available < bytes)\n\t\treturn -ENOSPC;\n\n\tif (available < bytes + super->s_root_reserve &&\n\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_readpage_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1063-1080",
    "snippet": "int logfs_readpage_nolock(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EIO;\n\n\tret = logfs_read_block(inode, page, READ);\n\n\tif (ret) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t} else {\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\tflush_dcache_page(page);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_read_block",
          "args": [
            "inode",
            "page",
            "READ"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "767-775",
          "snippet": "static int logfs_read_block(struct inode *inode, struct page *page,\n\t\tint rw_context)\n{\n\tpgoff_t index = page->index;\n\n\tif (index < I0_BLOCKS)\n\t\treturn logfs_read_direct(inode, page);\n\treturn logfs_read_loop(inode, page, rw_context);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_block(struct inode *inode, struct page *page,\n\t\tint rw_context)\n{\n\tpgoff_t index = page->index;\n\n\tif (index < I0_BLOCKS)\n\t\treturn logfs_read_direct(inode, page);\n\treturn logfs_read_loop(inode, page, rw_context);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_readpage_nolock(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EIO;\n\n\tret = logfs_read_block(inode, page, READ);\n\n\tif (ret) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t} else {\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\tflush_dcache_page(page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "logfs_is_valid_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1031-1061",
    "snippet": "int logfs_is_valid_block(struct super_block *sb, u64 ofs, u64 ino, u64 bix,\n\t\tgc_level_t gc_level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tint ret, cookie;\n\n\t/* Umount closes a segment with free blocks remaining.  Those\n\t * blocks are by definition invalid. */\n\tif (ino == -1)\n\t\treturn 0;\n\n\tLOGFS_BUG_ON((u64)(u_long)ino != ino, sb);\n\n\tinode = logfs_safe_iget(sb, ino, &cookie);\n\tif (IS_ERR(inode))\n\t\tgoto invalid;\n\n\tret = __logfs_is_valid_block(inode, bix, ofs);\n\tlogfs_safe_iput(inode, cookie);\n\tif (ret)\n\t\treturn ret;\n\ninvalid:\n\t/* Block is nominally invalid, but may still sit in the shadow tree,\n\t * waiting for a journal commit.\n\t */\n\tif (btree_lookup64(&super->s_shadow_tree.old, ofs))\n\t\treturn 2;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btree_lookup64",
          "args": [
            "&super->s_shadow_tree.old",
            "ofs"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_safe_iput",
          "args": [
            "inode",
            "cookie"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_safe_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "187-200",
          "snippet": "void logfs_safe_iput(struct inode *inode, int is_cached)\n{\n\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\treturn;\n\tif (inode->i_ino == LOGFS_INO_SEGFILE)\n\t\treturn;\n\n\tif (is_cached) {\n\t\tlogfs_destroy_inode(inode);\n\t\treturn;\n\t}\n\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_safe_iput(struct inode *inode, int is_cached)\n{\n\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\treturn;\n\tif (inode->i_ino == LOGFS_INO_SEGFILE)\n\t\treturn;\n\n\tif (is_cached) {\n\t\tlogfs_destroy_inode(inode);\n\t\treturn;\n\t}\n\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_is_valid_block",
          "args": [
            "inode",
            "bix",
            "ofs"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_is_valid_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1007-1017",
          "snippet": "static int __logfs_is_valid_block(struct inode *inode, u64 bix, u64 ofs)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif ((inode->i_nlink == 0) && atomic_read(&inode->i_count) == 1)\n\t\treturn 0;\n\n\tif (bix < I0_BLOCKS)\n\t\treturn logfs_is_valid_direct(li, bix, ofs);\n\treturn logfs_is_valid_loop(inode, bix, ofs);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_is_valid_block(struct inode *inode, u64 bix, u64 ofs)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif ((inode->i_nlink == 0) && atomic_read(&inode->i_count) == 1)\n\t\treturn 0;\n\n\tif (bix < I0_BLOCKS)\n\t\treturn logfs_is_valid_direct(li, bix, ofs);\n\treturn logfs_is_valid_loop(inode, bix, ofs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_safe_iget",
          "args": [
            "sb",
            "ino",
            "&cookie"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_safe_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "120-142",
          "snippet": "struct inode *logfs_safe_iget(struct super_block *sb, ino_t ino, int *is_cached)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_inode *li;\n\n\tif (ino == LOGFS_INO_MASTER)\n\t\treturn super->s_master_inode;\n\tif (ino == LOGFS_INO_SEGFILE)\n\t\treturn super->s_segfile_inode;\n\n\tspin_lock(&logfs_inode_lock);\n\tlist_for_each_entry(li, &super->s_freeing_list, li_freeing_list)\n\t\tif (li->vfs_inode.i_ino == ino) {\n\t\t\tli->li_refcount++;\n\t\t\tspin_unlock(&logfs_inode_lock);\n\t\t\t*is_cached = 1;\n\t\t\treturn &li->vfs_inode;\n\t\t}\n\tspin_unlock(&logfs_inode_lock);\n\n\t*is_cached = 0;\n\treturn __logfs_iget(sb, ino);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(logfs_inode_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic DEFINE_SPINLOCK(logfs_inode_lock);\n\nstruct inode *logfs_safe_iget(struct super_block *sb, ino_t ino, int *is_cached)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_inode *li;\n\n\tif (ino == LOGFS_INO_MASTER)\n\t\treturn super->s_master_inode;\n\tif (ino == LOGFS_INO_SEGFILE)\n\t\treturn super->s_segfile_inode;\n\n\tspin_lock(&logfs_inode_lock);\n\tlist_for_each_entry(li, &super->s_freeing_list, li_freeing_list)\n\t\tif (li->vfs_inode.i_ino == ino) {\n\t\t\tli->li_refcount++;\n\t\t\tspin_unlock(&logfs_inode_lock);\n\t\t\t*is_cached = 1;\n\t\t\treturn &li->vfs_inode;\n\t\t}\n\tspin_unlock(&logfs_inode_lock);\n\n\t*is_cached = 0;\n\treturn __logfs_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGFS_BUG_ON",
          "args": [
            "(u64)(u_long)ino != ino",
            "sb"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_is_valid_block(struct super_block *sb, u64 ofs, u64 ino, u64 bix,\n\t\tgc_level_t gc_level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tint ret, cookie;\n\n\t/* Umount closes a segment with free blocks remaining.  Those\n\t * blocks are by definition invalid. */\n\tif (ino == -1)\n\t\treturn 0;\n\n\tLOGFS_BUG_ON((u64)(u_long)ino != ino, sb);\n\n\tinode = logfs_safe_iget(sb, ino, &cookie);\n\tif (IS_ERR(inode))\n\t\tgoto invalid;\n\n\tret = __logfs_is_valid_block(inode, bix, ofs);\n\tlogfs_safe_iput(inode, cookie);\n\tif (ret)\n\t\treturn ret;\n\ninvalid:\n\t/* Block is nominally invalid, but may still sit in the shadow tree,\n\t * waiting for a journal commit.\n\t */\n\tif (btree_lookup64(&super->s_shadow_tree.old, ofs))\n\t\treturn 2;\n\treturn 0;\n}"
  },
  {
    "function_name": "__logfs_is_valid_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "1007-1017",
    "snippet": "static int __logfs_is_valid_block(struct inode *inode, u64 bix, u64 ofs)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif ((inode->i_nlink == 0) && atomic_read(&inode->i_count) == 1)\n\t\treturn 0;\n\n\tif (bix < I0_BLOCKS)\n\t\treturn logfs_is_valid_direct(li, bix, ofs);\n\treturn logfs_is_valid_loop(inode, bix, ofs);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_is_valid_loop",
          "args": [
            "inode",
            "bix",
            "ofs"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_is_valid_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "990-1005",
          "snippet": "static int logfs_is_valid_loop(struct inode *inode, u64 bix, u64 ofs)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 bofs = li->li_data[INDIRECT_INDEX];\n\n\tif (!bofs)\n\t\treturn 0;\n\n\tif (bix >= maxbix(li->li_height))\n\t\treturn 0;\n\n\tif (pure_ofs(bofs) == ofs)\n\t\treturn 1;\n\n\treturn __logfs_is_valid_loop(inode, bix, ofs, bofs);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_is_valid_loop(struct inode *inode, u64 bix, u64 ofs)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 bofs = li->li_data[INDIRECT_INDEX];\n\n\tif (!bofs)\n\t\treturn 0;\n\n\tif (bix >= maxbix(li->li_height))\n\t\treturn 0;\n\n\tif (pure_ofs(bofs) == ofs)\n\t\treturn 1;\n\n\treturn __logfs_is_valid_loop(inode, bix, ofs, bofs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_is_valid_direct",
          "args": [
            "li",
            "bix",
            "ofs"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_is_valid_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "956-959",
          "snippet": "static int logfs_is_valid_direct(struct logfs_inode *li, u64 bix, u64 ofs)\n{\n\treturn pure_ofs(li->li_data[bix]) == ofs;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_is_valid_direct(struct logfs_inode *li, u64 bix, u64 ofs)\n{\n\treturn pure_ofs(li->li_data[bix]) == ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_is_valid_block(struct inode *inode, u64 bix, u64 ofs)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif ((inode->i_nlink == 0) && atomic_read(&inode->i_count) == 1)\n\t\treturn 0;\n\n\tif (bix < I0_BLOCKS)\n\t\treturn logfs_is_valid_direct(li, bix, ofs);\n\treturn logfs_is_valid_loop(inode, bix, ofs);\n}"
  },
  {
    "function_name": "logfs_is_valid_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "990-1005",
    "snippet": "static int logfs_is_valid_loop(struct inode *inode, u64 bix, u64 ofs)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 bofs = li->li_data[INDIRECT_INDEX];\n\n\tif (!bofs)\n\t\treturn 0;\n\n\tif (bix >= maxbix(li->li_height))\n\t\treturn 0;\n\n\tif (pure_ofs(bofs) == ofs)\n\t\treturn 1;\n\n\treturn __logfs_is_valid_loop(inode, bix, ofs, bofs);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_is_valid_loop",
          "args": [
            "inode",
            "bix",
            "ofs",
            "bofs"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_is_valid_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "961-988",
          "snippet": "static int __logfs_is_valid_loop(struct inode *inode, u64 bix,\n\t\tu64 ofs, u64 bofs)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tlevel_t level;\n\tint ret;\n\tstruct page *page;\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)){\n\t\tpage = logfs_get_write_page(inode, bix, level);\n\t\tBUG_ON(!page);\n\n\t\tret = logfs_segment_read(inode, page, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_write_page(page);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbofs = block_get_pointer(page, get_bits(bix, SUBLEVEL(level)));\n\t\tlogfs_put_write_page(page);\n\t\tif (!bofs)\n\t\t\treturn 0;\n\n\t\tif (pure_ofs(bofs) == ofs)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_is_valid_loop(struct inode *inode, u64 bix,\n\t\tu64 ofs, u64 bofs)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tlevel_t level;\n\tint ret;\n\tstruct page *page;\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)){\n\t\tpage = logfs_get_write_page(inode, bix, level);\n\t\tBUG_ON(!page);\n\n\t\tret = logfs_segment_read(inode, page, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_write_page(page);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbofs = block_get_pointer(page, get_bits(bix, SUBLEVEL(level)));\n\t\tlogfs_put_write_page(page);\n\t\tif (!bofs)\n\t\t\treturn 0;\n\n\t\tif (pure_ofs(bofs) == ofs)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pure_ofs",
          "args": [
            "bofs"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maxbix",
          "args": [
            "li->li_height"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "maxbix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "44-47",
          "snippet": "static inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_is_valid_loop(struct inode *inode, u64 bix, u64 ofs)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 bofs = li->li_data[INDIRECT_INDEX];\n\n\tif (!bofs)\n\t\treturn 0;\n\n\tif (bix >= maxbix(li->li_height))\n\t\treturn 0;\n\n\tif (pure_ofs(bofs) == ofs)\n\t\treturn 1;\n\n\treturn __logfs_is_valid_loop(inode, bix, ofs, bofs);\n}"
  },
  {
    "function_name": "__logfs_is_valid_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "961-988",
    "snippet": "static int __logfs_is_valid_loop(struct inode *inode, u64 bix,\n\t\tu64 ofs, u64 bofs)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tlevel_t level;\n\tint ret;\n\tstruct page *page;\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)){\n\t\tpage = logfs_get_write_page(inode, bix, level);\n\t\tBUG_ON(!page);\n\n\t\tret = logfs_segment_read(inode, page, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_write_page(page);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbofs = block_get_pointer(page, get_bits(bix, SUBLEVEL(level)));\n\t\tlogfs_put_write_page(page);\n\t\tif (!bofs)\n\t\t\treturn 0;\n\n\t\tif (pure_ofs(bofs) == ofs)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pure_ofs",
          "args": [
            "bofs"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_get_pointer",
          "args": [
            "page",
            "get_bits(bix, SUBLEVEL(level))"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "block_get_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "699-708",
          "snippet": "static u64 block_get_pointer(struct page *page, int index)\n{\n\t__be64 *block;\n\tu64 ptr;\n\n\tblock = kmap_atomic(page);\n\tptr = be64_to_cpu(block[index]);\n\tkunmap_atomic(block);\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 block_get_pointer(struct page *page, int index)\n{\n\t__be64 *block;\n\tu64 ptr;\n\n\tblock = kmap_atomic(page);\n\tptr = be64_to_cpu(block[index]);\n\tkunmap_atomic(block);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bits",
          "args": [
            "bix",
            "SUBLEVEL(level)"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "get_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "375-378",
          "snippet": "static unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_segment_read",
          "args": [
            "inode",
            "page",
            "bofs",
            "bix",
            "level"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "656-677",
          "snippet": "int logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "inode",
            "bix",
            "level"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "li->li_height"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_is_valid_loop(struct inode *inode, u64 bix,\n\t\tu64 ofs, u64 bofs)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tlevel_t level;\n\tint ret;\n\tstruct page *page;\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)){\n\t\tpage = logfs_get_write_page(inode, bix, level);\n\t\tBUG_ON(!page);\n\n\t\tret = logfs_segment_read(inode, page, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_write_page(page);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbofs = block_get_pointer(page, get_bits(bix, SUBLEVEL(level)));\n\t\tlogfs_put_write_page(page);\n\t\tif (!bofs)\n\t\t\treturn 0;\n\n\t\tif (pure_ofs(bofs) == ofs)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_is_valid_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "956-959",
    "snippet": "static int logfs_is_valid_direct(struct logfs_inode *li, u64 bix, u64 ofs)\n{\n\treturn pure_ofs(li->li_data[bix]) == ofs;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pure_ofs",
          "args": [
            "li->li_data[bix]"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_is_valid_direct(struct logfs_inode *li, u64 bix, u64 ofs)\n{\n\treturn pure_ofs(li->li_data[bix]) == ofs;\n}"
  },
  {
    "function_name": "logfs_seek_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "944-954",
    "snippet": "u64 logfs_seek_data(struct inode *inode, u64 bix)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu64 ret, end;\n\n\tret = __logfs_seek_data(inode, bix);\n\tend = i_size_read(inode) >> sb->s_blocksize_bits;\n\tif (ret >= end)\n\t\tret = max(bix, end);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "bix",
            "end"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__logfs_seek_data",
          "args": [
            "inode",
            "bix"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_seek_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "916-934",
          "snippet": "static u64 __logfs_seek_data(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS) {\n\t\tbix = seek_holedata_direct(inode, bix, 1);\n\t\tif (bix < I0_BLOCKS)\n\t\t\treturn bix;\n\t}\n\n\tif (bix < maxbix(li->li_height)) {\n\t\tif (!li->li_data[INDIRECT_INDEX])\n\t\t\tbix = maxbix(li->li_height);\n\t\telse\n\t\t\treturn seek_holedata_loop(inode, bix, 1);\n\t}\n\n\treturn bix;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 __logfs_seek_data(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS) {\n\t\tbix = seek_holedata_direct(inode, bix, 1);\n\t\tif (bix < I0_BLOCKS)\n\t\t\treturn bix;\n\t}\n\n\tif (bix < maxbix(li->li_height)) {\n\t\tif (!li->li_data[INDIRECT_INDEX])\n\t\t\tbix = maxbix(li->li_height);\n\t\telse\n\t\t\treturn seek_holedata_loop(inode, bix, 1);\n\t}\n\n\treturn bix;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nu64 logfs_seek_data(struct inode *inode, u64 bix)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu64 ret, end;\n\n\tret = __logfs_seek_data(inode, bix);\n\tend = i_size_read(inode) >> sb->s_blocksize_bits;\n\tif (ret >= end)\n\t\tret = max(bix, end);\n\treturn ret;\n}"
  },
  {
    "function_name": "__logfs_seek_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "916-934",
    "snippet": "static u64 __logfs_seek_data(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS) {\n\t\tbix = seek_holedata_direct(inode, bix, 1);\n\t\tif (bix < I0_BLOCKS)\n\t\t\treturn bix;\n\t}\n\n\tif (bix < maxbix(li->li_height)) {\n\t\tif (!li->li_data[INDIRECT_INDEX])\n\t\t\tbix = maxbix(li->li_height);\n\t\telse\n\t\t\treturn seek_holedata_loop(inode, bix, 1);\n\t}\n\n\treturn bix;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seek_holedata_loop",
          "args": [
            "inode",
            "bix",
            "1"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "seek_holedata_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "829-877",
          "snippet": "static u64 seek_holedata_loop(struct inode *inode, u64 bix, int data)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\t__be64 *rblock;\n\tu64 increment, bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level;\n\tint ret, slot;\n\tstruct page *page;\n\n\tBUG_ON(!bofs);\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)) {\n\t\tincrement = 1 << (LOGFS_BLOCK_BITS * ((__force u8)level-1));\n\t\tpage = logfs_get_read_page(inode, bix, level);\n\t\tif (!page)\n\t\t\treturn bix;\n\n\t\tret = logfs_segment_read(inode, page, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(page);\n\t\t\treturn bix;\n\t\t}\n\n\t\tslot = get_bits(bix, SUBLEVEL(level));\n\t\trblock = kmap_atomic(page);\n\t\twhile (slot < LOGFS_BLOCK_FACTOR) {\n\t\t\tif (data && (rblock[slot] != 0))\n\t\t\t\tbreak;\n\t\t\tif (!data && !(be64_to_cpu(rblock[slot]) & LOGFS_FULLY_POPULATED))\n\t\t\t\tbreak;\n\t\t\tslot++;\n\t\t\tbix += increment;\n\t\t\tbix &= ~(increment - 1);\n\t\t}\n\t\tif (slot >= LOGFS_BLOCK_FACTOR) {\n\t\t\tkunmap_atomic(rblock);\n\t\t\tlogfs_put_read_page(page);\n\t\t\treturn bix;\n\t\t}\n\t\tbofs = be64_to_cpu(rblock[slot]);\n\t\tkunmap_atomic(rblock);\n\t\tlogfs_put_read_page(page);\n\t\tif (!bofs) {\n\t\t\tBUG_ON(data);\n\t\t\treturn bix;\n\t\t}\n\t}\n\treturn bix;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 seek_holedata_loop(struct inode *inode, u64 bix, int data)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\t__be64 *rblock;\n\tu64 increment, bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level;\n\tint ret, slot;\n\tstruct page *page;\n\n\tBUG_ON(!bofs);\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)) {\n\t\tincrement = 1 << (LOGFS_BLOCK_BITS * ((__force u8)level-1));\n\t\tpage = logfs_get_read_page(inode, bix, level);\n\t\tif (!page)\n\t\t\treturn bix;\n\n\t\tret = logfs_segment_read(inode, page, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(page);\n\t\t\treturn bix;\n\t\t}\n\n\t\tslot = get_bits(bix, SUBLEVEL(level));\n\t\trblock = kmap_atomic(page);\n\t\twhile (slot < LOGFS_BLOCK_FACTOR) {\n\t\t\tif (data && (rblock[slot] != 0))\n\t\t\t\tbreak;\n\t\t\tif (!data && !(be64_to_cpu(rblock[slot]) & LOGFS_FULLY_POPULATED))\n\t\t\t\tbreak;\n\t\t\tslot++;\n\t\t\tbix += increment;\n\t\t\tbix &= ~(increment - 1);\n\t\t}\n\t\tif (slot >= LOGFS_BLOCK_FACTOR) {\n\t\t\tkunmap_atomic(rblock);\n\t\t\tlogfs_put_read_page(page);\n\t\t\treturn bix;\n\t\t}\n\t\tbofs = be64_to_cpu(rblock[slot]);\n\t\tkunmap_atomic(rblock);\n\t\tlogfs_put_read_page(page);\n\t\tif (!bofs) {\n\t\t\tBUG_ON(data);\n\t\t\treturn bix;\n\t\t}\n\t}\n\treturn bix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "maxbix",
          "args": [
            "li->li_height"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "maxbix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "44-47",
          "snippet": "static inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seek_holedata_direct",
          "args": [
            "inode",
            "bix",
            "1"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "seek_holedata_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "819-827",
          "snippet": "static u64 seek_holedata_direct(struct inode *inode, u64 bix, int data)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tfor (; bix < I0_BLOCKS; bix++)\n\t\tif (data ^ (li->li_data[bix] == 0))\n\t\t\treturn bix;\n\treturn I0_BLOCKS;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 seek_holedata_direct(struct inode *inode, u64 bix, int data)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tfor (; bix < I0_BLOCKS; bix++)\n\t\tif (data ^ (li->li_data[bix] == 0))\n\t\t\treturn bix;\n\treturn I0_BLOCKS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 __logfs_seek_data(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS) {\n\t\tbix = seek_holedata_direct(inode, bix, 1);\n\t\tif (bix < I0_BLOCKS)\n\t\t\treturn bix;\n\t}\n\n\tif (bix < maxbix(li->li_height)) {\n\t\tif (!li->li_data[INDIRECT_INDEX])\n\t\t\tbix = maxbix(li->li_height);\n\t\telse\n\t\t\treturn seek_holedata_loop(inode, bix, 1);\n\t}\n\n\treturn bix;\n}"
  },
  {
    "function_name": "logfs_seek_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "887-914",
    "snippet": "u64 logfs_seek_hole(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS) {\n\t\tbix = seek_holedata_direct(inode, bix, 0);\n\t\tif (bix < I0_BLOCKS)\n\t\t\treturn bix;\n\t}\n\n\tif (!li->li_data[INDIRECT_INDEX])\n\t\treturn bix;\n\telse if (li->li_data[INDIRECT_INDEX] & LOGFS_FULLY_POPULATED)\n\t\tbix = maxbix(li->li_height);\n\telse if (bix >= maxbix(li->li_height))\n\t\treturn bix;\n\telse {\n\t\tbix = seek_holedata_loop(inode, bix, 0);\n\t\tif (bix < maxbix(li->li_height))\n\t\t\treturn bix;\n\t\t/* Should not happen anymore.  But if some port writes semi-\n\t\t * corrupt images (as this one used to) we might run into it.\n\t\t */\n\t\tWARN_ON_ONCE(bix == maxbix(li->li_height));\n\t}\n\n\treturn bix;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "bix == maxbix(li->li_height)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maxbix",
          "args": [
            "li->li_height"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "maxbix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "44-47",
          "snippet": "static inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seek_holedata_loop",
          "args": [
            "inode",
            "bix",
            "0"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "seek_holedata_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "829-877",
          "snippet": "static u64 seek_holedata_loop(struct inode *inode, u64 bix, int data)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\t__be64 *rblock;\n\tu64 increment, bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level;\n\tint ret, slot;\n\tstruct page *page;\n\n\tBUG_ON(!bofs);\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)) {\n\t\tincrement = 1 << (LOGFS_BLOCK_BITS * ((__force u8)level-1));\n\t\tpage = logfs_get_read_page(inode, bix, level);\n\t\tif (!page)\n\t\t\treturn bix;\n\n\t\tret = logfs_segment_read(inode, page, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(page);\n\t\t\treturn bix;\n\t\t}\n\n\t\tslot = get_bits(bix, SUBLEVEL(level));\n\t\trblock = kmap_atomic(page);\n\t\twhile (slot < LOGFS_BLOCK_FACTOR) {\n\t\t\tif (data && (rblock[slot] != 0))\n\t\t\t\tbreak;\n\t\t\tif (!data && !(be64_to_cpu(rblock[slot]) & LOGFS_FULLY_POPULATED))\n\t\t\t\tbreak;\n\t\t\tslot++;\n\t\t\tbix += increment;\n\t\t\tbix &= ~(increment - 1);\n\t\t}\n\t\tif (slot >= LOGFS_BLOCK_FACTOR) {\n\t\t\tkunmap_atomic(rblock);\n\t\t\tlogfs_put_read_page(page);\n\t\t\treturn bix;\n\t\t}\n\t\tbofs = be64_to_cpu(rblock[slot]);\n\t\tkunmap_atomic(rblock);\n\t\tlogfs_put_read_page(page);\n\t\tif (!bofs) {\n\t\t\tBUG_ON(data);\n\t\t\treturn bix;\n\t\t}\n\t}\n\treturn bix;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 seek_holedata_loop(struct inode *inode, u64 bix, int data)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\t__be64 *rblock;\n\tu64 increment, bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level;\n\tint ret, slot;\n\tstruct page *page;\n\n\tBUG_ON(!bofs);\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)) {\n\t\tincrement = 1 << (LOGFS_BLOCK_BITS * ((__force u8)level-1));\n\t\tpage = logfs_get_read_page(inode, bix, level);\n\t\tif (!page)\n\t\t\treturn bix;\n\n\t\tret = logfs_segment_read(inode, page, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(page);\n\t\t\treturn bix;\n\t\t}\n\n\t\tslot = get_bits(bix, SUBLEVEL(level));\n\t\trblock = kmap_atomic(page);\n\t\twhile (slot < LOGFS_BLOCK_FACTOR) {\n\t\t\tif (data && (rblock[slot] != 0))\n\t\t\t\tbreak;\n\t\t\tif (!data && !(be64_to_cpu(rblock[slot]) & LOGFS_FULLY_POPULATED))\n\t\t\t\tbreak;\n\t\t\tslot++;\n\t\t\tbix += increment;\n\t\t\tbix &= ~(increment - 1);\n\t\t}\n\t\tif (slot >= LOGFS_BLOCK_FACTOR) {\n\t\t\tkunmap_atomic(rblock);\n\t\t\tlogfs_put_read_page(page);\n\t\t\treturn bix;\n\t\t}\n\t\tbofs = be64_to_cpu(rblock[slot]);\n\t\tkunmap_atomic(rblock);\n\t\tlogfs_put_read_page(page);\n\t\tif (!bofs) {\n\t\t\tBUG_ON(data);\n\t\t\treturn bix;\n\t\t}\n\t}\n\treturn bix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seek_holedata_direct",
          "args": [
            "inode",
            "bix",
            "0"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "seek_holedata_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "819-827",
          "snippet": "static u64 seek_holedata_direct(struct inode *inode, u64 bix, int data)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tfor (; bix < I0_BLOCKS; bix++)\n\t\tif (data ^ (li->li_data[bix] == 0))\n\t\t\treturn bix;\n\treturn I0_BLOCKS;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 seek_holedata_direct(struct inode *inode, u64 bix, int data)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tfor (; bix < I0_BLOCKS; bix++)\n\t\tif (data ^ (li->li_data[bix] == 0))\n\t\t\treturn bix;\n\treturn I0_BLOCKS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nu64 logfs_seek_hole(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS) {\n\t\tbix = seek_holedata_direct(inode, bix, 0);\n\t\tif (bix < I0_BLOCKS)\n\t\t\treturn bix;\n\t}\n\n\tif (!li->li_data[INDIRECT_INDEX])\n\t\treturn bix;\n\telse if (li->li_data[INDIRECT_INDEX] & LOGFS_FULLY_POPULATED)\n\t\tbix = maxbix(li->li_height);\n\telse if (bix >= maxbix(li->li_height))\n\t\treturn bix;\n\telse {\n\t\tbix = seek_holedata_loop(inode, bix, 0);\n\t\tif (bix < maxbix(li->li_height))\n\t\t\treturn bix;\n\t\t/* Should not happen anymore.  But if some port writes semi-\n\t\t * corrupt images (as this one used to) we might run into it.\n\t\t */\n\t\tWARN_ON_ONCE(bix == maxbix(li->li_height));\n\t}\n\n\treturn bix;\n}"
  },
  {
    "function_name": "seek_holedata_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "829-877",
    "snippet": "static u64 seek_holedata_loop(struct inode *inode, u64 bix, int data)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\t__be64 *rblock;\n\tu64 increment, bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level;\n\tint ret, slot;\n\tstruct page *page;\n\n\tBUG_ON(!bofs);\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)) {\n\t\tincrement = 1 << (LOGFS_BLOCK_BITS * ((__force u8)level-1));\n\t\tpage = logfs_get_read_page(inode, bix, level);\n\t\tif (!page)\n\t\t\treturn bix;\n\n\t\tret = logfs_segment_read(inode, page, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(page);\n\t\t\treturn bix;\n\t\t}\n\n\t\tslot = get_bits(bix, SUBLEVEL(level));\n\t\trblock = kmap_atomic(page);\n\t\twhile (slot < LOGFS_BLOCK_FACTOR) {\n\t\t\tif (data && (rblock[slot] != 0))\n\t\t\t\tbreak;\n\t\t\tif (!data && !(be64_to_cpu(rblock[slot]) & LOGFS_FULLY_POPULATED))\n\t\t\t\tbreak;\n\t\t\tslot++;\n\t\t\tbix += increment;\n\t\t\tbix &= ~(increment - 1);\n\t\t}\n\t\tif (slot >= LOGFS_BLOCK_FACTOR) {\n\t\t\tkunmap_atomic(rblock);\n\t\t\tlogfs_put_read_page(page);\n\t\t\treturn bix;\n\t\t}\n\t\tbofs = be64_to_cpu(rblock[slot]);\n\t\tkunmap_atomic(rblock);\n\t\tlogfs_put_read_page(page);\n\t\tif (!bofs) {\n\t\t\tBUG_ON(data);\n\t\t\treturn bix;\n\t\t}\n\t}\n\treturn bix;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "data"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_put_read_page",
          "args": [
            "page"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "281-285",
          "snippet": "static void logfs_put_read_page(struct page *page)\n{\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_read_page(struct page *page)\n{\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "rblock"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "rblock[slot]"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "rblock"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "rblock[slot]"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bits",
          "args": [
            "bix",
            "SUBLEVEL(level)"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "get_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "375-378",
          "snippet": "static unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_segment_read",
          "args": [
            "inode",
            "page",
            "bofs",
            "bix",
            "level"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "656-677",
          "snippet": "int logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_read_page",
          "args": [
            "inode",
            "bix",
            "level"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "274-279",
          "snippet": "static struct page *logfs_get_read_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\treturn find_or_create_page(inode->i_mapping,\n\t\t\tlogfs_pack_index(bix, level), GFP_NOFS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_read_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\treturn find_or_create_page(inode->i_mapping,\n\t\t\tlogfs_pack_index(bix, level), GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "li->li_height"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bofs"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 seek_holedata_loop(struct inode *inode, u64 bix, int data)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\t__be64 *rblock;\n\tu64 increment, bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level;\n\tint ret, slot;\n\tstruct page *page;\n\n\tBUG_ON(!bofs);\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)) {\n\t\tincrement = 1 << (LOGFS_BLOCK_BITS * ((__force u8)level-1));\n\t\tpage = logfs_get_read_page(inode, bix, level);\n\t\tif (!page)\n\t\t\treturn bix;\n\n\t\tret = logfs_segment_read(inode, page, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(page);\n\t\t\treturn bix;\n\t\t}\n\n\t\tslot = get_bits(bix, SUBLEVEL(level));\n\t\trblock = kmap_atomic(page);\n\t\twhile (slot < LOGFS_BLOCK_FACTOR) {\n\t\t\tif (data && (rblock[slot] != 0))\n\t\t\t\tbreak;\n\t\t\tif (!data && !(be64_to_cpu(rblock[slot]) & LOGFS_FULLY_POPULATED))\n\t\t\t\tbreak;\n\t\t\tslot++;\n\t\t\tbix += increment;\n\t\t\tbix &= ~(increment - 1);\n\t\t}\n\t\tif (slot >= LOGFS_BLOCK_FACTOR) {\n\t\t\tkunmap_atomic(rblock);\n\t\t\tlogfs_put_read_page(page);\n\t\t\treturn bix;\n\t\t}\n\t\tbofs = be64_to_cpu(rblock[slot]);\n\t\tkunmap_atomic(rblock);\n\t\tlogfs_put_read_page(page);\n\t\tif (!bofs) {\n\t\t\tBUG_ON(data);\n\t\t\treturn bix;\n\t\t}\n\t}\n\treturn bix;\n}"
  },
  {
    "function_name": "seek_holedata_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "819-827",
    "snippet": "static u64 seek_holedata_direct(struct inode *inode, u64 bix, int data)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tfor (; bix < I0_BLOCKS; bix++)\n\t\tif (data ^ (li->li_data[bix] == 0))\n\t\t\treturn bix;\n\treturn I0_BLOCKS;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 seek_holedata_direct(struct inode *inode, u64 bix, int data)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tfor (; bix < I0_BLOCKS; bix++)\n\t\tif (data ^ (li->li_data[bix] == 0))\n\t\t\treturn bix;\n\treturn I0_BLOCKS;\n}"
  },
  {
    "function_name": "logfs_exist_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "810-817",
    "snippet": "int logfs_exist_block(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS)\n\t\treturn !!li->li_data[bix];\n\treturn logfs_exist_loop(inode, bix);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_exist_loop",
          "args": [
            "inode",
            "bix"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_exist_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "777-808",
          "snippet": "static int logfs_exist_loop(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level;\n\tint ret;\n\tstruct page *ipage;\n\n\tif (!bofs)\n\t\treturn 0;\n\tif (bix >= maxbix(li->li_height))\n\t\treturn 0;\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)) {\n\t\tipage = logfs_get_read_page(inode, bix, level);\n\t\tif (!ipage)\n\t\t\treturn -ENOMEM;\n\n\t\tret = logfs_segment_read(inode, ipage, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(ipage);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbofs = block_get_pointer(ipage, get_bits(bix, SUBLEVEL(level)));\n\t\tlogfs_put_read_page(ipage);\n\t\tif (!bofs)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_exist_loop(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level;\n\tint ret;\n\tstruct page *ipage;\n\n\tif (!bofs)\n\t\treturn 0;\n\tif (bix >= maxbix(li->li_height))\n\t\treturn 0;\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)) {\n\t\tipage = logfs_get_read_page(inode, bix, level);\n\t\tif (!ipage)\n\t\t\treturn -ENOMEM;\n\n\t\tret = logfs_segment_read(inode, ipage, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(ipage);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbofs = block_get_pointer(ipage, get_bits(bix, SUBLEVEL(level)));\n\t\tlogfs_put_read_page(ipage);\n\t\tif (!bofs)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_exist_block(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS)\n\t\treturn !!li->li_data[bix];\n\treturn logfs_exist_loop(inode, bix);\n}"
  },
  {
    "function_name": "logfs_exist_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "777-808",
    "snippet": "static int logfs_exist_loop(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level;\n\tint ret;\n\tstruct page *ipage;\n\n\tif (!bofs)\n\t\treturn 0;\n\tif (bix >= maxbix(li->li_height))\n\t\treturn 0;\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)) {\n\t\tipage = logfs_get_read_page(inode, bix, level);\n\t\tif (!ipage)\n\t\t\treturn -ENOMEM;\n\n\t\tret = logfs_segment_read(inode, ipage, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(ipage);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbofs = block_get_pointer(ipage, get_bits(bix, SUBLEVEL(level)));\n\t\tlogfs_put_read_page(ipage);\n\t\tif (!bofs)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_read_page",
          "args": [
            "ipage"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "281-285",
          "snippet": "static void logfs_put_read_page(struct page *page)\n{\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_read_page(struct page *page)\n{\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_get_pointer",
          "args": [
            "ipage",
            "get_bits(bix, SUBLEVEL(level))"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "block_get_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "699-708",
          "snippet": "static u64 block_get_pointer(struct page *page, int index)\n{\n\t__be64 *block;\n\tu64 ptr;\n\n\tblock = kmap_atomic(page);\n\tptr = be64_to_cpu(block[index]);\n\tkunmap_atomic(block);\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 block_get_pointer(struct page *page, int index)\n{\n\t__be64 *block;\n\tu64 ptr;\n\n\tblock = kmap_atomic(page);\n\tptr = be64_to_cpu(block[index]);\n\tkunmap_atomic(block);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bits",
          "args": [
            "bix",
            "SUBLEVEL(level)"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "get_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "375-378",
          "snippet": "static unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_segment_read",
          "args": [
            "inode",
            "ipage",
            "bofs",
            "bix",
            "level"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "656-677",
          "snippet": "int logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_read_page",
          "args": [
            "inode",
            "bix",
            "level"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "274-279",
          "snippet": "static struct page *logfs_get_read_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\treturn find_or_create_page(inode->i_mapping,\n\t\t\tlogfs_pack_index(bix, level), GFP_NOFS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_read_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\treturn find_or_create_page(inode->i_mapping,\n\t\t\tlogfs_pack_index(bix, level), GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "li->li_height"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maxbix",
          "args": [
            "li->li_height"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "maxbix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "44-47",
          "snippet": "static inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_exist_loop(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level;\n\tint ret;\n\tstruct page *ipage;\n\n\tif (!bofs)\n\t\treturn 0;\n\tif (bix >= maxbix(li->li_height))\n\t\treturn 0;\n\n\tfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)) {\n\t\tipage = logfs_get_read_page(inode, bix, level);\n\t\tif (!ipage)\n\t\t\treturn -ENOMEM;\n\n\t\tret = logfs_segment_read(inode, ipage, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(ipage);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbofs = block_get_pointer(ipage, get_bits(bix, SUBLEVEL(level)));\n\t\tlogfs_put_read_page(ipage);\n\t\tif (!bofs)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "logfs_read_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "767-775",
    "snippet": "static int logfs_read_block(struct inode *inode, struct page *page,\n\t\tint rw_context)\n{\n\tpgoff_t index = page->index;\n\n\tif (index < I0_BLOCKS)\n\t\treturn logfs_read_direct(inode, page);\n\treturn logfs_read_loop(inode, page, rw_context);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_read_loop",
          "args": [
            "inode",
            "page",
            "rw_context"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "729-765",
          "snippet": "static int logfs_read_loop(struct inode *inode, struct page *page,\n\t\tint rw_context)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 bix, bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level, target_level;\n\tint ret;\n\tstruct page *ipage;\n\n\tlogfs_unpack_index(page->index, &bix, &target_level);\n\tif (!bofs)\n\t\treturn logfs_read_empty(page);\n\n\tif (bix >= maxbix(li->li_height))\n\t\treturn logfs_read_empty(page);\n\n\tfor (level = LEVEL(li->li_height);\n\t\t\t(__force u8)level > (__force u8)target_level;\n\t\t\tlevel = SUBLEVEL(level)){\n\t\tipage = logfs_get_page(inode, bix, level, rw_context);\n\t\tif (!ipage)\n\t\t\treturn -ENOMEM;\n\n\t\tret = logfs_segment_read(inode, ipage, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(ipage);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbofs = block_get_pointer(ipage, get_bits(bix, SUBLEVEL(level)));\n\t\tlogfs_put_page(ipage, rw_context);\n\t\tif (!bofs)\n\t\t\treturn logfs_read_empty(page);\n\t}\n\n\treturn logfs_segment_read(inode, page, bofs, bix, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_loop(struct inode *inode, struct page *page,\n\t\tint rw_context)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 bix, bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level, target_level;\n\tint ret;\n\tstruct page *ipage;\n\n\tlogfs_unpack_index(page->index, &bix, &target_level);\n\tif (!bofs)\n\t\treturn logfs_read_empty(page);\n\n\tif (bix >= maxbix(li->li_height))\n\t\treturn logfs_read_empty(page);\n\n\tfor (level = LEVEL(li->li_height);\n\t\t\t(__force u8)level > (__force u8)target_level;\n\t\t\tlevel = SUBLEVEL(level)){\n\t\tipage = logfs_get_page(inode, bix, level, rw_context);\n\t\tif (!ipage)\n\t\t\treturn -ENOMEM;\n\n\t\tret = logfs_segment_read(inode, ipage, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(ipage);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbofs = block_get_pointer(ipage, get_bits(bix, SUBLEVEL(level)));\n\t\tlogfs_put_page(ipage, rw_context);\n\t\tif (!bofs)\n\t\t\treturn logfs_read_empty(page);\n\t}\n\n\treturn logfs_segment_read(inode, page, bofs, bix, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_read_direct",
          "args": [
            "inode",
            "page"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "716-727",
          "snippet": "static int logfs_read_direct(struct inode *inode, struct page *page)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tpgoff_t index = page->index;\n\tu64 block;\n\n\tblock = li->li_data[index];\n\tif (!block)\n\t\treturn logfs_read_empty(page);\n\n\treturn logfs_segment_read(inode, page, block, index, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_direct(struct inode *inode, struct page *page)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tpgoff_t index = page->index;\n\tu64 block;\n\n\tblock = li->li_data[index];\n\tif (!block)\n\t\treturn logfs_read_empty(page);\n\n\treturn logfs_segment_read(inode, page, block, index, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_block(struct inode *inode, struct page *page,\n\t\tint rw_context)\n{\n\tpgoff_t index = page->index;\n\n\tif (index < I0_BLOCKS)\n\t\treturn logfs_read_direct(inode, page);\n\treturn logfs_read_loop(inode, page, rw_context);\n}"
  },
  {
    "function_name": "logfs_read_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "729-765",
    "snippet": "static int logfs_read_loop(struct inode *inode, struct page *page,\n\t\tint rw_context)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 bix, bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level, target_level;\n\tint ret;\n\tstruct page *ipage;\n\n\tlogfs_unpack_index(page->index, &bix, &target_level);\n\tif (!bofs)\n\t\treturn logfs_read_empty(page);\n\n\tif (bix >= maxbix(li->li_height))\n\t\treturn logfs_read_empty(page);\n\n\tfor (level = LEVEL(li->li_height);\n\t\t\t(__force u8)level > (__force u8)target_level;\n\t\t\tlevel = SUBLEVEL(level)){\n\t\tipage = logfs_get_page(inode, bix, level, rw_context);\n\t\tif (!ipage)\n\t\t\treturn -ENOMEM;\n\n\t\tret = logfs_segment_read(inode, ipage, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(ipage);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbofs = block_get_pointer(ipage, get_bits(bix, SUBLEVEL(level)));\n\t\tlogfs_put_page(ipage, rw_context);\n\t\tif (!bofs)\n\t\t\treturn logfs_read_empty(page);\n\t}\n\n\treturn logfs_segment_read(inode, page, bofs, bix, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_segment_read",
          "args": [
            "inode",
            "page",
            "bofs",
            "bix",
            "0"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "656-677",
          "snippet": "int logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_read_empty",
          "args": [
            "page"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "710-714",
          "snippet": "static int logfs_read_empty(struct page *page)\n{\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_empty(struct page *page)\n{\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_put_page",
          "args": [
            "ipage",
            "rw_context"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "357-363",
          "snippet": "static void logfs_put_page(struct page *page, int rw)\n{\n\tif (rw == READ)\n\t\tlogfs_put_read_page(page);\n\telse\n\t\tlogfs_put_write_page(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_page(struct page *page, int rw)\n{\n\tif (rw == READ)\n\t\tlogfs_put_read_page(page);\n\telse\n\t\tlogfs_put_write_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_get_pointer",
          "args": [
            "ipage",
            "get_bits(bix, SUBLEVEL(level))"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "block_get_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "699-708",
          "snippet": "static u64 block_get_pointer(struct page *page, int index)\n{\n\t__be64 *block;\n\tu64 ptr;\n\n\tblock = kmap_atomic(page);\n\tptr = be64_to_cpu(block[index]);\n\tkunmap_atomic(block);\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 block_get_pointer(struct page *page, int index)\n{\n\t__be64 *block;\n\tu64 ptr;\n\n\tblock = kmap_atomic(page);\n\tptr = be64_to_cpu(block[index]);\n\tkunmap_atomic(block);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bits",
          "args": [
            "bix",
            "SUBLEVEL(level)"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "get_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "375-378",
          "snippet": "static unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_put_read_page",
          "args": [
            "ipage"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "281-285",
          "snippet": "static void logfs_put_read_page(struct page *page)\n{\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_read_page(struct page *page)\n{\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_page",
          "args": [
            "inode",
            "bix",
            "level",
            "rw_context"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "348-355",
          "snippet": "static struct page *logfs_get_page(struct inode *inode, u64 bix, level_t level,\n\t\tint rw)\n{\n\tif (rw == READ)\n\t\treturn logfs_get_read_page(inode, bix, level);\n\telse\n\t\treturn logfs_get_write_page(inode, bix, level);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_page(struct inode *inode, u64 bix, level_t level,\n\t\tint rw)\n{\n\tif (rw == READ)\n\t\treturn logfs_get_read_page(inode, bix, level);\n\telse\n\t\treturn logfs_get_write_page(inode, bix, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUBLEVEL",
          "args": [
            "level"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "li->li_height"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maxbix",
          "args": [
            "li->li_height"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "maxbix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "44-47",
          "snippet": "static inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_unpack_index",
          "args": [
            "page->index",
            "&bix",
            "&target_level"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_unpack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "81-96",
          "snippet": "void logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\nvoid logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_loop(struct inode *inode, struct page *page,\n\t\tint rw_context)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 bix, bofs = li->li_data[INDIRECT_INDEX];\n\tlevel_t level, target_level;\n\tint ret;\n\tstruct page *ipage;\n\n\tlogfs_unpack_index(page->index, &bix, &target_level);\n\tif (!bofs)\n\t\treturn logfs_read_empty(page);\n\n\tif (bix >= maxbix(li->li_height))\n\t\treturn logfs_read_empty(page);\n\n\tfor (level = LEVEL(li->li_height);\n\t\t\t(__force u8)level > (__force u8)target_level;\n\t\t\tlevel = SUBLEVEL(level)){\n\t\tipage = logfs_get_page(inode, bix, level, rw_context);\n\t\tif (!ipage)\n\t\t\treturn -ENOMEM;\n\n\t\tret = logfs_segment_read(inode, ipage, bofs, bix, level);\n\t\tif (ret) {\n\t\t\tlogfs_put_read_page(ipage);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbofs = block_get_pointer(ipage, get_bits(bix, SUBLEVEL(level)));\n\t\tlogfs_put_page(ipage, rw_context);\n\t\tif (!bofs)\n\t\t\treturn logfs_read_empty(page);\n\t}\n\n\treturn logfs_segment_read(inode, page, bofs, bix, 0);\n}"
  },
  {
    "function_name": "logfs_read_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "716-727",
    "snippet": "static int logfs_read_direct(struct inode *inode, struct page *page)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tpgoff_t index = page->index;\n\tu64 block;\n\n\tblock = li->li_data[index];\n\tif (!block)\n\t\treturn logfs_read_empty(page);\n\n\treturn logfs_segment_read(inode, page, block, index, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_segment_read",
          "args": [
            "inode",
            "page",
            "block",
            "index",
            "0"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_segment_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "656-677",
          "snippet": "int logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_segment_read(struct inode *inode, struct page *page,\n\t\tu64 ofs, u64 bix, level_t level)\n{\n\tint err;\n\tvoid *buf;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tofs &= ~LOGFS_FULLY_POPULATED;\n\n\tbuf = kmap(page);\n\terr = __logfs_segment_read(inode, buf, ofs, bix, level);\n\tif (!err) {\n\t\tmove_btree_to_page(inode, page, buf);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap(page);\n\tlog_segment(\"logfs_segment_read(%lx, %llx, %x) %llx (%d)\\n\",\n\t\t\tinode->i_ino, bix, level, ofs, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_read_empty",
          "args": [
            "page"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "710-714",
          "snippet": "static int logfs_read_empty(struct page *page)\n{\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_empty(struct page *page)\n{\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_direct(struct inode *inode, struct page *page)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tpgoff_t index = page->index;\n\tu64 block;\n\n\tblock = li->li_data[index];\n\tif (!block)\n\t\treturn logfs_read_empty(page);\n\n\treturn logfs_segment_read(inode, page, block, index, 0);\n}"
  },
  {
    "function_name": "logfs_read_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "710-714",
    "snippet": "static int logfs_read_empty(struct page *page)\n{\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_empty(struct page *page)\n{\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\treturn 0;\n}"
  },
  {
    "function_name": "block_get_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "699-708",
    "snippet": "static u64 block_get_pointer(struct page *page, int index)\n{\n\t__be64 *block;\n\tu64 ptr;\n\n\tblock = kmap_atomic(page);\n\tptr = be64_to_cpu(block[index]);\n\tkunmap_atomic(block);\n\treturn ptr;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "block"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block[index]"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 block_get_pointer(struct page *page, int index)\n{\n\t__be64 *block;\n\tu64 ptr;\n\n\tblock = kmap_atomic(page);\n\tptr = be64_to_cpu(block[index]);\n\tkunmap_atomic(block);\n\treturn ptr;\n}"
  },
  {
    "function_name": "block_set_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "681-697",
    "snippet": "static void block_set_pointer(struct page *page, int index, u64 ptr)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\t__be64 *array;\n\tu64 oldptr;\n\n\tBUG_ON(!block);\n\tarray = kmap_atomic(page);\n\toldptr = be64_to_cpu(array[index]);\n\tarray[index] = cpu_to_be64(ptr);\n\tkunmap_atomic(array);\n\tSetPageUptodate(page);\n\n\tblock->full += !!(ptr & LOGFS_FULLY_POPULATED)\n\t\t- !!(oldptr & LOGFS_FULLY_POPULATED);\n\tblock->partial += !!ptr - !!oldptr;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "array"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ptr"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "array[index]"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!block"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "page"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void block_set_pointer(struct page *page, int index, u64 ptr)\n{\n\tstruct logfs_block *block = logfs_block(page);\n\t__be64 *array;\n\tu64 oldptr;\n\n\tBUG_ON(!block);\n\tarray = kmap_atomic(page);\n\toldptr = be64_to_cpu(array[index]);\n\tarray[index] = cpu_to_be64(ptr);\n\tkunmap_atomic(array);\n\tSetPageUptodate(page);\n\n\tblock->full += !!(ptr & LOGFS_FULLY_POPULATED)\n\t\t- !!(oldptr & LOGFS_FULLY_POPULATED);\n\tblock->partial += !!ptr - !!oldptr;\n}"
  },
  {
    "function_name": "alloc_indirect_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "664-679",
    "snippet": "static void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "array"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_block_counters",
          "args": [
            "page",
            "block",
            "array",
            "page_is_empty"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_block_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "615-642",
          "snippet": "void initialize_block_counters(struct page *page, struct logfs_block *block,\n\t\t__be64 *array, int page_is_empty)\n{\n\tu64 ptr;\n\tint i, start;\n\n\tblock->partial = 0;\n\tblock->full = 0;\n\tstart = 0;\n\tif (page->index < first_indirect_block()) {\n\t\t/* Counters are pointless on level 0 */\n\t\treturn;\n\t}\n\tif (page->index == first_indirect_block()) {\n\t\t/* Skip unused pointers */\n\t\tstart = I0_BLOCKS;\n\t\tblock->full = I0_BLOCKS;\n\t}\n\tif (!page_is_empty) {\n\t\tfor (i = start; i < LOGFS_BLOCK_FACTOR; i++) {\n\t\t\tptr = be64_to_cpu(array[i]);\n\t\t\tif (ptr)\n\t\t\t\tblock->partial++;\n\t\t\tif (ptr & LOGFS_FULLY_POPULATED)\n\t\t\t\tblock->full++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid initialize_block_counters(struct page *page, struct logfs_block *block,\n\t\t__be64 *array, int page_is_empty)\n{\n\tu64 ptr;\n\tint i, start;\n\n\tblock->partial = 0;\n\tblock->full = 0;\n\tstart = 0;\n\tif (page->index < first_indirect_block()) {\n\t\t/* Counters are pointless on level 0 */\n\t\treturn;\n\t}\n\tif (page->index == first_indirect_block()) {\n\t\t/* Skip unused pointers */\n\t\tstart = I0_BLOCKS;\n\t\tblock->full = I0_BLOCKS;\n\t}\n\tif (!page_is_empty) {\n\t\tfor (i = start; i < LOGFS_BLOCK_FACTOR; i++) {\n\t\t\tptr = be64_to_cpu(array[i]);\n\t\t\tif (ptr)\n\t\t\t\tblock->partial++;\n\t\t\tif (ptr & LOGFS_FULLY_POPULATED)\n\t\t\t\tblock->full++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_block",
          "args": [
            "page"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "688-691",
          "snippet": "static inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_block *logfs_block(struct page *page)\n{\n\treturn (void *)page->private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_data_block",
          "args": [
            "inode",
            "page"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_data_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "644-662",
          "snippet": "static void alloc_data_block(struct inode *inode, struct page *page)\n{\n\tstruct logfs_block *block;\n\tu64 bix;\n\tlevel_t level;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tblock = __alloc_block(inode->i_sb, inode->i_ino, bix, level);\n\tblock->page = page;\n\n\tSetPagePrivate(page);\n\tpage_cache_get(page);\n\tset_page_private(page, (unsigned long) block);\n\n\tblock->ops = &indirect_block_ops;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct logfs_block_ops indirect_block_ops = {\n\t.write_block = indirect_write_block,\n\t.free_block = indirect_free_block,\n\t.write_alias = indirect_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstruct logfs_block_ops indirect_block_ops = {\n\t.write_block = indirect_write_block,\n\t.free_block = indirect_free_block,\n\t.write_alias = indirect_write_alias,\n};\n\nstatic void alloc_data_block(struct inode *inode, struct page *page)\n{\n\tstruct logfs_block *block;\n\tu64 bix;\n\tlevel_t level;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tblock = __alloc_block(inode->i_sb, inode->i_ino, bix, level);\n\tblock->page = page;\n\n\tSetPagePrivate(page);\n\tpage_cache_get(page);\n\tset_page_private(page, (unsigned long) block);\n\n\tblock->ops = &indirect_block_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void alloc_indirect_block(struct inode *inode, struct page *page,\n\t\tint page_is_empty)\n{\n\tstruct logfs_block *block;\n\t__be64 *array;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\talloc_data_block(inode, page);\n\n\tblock = logfs_block(page);\n\tarray = kmap_atomic(page);\n\tinitialize_block_counters(page, block, array, page_is_empty);\n\tkunmap_atomic(array);\n}"
  },
  {
    "function_name": "alloc_data_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "644-662",
    "snippet": "static void alloc_data_block(struct inode *inode, struct page *page)\n{\n\tstruct logfs_block *block;\n\tu64 bix;\n\tlevel_t level;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tblock = __alloc_block(inode->i_sb, inode->i_ino, bix, level);\n\tblock->page = page;\n\n\tSetPagePrivate(page);\n\tpage_cache_get(page);\n\tset_page_private(page, (unsigned long) block);\n\n\tblock->ops = &indirect_block_ops;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct logfs_block_ops indirect_block_ops = {\n\t.write_block = indirect_write_block,\n\t.free_block = indirect_free_block,\n\t.write_alias = indirect_write_alias,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "(unsigned long) block"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_block",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "bix",
            "level"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "584-599",
          "snippet": "struct logfs_block *__alloc_block(struct super_block *sb,\n\t\tu64 ino, u64 bix, level_t level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\n\tblock = mempool_alloc(super->s_block_pool, GFP_NOFS);\n\tmemset(block, 0, sizeof(*block));\n\tINIT_LIST_HEAD(&block->alias_list);\n\tINIT_LIST_HEAD(&block->item_list);\n\tblock->sb = sb;\n\tblock->ino = ino;\n\tblock->bix = bix;\n\tblock->level = level;\n\treturn block;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstruct logfs_block *__alloc_block(struct super_block *sb,\n\t\tu64 ino, u64 bix, level_t level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\n\tblock = mempool_alloc(super->s_block_pool, GFP_NOFS);\n\tmemset(block, 0, sizeof(*block));\n\tINIT_LIST_HEAD(&block->alias_list);\n\tINIT_LIST_HEAD(&block->item_list);\n\tblock->sb = sb;\n\tblock->ino = ino;\n\tblock->bix = bix;\n\tblock->level = level;\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_unpack_index",
          "args": [
            "page->index",
            "&bix",
            "&level"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_unpack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "81-96",
          "snippet": "void logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\nvoid logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstruct logfs_block_ops indirect_block_ops = {\n\t.write_block = indirect_write_block,\n\t.free_block = indirect_free_block,\n\t.write_alias = indirect_write_alias,\n};\n\nstatic void alloc_data_block(struct inode *inode, struct page *page)\n{\n\tstruct logfs_block *block;\n\tu64 bix;\n\tlevel_t level;\n\n\tif (PagePrivate(page))\n\t\treturn;\n\n\tlogfs_unpack_index(page->index, &bix, &level);\n\tblock = __alloc_block(inode->i_sb, inode->i_ino, bix, level);\n\tblock->page = page;\n\n\tSetPagePrivate(page);\n\tpage_cache_get(page);\n\tset_page_private(page, (unsigned long) block);\n\n\tblock->ops = &indirect_block_ops;\n}"
  },
  {
    "function_name": "initialize_block_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "615-642",
    "snippet": "void initialize_block_counters(struct page *page, struct logfs_block *block,\n\t\t__be64 *array, int page_is_empty)\n{\n\tu64 ptr;\n\tint i, start;\n\n\tblock->partial = 0;\n\tblock->full = 0;\n\tstart = 0;\n\tif (page->index < first_indirect_block()) {\n\t\t/* Counters are pointless on level 0 */\n\t\treturn;\n\t}\n\tif (page->index == first_indirect_block()) {\n\t\t/* Skip unused pointers */\n\t\tstart = I0_BLOCKS;\n\t\tblock->full = I0_BLOCKS;\n\t}\n\tif (!page_is_empty) {\n\t\tfor (i = start; i < LOGFS_BLOCK_FACTOR; i++) {\n\t\t\tptr = be64_to_cpu(array[i]);\n\t\t\tif (ptr)\n\t\t\t\tblock->partial++;\n\t\t\tif (ptr & LOGFS_FULLY_POPULATED)\n\t\t\t\tblock->full++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "array[i]"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_indirect_block",
          "args": [],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "first_indirect_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "62-65",
          "snippet": "static inline pgoff_t first_indirect_block(void)\n{\n\treturn INDIRECT_BIT | (1ULL << LEVEL_SHIFT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\nstatic inline pgoff_t first_indirect_block(void)\n{\n\treturn INDIRECT_BIT | (1ULL << LEVEL_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid initialize_block_counters(struct page *page, struct logfs_block *block,\n\t\t__be64 *array, int page_is_empty)\n{\n\tu64 ptr;\n\tint i, start;\n\n\tblock->partial = 0;\n\tblock->full = 0;\n\tstart = 0;\n\tif (page->index < first_indirect_block()) {\n\t\t/* Counters are pointless on level 0 */\n\t\treturn;\n\t}\n\tif (page->index == first_indirect_block()) {\n\t\t/* Skip unused pointers */\n\t\tstart = I0_BLOCKS;\n\t\tblock->full = I0_BLOCKS;\n\t}\n\tif (!page_is_empty) {\n\t\tfor (i = start; i < LOGFS_BLOCK_FACTOR; i++) {\n\t\t\tptr = be64_to_cpu(array[i]);\n\t\t\tif (ptr)\n\t\t\t\tblock->partial++;\n\t\t\tif (ptr & LOGFS_FULLY_POPULATED)\n\t\t\t\tblock->full++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "alloc_inode_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "601-613",
    "snippet": "static void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__alloc_block",
          "args": [
            "inode->i_sb",
            "LOGFS_INO_MASTER",
            "inode->i_ino",
            "0"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "584-599",
          "snippet": "struct logfs_block *__alloc_block(struct super_block *sb,\n\t\tu64 ino, u64 bix, level_t level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\n\tblock = mempool_alloc(super->s_block_pool, GFP_NOFS);\n\tmemset(block, 0, sizeof(*block));\n\tINIT_LIST_HEAD(&block->alias_list);\n\tINIT_LIST_HEAD(&block->item_list);\n\tblock->sb = sb;\n\tblock->ino = ino;\n\tblock->bix = bix;\n\tblock->level = level;\n\treturn block;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstruct logfs_block *__alloc_block(struct super_block *sb,\n\t\tu64 ino, u64 bix, level_t level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\n\tblock = mempool_alloc(super->s_block_pool, GFP_NOFS);\n\tmemset(block, 0, sizeof(*block));\n\tINIT_LIST_HEAD(&block->alias_list);\n\tINIT_LIST_HEAD(&block->item_list);\n\tblock->sb = sb;\n\tblock->ino = ino;\n\tblock->bix = bix;\n\tblock->level = level;\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops inode_block_ops = {\n\t.write_block = inode_write_block,\n\t.free_block = inode_free_block,\n\t.write_alias = inode_write_alias,\n};\n\nstatic void alloc_inode_block(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct logfs_block *block;\n\n\tif (li->li_block)\n\t\treturn;\n\n\tblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\n\tblock->inode = inode;\n\tli->li_block = block;\n\tblock->ops = &inode_block_ops;\n}"
  },
  {
    "function_name": "__alloc_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "584-599",
    "snippet": "struct logfs_block *__alloc_block(struct super_block *sb,\n\t\tu64 ino, u64 bix, level_t level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\n\tblock = mempool_alloc(super->s_block_pool, GFP_NOFS);\n\tmemset(block, 0, sizeof(*block));\n\tINIT_LIST_HEAD(&block->alias_list);\n\tINIT_LIST_HEAD(&block->item_list);\n\tblock->sb = sb;\n\tblock->ino = ino;\n\tblock->bix = bix;\n\tblock->level = level;\n\treturn block;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&block->item_list"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&block->alias_list"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "block",
            "0",
            "sizeof(*block)"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_alloc",
          "args": [
            "super->s_block_pool",
            "GFP_NOFS"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstruct logfs_block *__alloc_block(struct super_block *sb,\n\t\tu64 ino, u64 bix, level_t level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\n\tblock = mempool_alloc(super->s_block_pool, GFP_NOFS);\n\tmemset(block, 0, sizeof(*block));\n\tINIT_LIST_HEAD(&block->alias_list);\n\tINIT_LIST_HEAD(&block->item_list);\n\tblock->sb = sb;\n\tblock->ino = ino;\n\tblock->bix = bix;\n\tblock->level = level;\n\treturn block;\n}"
  },
  {
    "function_name": "indirect_free_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "558-569",
    "snippet": "static void indirect_free_block(struct super_block *sb,\n\t\tstruct logfs_block *block)\n{\n\tstruct page *page = block->page;\n\n\tif (PagePrivate(page)) {\n\t\tClearPagePrivate(page);\n\t\tpage_cache_release(page);\n\t\tset_page_private(page, 0);\n\t}\n\t__free_block(sb, block);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_block",
          "args": [
            "sb",
            "block"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "__free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "543-548",
          "snippet": "void __free_block(struct super_block *sb, struct logfs_block *block)\n{\n\tBUG_ON(!list_empty(&block->item_list));\n\tlist_del(&block->alias_list);\n\tmempool_free(block, logfs_super(sb)->s_block_pool);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid __free_block(struct super_block *sb, struct logfs_block *block)\n{\n\tBUG_ON(!list_empty(&block->item_list));\n\tlist_del(&block->alias_list);\n\tmempool_free(block, logfs_super(sb)->s_block_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void indirect_free_block(struct super_block *sb,\n\t\tstruct logfs_block *block)\n{\n\tstruct page *page = block->page;\n\n\tif (PagePrivate(page)) {\n\t\tClearPagePrivate(page);\n\t\tpage_cache_release(page);\n\t\tset_page_private(page, 0);\n\t}\n\t__free_block(sb, block);\n}"
  },
  {
    "function_name": "inode_free_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "550-556",
    "snippet": "static void inode_free_block(struct super_block *sb, struct logfs_block *block)\n{\n\tstruct inode *inode = block->inode;\n\n\tlogfs_inode(inode)->li_block = NULL;\n\t__free_block(sb, block);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_block",
          "args": [
            "sb",
            "block"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "__free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "543-548",
          "snippet": "void __free_block(struct super_block *sb, struct logfs_block *block)\n{\n\tBUG_ON(!list_empty(&block->item_list));\n\tlist_del(&block->alias_list);\n\tmempool_free(block, logfs_super(sb)->s_block_pool);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid __free_block(struct super_block *sb, struct logfs_block *block)\n{\n\tBUG_ON(!list_empty(&block->item_list));\n\tlist_del(&block->alias_list);\n\tmempool_free(block, logfs_super(sb)->s_block_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void inode_free_block(struct super_block *sb, struct logfs_block *block)\n{\n\tstruct inode *inode = block->inode;\n\n\tlogfs_inode(inode)->li_block = NULL;\n\t__free_block(sb, block);\n}"
  },
  {
    "function_name": "__free_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "543-548",
    "snippet": "void __free_block(struct super_block *sb, struct logfs_block *block)\n{\n\tBUG_ON(!list_empty(&block->item_list));\n\tlist_del(&block->alias_list);\n\tmempool_free(block, logfs_super(sb)->s_block_pool);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "block",
            "logfs_super(sb)->s_block_pool"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&block->alias_list"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&block->item_list)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&block->item_list"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid __free_block(struct super_block *sb, struct logfs_block *block)\n{\n\tBUG_ON(!list_empty(&block->item_list));\n\tlist_del(&block->alias_list);\n\tmempool_free(block, logfs_super(sb)->s_block_pool);\n}"
  },
  {
    "function_name": "logfs_write_obj_aliases_pagecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "529-541",
    "snippet": "int logfs_write_obj_aliases_pagecache(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\tint err;\n\n\tlist_for_each_entry(block, &super->s_object_alias, alias_list) {\n\t\terr = block->ops->write_alias(sb, block, write_alias_journal);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block->ops->write_alias",
          "args": [
            "sb",
            "block",
            "write_alias_journal"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "block",
            "&super->s_object_alias",
            "alias_list"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_write_obj_aliases_pagecache(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\tint err;\n\n\tlist_for_each_entry(block, &super->s_object_alias, alias_list) {\n\t\terr = block->ops->write_alias(sb, block, write_alias_journal);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "indirect_write_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "503-527",
    "snippet": "static int indirect_write_alias(struct super_block *sb,\n\t\tstruct logfs_block *block, write_alias_t *write_one_alias)\n{\n\tunsigned long pos;\n\tstruct page *page = block->page;\n\tu64 ino , bix;\n\t__be64 *child, val;\n\tlevel_t level;\n\tint err;\n\n\tfor (pos = 0; ; pos++) {\n\t\tpos = fnb(block->alias_map, LOGFS_BLOCK_FACTOR, pos);\n\t\tif (pos >= LOGFS_BLOCK_FACTOR)\n\t\t\treturn 0;\n\n\t\tino = page->mapping->host->i_ino;\n\t\tlogfs_unpack_index(page->index, &bix, &level);\n\t\tchild = kmap_atomic(page);\n\t\tval = child[pos];\n\t\tkunmap_atomic(child);\n\t\terr = write_one_alias(sb, ino, bix, level, pos, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_one_alias",
          "args": [
            "sb",
            "ino",
            "bix",
            "level",
            "pos",
            "val"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "child"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_unpack_index",
          "args": [
            "page->index",
            "&bix",
            "&level"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_unpack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "81-96",
          "snippet": "void logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\nvoid logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnb",
          "args": [
            "block->alias_map",
            "LOGFS_BLOCK_FACTOR",
            "pos"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "fnb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "436-440",
          "snippet": "static unsigned long fnb(const unsigned long *addr,\n\t\tunsigned long size, unsigned long offset)\n{\n\treturn find_next_bit(addr, size, offset);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic unsigned long fnb(const unsigned long *addr,\n\t\tunsigned long size, unsigned long offset)\n{\n\treturn find_next_bit(addr, size, offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int indirect_write_alias(struct super_block *sb,\n\t\tstruct logfs_block *block, write_alias_t *write_one_alias)\n{\n\tunsigned long pos;\n\tstruct page *page = block->page;\n\tu64 ino , bix;\n\t__be64 *child, val;\n\tlevel_t level;\n\tint err;\n\n\tfor (pos = 0; ; pos++) {\n\t\tpos = fnb(block->alias_map, LOGFS_BLOCK_FACTOR, pos);\n\t\tif (pos >= LOGFS_BLOCK_FACTOR)\n\t\t\treturn 0;\n\n\t\tino = page->mapping->host->i_ino;\n\t\tlogfs_unpack_index(page->index, &bix, &level);\n\t\tchild = kmap_atomic(page);\n\t\tval = child[pos];\n\t\tkunmap_atomic(child);\n\t\terr = write_one_alias(sb, ino, bix, level, pos, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n}"
  },
  {
    "function_name": "inode_write_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "461-501",
    "snippet": "static int inode_write_alias(struct super_block *sb,\n\t\tstruct logfs_block *block, write_alias_t *write_one_alias)\n{\n\tstruct inode *inode = block->inode;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tunsigned long pos;\n\tu64 ino , bix;\n\t__be64 val;\n\tlevel_t level;\n\tint err;\n\n\tfor (pos = 0; ; pos++) {\n\t\tpos = fnb(block->alias_map, LOGFS_BLOCK_FACTOR, pos);\n\t\tif (pos >= LOGFS_EMBEDDED_FIELDS + INODE_POINTER_OFS)\n\t\t\treturn 0;\n\n\t\tswitch (pos) {\n\t\tcase INODE_HEIGHT_OFS:\n\t\t\tval = inode_val0(inode);\n\t\t\tbreak;\n\t\tcase INODE_USED_OFS:\n\t\t\tval = cpu_to_be64(li->li_used_bytes);\n\t\t\tbreak;\n\t\tcase INODE_SIZE_OFS:\n\t\t\tval = cpu_to_be64(i_size_read(inode));\n\t\t\tbreak;\n\t\tcase INODE_POINTER_OFS ... INODE_POINTER_OFS + LOGFS_EMBEDDED_FIELDS - 1:\n\t\t\tval = cpu_to_be64(li->li_data[pos - INODE_POINTER_OFS]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tino = LOGFS_INO_MASTER;\n\t\tbix = inode->i_ino;\n\t\tlevel = LEVEL(0);\n\t\terr = write_one_alias(sb, ino, bix, level, pos, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_one_alias",
          "args": [
            "sb",
            "ino",
            "bix",
            "level",
            "pos",
            "val"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "0"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "li->li_data[pos - INODE_POINTER_OFS]"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "i_size_read(inode)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "li->li_used_bytes"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_val0",
          "args": [
            "inode"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "inode_val0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "442-459",
          "snippet": "static __be64 inode_val0(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 val;\n\n\t/*\n\t * Explicit shifting generates good code, but must match the format\n\t * of the structure.  Add some paranoia just in case.\n\t */\n\tBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_mode) != 0);\n\tBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_height) != 2);\n\tBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_flags) != 4);\n\n\tval =\t(u64)inode->i_mode << 48 |\n\t\t(u64)li->li_height << 40 |\n\t\t(u64)li->li_flags;\n\treturn cpu_to_be64(val);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic __be64 inode_val0(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 val;\n\n\t/*\n\t * Explicit shifting generates good code, but must match the format\n\t * of the structure.  Add some paranoia just in case.\n\t */\n\tBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_mode) != 0);\n\tBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_height) != 2);\n\tBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_flags) != 4);\n\n\tval =\t(u64)inode->i_mode << 48 |\n\t\t(u64)li->li_height << 40 |\n\t\t(u64)li->li_flags;\n\treturn cpu_to_be64(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnb",
          "args": [
            "block->alias_map",
            "LOGFS_BLOCK_FACTOR",
            "pos"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "fnb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "436-440",
          "snippet": "static unsigned long fnb(const unsigned long *addr,\n\t\tunsigned long size, unsigned long offset)\n{\n\treturn find_next_bit(addr, size, offset);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic unsigned long fnb(const unsigned long *addr,\n\t\tunsigned long size, unsigned long offset)\n{\n\treturn find_next_bit(addr, size, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int inode_write_alias(struct super_block *sb,\n\t\tstruct logfs_block *block, write_alias_t *write_one_alias)\n{\n\tstruct inode *inode = block->inode;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tunsigned long pos;\n\tu64 ino , bix;\n\t__be64 val;\n\tlevel_t level;\n\tint err;\n\n\tfor (pos = 0; ; pos++) {\n\t\tpos = fnb(block->alias_map, LOGFS_BLOCK_FACTOR, pos);\n\t\tif (pos >= LOGFS_EMBEDDED_FIELDS + INODE_POINTER_OFS)\n\t\t\treturn 0;\n\n\t\tswitch (pos) {\n\t\tcase INODE_HEIGHT_OFS:\n\t\t\tval = inode_val0(inode);\n\t\t\tbreak;\n\t\tcase INODE_USED_OFS:\n\t\t\tval = cpu_to_be64(li->li_used_bytes);\n\t\t\tbreak;\n\t\tcase INODE_SIZE_OFS:\n\t\t\tval = cpu_to_be64(i_size_read(inode));\n\t\t\tbreak;\n\t\tcase INODE_POINTER_OFS ... INODE_POINTER_OFS + LOGFS_EMBEDDED_FIELDS - 1:\n\t\t\tval = cpu_to_be64(li->li_data[pos - INODE_POINTER_OFS]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tino = LOGFS_INO_MASTER;\n\t\tbix = inode->i_ino;\n\t\tlevel = LEVEL(0);\n\t\terr = write_one_alias(sb, ino, bix, level, pos, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n}"
  },
  {
    "function_name": "inode_val0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "442-459",
    "snippet": "static __be64 inode_val0(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 val;\n\n\t/*\n\t * Explicit shifting generates good code, but must match the format\n\t * of the structure.  Add some paranoia just in case.\n\t */\n\tBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_mode) != 0);\n\tBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_height) != 2);\n\tBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_flags) != 4);\n\n\tval =\t(u64)inode->i_mode << 48 |\n\t\t(u64)li->li_height << 40 |\n\t\t(u64)li->li_flags;\n\treturn cpu_to_be64(val);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "val"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct logfs_disk_inode, di_flags) != 4"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct logfs_disk_inode, di_height) != 2"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct logfs_disk_inode, di_mode) != 0"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic __be64 inode_val0(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tu64 val;\n\n\t/*\n\t * Explicit shifting generates good code, but must match the format\n\t * of the structure.  Add some paranoia just in case.\n\t */\n\tBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_mode) != 0);\n\tBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_height) != 2);\n\tBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_flags) != 4);\n\n\tval =\t(u64)inode->i_mode << 48 |\n\t\t(u64)li->li_height << 40 |\n\t\t(u64)li->li_flags;\n\treturn cpu_to_be64(val);\n}"
  },
  {
    "function_name": "fnb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "436-440",
    "snippet": "static unsigned long fnb(const unsigned long *addr,\n\t\tunsigned long size, unsigned long offset)\n{\n\treturn find_next_bit(addr, size, offset);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "addr",
            "size",
            "offset"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic unsigned long fnb(const unsigned long *addr,\n\t\tunsigned long size, unsigned long offset)\n{\n\treturn find_next_bit(addr, size, offset);\n}"
  },
  {
    "function_name": "inode_write_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "416-429",
    "snippet": "static void inode_write_block(struct logfs_block *block)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = block->inode;\n\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\tlogfs_write_anchor(inode->i_sb);\n\telse {\n\t\tret = __logfs_write_inode(inode, NULL, 0);\n\t\t/* see indirect_write_block comment */\n\t\tBUG_ON(ret);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__logfs_write_inode",
          "args": [
            "inode",
            "NULL",
            "0"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2132-2141",
          "snippet": "int __logfs_write_inode(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = do_write_inode(inode);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint __logfs_write_inode(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = do_write_inode(inode);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_anchor",
          "args": [
            "inode->i_sb"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_anchor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "734-803",
          "snippet": "void logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void inode_write_block(struct logfs_block *block)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = block->inode;\n\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\tlogfs_write_anchor(inode->i_sb);\n\telse {\n\t\tret = __logfs_write_inode(inode, NULL, 0);\n\t\t/* see indirect_write_block comment */\n\t\tBUG_ON(ret);\n\t}\n}"
  },
  {
    "function_name": "indirect_write_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "389-414",
    "snippet": "static void indirect_write_block(struct logfs_block *block)\n{\n\tstruct page *page;\n\tstruct inode *inode;\n\tint ret;\n\n\tpage = block->page;\n\tinode = page->mapping->host;\n\tlogfs_lock_write_page(page);\n\tret = logfs_write_buf(inode, page, 0);\n\tlogfs_unlock_write_page(page);\n\t/*\n\t * This needs some rework.  Unless you want your filesystem to run\n\t * completely synchronously (you don't), the filesystem will always\n\t * report writes as 'successful' before the actual work has been\n\t * done.  The actual work gets done here and this is where any errors\n\t * will show up.  And there isn't much we can do about it, really.\n\t *\n\t * Some attempts to fix the errors (move from bad blocks, retry io,...)\n\t * have already been done, so anything left should be either a broken\n\t * device or a bug somewhere in logfs itself.  Being relatively new,\n\t * the odds currently favor a bug, so for now the line below isn't\n\t * entirely tasteles.\n\t */\n\tBUG_ON(ret);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_unlock_write_page",
          "args": [
            "page"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_unlock_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "336-340",
          "snippet": "static void logfs_unlock_write_page(struct page *page)\n{\n\tif (!PagePreLocked(page))\n\t\tunlock_page(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_unlock_write_page(struct page *page)\n{\n\tif (!PagePreLocked(page))\n\t\tunlock_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_buf",
          "args": [
            "inode",
            "page",
            "0"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1565-1574",
          "snippet": "int logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = __logfs_write_buf(inode, page, flags);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_write_buf(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = __logfs_write_buf(inode, page, flags);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_lock_write_page",
          "args": [
            "page"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_lock_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "287-308",
          "snippet": "static void logfs_lock_write_page(struct page *page)\n{\n\tint loop = 0;\n\n\twhile (unlikely(!trylock_page(page))) {\n\t\tif (loop++ > 0x1000) {\n\t\t\t/* Has been observed once so far... */\n\t\t\tprintk(KERN_ERR \"stack at %p\\n\", &loop);\n\t\t\tBUG();\n\t\t}\n\t\tif (PagePreLocked(page)) {\n\t\t\t/* Holder of page lock is waiting for us, it\n\t\t\t * is safe to use this page. */\n\t\t\tbreak;\n\t\t}\n\t\t/* Some other process has this page locked and has\n\t\t * nothing to do with us.  Wait for it to finish.\n\t\t */\n\t\tschedule();\n\t}\n\tBUG_ON(!PageLocked(page));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_lock_write_page(struct page *page)\n{\n\tint loop = 0;\n\n\twhile (unlikely(!trylock_page(page))) {\n\t\tif (loop++ > 0x1000) {\n\t\t\t/* Has been observed once so far... */\n\t\t\tprintk(KERN_ERR \"stack at %p\\n\", &loop);\n\t\t\tBUG();\n\t\t}\n\t\tif (PagePreLocked(page)) {\n\t\t\t/* Holder of page lock is waiting for us, it\n\t\t\t * is safe to use this page. */\n\t\t\tbreak;\n\t\t}\n\t\t/* Some other process has this page locked and has\n\t\t * nothing to do with us.  Wait for it to finish.\n\t\t */\n\t\tschedule();\n\t}\n\tBUG_ON(!PageLocked(page));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void indirect_write_block(struct logfs_block *block)\n{\n\tstruct page *page;\n\tstruct inode *inode;\n\tint ret;\n\n\tpage = block->page;\n\tinode = page->mapping->host;\n\tlogfs_lock_write_page(page);\n\tret = logfs_write_buf(inode, page, 0);\n\tlogfs_unlock_write_page(page);\n\t/*\n\t * This needs some rework.  Unless you want your filesystem to run\n\t * completely synchronously (you don't), the filesystem will always\n\t * report writes as 'successful' before the actual work has been\n\t * done.  The actual work gets done here and this is where any errors\n\t * will show up.  And there isn't much we can do about it, really.\n\t *\n\t * Some attempts to fix the errors (move from bad blocks, retry io,...)\n\t * have already been done, so anything left should be either a broken\n\t * device or a bug somewhere in logfs itself.  Being relatively new,\n\t * the odds currently favor a bug, so for now the line below isn't\n\t * entirely tasteles.\n\t */\n\tBUG_ON(ret);\n}"
  },
  {
    "function_name": "init_shadow_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "380-387",
    "snippet": "static inline void init_shadow_tree(struct super_block *sb,\n\t\tstruct shadow_tree *tree)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_init_mempool64(&tree->new, super->s_btree_pool);\n\tbtree_init_mempool64(&tree->old, super->s_btree_pool);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btree_init_mempool64",
          "args": [
            "&tree->old",
            "super->s_btree_pool"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_init_mempool64",
          "args": [
            "&tree->new",
            "super->s_btree_pool"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic inline void init_shadow_tree(struct super_block *sb,\n\t\tstruct shadow_tree *tree)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_init_mempool64(&tree->new, super->s_btree_pool);\n\tbtree_init_mempool64(&tree->old, super->s_btree_pool);\n}"
  },
  {
    "function_name": "get_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "375-378",
    "snippet": "static unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_bits",
          "args": [
            "val",
            "(__force int)skip",
            "LOGFS_BLOCK_BITS"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "__get_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "365-373",
          "snippet": "static unsigned long __get_bits(u64 val, int skip, int no)\n{\n\tu64 ret = val;\n\n\tret >>= skip * no;\n\tret <<= 64 - no;\n\tret >>= 64 - no;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic unsigned long __get_bits(u64 val, int skip, int no)\n{\n\tu64 ret = val;\n\n\tret >>= skip * no;\n\tret <<= 64 - no;\n\tret >>= 64 - no;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}"
  },
  {
    "function_name": "__get_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "365-373",
    "snippet": "static unsigned long __get_bits(u64 val, int skip, int no)\n{\n\tu64 ret = val;\n\n\tret >>= skip * no;\n\tret <<= 64 - no;\n\tret >>= 64 - no;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic unsigned long __get_bits(u64 val, int skip, int no)\n{\n\tu64 ret = val;\n\n\tret >>= skip * no;\n\tret <<= 64 - no;\n\tret >>= 64 - no;\n\treturn ret;\n}"
  },
  {
    "function_name": "logfs_put_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "357-363",
    "snippet": "static void logfs_put_page(struct page *page, int rw)\n{\n\tif (rw == READ)\n\t\tlogfs_put_read_page(page);\n\telse\n\t\tlogfs_put_write_page(page);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_write_page",
          "args": [
            "page"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "342-346",
          "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_put_read_page",
          "args": [
            "page"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "281-285",
          "snippet": "static void logfs_put_read_page(struct page *page)\n{\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_read_page(struct page *page)\n{\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_page(struct page *page, int rw)\n{\n\tif (rw == READ)\n\t\tlogfs_put_read_page(page);\n\telse\n\t\tlogfs_put_write_page(page);\n}"
  },
  {
    "function_name": "logfs_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "348-355",
    "snippet": "static struct page *logfs_get_page(struct inode *inode, u64 bix, level_t level,\n\t\tint rw)\n{\n\tif (rw == READ)\n\t\treturn logfs_get_read_page(inode, bix, level);\n\telse\n\t\treturn logfs_get_write_page(inode, bix, level);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_get_write_page",
          "args": [
            "inode",
            "bix",
            "level"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "310-334",
          "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_read_page",
          "args": [
            "inode",
            "bix",
            "level"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "274-279",
          "snippet": "static struct page *logfs_get_read_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\treturn find_or_create_page(inode->i_mapping,\n\t\t\tlogfs_pack_index(bix, level), GFP_NOFS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_read_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\treturn find_or_create_page(inode->i_mapping,\n\t\t\tlogfs_pack_index(bix, level), GFP_NOFS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_page(struct inode *inode, u64 bix, level_t level,\n\t\tint rw)\n{\n\tif (rw == READ)\n\t\treturn logfs_get_read_page(inode, bix, level);\n\telse\n\t\treturn logfs_get_write_page(inode, bix, level);\n}"
  },
  {
    "function_name": "logfs_put_write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "342-346",
    "snippet": "static void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_unlock_write_page",
          "args": [
            "page"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_unlock_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "336-340",
          "snippet": "static void logfs_unlock_write_page(struct page *page)\n{\n\tif (!PagePreLocked(page))\n\t\tunlock_page(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_unlock_write_page(struct page *page)\n{\n\tif (!PagePreLocked(page))\n\t\tunlock_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_write_page(struct page *page)\n{\n\tlogfs_unlock_write_page(page);\n\tpage_cache_release(page);\n}"
  },
  {
    "function_name": "logfs_unlock_write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "336-340",
    "snippet": "static void logfs_unlock_write_page(struct page *page)\n{\n\tif (!PagePreLocked(page))\n\t\tunlock_page(page);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PagePreLocked",
          "args": [
            "page"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_unlock_write_page(struct page *page)\n{\n\tif (!PagePreLocked(page))\n\t\tunlock_page(page);\n}"
  },
  {
    "function_name": "logfs_get_write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "310-334",
    "snippet": "static struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_lock_write_page",
          "args": [
            "page"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_lock_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "287-308",
          "snippet": "static void logfs_lock_write_page(struct page *page)\n{\n\tint loop = 0;\n\n\twhile (unlikely(!trylock_page(page))) {\n\t\tif (loop++ > 0x1000) {\n\t\t\t/* Has been observed once so far... */\n\t\t\tprintk(KERN_ERR \"stack at %p\\n\", &loop);\n\t\t\tBUG();\n\t\t}\n\t\tif (PagePreLocked(page)) {\n\t\t\t/* Holder of page lock is waiting for us, it\n\t\t\t * is safe to use this page. */\n\t\t\tbreak;\n\t\t}\n\t\t/* Some other process has this page locked and has\n\t\t * nothing to do with us.  Wait for it to finish.\n\t\t */\n\t\tschedule();\n\t}\n\tBUG_ON(!PageLocked(page));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_lock_write_page(struct page *page)\n{\n\tint loop = 0;\n\n\twhile (unlikely(!trylock_page(page))) {\n\t\tif (loop++ > 0x1000) {\n\t\t\t/* Has been observed once so far... */\n\t\t\tprintk(KERN_ERR \"stack at %p\\n\", &loop);\n\t\t\tBUG();\n\t\t}\n\t\tif (PagePreLocked(page)) {\n\t\t\t/* Holder of page lock is waiting for us, it\n\t\t\t * is safe to use this page. */\n\t\t\tbreak;\n\t\t}\n\t\t/* Some other process has this page locked and has\n\t\t * nothing to do with us.  Wait for it to finish.\n\t\t */\n\t\tschedule();\n\t}\n\tBUG_ON(!PageLocked(page));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__page_cache_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_pack_index",
          "args": [
            "bix",
            "level"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_pack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "67-79",
          "snippet": "pgoff_t logfs_pack_index(u64 bix, level_t level)\n{\n\tpgoff_t index;\n\n\tBUG_ON(bix >= INDIRECT_BIT);\n\tif (level == 0)\n\t\treturn bix;\n\n\tindex  = INDIRECT_BIT;\n\tindex |= (__force long)level << LEVEL_SHIFT;\n\tindex |= bix >> ((__force u8)level * LOGFS_BLOCK_BITS);\n\treturn index;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\npgoff_t logfs_pack_index(u64 bix, level_t level)\n{\n\tpgoff_t index;\n\n\tBUG_ON(bix >= INDIRECT_BIT);\n\tif (level == 0)\n\t\treturn bix;\n\n\tindex  = INDIRECT_BIT;\n\tindex |= (__force long)level << LEVEL_SHIFT;\n\tindex |= bix >> ((__force u8)level * LOGFS_BLOCK_BITS);\n\treturn index;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index = logfs_pack_index(bix, level);\n\tstruct page *page;\n\tint err;\n\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\terr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\n\t\tif (unlikely(err)) {\n\t\t\tpage_cache_release(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\treturn NULL;\n\t\t}\n\t} else logfs_lock_write_page(page);\n\tBUG_ON(!PageLocked(page));\n\treturn page;\n}"
  },
  {
    "function_name": "logfs_lock_write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "287-308",
    "snippet": "static void logfs_lock_write_page(struct page *page)\n{\n\tint loop = 0;\n\n\twhile (unlikely(!trylock_page(page))) {\n\t\tif (loop++ > 0x1000) {\n\t\t\t/* Has been observed once so far... */\n\t\t\tprintk(KERN_ERR \"stack at %p\\n\", &loop);\n\t\t\tBUG();\n\t\t}\n\t\tif (PagePreLocked(page)) {\n\t\t\t/* Holder of page lock is waiting for us, it\n\t\t\t * is safe to use this page. */\n\t\t\tbreak;\n\t\t}\n\t\t/* Some other process has this page locked and has\n\t\t * nothing to do with us.  Wait for it to finish.\n\t\t */\n\t\tschedule();\n\t}\n\tBUG_ON(!PageLocked(page));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePreLocked",
          "args": [
            "page"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"stack at %p\\n\"",
            "&loop"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!trylock_page(page)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_lock_write_page(struct page *page)\n{\n\tint loop = 0;\n\n\twhile (unlikely(!trylock_page(page))) {\n\t\tif (loop++ > 0x1000) {\n\t\t\t/* Has been observed once so far... */\n\t\t\tprintk(KERN_ERR \"stack at %p\\n\", &loop);\n\t\t\tBUG();\n\t\t}\n\t\tif (PagePreLocked(page)) {\n\t\t\t/* Holder of page lock is waiting for us, it\n\t\t\t * is safe to use this page. */\n\t\t\tbreak;\n\t\t}\n\t\t/* Some other process has this page locked and has\n\t\t * nothing to do with us.  Wait for it to finish.\n\t\t */\n\t\tschedule();\n\t}\n\tBUG_ON(!PageLocked(page));\n}"
  },
  {
    "function_name": "logfs_put_read_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "281-285",
    "snippet": "static void logfs_put_read_page(struct page *page)\n{\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_read_page(struct page *page)\n{\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
  },
  {
    "function_name": "logfs_get_read_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "274-279",
    "snippet": "static struct page *logfs_get_read_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\treturn find_or_create_page(inode->i_mapping,\n\t\t\tlogfs_pack_index(bix, level), GFP_NOFS);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "logfs_pack_index(bix, level)",
            "GFP_NOFS"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_pack_index",
          "args": [
            "bix",
            "level"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_pack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "67-79",
          "snippet": "pgoff_t logfs_pack_index(u64 bix, level_t level)\n{\n\tpgoff_t index;\n\n\tBUG_ON(bix >= INDIRECT_BIT);\n\tif (level == 0)\n\t\treturn bix;\n\n\tindex  = INDIRECT_BIT;\n\tindex |= (__force long)level << LEVEL_SHIFT;\n\tindex |= bix >> ((__force u8)level * LOGFS_BLOCK_BITS);\n\treturn index;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
            "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\npgoff_t logfs_pack_index(u64 bix, level_t level)\n{\n\tpgoff_t index;\n\n\tBUG_ON(bix >= INDIRECT_BIT);\n\tif (level == 0)\n\t\treturn bix;\n\n\tindex  = INDIRECT_BIT;\n\tindex |= (__force long)level << LEVEL_SHIFT;\n\tindex |= bix >> ((__force u8)level * LOGFS_BLOCK_BITS);\n\treturn index;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_get_read_page(struct inode *inode, u64 bix,\n\t\tlevel_t level)\n{\n\treturn find_or_create_page(inode->i_mapping,\n\t\t\tlogfs_pack_index(bix, level), GFP_NOFS);\n}"
  },
  {
    "function_name": "logfs_put_wblocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "262-272",
    "snippet": "void logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&super->s_write_mutex"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preunlock_page",
          "args": [
            "sb",
            "page",
            "lock"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "preunlock_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "222-237",
          "snippet": "static void preunlock_page(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tBUG_ON(!PageLocked(page));\n\tif (lock)\n\t\tClearPagePreLocked(page);\n\telse {\n\t\t/* We are in GC path. */\n\t\tBUG_ON(!PagePreLocked(page));\n\t\tif (super->s_lock_count)\n\t\t\tsuper->s_lock_count--;\n\t\telse\n\t\t\tClearPagePreLocked(page);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void preunlock_page(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tBUG_ON(!PageLocked(page));\n\tif (lock)\n\t\tClearPagePreLocked(page);\n\telse {\n\t\t/* We are in GC path. */\n\t\tBUG_ON(!PagePreLocked(page));\n\t\tif (super->s_lock_count)\n\t\t\tsuper->s_lock_count--;\n\t\telse\n\t\t\tClearPagePreLocked(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}"
  },
  {
    "function_name": "logfs_get_wblocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "247-260",
    "snippet": "void logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_gc_pass",
          "args": [
            "sb"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_gc_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "615-629",
          "snippet": "void logfs_gc_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\t//BUG_ON(mutex_trylock(&logfs_super(sb)->s_w_mutex));\n\t/* Write journal before free space is getting saturated with dirty\n\t * objects.\n\t */\n\tif (super->s_dirty_used_bytes + super->s_dirty_free_bytes\n\t\t\t+ LOGFS_MAX_OBJECTSIZE >= super->s_free_bytes)\n\t\tlogfs_write_anchor(sb);\n\t__logfs_gc_pass(sb, super->s_total_levels);\n\tlogfs_wl_pass(sb);\n\tlogfs_journal_wl_pass(sb);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_gc_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\t//BUG_ON(mutex_trylock(&logfs_super(sb)->s_w_mutex));\n\t/* Write journal before free space is getting saturated with dirty\n\t * objects.\n\t */\n\tif (super->s_dirty_used_bytes + super->s_dirty_free_bytes\n\t\t\t+ LOGFS_MAX_OBJECTSIZE >= super->s_free_bytes)\n\t\tlogfs_write_anchor(sb);\n\t__logfs_gc_pass(sb, super->s_total_levels);\n\tlogfs_wl_pass(sb);\n\tlogfs_journal_wl_pass(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&super->s_write_mutex"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prelock_page",
          "args": [
            "sb",
            "page",
            "lock"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "prelock_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "205-220",
          "snippet": "static void prelock_page(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tBUG_ON(!PageLocked(page));\n\tif (lock) {\n\t\tBUG_ON(PagePreLocked(page));\n\t\tSetPagePreLocked(page);\n\t} else {\n\t\t/* We are in GC path. */\n\t\tif (PagePreLocked(page))\n\t\t\tsuper->s_lock_count++;\n\t\telse\n\t\t\tSetPagePreLocked(page);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void prelock_page(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tBUG_ON(!PageLocked(page));\n\tif (lock) {\n\t\tBUG_ON(PagePreLocked(page));\n\t\tSetPagePreLocked(page);\n\t} else {\n\t\t/* We are in GC path. */\n\t\tif (PagePreLocked(page))\n\t\t\tsuper->s_lock_count++;\n\t\telse\n\t\t\tSetPagePreLocked(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}"
  },
  {
    "function_name": "preunlock_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "222-237",
    "snippet": "static void preunlock_page(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tBUG_ON(!PageLocked(page));\n\tif (lock)\n\t\tClearPagePreLocked(page);\n\telse {\n\t\t/* We are in GC path. */\n\t\tBUG_ON(!PagePreLocked(page));\n\t\tif (super->s_lock_count)\n\t\t\tsuper->s_lock_count--;\n\t\telse\n\t\t\tClearPagePreLocked(page);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPagePreLocked",
          "args": [
            "page"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PagePreLocked(page)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePreLocked",
          "args": [
            "page"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePreLocked",
          "args": [
            "page"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void preunlock_page(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tBUG_ON(!PageLocked(page));\n\tif (lock)\n\t\tClearPagePreLocked(page);\n\telse {\n\t\t/* We are in GC path. */\n\t\tBUG_ON(!PagePreLocked(page));\n\t\tif (super->s_lock_count)\n\t\t\tsuper->s_lock_count--;\n\t\telse\n\t\t\tClearPagePreLocked(page);\n\t}\n}"
  },
  {
    "function_name": "prelock_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "205-220",
    "snippet": "static void prelock_page(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tBUG_ON(!PageLocked(page));\n\tif (lock) {\n\t\tBUG_ON(PagePreLocked(page));\n\t\tSetPagePreLocked(page);\n\t} else {\n\t\t/* We are in GC path. */\n\t\tif (PagePreLocked(page))\n\t\t\tsuper->s_lock_count++;\n\t\telse\n\t\t\tSetPagePreLocked(page);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPagePreLocked",
          "args": [
            "page"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePreLocked",
          "args": [
            "page"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePreLocked",
          "args": [
            "page"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PagePreLocked(page)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePreLocked",
          "args": [
            "page"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void prelock_page(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tBUG_ON(!PageLocked(page));\n\tif (lock) {\n\t\tBUG_ON(PagePreLocked(page));\n\t\tSetPagePreLocked(page);\n\t} else {\n\t\t/* We are in GC path. */\n\t\tif (PagePreLocked(page))\n\t\t\tsuper->s_lock_count++;\n\t\telse\n\t\t\tSetPagePreLocked(page);\n\t}\n}"
  },
  {
    "function_name": "logfs_set_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "197-203",
    "snippet": "void logfs_set_blocks(struct inode *inode, u64 bytes)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tli->li_used_bytes = bytes;\n\t__logfs_set_blocks(inode);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_set_blocks",
          "args": [
            "inode"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_set_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "187-195",
          "snippet": "static void __logfs_set_blocks(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tinode->i_blocks = ULONG_MAX;\n\tif (li->li_used_bytes >> sb->s_blocksize_bits < ULONG_MAX)\n\t\tinode->i_blocks = ALIGN(li->li_used_bytes, 512) >> 9;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void __logfs_set_blocks(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tinode->i_blocks = ULONG_MAX;\n\tif (li->li_used_bytes >> sb->s_blocksize_bits < ULONG_MAX)\n\t\tinode->i_blocks = ALIGN(li->li_used_bytes, 512) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_set_blocks(struct inode *inode, u64 bytes)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tli->li_used_bytes = bytes;\n\t__logfs_set_blocks(inode);\n}"
  },
  {
    "function_name": "__logfs_set_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "187-195",
    "snippet": "static void __logfs_set_blocks(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tinode->i_blocks = ULONG_MAX;\n\tif (li->li_used_bytes >> sb->s_blocksize_bits < ULONG_MAX)\n\t\tinode->i_blocks = ALIGN(li->li_used_bytes, 512) >> 9;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "li->li_used_bytes",
            "512"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void __logfs_set_blocks(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tinode->i_blocks = ULONG_MAX;\n\tif (li->li_used_bytes >> sb->s_blocksize_bits < ULONG_MAX)\n\t\tinode->i_blocks = ALIGN(li->li_used_bytes, 512) >> 9;\n}"
  },
  {
    "function_name": "logfs_inode_to_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "150-185",
    "snippet": "static void logfs_inode_to_disk(struct inode *inode, struct logfs_disk_inode*di)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tdi->di_mode\t= cpu_to_be16(inode->i_mode);\n\tdi->di_height\t= li->li_height;\n\tdi->di_pad\t= 0;\n\tdi->di_flags\t= cpu_to_be32(li->li_flags);\n\tdi->di_uid\t= cpu_to_be32(i_uid_read(inode));\n\tdi->di_gid\t= cpu_to_be32(i_gid_read(inode));\n\tdi->di_size\t= cpu_to_be64(i_size_read(inode));\n\tdi->di_used_bytes = cpu_to_be64(li->li_used_bytes);\n\tdi->di_atime\t= timespec_to_be64(inode->i_atime);\n\tdi->di_ctime\t= timespec_to_be64(inode->i_ctime);\n\tdi->di_mtime\t= timespec_to_be64(inode->i_mtime);\n\tdi->di_refcount\t= cpu_to_be32(inode->i_nlink);\n\tdi->di_generation = cpu_to_be32(inode->i_generation);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tdi->di_data[0] = cpu_to_be64(inode->i_rdev);\n\t\tbreak;\n\tcase S_IFDIR:\t/* fall through */\n\tcase S_IFREG:\t/* fall through */\n\tcase S_IFLNK:\n\t\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\t\tdi->di_data[i] = cpu_to_be64(li->li_data[i]);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "li->li_data[i]"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "inode->i_rdev"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_generation"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_nlink"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_to_be64",
          "args": [
            "inode->i_mtime"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "timespec_to_be64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "109-112",
          "snippet": "static __be64 timespec_to_be64(struct timespec tsp)\n{\n\treturn cpu_to_be64((u64)tsp.tv_sec * NSEC_PER_SEC + tsp.tv_nsec);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic __be64 timespec_to_be64(struct timespec tsp)\n{\n\treturn cpu_to_be64((u64)tsp.tv_sec * NSEC_PER_SEC + tsp.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "li->li_used_bytes"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "i_size_read(inode)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "i_gid_read(inode)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "i_uid_read(inode)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "li->li_flags"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "inode->i_mode"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_to_disk(struct inode *inode, struct logfs_disk_inode*di)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tdi->di_mode\t= cpu_to_be16(inode->i_mode);\n\tdi->di_height\t= li->li_height;\n\tdi->di_pad\t= 0;\n\tdi->di_flags\t= cpu_to_be32(li->li_flags);\n\tdi->di_uid\t= cpu_to_be32(i_uid_read(inode));\n\tdi->di_gid\t= cpu_to_be32(i_gid_read(inode));\n\tdi->di_size\t= cpu_to_be64(i_size_read(inode));\n\tdi->di_used_bytes = cpu_to_be64(li->li_used_bytes);\n\tdi->di_atime\t= timespec_to_be64(inode->i_atime);\n\tdi->di_ctime\t= timespec_to_be64(inode->i_ctime);\n\tdi->di_mtime\t= timespec_to_be64(inode->i_mtime);\n\tdi->di_refcount\t= cpu_to_be32(inode->i_nlink);\n\tdi->di_generation = cpu_to_be32(inode->i_generation);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tdi->di_data[0] = cpu_to_be64(inode->i_rdev);\n\t\tbreak;\n\tcase S_IFDIR:\t/* fall through */\n\tcase S_IFREG:\t/* fall through */\n\tcase S_IFLNK:\n\t\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\t\tdi->di_data[i] = cpu_to_be64(li->li_data[i]);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "logfs_disk_to_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "114-148",
    "snippet": "static void logfs_disk_to_inode(struct logfs_disk_inode *di, struct inode*inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tinode->i_mode\t= be16_to_cpu(di->di_mode);\n\tli->li_height\t= di->di_height;\n\tli->li_flags\t= be32_to_cpu(di->di_flags);\n\ti_uid_write(inode, be32_to_cpu(di->di_uid));\n\ti_gid_write(inode, be32_to_cpu(di->di_gid));\n\tinode->i_size\t= be64_to_cpu(di->di_size);\n\tlogfs_set_blocks(inode, be64_to_cpu(di->di_used_bytes));\n\tinode->i_atime\t= be64_to_timespec(di->di_atime);\n\tinode->i_ctime\t= be64_to_timespec(di->di_ctime);\n\tinode->i_mtime\t= be64_to_timespec(di->di_mtime);\n\tset_nlink(inode, be32_to_cpu(di->di_refcount));\n\tinode->i_generation = be32_to_cpu(di->di_generation);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinode->i_rdev = be64_to_cpu(di->di_data[0]);\n\t\tbreak;\n\tcase S_IFDIR:\t/* fall through */\n\tcase S_IFREG:\t/* fall through */\n\tcase S_IFLNK:\n\t\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\t\tli->li_data[i] = be64_to_cpu(di->di_data[i]);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "di->di_data[i]"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "di->di_data[0]"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "di->di_generation"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "be32_to_cpu(di->di_refcount)"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "di->di_refcount"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_timespec",
          "args": [
            "di->di_mtime"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "be64_to_timespec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "104-107",
          "snippet": "static struct timespec be64_to_timespec(__be64 betime)\n{\n\treturn ns_to_timespec(be64_to_cpu(betime));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct timespec be64_to_timespec(__be64 betime)\n{\n\treturn ns_to_timespec(be64_to_cpu(betime));\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_set_blocks",
          "args": [
            "inode",
            "be64_to_cpu(di->di_used_bytes)"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "197-203",
          "snippet": "void logfs_set_blocks(struct inode *inode, u64 bytes)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tli->li_used_bytes = bytes;\n\t__logfs_set_blocks(inode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_set_blocks(struct inode *inode, u64 bytes)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tli->li_used_bytes = bytes;\n\t__logfs_set_blocks(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "di->di_used_bytes"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "di->di_size"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "be32_to_cpu(di->di_gid)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "di->di_gid"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "be32_to_cpu(di->di_uid)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "di->di_uid"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "di->di_flags"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "di->di_mode"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_disk_to_inode(struct logfs_disk_inode *di, struct inode*inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tinode->i_mode\t= be16_to_cpu(di->di_mode);\n\tli->li_height\t= di->di_height;\n\tli->li_flags\t= be32_to_cpu(di->di_flags);\n\ti_uid_write(inode, be32_to_cpu(di->di_uid));\n\ti_gid_write(inode, be32_to_cpu(di->di_gid));\n\tinode->i_size\t= be64_to_cpu(di->di_size);\n\tlogfs_set_blocks(inode, be64_to_cpu(di->di_used_bytes));\n\tinode->i_atime\t= be64_to_timespec(di->di_atime);\n\tinode->i_ctime\t= be64_to_timespec(di->di_ctime);\n\tinode->i_mtime\t= be64_to_timespec(di->di_mtime);\n\tset_nlink(inode, be32_to_cpu(di->di_refcount));\n\tinode->i_generation = be32_to_cpu(di->di_generation);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinode->i_rdev = be64_to_cpu(di->di_data[0]);\n\t\tbreak;\n\tcase S_IFDIR:\t/* fall through */\n\tcase S_IFREG:\t/* fall through */\n\tcase S_IFLNK:\n\t\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\t\tli->li_data[i] = be64_to_cpu(di->di_data[i]);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "timespec_to_be64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "109-112",
    "snippet": "static __be64 timespec_to_be64(struct timespec tsp)\n{\n\treturn cpu_to_be64((u64)tsp.tv_sec * NSEC_PER_SEC + tsp.tv_nsec);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "(u64)tsp.tv_sec * NSEC_PER_SEC + tsp.tv_nsec"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic __be64 timespec_to_be64(struct timespec tsp)\n{\n\treturn cpu_to_be64((u64)tsp.tv_sec * NSEC_PER_SEC + tsp.tv_nsec);\n}"
  },
  {
    "function_name": "be64_to_timespec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "104-107",
    "snippet": "static struct timespec be64_to_timespec(__be64 betime)\n{\n\treturn ns_to_timespec(be64_to_cpu(betime));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timespec",
          "args": [
            "be64_to_cpu(betime)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "betime"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct timespec be64_to_timespec(__be64 betime)\n{\n\treturn ns_to_timespec(be64_to_cpu(betime));\n}"
  },
  {
    "function_name": "logfs_unpack_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "81-96",
    "snippet": "void logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [
      "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
      "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "adjust_bix",
          "args": [
            "*bix",
            "*level"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_bix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "23-42",
          "snippet": "static u64 adjust_bix(u64 bix, level_t level)\n{\n\tswitch (level) {\n\tcase 0:\n\t\treturn bix;\n\tcase LEVEL(1):\n\t\treturn max_t(u64, bix, I0_BLOCKS);\n\tcase LEVEL(2):\n\t\treturn max_t(u64, bix, I1_BLOCKS);\n\tcase LEVEL(3):\n\t\treturn max_t(u64, bix, I2_BLOCKS);\n\tcase LEVEL(4):\n\t\treturn max_t(u64, bix, I3_BLOCKS);\n\tcase LEVEL(5):\n\t\treturn max_t(u64, bix, I4_BLOCKS);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn bix;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 adjust_bix(u64 bix, level_t level)\n{\n\tswitch (level) {\n\tcase 0:\n\t\treturn bix;\n\tcase LEVEL(1):\n\t\treturn max_t(u64, bix, I0_BLOCKS);\n\tcase LEVEL(2):\n\t\treturn max_t(u64, bix, I1_BLOCKS);\n\tcase LEVEL(3):\n\t\treturn max_t(u64, bix, I2_BLOCKS);\n\tcase LEVEL(4):\n\t\treturn max_t(u64, bix, I3_BLOCKS);\n\tcase LEVEL(5):\n\t\treturn max_t(u64, bix, I4_BLOCKS);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn bix;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "__level"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\nvoid logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\n{\n\tu8 __level;\n\n\tif (!(index & INDIRECT_BIT)) {\n\t\t*bix = index;\n\t\t*level = 0;\n\t\treturn;\n\t}\n\n\t__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\n\t*level = LEVEL(__level);\n\t*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\n\t*bix = adjust_bix(*bix, *level);\n\treturn;\n}"
  },
  {
    "function_name": "logfs_pack_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "67-79",
    "snippet": "pgoff_t logfs_pack_index(u64 bix, level_t level)\n{\n\tpgoff_t index;\n\n\tBUG_ON(bix >= INDIRECT_BIT);\n\tif (level == 0)\n\t\treturn bix;\n\n\tindex  = INDIRECT_BIT;\n\tindex |= (__force long)level << LEVEL_SHIFT;\n\tindex |= bix >> ((__force u8)level * LOGFS_BLOCK_BITS);\n\treturn index;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [
      "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
      "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bix >= INDIRECT_BIT"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\npgoff_t logfs_pack_index(u64 bix, level_t level)\n{\n\tpgoff_t index;\n\n\tBUG_ON(bix >= INDIRECT_BIT);\n\tif (level == 0)\n\t\treturn bix;\n\n\tindex  = INDIRECT_BIT;\n\tindex |= (__force long)level << LEVEL_SHIFT;\n\tindex |= bix >> ((__force u8)level * LOGFS_BLOCK_BITS);\n\treturn index;\n}"
  },
  {
    "function_name": "first_indirect_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "62-65",
    "snippet": "static inline pgoff_t first_indirect_block(void)\n{\n\treturn INDIRECT_BIT | (1ULL << LEVEL_SHIFT);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [
      "#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)",
      "#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LEVEL_SHIFT\t(28 + ARCH_SHIFT)\n#define INDIRECT_BIT\t(0x80000000UL << ARCH_SHIFT)\n\nstatic inline pgoff_t first_indirect_block(void)\n{\n\treturn INDIRECT_BIT | (1ULL << LEVEL_SHIFT);\n}"
  },
  {
    "function_name": "maxbix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "44-47",
    "snippet": "static inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic inline u64 maxbix(u8 height)\n{\n\treturn 1ULL << (LOGFS_BLOCK_BITS * height);\n}"
  },
  {
    "function_name": "adjust_bix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
    "lines": "23-42",
    "snippet": "static u64 adjust_bix(u64 bix, level_t level)\n{\n\tswitch (level) {\n\tcase 0:\n\t\treturn bix;\n\tcase LEVEL(1):\n\t\treturn max_t(u64, bix, I0_BLOCKS);\n\tcase LEVEL(2):\n\t\treturn max_t(u64, bix, I1_BLOCKS);\n\tcase LEVEL(3):\n\t\treturn max_t(u64, bix, I2_BLOCKS);\n\tcase LEVEL(4):\n\t\treturn max_t(u64, bix, I3_BLOCKS);\n\tcase LEVEL(5):\n\t\treturn max_t(u64, bix, I4_BLOCKS);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn bix;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "bix",
            "I4_BLOCKS"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "5"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "bix",
            "I3_BLOCKS"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "4"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "bix",
            "I2_BLOCKS"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "3"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "bix",
            "I1_BLOCKS"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "2"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "bix",
            "I0_BLOCKS"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEVEL",
          "args": [
            "1"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u64 adjust_bix(u64 bix, level_t level)\n{\n\tswitch (level) {\n\tcase 0:\n\t\treturn bix;\n\tcase LEVEL(1):\n\t\treturn max_t(u64, bix, I0_BLOCKS);\n\tcase LEVEL(2):\n\t\treturn max_t(u64, bix, I1_BLOCKS);\n\tcase LEVEL(3):\n\t\treturn max_t(u64, bix, I2_BLOCKS);\n\tcase LEVEL(4):\n\t\treturn max_t(u64, bix, I3_BLOCKS);\n\tcase LEVEL(5):\n\t\treturn max_t(u64, bix, I4_BLOCKS);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn bix;\n\t}\n}"
  }
]