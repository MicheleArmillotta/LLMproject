[
  {
    "function_name": "unfix_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "2781-2825",
    "snippet": "void unfix_nodes(struct tree_balance *tb)\n{\n\tint i;\n\n\t/* Release path buffers. */\n\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\n\t/* brelse all resources collected for balancing */\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->L[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->R[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FR[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFR[i]);\n\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\t}\n\n\t/* deal with list of allocated (used and unused) nodes */\n\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\tif (tb->FEB[i]) {\n\t\t\tb_blocknr_t blocknr = tb->FEB[i]->b_blocknr;\n\t\t\t/*\n\t\t\t * de-allocated block which was not used by\n\t\t\t * balancing and bforget about buffer for it\n\t\t\t */\n\t\t\tbrelse(tb->FEB[i]);\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t\tif (tb->used[i]) {\n\t\t\t/* release used as new nodes including a new root */\n\t\t\tbrelse(tb->used[i]);\n\t\t}\n\t}\n\n\tkfree(tb->vn_buf);\n\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tb->vn_buf"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "tb->used[i]"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_free_block",
          "args": [
            "tb->transaction_handle",
            "NULL",
            "blocknr",
            "0"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "467-488",
          "snippet": "void reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_restore_prepared_buffer",
          "args": [
            "tb->tb_sb",
            "tb->CFR[i]"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_restore_prepared_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3920-3942",
          "snippet": "void reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse_and_restore",
          "args": [
            "tb->tb_sb",
            "tb->tb_path"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse_and_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "358-373",
          "snippet": "void pathrelse_and_restore(struct super_block *sb,\n\t\t\t   struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"clm-4000: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {\n\t\tstruct buffer_head *bh;\n\t\tbh = PATH_OFFSET_PBUFFER(search_path, path_offset--);\n\t\treiserfs_restore_prepared_buffer(sb, bh);\n\t\tbrelse(bh);\n\t}\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse_and_restore(struct super_block *sb,\n\t\t\t   struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"clm-4000: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {\n\t\tstruct buffer_head *bh;\n\t\tbh = PATH_OFFSET_PBUFFER(search_path, path_offset--);\n\t\treiserfs_restore_prepared_buffer(sb, bh);\n\t\tbrelse(bh);\n\t}\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nvoid unfix_nodes(struct tree_balance *tb)\n{\n\tint i;\n\n\t/* Release path buffers. */\n\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\n\t/* brelse all resources collected for balancing */\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->L[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->R[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FR[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFR[i]);\n\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\t}\n\n\t/* deal with list of allocated (used and unused) nodes */\n\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\tif (tb->FEB[i]) {\n\t\t\tb_blocknr_t blocknr = tb->FEB[i]->b_blocknr;\n\t\t\t/*\n\t\t\t * de-allocated block which was not used by\n\t\t\t * balancing and bforget about buffer for it\n\t\t\t */\n\t\t\tbrelse(tb->FEB[i]);\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t\tif (tb->used[i]) {\n\t\t\t/* release used as new nodes including a new root */\n\t\t\tbrelse(tb->used[i]);\n\t\t}\n\t}\n\n\tkfree(tb->vn_buf);\n\n}"
  },
  {
    "function_name": "fix_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "2549-2779",
    "snippet": "int fix_nodes(int op_mode, struct tree_balance *tb,\n\t      struct item_head *ins_ih, const void *data)\n{\n\tint ret, h, item_num = PATH_LAST_POSITION(tb->tb_path);\n\tint pos_in_item;\n\n\t/*\n\t * we set wait_tb_buffers_run when we have to restore any dirty\n\t * bits cleared during wait_tb_buffers_run\n\t */\n\tint wait_tb_buffers_run = 0;\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\n\t++REISERFS_SB(tb->tb_sb)->s_fix_nodes;\n\n\tpos_in_item = tb->tb_path->pos_in_item;\n\n\ttb->fs_gen = get_generation(tb->tb_sb);\n\n\t/*\n\t * we prepare and log the super here so it will already be in the\n\t * transaction when do_balance needs to change it.\n\t * This way do_balance won't have to schedule when trying to prepare\n\t * the super for logging\n\t */\n\treiserfs_prepare_for_journal(tb->tb_sb,\n\t\t\t\t     SB_BUFFER_WITH_SB(tb->tb_sb), 1);\n\tjournal_mark_dirty(tb->transaction_handle,\n\t\t\t   SB_BUFFER_WITH_SB(tb->tb_sb));\n\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\treturn REPEAT_SEARCH;\n\n\t/* if it possible in indirect_to_direct conversion */\n\tif (buffer_locked(tbS0)) {\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(tbS0);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\treturn REPEAT_SEARCH;\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\tif (REISERFS_SB(tb->tb_sb)->cur_tb) {\n\t\tprint_cur_tb(\"fix_nodes\");\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8305\",\n\t\t\t       \"there is pending do_balance\");\n\t}\n\n\tif (!buffer_uptodate(tbS0) || !B_IS_IN_TREE(tbS0))\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8320\", \"S[0] (%b %z) is \"\n\t\t\t       \"not uptodate at the beginning of fix_nodes \"\n\t\t\t       \"or not in tree (mode %c)\",\n\t\t\t       tbS0, tbS0, op_mode);\n\n\t/* Check parameters. */\n\tswitch (op_mode) {\n\tcase M_INSERT:\n\t\tif (item_num <= 0 || item_num > B_NR_ITEMS(tbS0))\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-8330\", \"Incorrect \"\n\t\t\t\t       \"item number %d (in S0 - %d) in case \"\n\t\t\t\t       \"of insert\", item_num,\n\t\t\t\t       B_NR_ITEMS(tbS0));\n\t\tbreak;\n\tcase M_PASTE:\n\tcase M_DELETE:\n\tcase M_CUT:\n\t\tif (item_num < 0 || item_num >= B_NR_ITEMS(tbS0)) {\n\t\t\tprint_block(tbS0, 0, -1, -1);\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-8335\", \"Incorrect \"\n\t\t\t\t       \"item number(%d); mode = %c \"\n\t\t\t\t       \"insert_size = %d\",\n\t\t\t\t       item_num, op_mode,\n\t\t\t\t       tb->insert_size[0]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8340\", \"Incorrect mode \"\n\t\t\t       \"of operation\");\n\t}\n#endif\n\n\tif (get_mem_for_virtual_node(tb) == REPEAT_SEARCH)\n\t\t/* FIXME: maybe -ENOMEM when tb->vn_buf == 0? Now just repeat */\n\t\treturn REPEAT_SEARCH;\n\n\t/* Starting from the leaf level; for all levels h of the tree. */\n\tfor (h = 0; h < MAX_HEIGHT && tb->insert_size[h]; h++) {\n\t\tret = get_direct_parent(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\tret = check_balance(op_mode, tb, h, item_num,\n\t\t\t\t    pos_in_item, ins_ih, data);\n\t\tif (ret != CARRY_ON) {\n\t\t\tif (ret == NO_BALANCING_NEEDED) {\n\t\t\t\t/* No balancing for higher levels needed. */\n\t\t\t\tret = get_neighbors(tb, h);\n\t\t\t\tif (ret != CARRY_ON)\n\t\t\t\t\tgoto repeat;\n\t\t\t\tif (h != MAX_HEIGHT - 1)\n\t\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t\t\t/*\n\t\t\t\t * ok, analysis and resource gathering\n\t\t\t\t * are complete\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tret = get_neighbors(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\t/*\n\t\t * No disk space, or schedule occurred and analysis may be\n\t\t * invalid and needs to be redone.\n\t\t */\n\t\tret = get_empty_nodes(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\t/*\n\t\t * We have a positive insert size but no nodes exist on this\n\t\t * level, this means that we are creating a new root.\n\t\t */\n\t\tif (!PATH_H_PBUFFER(tb->tb_path, h)) {\n\n\t\t\tRFALSE(tb->blknum[h] != 1,\n\t\t\t       \"PAP-8350: creating new empty root\");\n\n\t\t\tif (h < MAX_HEIGHT - 1)\n\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t} else if (!PATH_H_PBUFFER(tb->tb_path, h + 1)) {\n\t\t\t/*\n\t\t\t * The tree needs to be grown, so this node S[h]\n\t\t\t * which is the root node is split into two nodes,\n\t\t\t * and a new node (S[h+1]) will be created to\n\t\t\t * become the root node.\n\t\t\t */\n\t\t\tif (tb->blknum[h] > 1) {\n\n\t\t\t\tRFALSE(h == MAX_HEIGHT - 1,\n\t\t\t\t       \"PAP-8355: attempt to create too high of a tree\");\n\n\t\t\t\ttb->insert_size[h + 1] =\n\t\t\t\t    (DC_SIZE +\n\t\t\t\t     KEY_SIZE) * (tb->blknum[h] - 1) +\n\t\t\t\t    DC_SIZE;\n\t\t\t} else if (h < MAX_HEIGHT - 1)\n\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t} else\n\t\t\ttb->insert_size[h + 1] =\n\t\t\t    (DC_SIZE + KEY_SIZE) * (tb->blknum[h] - 1);\n\t}\n\n\tret = wait_tb_buffers_until_unlocked(tb);\n\tif (ret == CARRY_ON) {\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\twait_tb_buffers_run = 1;\n\t\t\tret = REPEAT_SEARCH;\n\t\t\tgoto repeat;\n\t\t} else {\n\t\t\treturn CARRY_ON;\n\t\t}\n\t} else {\n\t\twait_tb_buffers_run = 1;\n\t\tgoto repeat;\n\t}\n\nrepeat:\n\t/*\n\t * fix_nodes was unable to perform its calculation due to\n\t * filesystem got changed under us, lack of free disk space or i/o\n\t * failure. If the first is the case - the search will be\n\t * repeated. For now - free all resources acquired so far except\n\t * for the new allocated nodes\n\t */\n\t{\n\t\tint i;\n\n\t\t/* Release path buffers. */\n\t\tif (wait_tb_buffers_run) {\n\t\t\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\t\t} else {\n\t\t\tpathrelse(tb->tb_path);\n\t\t}\n\t\t/* brelse all resources collected for balancing */\n\t\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\t\tif (wait_tb_buffers_run) {\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->L[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->R[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->FL[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->FR[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->\n\t\t\t\t\t\t\t\t CFL[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->\n\t\t\t\t\t\t\t\t CFR[i]);\n\t\t\t}\n\n\t\t\tbrelse(tb->L[i]);\n\t\t\tbrelse(tb->R[i]);\n\t\t\tbrelse(tb->FL[i]);\n\t\t\tbrelse(tb->FR[i]);\n\t\t\tbrelse(tb->CFL[i]);\n\t\t\tbrelse(tb->CFR[i]);\n\n\t\t\ttb->L[i] = NULL;\n\t\t\ttb->R[i] = NULL;\n\t\t\ttb->FL[i] = NULL;\n\t\t\ttb->FR[i] = NULL;\n\t\t\ttb->CFL[i] = NULL;\n\t\t\ttb->CFR[i] = NULL;\n\t\t}\n\n\t\tif (wait_tb_buffers_run) {\n\t\t\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\t\t\tif (tb->FEB[i])\n\t\t\t\t\treiserfs_restore_prepared_buffer\n\t\t\t\t\t    (tb->tb_sb, tb->FEB[i]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_restore_prepared_buffer",
          "args": [
            "tb->tb_sb",
            "tb->FEB[i]"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_restore_prepared_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3920-3942",
          "snippet": "void reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "tb->CFR[i]"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "tb->tb_path"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse_and_restore",
          "args": [
            "tb->tb_sb",
            "tb->tb_path"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse_and_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "358-373",
          "snippet": "void pathrelse_and_restore(struct super_block *sb,\n\t\t\t   struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"clm-4000: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {\n\t\tstruct buffer_head *bh;\n\t\tbh = PATH_OFFSET_PBUFFER(search_path, path_offset--);\n\t\treiserfs_restore_prepared_buffer(sb, bh);\n\t\tbrelse(bh);\n\t}\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse_and_restore(struct super_block *sb,\n\t\t\t   struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"clm-4000: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {\n\t\tstruct buffer_head *bh;\n\t\tbh = PATH_OFFSET_PBUFFER(search_path, path_offset--);\n\t\treiserfs_restore_prepared_buffer(sb, bh);\n\t\tbrelse(bh);\n\t}\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_tb_buffers_until_unlocked",
          "args": [
            "tb"
          ],
          "line": 2704
        },
        "resolved": true,
        "details": {
          "function_name": "wait_tb_buffers_until_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2367-2516",
          "snippet": "static int wait_tb_buffers_until_unlocked(struct tree_balance *tb)\n{\n\tstruct buffer_head *locked;\n#ifdef CONFIG_REISERFS_CHECK\n\tint repeat_counter = 0;\n#endif\n\tint i;\n\n\tdo {\n\n\t\tlocked = NULL;\n\n\t\tfor (i = tb->tb_path->path_length;\n\t\t     !locked && i > ILLEGAL_PATH_ELEMENT_OFFSET; i--) {\n\t\t\tif (PATH_OFFSET_PBUFFER(tb->tb_path, i)) {\n\t\t\t\t/*\n\t\t\t\t * if I understand correctly, we can only\n\t\t\t\t * be sure the last buffer in the path is\n\t\t\t\t * in the tree --clm\n\t\t\t\t */\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\tif (PATH_PLAST_BUFFER(tb->tb_path) ==\n\t\t\t\t    PATH_OFFSET_PBUFFER(tb->tb_path, i))\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       PATH_OFFSET_PBUFFER\n\t\t\t\t\t\t\t       (tb->tb_path,\n\t\t\t\t\t\t\t\ti), \"S\",\n\t\t\t\t\t\t\t       tb->tb_path->\n\t\t\t\t\t\t\t       path_length - i);\n#endif\n\t\t\t\tif (!clear_all_dirty_bits(tb->tb_sb,\n\t\t\t\t\t\t\t  PATH_OFFSET_PBUFFER\n\t\t\t\t\t\t\t  (tb->tb_path,\n\t\t\t\t\t\t\t   i))) {\n\t\t\t\t\tlocked =\n\t\t\t\t\t    PATH_OFFSET_PBUFFER(tb->tb_path,\n\t\t\t\t\t\t\t\ti);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; !locked && i < MAX_HEIGHT && tb->insert_size[i];\n\t\t     i++) {\n\n\t\t\tif (tb->lnum[i]) {\n\n\t\t\t\tif (tb->L[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->L[i],\n\t\t\t\t\t\t\t       \"L\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->L[i]))\n\t\t\t\t\t\tlocked = tb->L[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->FL[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->FL[i],\n\t\t\t\t\t\t\t       \"FL\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->FL[i]))\n\t\t\t\t\t\tlocked = tb->FL[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->CFL[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->CFL[i],\n\t\t\t\t\t\t\t       \"CFL\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->CFL[i]))\n\t\t\t\t\t\tlocked = tb->CFL[i];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (!locked && (tb->rnum[i])) {\n\n\t\t\t\tif (tb->R[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->R[i],\n\t\t\t\t\t\t\t       \"R\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->R[i]))\n\t\t\t\t\t\tlocked = tb->R[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->FR[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->FR[i],\n\t\t\t\t\t\t\t       \"FR\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->FR[i]))\n\t\t\t\t\t\tlocked = tb->FR[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->CFR[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->CFR[i],\n\t\t\t\t\t\t\t       \"CFR\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->CFR[i]))\n\t\t\t\t\t\tlocked = tb->CFR[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * as far as I can tell, this is not required.  The FEB list\n\t\t * seems to be full of newly allocated nodes, which will\n\t\t * never be locked, dirty, or anything else.\n\t\t * To be safe, I'm putting in the checks and waits in.\n\t\t * For the moment, they are needed to keep the code in\n\t\t * journal.c from complaining about the buffer.\n\t\t * That code is inside CONFIG_REISERFS_CHECK as well.  --clm\n\t\t */\n\t\tfor (i = 0; !locked && i < MAX_FEB_SIZE; i++) {\n\t\t\tif (tb->FEB[i]) {\n\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t    (tb->tb_sb, tb->FEB[i]))\n\t\t\t\t\tlocked = tb->FEB[i];\n\t\t\t}\n\t\t}\n\n\t\tif (locked) {\n\t\t\tint depth;\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\trepeat_counter++;\n\t\t\tif ((repeat_counter % 10000) == 0) {\n\t\t\t\treiserfs_warning(tb->tb_sb, \"reiserfs-8200\",\n\t\t\t\t\t\t \"too many iterations waiting \"\n\t\t\t\t\t\t \"for buffer to unlock \"\n\t\t\t\t\t\t \"(%b)\", locked);\n\n\t\t\t\t/* Don't loop forever.  Try to recover from possible error. */\n\n\t\t\t\treturn (FILESYSTEM_CHANGED_TB(tb)) ?\n\t\t\t\t    REPEAT_SEARCH : CARRY_ON;\n\t\t\t}\n#endif\n\t\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t\t__wait_on_buffer(locked);\n\t\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t} while (locked);\n\n\treturn CARRY_ON;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int wait_tb_buffers_until_unlocked(struct tree_balance *tb)\n{\n\tstruct buffer_head *locked;\n#ifdef CONFIG_REISERFS_CHECK\n\tint repeat_counter = 0;\n#endif\n\tint i;\n\n\tdo {\n\n\t\tlocked = NULL;\n\n\t\tfor (i = tb->tb_path->path_length;\n\t\t     !locked && i > ILLEGAL_PATH_ELEMENT_OFFSET; i--) {\n\t\t\tif (PATH_OFFSET_PBUFFER(tb->tb_path, i)) {\n\t\t\t\t/*\n\t\t\t\t * if I understand correctly, we can only\n\t\t\t\t * be sure the last buffer in the path is\n\t\t\t\t * in the tree --clm\n\t\t\t\t */\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\tif (PATH_PLAST_BUFFER(tb->tb_path) ==\n\t\t\t\t    PATH_OFFSET_PBUFFER(tb->tb_path, i))\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       PATH_OFFSET_PBUFFER\n\t\t\t\t\t\t\t       (tb->tb_path,\n\t\t\t\t\t\t\t\ti), \"S\",\n\t\t\t\t\t\t\t       tb->tb_path->\n\t\t\t\t\t\t\t       path_length - i);\n#endif\n\t\t\t\tif (!clear_all_dirty_bits(tb->tb_sb,\n\t\t\t\t\t\t\t  PATH_OFFSET_PBUFFER\n\t\t\t\t\t\t\t  (tb->tb_path,\n\t\t\t\t\t\t\t   i))) {\n\t\t\t\t\tlocked =\n\t\t\t\t\t    PATH_OFFSET_PBUFFER(tb->tb_path,\n\t\t\t\t\t\t\t\ti);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; !locked && i < MAX_HEIGHT && tb->insert_size[i];\n\t\t     i++) {\n\n\t\t\tif (tb->lnum[i]) {\n\n\t\t\t\tif (tb->L[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->L[i],\n\t\t\t\t\t\t\t       \"L\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->L[i]))\n\t\t\t\t\t\tlocked = tb->L[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->FL[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->FL[i],\n\t\t\t\t\t\t\t       \"FL\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->FL[i]))\n\t\t\t\t\t\tlocked = tb->FL[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->CFL[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->CFL[i],\n\t\t\t\t\t\t\t       \"CFL\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->CFL[i]))\n\t\t\t\t\t\tlocked = tb->CFL[i];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (!locked && (tb->rnum[i])) {\n\n\t\t\t\tif (tb->R[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->R[i],\n\t\t\t\t\t\t\t       \"R\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->R[i]))\n\t\t\t\t\t\tlocked = tb->R[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->FR[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->FR[i],\n\t\t\t\t\t\t\t       \"FR\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->FR[i]))\n\t\t\t\t\t\tlocked = tb->FR[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->CFR[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->CFR[i],\n\t\t\t\t\t\t\t       \"CFR\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->CFR[i]))\n\t\t\t\t\t\tlocked = tb->CFR[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * as far as I can tell, this is not required.  The FEB list\n\t\t * seems to be full of newly allocated nodes, which will\n\t\t * never be locked, dirty, or anything else.\n\t\t * To be safe, I'm putting in the checks and waits in.\n\t\t * For the moment, they are needed to keep the code in\n\t\t * journal.c from complaining about the buffer.\n\t\t * That code is inside CONFIG_REISERFS_CHECK as well.  --clm\n\t\t */\n\t\tfor (i = 0; !locked && i < MAX_FEB_SIZE; i++) {\n\t\t\tif (tb->FEB[i]) {\n\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t    (tb->tb_sb, tb->FEB[i]))\n\t\t\t\t\tlocked = tb->FEB[i];\n\t\t\t}\n\t\t}\n\n\t\tif (locked) {\n\t\t\tint depth;\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\trepeat_counter++;\n\t\t\tif ((repeat_counter % 10000) == 0) {\n\t\t\t\treiserfs_warning(tb->tb_sb, \"reiserfs-8200\",\n\t\t\t\t\t\t \"too many iterations waiting \"\n\t\t\t\t\t\t \"for buffer to unlock \"\n\t\t\t\t\t\t \"(%b)\", locked);\n\n\t\t\t\t/* Don't loop forever.  Try to recover from possible error. */\n\n\t\t\t\treturn (FILESYSTEM_CHANGED_TB(tb)) ?\n\t\t\t\t    REPEAT_SEARCH : CARRY_ON;\n\t\t\t}\n#endif\n\t\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t\t__wait_on_buffer(locked);\n\t\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t} while (locked);\n\n\treturn CARRY_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "h == MAX_HEIGHT - 1",
            "\"PAP-8355: attempt to create too high of a tree\""
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->blknum[h] != 1",
            "\"PAP-8350: creating new empty root\""
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_empty_nodes",
          "args": [
            "tb",
            "h"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "get_empty_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "829-911",
          "snippet": "static int get_empty_nodes(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *new_bh, *Sh = PATH_H_PBUFFER(tb->tb_path, h);\n\tb_blocknr_t *blocknr, blocknrs[MAX_AMOUNT_NEEDED] = { 0, };\n\tint counter, number_of_freeblk;\n\tint  amount_needed;\t/* number of needed empty blocks */\n\tint  retval = CARRY_ON;\n\tstruct super_block *sb = tb->tb_sb;\n\n\t/*\n\t * number_of_freeblk is the number of empty blocks which have been\n\t * acquired for use by the balancing algorithm minus the number of\n\t * empty blocks used in the previous levels of the analysis,\n\t * number_of_freeblk = tb->cur_blknum can be non-zero if a schedule\n\t * occurs after empty blocks are acquired, and the balancing analysis\n\t * is then restarted, amount_needed is the number needed by this\n\t * level (h) of the balancing analysis.\n\t *\n\t * Note that for systems with many processes writing, it would be\n\t * more layout optimal to calculate the total number needed by all\n\t * levels and then to run reiserfs_new_blocks to get all of them at\n\t * once.\n\t */\n\n\t/*\n\t * Initiate number_of_freeblk to the amount acquired prior to the\n\t * restart of the analysis or 0 if not restarted, then subtract the\n\t * amount needed by all of the levels of the tree below h.\n\t */\n\t/* blknum includes S[h], so we subtract 1 in this calculation */\n\tfor (counter = 0, number_of_freeblk = tb->cur_blknum;\n\t     counter < h; counter++)\n\t\tnumber_of_freeblk -=\n\t\t    (tb->blknum[counter]) ? (tb->blknum[counter] -\n\t\t\t\t\t\t   1) : 0;\n\n\t/* Allocate missing empty blocks. */\n\t/* if Sh == 0  then we are getting a new root */\n\tamount_needed = (Sh) ? (tb->blknum[h] - 1) : 1;\n\t/*\n\t * Amount_needed = the amount that we need more than the\n\t * amount that we have.\n\t */\n\tif (amount_needed > number_of_freeblk)\n\t\tamount_needed -= number_of_freeblk;\n\telse\t/* If we have enough already then there is nothing to do. */\n\t\treturn CARRY_ON;\n\n\t/*\n\t * No need to check quota - is not allocated for blocks used\n\t * for formatted nodes\n\t */\n\tif (reiserfs_new_form_blocknrs(tb, blocknrs,\n\t\t\t\t       amount_needed) == NO_DISK_SPACE)\n\t\treturn NO_DISK_SPACE;\n\n\t/* for each blocknumber we just got, get a buffer and stick it on FEB */\n\tfor (blocknr = blocknrs, counter = 0;\n\t     counter < amount_needed; blocknr++, counter++) {\n\n\t\tRFALSE(!*blocknr,\n\t\t       \"PAP-8135: reiserfs_new_blocknrs failed when got new blocks\");\n\n\t\tnew_bh = sb_getblk(sb, *blocknr);\n\t\tRFALSE(buffer_dirty(new_bh) ||\n\t\t       buffer_journaled(new_bh) ||\n\t\t       buffer_journal_dirty(new_bh),\n\t\t       \"PAP-8140: journaled or dirty buffer %b for the new block\",\n\t\t       new_bh);\n\n\t\t/* Put empty buffers into the array. */\n\t\tRFALSE(tb->FEB[tb->cur_blknum],\n\t\t       \"PAP-8141: busy slot for new buffer\");\n\n\t\tset_buffer_journal_new(new_bh);\n\t\ttb->FEB[tb->cur_blknum++] = new_bh;\n\t}\n\n\tif (retval == CARRY_ON && FILESYSTEM_CHANGED_TB(tb))\n\t\tretval = REPEAT_SEARCH;\n\n\treturn retval;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_empty_nodes(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *new_bh, *Sh = PATH_H_PBUFFER(tb->tb_path, h);\n\tb_blocknr_t *blocknr, blocknrs[MAX_AMOUNT_NEEDED] = { 0, };\n\tint counter, number_of_freeblk;\n\tint  amount_needed;\t/* number of needed empty blocks */\n\tint  retval = CARRY_ON;\n\tstruct super_block *sb = tb->tb_sb;\n\n\t/*\n\t * number_of_freeblk is the number of empty blocks which have been\n\t * acquired for use by the balancing algorithm minus the number of\n\t * empty blocks used in the previous levels of the analysis,\n\t * number_of_freeblk = tb->cur_blknum can be non-zero if a schedule\n\t * occurs after empty blocks are acquired, and the balancing analysis\n\t * is then restarted, amount_needed is the number needed by this\n\t * level (h) of the balancing analysis.\n\t *\n\t * Note that for systems with many processes writing, it would be\n\t * more layout optimal to calculate the total number needed by all\n\t * levels and then to run reiserfs_new_blocks to get all of them at\n\t * once.\n\t */\n\n\t/*\n\t * Initiate number_of_freeblk to the amount acquired prior to the\n\t * restart of the analysis or 0 if not restarted, then subtract the\n\t * amount needed by all of the levels of the tree below h.\n\t */\n\t/* blknum includes S[h], so we subtract 1 in this calculation */\n\tfor (counter = 0, number_of_freeblk = tb->cur_blknum;\n\t     counter < h; counter++)\n\t\tnumber_of_freeblk -=\n\t\t    (tb->blknum[counter]) ? (tb->blknum[counter] -\n\t\t\t\t\t\t   1) : 0;\n\n\t/* Allocate missing empty blocks. */\n\t/* if Sh == 0  then we are getting a new root */\n\tamount_needed = (Sh) ? (tb->blknum[h] - 1) : 1;\n\t/*\n\t * Amount_needed = the amount that we need more than the\n\t * amount that we have.\n\t */\n\tif (amount_needed > number_of_freeblk)\n\t\tamount_needed -= number_of_freeblk;\n\telse\t/* If we have enough already then there is nothing to do. */\n\t\treturn CARRY_ON;\n\n\t/*\n\t * No need to check quota - is not allocated for blocks used\n\t * for formatted nodes\n\t */\n\tif (reiserfs_new_form_blocknrs(tb, blocknrs,\n\t\t\t\t       amount_needed) == NO_DISK_SPACE)\n\t\treturn NO_DISK_SPACE;\n\n\t/* for each blocknumber we just got, get a buffer and stick it on FEB */\n\tfor (blocknr = blocknrs, counter = 0;\n\t     counter < amount_needed; blocknr++, counter++) {\n\n\t\tRFALSE(!*blocknr,\n\t\t       \"PAP-8135: reiserfs_new_blocknrs failed when got new blocks\");\n\n\t\tnew_bh = sb_getblk(sb, *blocknr);\n\t\tRFALSE(buffer_dirty(new_bh) ||\n\t\t       buffer_journaled(new_bh) ||\n\t\t       buffer_journal_dirty(new_bh),\n\t\t       \"PAP-8140: journaled or dirty buffer %b for the new block\",\n\t\t       new_bh);\n\n\t\t/* Put empty buffers into the array. */\n\t\tRFALSE(tb->FEB[tb->cur_blknum],\n\t\t       \"PAP-8141: busy slot for new buffer\");\n\n\t\tset_buffer_journal_new(new_bh);\n\t\ttb->FEB[tb->cur_blknum++] = new_bh;\n\t}\n\n\tif (retval == CARRY_ON && FILESYSTEM_CHANGED_TB(tb))\n\t\tretval = REPEAT_SEARCH;\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_neighbors",
          "args": [
            "tb",
            "h"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "get_neighbors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2155-2243",
          "snippet": "static int get_neighbors(struct tree_balance *tb, int h)\n{\n\tint child_position,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h + 1);\n\tunsigned long son_number;\n\tstruct super_block *sb = tb->tb_sb;\n\tstruct buffer_head *bh;\n\tint depth;\n\n\tPROC_INFO_INC(sb, get_neighbors[h]);\n\n\tif (tb->lnum[h]) {\n\t\t/* We need left neighbor to balance S[h]. */\n\t\tPROC_INFO_INC(sb, need_l_neighbor[h]);\n\t\tbh = PATH_OFFSET_PBUFFER(tb->tb_path, path_offset);\n\n\t\tRFALSE(bh == tb->FL[h] &&\n\t\t       !PATH_OFFSET_POSITION(tb->tb_path, path_offset),\n\t\t       \"PAP-8270: invalid position in the parent\");\n\n\t\tchild_position =\n\t\t    (bh ==\n\t\t     tb->FL[h]) ? tb->lkey[h] : B_NR_ITEMS(tb->\n\t\t\t\t\t\t\t\t       FL[h]);\n\t\tson_number = B_N_CHILD_NUM(tb->FL[h], child_position);\n\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\tbh = sb_bread(sb, son_number);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (!bh)\n\t\t\treturn IO_ERROR;\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(bh);\n\t\t\tPROC_INFO_INC(sb, get_neighbors_restart[h]);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t\tRFALSE(!B_IS_IN_TREE(tb->FL[h]) ||\n\t\t       child_position > B_NR_ITEMS(tb->FL[h]) ||\n\t\t       B_N_CHILD_NUM(tb->FL[h], child_position) !=\n\t\t       bh->b_blocknr, \"PAP-8275: invalid parent\");\n\t\tRFALSE(!B_IS_IN_TREE(bh), \"PAP-8280: invalid child\");\n\t\tRFALSE(!h &&\n\t\t       B_FREE_SPACE(bh) !=\n\t\t       MAX_CHILD_SIZE(bh) -\n\t\t       dc_size(B_N_CHILD(tb->FL[0], child_position)),\n\t\t       \"PAP-8290: invalid child size of left neighbor\");\n\n\t\tbrelse(tb->L[h]);\n\t\ttb->L[h] = bh;\n\t}\n\n\t/* We need right neighbor to balance S[path_offset]. */\n\tif (tb->rnum[h]) {\n\t\tPROC_INFO_INC(sb, need_r_neighbor[h]);\n\t\tbh = PATH_OFFSET_PBUFFER(tb->tb_path, path_offset);\n\n\t\tRFALSE(bh == tb->FR[h] &&\n\t\t       PATH_OFFSET_POSITION(tb->tb_path,\n\t\t\t\t\t    path_offset) >=\n\t\t       B_NR_ITEMS(bh),\n\t\t       \"PAP-8295: invalid position in the parent\");\n\n\t\tchild_position =\n\t\t    (bh == tb->FR[h]) ? tb->rkey[h] + 1 : 0;\n\t\tson_number = B_N_CHILD_NUM(tb->FR[h], child_position);\n\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\tbh = sb_bread(sb, son_number);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (!bh)\n\t\t\treturn IO_ERROR;\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(bh);\n\t\t\tPROC_INFO_INC(sb, get_neighbors_restart[h]);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\t\tbrelse(tb->R[h]);\n\t\ttb->R[h] = bh;\n\n\t\tRFALSE(!h\n\t\t       && B_FREE_SPACE(bh) !=\n\t\t       MAX_CHILD_SIZE(bh) -\n\t\t       dc_size(B_N_CHILD(tb->FR[0], child_position)),\n\t\t       \"PAP-8300: invalid child size of right neighbor (%d != %d - %d)\",\n\t\t       B_FREE_SPACE(bh), MAX_CHILD_SIZE(bh),\n\t\t       dc_size(B_N_CHILD(tb->FR[0], child_position)));\n\n\t}\n\treturn CARRY_ON;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_neighbors(struct tree_balance *tb, int h)\n{\n\tint child_position,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h + 1);\n\tunsigned long son_number;\n\tstruct super_block *sb = tb->tb_sb;\n\tstruct buffer_head *bh;\n\tint depth;\n\n\tPROC_INFO_INC(sb, get_neighbors[h]);\n\n\tif (tb->lnum[h]) {\n\t\t/* We need left neighbor to balance S[h]. */\n\t\tPROC_INFO_INC(sb, need_l_neighbor[h]);\n\t\tbh = PATH_OFFSET_PBUFFER(tb->tb_path, path_offset);\n\n\t\tRFALSE(bh == tb->FL[h] &&\n\t\t       !PATH_OFFSET_POSITION(tb->tb_path, path_offset),\n\t\t       \"PAP-8270: invalid position in the parent\");\n\n\t\tchild_position =\n\t\t    (bh ==\n\t\t     tb->FL[h]) ? tb->lkey[h] : B_NR_ITEMS(tb->\n\t\t\t\t\t\t\t\t       FL[h]);\n\t\tson_number = B_N_CHILD_NUM(tb->FL[h], child_position);\n\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\tbh = sb_bread(sb, son_number);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (!bh)\n\t\t\treturn IO_ERROR;\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(bh);\n\t\t\tPROC_INFO_INC(sb, get_neighbors_restart[h]);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t\tRFALSE(!B_IS_IN_TREE(tb->FL[h]) ||\n\t\t       child_position > B_NR_ITEMS(tb->FL[h]) ||\n\t\t       B_N_CHILD_NUM(tb->FL[h], child_position) !=\n\t\t       bh->b_blocknr, \"PAP-8275: invalid parent\");\n\t\tRFALSE(!B_IS_IN_TREE(bh), \"PAP-8280: invalid child\");\n\t\tRFALSE(!h &&\n\t\t       B_FREE_SPACE(bh) !=\n\t\t       MAX_CHILD_SIZE(bh) -\n\t\t       dc_size(B_N_CHILD(tb->FL[0], child_position)),\n\t\t       \"PAP-8290: invalid child size of left neighbor\");\n\n\t\tbrelse(tb->L[h]);\n\t\ttb->L[h] = bh;\n\t}\n\n\t/* We need right neighbor to balance S[path_offset]. */\n\tif (tb->rnum[h]) {\n\t\tPROC_INFO_INC(sb, need_r_neighbor[h]);\n\t\tbh = PATH_OFFSET_PBUFFER(tb->tb_path, path_offset);\n\n\t\tRFALSE(bh == tb->FR[h] &&\n\t\t       PATH_OFFSET_POSITION(tb->tb_path,\n\t\t\t\t\t    path_offset) >=\n\t\t       B_NR_ITEMS(bh),\n\t\t       \"PAP-8295: invalid position in the parent\");\n\n\t\tchild_position =\n\t\t    (bh == tb->FR[h]) ? tb->rkey[h] + 1 : 0;\n\t\tson_number = B_N_CHILD_NUM(tb->FR[h], child_position);\n\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\tbh = sb_bread(sb, son_number);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (!bh)\n\t\t\treturn IO_ERROR;\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(bh);\n\t\t\tPROC_INFO_INC(sb, get_neighbors_restart[h]);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\t\tbrelse(tb->R[h]);\n\t\ttb->R[h] = bh;\n\n\t\tRFALSE(!h\n\t\t       && B_FREE_SPACE(bh) !=\n\t\t       MAX_CHILD_SIZE(bh) -\n\t\t       dc_size(B_N_CHILD(tb->FR[0], child_position)),\n\t\t       \"PAP-8300: invalid child size of right neighbor (%d != %d - %d)\",\n\t\t       B_FREE_SPACE(bh), MAX_CHILD_SIZE(bh),\n\t\t       dc_size(B_N_CHILD(tb->FR[0], child_position)));\n\n\t}\n\treturn CARRY_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_balance",
          "args": [
            "op_mode",
            "tb",
            "h",
            "item_num",
            "pos_in_item",
            "ins_ih",
            "data"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "check_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2065-2091",
          "snippet": "static int check_balance(int mode,\n\t\t\t struct tree_balance *tb,\n\t\t\t int h,\n\t\t\t int inum,\n\t\t\t int pos_in_item,\n\t\t\t struct item_head *ins_ih, const void *data)\n{\n\tstruct virtual_node *vn;\n\n\tvn = tb->tb_vn = (struct virtual_node *)(tb->vn_buf);\n\tvn->vn_free_ptr = (char *)(tb->tb_vn + 1);\n\tvn->vn_mode = mode;\n\tvn->vn_affected_item_num = inum;\n\tvn->vn_pos_in_item = pos_in_item;\n\tvn->vn_ins_ih = ins_ih;\n\tvn->vn_data = data;\n\n\tRFALSE(mode == M_INSERT && !vn->vn_ins_ih,\n\t       \"vs-8255: ins_ih can not be 0 in insert mode\");\n\n\t/* Calculate balance parameters when size of node is increasing. */\n\tif (tb->insert_size[h] > 0)\n\t\treturn ip_check_balance(tb, h);\n\n\t/* Calculate balance parameters when  size of node is decreasing. */\n\treturn dc_check_balance(tb, h);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int check_balance(int mode,\n\t\t\t struct tree_balance *tb,\n\t\t\t int h,\n\t\t\t int inum,\n\t\t\t int pos_in_item,\n\t\t\t struct item_head *ins_ih, const void *data)\n{\n\tstruct virtual_node *vn;\n\n\tvn = tb->tb_vn = (struct virtual_node *)(tb->vn_buf);\n\tvn->vn_free_ptr = (char *)(tb->tb_vn + 1);\n\tvn->vn_mode = mode;\n\tvn->vn_affected_item_num = inum;\n\tvn->vn_pos_in_item = pos_in_item;\n\tvn->vn_ins_ih = ins_ih;\n\tvn->vn_data = data;\n\n\tRFALSE(mode == M_INSERT && !vn->vn_ins_ih,\n\t       \"vs-8255: ins_ih can not be 0 in insert mode\");\n\n\t/* Calculate balance parameters when size of node is increasing. */\n\tif (tb->insert_size[h] > 0)\n\t\treturn ip_check_balance(tb, h);\n\n\t/* Calculate balance parameters when  size of node is decreasing. */\n\treturn dc_check_balance(tb, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_direct_parent",
          "args": [
            "tb",
            "h"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "get_direct_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2094-2146",
          "snippet": "static int get_direct_parent(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *bh;\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\n\t/* We are in the root or in the new root. */\n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET - 1,\n\t\t       \"PAP-8260: invalid offset in the path\");\n\n\t\tif (PATH_OFFSET_PBUFFER(path, FIRST_PATH_ELEMENT_OFFSET)->\n\t\t    b_blocknr == SB_ROOT_BLOCK(tb->tb_sb)) {\n\t\t\t/* Root is not changed. */\n\t\t\tPATH_OFFSET_PBUFFER(path, path_offset - 1) = NULL;\n\t\t\tPATH_OFFSET_POSITION(path, path_offset - 1) = 0;\n\t\t\treturn CARRY_ON;\n\t\t}\n\t\t/* Root is changed and we must recalculate the path. */\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\t/* Parent in the path is not in the tree. */\n\tif (!B_IS_IN_TREE\n\t    (bh = PATH_OFFSET_PBUFFER(path, path_offset - 1)))\n\t\treturn REPEAT_SEARCH;\n\n\tif ((position =\n\t     PATH_OFFSET_POSITION(path,\n\t\t\t\t  path_offset - 1)) > B_NR_ITEMS(bh))\n\t\treturn REPEAT_SEARCH;\n\n\t/* Parent in the path is not parent of the current node in the tree. */\n\tif (B_N_CHILD_NUM(bh, position) !=\n\t    PATH_OFFSET_PBUFFER(path, path_offset)->b_blocknr)\n\t\treturn REPEAT_SEARCH;\n\n\tif (buffer_locked(bh)) {\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(bh);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\treturn REPEAT_SEARCH;\n\t}\n\n\t/*\n\t * Parent in the path is unlocked and really parent\n\t * of the current node.\n\t */\n\treturn CARRY_ON;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_direct_parent(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *bh;\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\n\t/* We are in the root or in the new root. */\n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET - 1,\n\t\t       \"PAP-8260: invalid offset in the path\");\n\n\t\tif (PATH_OFFSET_PBUFFER(path, FIRST_PATH_ELEMENT_OFFSET)->\n\t\t    b_blocknr == SB_ROOT_BLOCK(tb->tb_sb)) {\n\t\t\t/* Root is not changed. */\n\t\t\tPATH_OFFSET_PBUFFER(path, path_offset - 1) = NULL;\n\t\t\tPATH_OFFSET_POSITION(path, path_offset - 1) = 0;\n\t\t\treturn CARRY_ON;\n\t\t}\n\t\t/* Root is changed and we must recalculate the path. */\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\t/* Parent in the path is not in the tree. */\n\tif (!B_IS_IN_TREE\n\t    (bh = PATH_OFFSET_PBUFFER(path, path_offset - 1)))\n\t\treturn REPEAT_SEARCH;\n\n\tif ((position =\n\t     PATH_OFFSET_POSITION(path,\n\t\t\t\t  path_offset - 1)) > B_NR_ITEMS(bh))\n\t\treturn REPEAT_SEARCH;\n\n\t/* Parent in the path is not parent of the current node in the tree. */\n\tif (B_N_CHILD_NUM(bh, position) !=\n\t    PATH_OFFSET_PBUFFER(path, path_offset)->b_blocknr)\n\t\treturn REPEAT_SEARCH;\n\n\tif (buffer_locked(bh)) {\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(bh);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\treturn REPEAT_SEARCH;\n\t}\n\n\t/*\n\t * Parent in the path is unlocked and really parent\n\t * of the current node.\n\t */\n\treturn CARRY_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mem_for_virtual_node",
          "args": [
            "tb"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "get_mem_for_virtual_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2268-2314",
          "snippet": "static int get_mem_for_virtual_node(struct tree_balance *tb)\n{\n\tint check_fs = 0;\n\tint size;\n\tchar *buf;\n\n\tsize = get_virtual_node_size(tb->tb_sb, PATH_PLAST_BUFFER(tb->tb_path));\n\n\t/* we have to allocate more memory for virtual node */\n\tif (size > tb->vn_buf_size) {\n\t\tif (tb->vn_buf) {\n\t\t\t/* free memory allocated before */\n\t\t\tkfree(tb->vn_buf);\n\t\t\t/* this is not needed if kfree is atomic */\n\t\t\tcheck_fs = 1;\n\t\t}\n\n\t\t/* virtual node requires now more memory */\n\t\ttb->vn_buf_size = size;\n\n\t\t/* get memory for virtual item */\n\t\tbuf = kmalloc(size, GFP_ATOMIC | __GFP_NOWARN);\n\t\tif (!buf) {\n\t\t\t/*\n\t\t\t * getting memory with GFP_KERNEL priority may involve\n\t\t\t * balancing now (due to indirect_to_direct conversion\n\t\t\t * on dcache shrinking). So, release path and collected\n\t\t\t * resources here\n\t\t\t */\n\t\t\tfree_buffers_in_tb(tb);\n\t\t\tbuf = kmalloc(size, GFP_NOFS);\n\t\t\tif (!buf) {\n\t\t\t\ttb->vn_buf_size = 0;\n\t\t\t}\n\t\t\ttb->vn_buf = buf;\n\t\t\tschedule();\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t\ttb->vn_buf = buf;\n\t}\n\n\tif (check_fs && FILESYSTEM_CHANGED_TB(tb))\n\t\treturn REPEAT_SEARCH;\n\n\treturn CARRY_ON;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_mem_for_virtual_node(struct tree_balance *tb)\n{\n\tint check_fs = 0;\n\tint size;\n\tchar *buf;\n\n\tsize = get_virtual_node_size(tb->tb_sb, PATH_PLAST_BUFFER(tb->tb_path));\n\n\t/* we have to allocate more memory for virtual node */\n\tif (size > tb->vn_buf_size) {\n\t\tif (tb->vn_buf) {\n\t\t\t/* free memory allocated before */\n\t\t\tkfree(tb->vn_buf);\n\t\t\t/* this is not needed if kfree is atomic */\n\t\t\tcheck_fs = 1;\n\t\t}\n\n\t\t/* virtual node requires now more memory */\n\t\ttb->vn_buf_size = size;\n\n\t\t/* get memory for virtual item */\n\t\tbuf = kmalloc(size, GFP_ATOMIC | __GFP_NOWARN);\n\t\tif (!buf) {\n\t\t\t/*\n\t\t\t * getting memory with GFP_KERNEL priority may involve\n\t\t\t * balancing now (due to indirect_to_direct conversion\n\t\t\t * on dcache shrinking). So, release path and collected\n\t\t\t * resources here\n\t\t\t */\n\t\t\tfree_buffers_in_tb(tb);\n\t\t\tbuf = kmalloc(size, GFP_NOFS);\n\t\t\tif (!buf) {\n\t\t\t\ttb->vn_buf_size = 0;\n\t\t\t}\n\t\t\ttb->vn_buf = buf;\n\t\t\tschedule();\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t\ttb->vn_buf = buf;\n\t}\n\n\tif (check_fs && FILESYSTEM_CHANGED_TB(tb))\n\t\treturn REPEAT_SEARCH;\n\n\treturn CARRY_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"PAP-8340\"",
            "\"Incorrect mode \"\n\t\t\t       \"of operation\""
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"PAP-8335\"",
            "\"Incorrect \"\n\t\t\t\t       \"item number(%d); mode = %c \"\n\t\t\t\t       \"insert_size = %d\"",
            "item_num",
            "op_mode",
            "tb->insert_size[0]"
          ],
          "line": 2616
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_block",
          "args": [
            "tbS0",
            "0",
            "-1",
            "-1"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "print_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "593-617",
          "snippet": "void print_block(struct buffer_head *bh, ...)\n{\n\tva_list args;\n\tint mode, first, last;\n\n\tif (!bh) {\n\t\tprintk(\"print_block: buffer is NULL\\n\");\n\t\treturn;\n\t}\n\n\tva_start(args, bh);\n\n\tmode = va_arg(args, int);\n\tfirst = va_arg(args, int);\n\tlast = va_arg(args, int);\n\tif (print_leaf(bh, mode, first, last))\n\t\tif (print_internal(bh, first, last))\n\t\t\tif (print_super_block(bh))\n\t\t\t\tif (print_desc_block(bh))\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"Block %llu contains unformatted data\\n\",\n\t\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid print_block(struct buffer_head *bh, ...)\n{\n\tva_list args;\n\tint mode, first, last;\n\n\tif (!bh) {\n\t\tprintk(\"print_block: buffer is NULL\\n\");\n\t\treturn;\n\t}\n\n\tva_start(args, bh);\n\n\tmode = va_arg(args, int);\n\tfirst = va_arg(args, int);\n\tlast = va_arg(args, int);\n\tif (print_leaf(bh, mode, first, last))\n\t\tif (print_internal(bh, first, last))\n\t\t\tif (print_super_block(bh))\n\t\t\t\tif (print_desc_block(bh))\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"Block %llu contains unformatted data\\n\",\n\t\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbS0"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbS0"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbS0"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "tbS0"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "tbS0"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"PAP-8305\"",
            "\"there is pending do_balance\""
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_cur_tb",
          "args": [
            "\"fix_nodes\""
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "print_cur_tb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "708-711",
          "snippet": "void print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char print_tb_buf[2048];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char print_tb_buf[2048];\n\nvoid print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "tb->tb_sb"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "tb->tb_sb",
            "depth"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wait_on_buffer",
          "args": [
            "tbS0"
          ],
          "line": 2584
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "tb->tb_sb"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "tbS0"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "tb->transaction_handle",
            "SB_BUFFER_WITH_SB(tb->tb_sb)"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "tb->tb_sb"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "tb->tb_sb",
            "SB_BUFFER_WITH_SB(tb->tb_sb)",
            "1"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "tb->tb_sb"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_generation",
          "args": [
            "tb->tb_sb"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "tb->tb_path"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nint fix_nodes(int op_mode, struct tree_balance *tb,\n\t      struct item_head *ins_ih, const void *data)\n{\n\tint ret, h, item_num = PATH_LAST_POSITION(tb->tb_path);\n\tint pos_in_item;\n\n\t/*\n\t * we set wait_tb_buffers_run when we have to restore any dirty\n\t * bits cleared during wait_tb_buffers_run\n\t */\n\tint wait_tb_buffers_run = 0;\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\n\t++REISERFS_SB(tb->tb_sb)->s_fix_nodes;\n\n\tpos_in_item = tb->tb_path->pos_in_item;\n\n\ttb->fs_gen = get_generation(tb->tb_sb);\n\n\t/*\n\t * we prepare and log the super here so it will already be in the\n\t * transaction when do_balance needs to change it.\n\t * This way do_balance won't have to schedule when trying to prepare\n\t * the super for logging\n\t */\n\treiserfs_prepare_for_journal(tb->tb_sb,\n\t\t\t\t     SB_BUFFER_WITH_SB(tb->tb_sb), 1);\n\tjournal_mark_dirty(tb->transaction_handle,\n\t\t\t   SB_BUFFER_WITH_SB(tb->tb_sb));\n\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\treturn REPEAT_SEARCH;\n\n\t/* if it possible in indirect_to_direct conversion */\n\tif (buffer_locked(tbS0)) {\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(tbS0);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\treturn REPEAT_SEARCH;\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\tif (REISERFS_SB(tb->tb_sb)->cur_tb) {\n\t\tprint_cur_tb(\"fix_nodes\");\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8305\",\n\t\t\t       \"there is pending do_balance\");\n\t}\n\n\tif (!buffer_uptodate(tbS0) || !B_IS_IN_TREE(tbS0))\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8320\", \"S[0] (%b %z) is \"\n\t\t\t       \"not uptodate at the beginning of fix_nodes \"\n\t\t\t       \"or not in tree (mode %c)\",\n\t\t\t       tbS0, tbS0, op_mode);\n\n\t/* Check parameters. */\n\tswitch (op_mode) {\n\tcase M_INSERT:\n\t\tif (item_num <= 0 || item_num > B_NR_ITEMS(tbS0))\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-8330\", \"Incorrect \"\n\t\t\t\t       \"item number %d (in S0 - %d) in case \"\n\t\t\t\t       \"of insert\", item_num,\n\t\t\t\t       B_NR_ITEMS(tbS0));\n\t\tbreak;\n\tcase M_PASTE:\n\tcase M_DELETE:\n\tcase M_CUT:\n\t\tif (item_num < 0 || item_num >= B_NR_ITEMS(tbS0)) {\n\t\t\tprint_block(tbS0, 0, -1, -1);\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-8335\", \"Incorrect \"\n\t\t\t\t       \"item number(%d); mode = %c \"\n\t\t\t\t       \"insert_size = %d\",\n\t\t\t\t       item_num, op_mode,\n\t\t\t\t       tb->insert_size[0]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"PAP-8340\", \"Incorrect mode \"\n\t\t\t       \"of operation\");\n\t}\n#endif\n\n\tif (get_mem_for_virtual_node(tb) == REPEAT_SEARCH)\n\t\t/* FIXME: maybe -ENOMEM when tb->vn_buf == 0? Now just repeat */\n\t\treturn REPEAT_SEARCH;\n\n\t/* Starting from the leaf level; for all levels h of the tree. */\n\tfor (h = 0; h < MAX_HEIGHT && tb->insert_size[h]; h++) {\n\t\tret = get_direct_parent(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\tret = check_balance(op_mode, tb, h, item_num,\n\t\t\t\t    pos_in_item, ins_ih, data);\n\t\tif (ret != CARRY_ON) {\n\t\t\tif (ret == NO_BALANCING_NEEDED) {\n\t\t\t\t/* No balancing for higher levels needed. */\n\t\t\t\tret = get_neighbors(tb, h);\n\t\t\t\tif (ret != CARRY_ON)\n\t\t\t\t\tgoto repeat;\n\t\t\t\tif (h != MAX_HEIGHT - 1)\n\t\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t\t\t/*\n\t\t\t\t * ok, analysis and resource gathering\n\t\t\t\t * are complete\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tret = get_neighbors(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\t/*\n\t\t * No disk space, or schedule occurred and analysis may be\n\t\t * invalid and needs to be redone.\n\t\t */\n\t\tret = get_empty_nodes(tb, h);\n\t\tif (ret != CARRY_ON)\n\t\t\tgoto repeat;\n\n\t\t/*\n\t\t * We have a positive insert size but no nodes exist on this\n\t\t * level, this means that we are creating a new root.\n\t\t */\n\t\tif (!PATH_H_PBUFFER(tb->tb_path, h)) {\n\n\t\t\tRFALSE(tb->blknum[h] != 1,\n\t\t\t       \"PAP-8350: creating new empty root\");\n\n\t\t\tif (h < MAX_HEIGHT - 1)\n\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t} else if (!PATH_H_PBUFFER(tb->tb_path, h + 1)) {\n\t\t\t/*\n\t\t\t * The tree needs to be grown, so this node S[h]\n\t\t\t * which is the root node is split into two nodes,\n\t\t\t * and a new node (S[h+1]) will be created to\n\t\t\t * become the root node.\n\t\t\t */\n\t\t\tif (tb->blknum[h] > 1) {\n\n\t\t\t\tRFALSE(h == MAX_HEIGHT - 1,\n\t\t\t\t       \"PAP-8355: attempt to create too high of a tree\");\n\n\t\t\t\ttb->insert_size[h + 1] =\n\t\t\t\t    (DC_SIZE +\n\t\t\t\t     KEY_SIZE) * (tb->blknum[h] - 1) +\n\t\t\t\t    DC_SIZE;\n\t\t\t} else if (h < MAX_HEIGHT - 1)\n\t\t\t\ttb->insert_size[h + 1] = 0;\n\t\t} else\n\t\t\ttb->insert_size[h + 1] =\n\t\t\t    (DC_SIZE + KEY_SIZE) * (tb->blknum[h] - 1);\n\t}\n\n\tret = wait_tb_buffers_until_unlocked(tb);\n\tif (ret == CARRY_ON) {\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\twait_tb_buffers_run = 1;\n\t\t\tret = REPEAT_SEARCH;\n\t\t\tgoto repeat;\n\t\t} else {\n\t\t\treturn CARRY_ON;\n\t\t}\n\t} else {\n\t\twait_tb_buffers_run = 1;\n\t\tgoto repeat;\n\t}\n\nrepeat:\n\t/*\n\t * fix_nodes was unable to perform its calculation due to\n\t * filesystem got changed under us, lack of free disk space or i/o\n\t * failure. If the first is the case - the search will be\n\t * repeated. For now - free all resources acquired so far except\n\t * for the new allocated nodes\n\t */\n\t{\n\t\tint i;\n\n\t\t/* Release path buffers. */\n\t\tif (wait_tb_buffers_run) {\n\t\t\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\t\t} else {\n\t\t\tpathrelse(tb->tb_path);\n\t\t}\n\t\t/* brelse all resources collected for balancing */\n\t\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\t\tif (wait_tb_buffers_run) {\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->L[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->R[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->FL[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->FR[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->\n\t\t\t\t\t\t\t\t CFL[i]);\n\t\t\t\treiserfs_restore_prepared_buffer(tb->tb_sb,\n\t\t\t\t\t\t\t\t tb->\n\t\t\t\t\t\t\t\t CFR[i]);\n\t\t\t}\n\n\t\t\tbrelse(tb->L[i]);\n\t\t\tbrelse(tb->R[i]);\n\t\t\tbrelse(tb->FL[i]);\n\t\t\tbrelse(tb->FR[i]);\n\t\t\tbrelse(tb->CFL[i]);\n\t\t\tbrelse(tb->CFR[i]);\n\n\t\t\ttb->L[i] = NULL;\n\t\t\ttb->R[i] = NULL;\n\t\t\ttb->FL[i] = NULL;\n\t\t\ttb->FR[i] = NULL;\n\t\t\ttb->CFL[i] = NULL;\n\t\t\ttb->CFR[i] = NULL;\n\t\t}\n\n\t\tif (wait_tb_buffers_run) {\n\t\t\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\t\t\tif (tb->FEB[i])\n\t\t\t\t\treiserfs_restore_prepared_buffer\n\t\t\t\t\t    (tb->tb_sb, tb->FEB[i]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "function_name": "wait_tb_buffers_until_unlocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "2367-2516",
    "snippet": "static int wait_tb_buffers_until_unlocked(struct tree_balance *tb)\n{\n\tstruct buffer_head *locked;\n#ifdef CONFIG_REISERFS_CHECK\n\tint repeat_counter = 0;\n#endif\n\tint i;\n\n\tdo {\n\n\t\tlocked = NULL;\n\n\t\tfor (i = tb->tb_path->path_length;\n\t\t     !locked && i > ILLEGAL_PATH_ELEMENT_OFFSET; i--) {\n\t\t\tif (PATH_OFFSET_PBUFFER(tb->tb_path, i)) {\n\t\t\t\t/*\n\t\t\t\t * if I understand correctly, we can only\n\t\t\t\t * be sure the last buffer in the path is\n\t\t\t\t * in the tree --clm\n\t\t\t\t */\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\tif (PATH_PLAST_BUFFER(tb->tb_path) ==\n\t\t\t\t    PATH_OFFSET_PBUFFER(tb->tb_path, i))\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       PATH_OFFSET_PBUFFER\n\t\t\t\t\t\t\t       (tb->tb_path,\n\t\t\t\t\t\t\t\ti), \"S\",\n\t\t\t\t\t\t\t       tb->tb_path->\n\t\t\t\t\t\t\t       path_length - i);\n#endif\n\t\t\t\tif (!clear_all_dirty_bits(tb->tb_sb,\n\t\t\t\t\t\t\t  PATH_OFFSET_PBUFFER\n\t\t\t\t\t\t\t  (tb->tb_path,\n\t\t\t\t\t\t\t   i))) {\n\t\t\t\t\tlocked =\n\t\t\t\t\t    PATH_OFFSET_PBUFFER(tb->tb_path,\n\t\t\t\t\t\t\t\ti);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; !locked && i < MAX_HEIGHT && tb->insert_size[i];\n\t\t     i++) {\n\n\t\t\tif (tb->lnum[i]) {\n\n\t\t\t\tif (tb->L[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->L[i],\n\t\t\t\t\t\t\t       \"L\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->L[i]))\n\t\t\t\t\t\tlocked = tb->L[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->FL[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->FL[i],\n\t\t\t\t\t\t\t       \"FL\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->FL[i]))\n\t\t\t\t\t\tlocked = tb->FL[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->CFL[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->CFL[i],\n\t\t\t\t\t\t\t       \"CFL\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->CFL[i]))\n\t\t\t\t\t\tlocked = tb->CFL[i];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (!locked && (tb->rnum[i])) {\n\n\t\t\t\tif (tb->R[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->R[i],\n\t\t\t\t\t\t\t       \"R\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->R[i]))\n\t\t\t\t\t\tlocked = tb->R[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->FR[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->FR[i],\n\t\t\t\t\t\t\t       \"FR\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->FR[i]))\n\t\t\t\t\t\tlocked = tb->FR[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->CFR[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->CFR[i],\n\t\t\t\t\t\t\t       \"CFR\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->CFR[i]))\n\t\t\t\t\t\tlocked = tb->CFR[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * as far as I can tell, this is not required.  The FEB list\n\t\t * seems to be full of newly allocated nodes, which will\n\t\t * never be locked, dirty, or anything else.\n\t\t * To be safe, I'm putting in the checks and waits in.\n\t\t * For the moment, they are needed to keep the code in\n\t\t * journal.c from complaining about the buffer.\n\t\t * That code is inside CONFIG_REISERFS_CHECK as well.  --clm\n\t\t */\n\t\tfor (i = 0; !locked && i < MAX_FEB_SIZE; i++) {\n\t\t\tif (tb->FEB[i]) {\n\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t    (tb->tb_sb, tb->FEB[i]))\n\t\t\t\t\tlocked = tb->FEB[i];\n\t\t\t}\n\t\t}\n\n\t\tif (locked) {\n\t\t\tint depth;\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\trepeat_counter++;\n\t\t\tif ((repeat_counter % 10000) == 0) {\n\t\t\t\treiserfs_warning(tb->tb_sb, \"reiserfs-8200\",\n\t\t\t\t\t\t \"too many iterations waiting \"\n\t\t\t\t\t\t \"for buffer to unlock \"\n\t\t\t\t\t\t \"(%b)\", locked);\n\n\t\t\t\t/* Don't loop forever.  Try to recover from possible error. */\n\n\t\t\t\treturn (FILESYSTEM_CHANGED_TB(tb)) ?\n\t\t\t\t    REPEAT_SEARCH : CARRY_ON;\n\t\t\t}\n#endif\n\t\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t\t__wait_on_buffer(locked);\n\t\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t} while (locked);\n\n\treturn CARRY_ON;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "tb->tb_sb",
            "depth"
          ],
          "line": 2508
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wait_on_buffer",
          "args": [
            "locked"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "tb->tb_sb"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "tb->tb_sb",
            "\"reiserfs-8200\"",
            "\"too many iterations waiting \"\n\t\t\t\t\t\t \"for buffer to unlock \"\n\t\t\t\t\t\t \"(%b)\"",
            "locked"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_all_dirty_bits",
          "args": [
            "tb->tb_sb",
            "tb->FEB[i]"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "clear_all_dirty_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2362-2365",
          "snippet": "static int clear_all_dirty_bits(struct super_block *s, struct buffer_head *bh)\n{\n\treturn reiserfs_prepare_for_journal(s, bh, 0);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int clear_all_dirty_bits(struct super_block *s, struct buffer_head *bh)\n{\n\treturn reiserfs_prepare_for_journal(s, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tb_buffer_sanity_check",
          "args": [
            "tb->tb_sb",
            "tb->CFR[i]",
            "\"CFR\"",
            "i"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "tb_buffer_sanity_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2355-2359",
          "snippet": "static void tb_buffer_sanity_check(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   const char *descr, int level)\n{;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void tb_buffer_sanity_check(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   const char *descr, int level)\n{;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "tb->tb_path",
            "i"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "tb->tb_path",
            "i"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "tb->tb_path",
            "i"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "tb->tb_path",
            "i"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "tb->tb_path",
            "i"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int wait_tb_buffers_until_unlocked(struct tree_balance *tb)\n{\n\tstruct buffer_head *locked;\n#ifdef CONFIG_REISERFS_CHECK\n\tint repeat_counter = 0;\n#endif\n\tint i;\n\n\tdo {\n\n\t\tlocked = NULL;\n\n\t\tfor (i = tb->tb_path->path_length;\n\t\t     !locked && i > ILLEGAL_PATH_ELEMENT_OFFSET; i--) {\n\t\t\tif (PATH_OFFSET_PBUFFER(tb->tb_path, i)) {\n\t\t\t\t/*\n\t\t\t\t * if I understand correctly, we can only\n\t\t\t\t * be sure the last buffer in the path is\n\t\t\t\t * in the tree --clm\n\t\t\t\t */\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\tif (PATH_PLAST_BUFFER(tb->tb_path) ==\n\t\t\t\t    PATH_OFFSET_PBUFFER(tb->tb_path, i))\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       PATH_OFFSET_PBUFFER\n\t\t\t\t\t\t\t       (tb->tb_path,\n\t\t\t\t\t\t\t\ti), \"S\",\n\t\t\t\t\t\t\t       tb->tb_path->\n\t\t\t\t\t\t\t       path_length - i);\n#endif\n\t\t\t\tif (!clear_all_dirty_bits(tb->tb_sb,\n\t\t\t\t\t\t\t  PATH_OFFSET_PBUFFER\n\t\t\t\t\t\t\t  (tb->tb_path,\n\t\t\t\t\t\t\t   i))) {\n\t\t\t\t\tlocked =\n\t\t\t\t\t    PATH_OFFSET_PBUFFER(tb->tb_path,\n\t\t\t\t\t\t\t\ti);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; !locked && i < MAX_HEIGHT && tb->insert_size[i];\n\t\t     i++) {\n\n\t\t\tif (tb->lnum[i]) {\n\n\t\t\t\tif (tb->L[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->L[i],\n\t\t\t\t\t\t\t       \"L\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->L[i]))\n\t\t\t\t\t\tlocked = tb->L[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->FL[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->FL[i],\n\t\t\t\t\t\t\t       \"FL\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->FL[i]))\n\t\t\t\t\t\tlocked = tb->FL[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->CFL[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->CFL[i],\n\t\t\t\t\t\t\t       \"CFL\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->CFL[i]))\n\t\t\t\t\t\tlocked = tb->CFL[i];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (!locked && (tb->rnum[i])) {\n\n\t\t\t\tif (tb->R[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->R[i],\n\t\t\t\t\t\t\t       \"R\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->R[i]))\n\t\t\t\t\t\tlocked = tb->R[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->FR[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->FR[i],\n\t\t\t\t\t\t\t       \"FR\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->FR[i]))\n\t\t\t\t\t\tlocked = tb->FR[i];\n\t\t\t\t}\n\n\t\t\t\tif (!locked && tb->CFR[i]) {\n\t\t\t\t\ttb_buffer_sanity_check(tb->tb_sb,\n\t\t\t\t\t\t\t       tb->CFR[i],\n\t\t\t\t\t\t\t       \"CFR\", i);\n\t\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t\t    (tb->tb_sb, tb->CFR[i]))\n\t\t\t\t\t\tlocked = tb->CFR[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * as far as I can tell, this is not required.  The FEB list\n\t\t * seems to be full of newly allocated nodes, which will\n\t\t * never be locked, dirty, or anything else.\n\t\t * To be safe, I'm putting in the checks and waits in.\n\t\t * For the moment, they are needed to keep the code in\n\t\t * journal.c from complaining about the buffer.\n\t\t * That code is inside CONFIG_REISERFS_CHECK as well.  --clm\n\t\t */\n\t\tfor (i = 0; !locked && i < MAX_FEB_SIZE; i++) {\n\t\t\tif (tb->FEB[i]) {\n\t\t\t\tif (!clear_all_dirty_bits\n\t\t\t\t    (tb->tb_sb, tb->FEB[i]))\n\t\t\t\t\tlocked = tb->FEB[i];\n\t\t\t}\n\t\t}\n\n\t\tif (locked) {\n\t\t\tint depth;\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\trepeat_counter++;\n\t\t\tif ((repeat_counter % 10000) == 0) {\n\t\t\t\treiserfs_warning(tb->tb_sb, \"reiserfs-8200\",\n\t\t\t\t\t\t \"too many iterations waiting \"\n\t\t\t\t\t\t \"for buffer to unlock \"\n\t\t\t\t\t\t \"(%b)\", locked);\n\n\t\t\t\t/* Don't loop forever.  Try to recover from possible error. */\n\n\t\t\t\treturn (FILESYSTEM_CHANGED_TB(tb)) ?\n\t\t\t\t    REPEAT_SEARCH : CARRY_ON;\n\t\t\t}\n#endif\n\t\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t\t__wait_on_buffer(locked);\n\t\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t} while (locked);\n\n\treturn CARRY_ON;\n}"
  },
  {
    "function_name": "clear_all_dirty_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "2362-2365",
    "snippet": "static int clear_all_dirty_bits(struct super_block *s, struct buffer_head *bh)\n{\n\treturn reiserfs_prepare_for_journal(s, bh, 0);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "s",
            "bh",
            "0"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int clear_all_dirty_bits(struct super_block *s, struct buffer_head *bh)\n{\n\treturn reiserfs_prepare_for_journal(s, bh, 0);\n}"
  },
  {
    "function_name": "tb_buffer_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "2355-2359",
    "snippet": "static void tb_buffer_sanity_check(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   const char *descr, int level)\n{;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void tb_buffer_sanity_check(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   const char *descr, int level)\n{;\n}"
  },
  {
    "function_name": "tb_buffer_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "2317-2353",
    "snippet": "static void tb_buffer_sanity_check(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   const char *descr, int level)\n{\n\tif (bh) {\n\t\tif (atomic_read(&(bh->b_count)) <= 0)\n\n\t\t\treiserfs_panic(sb, \"jmacd-1\", \"negative or zero \"\n\t\t\t\t       \"reference counter for buffer %s[%d] \"\n\t\t\t\t       \"(%b)\", descr, level, bh);\n\n\t\tif (!buffer_uptodate(bh))\n\t\t\treiserfs_panic(sb, \"jmacd-2\", \"buffer is not up \"\n\t\t\t\t       \"to date %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\n\t\tif (!B_IS_IN_TREE(bh))\n\t\t\treiserfs_panic(sb, \"jmacd-3\", \"buffer is not \"\n\t\t\t\t       \"in tree %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\n\t\tif (bh->b_bdev != sb->s_bdev)\n\t\t\treiserfs_panic(sb, \"jmacd-4\", \"buffer has wrong \"\n\t\t\t\t       \"device %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\n\t\tif (bh->b_size != sb->s_blocksize)\n\t\t\treiserfs_panic(sb, \"jmacd-5\", \"buffer has wrong \"\n\t\t\t\t       \"blocksize %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\n\t\tif (bh->b_blocknr > SB_BLOCK_COUNT(sb))\n\t\t\treiserfs_panic(sb, \"jmacd-6\", \"buffer block \"\n\t\t\t\t       \"number too high %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"jmacd-6\"",
            "\"buffer block \"\n\t\t\t\t       \"number too high %s[%d] (%b)\"",
            "descr",
            "level",
            "bh"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "sb"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "bh"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(bh->b_count)"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void tb_buffer_sanity_check(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   const char *descr, int level)\n{\n\tif (bh) {\n\t\tif (atomic_read(&(bh->b_count)) <= 0)\n\n\t\t\treiserfs_panic(sb, \"jmacd-1\", \"negative or zero \"\n\t\t\t\t       \"reference counter for buffer %s[%d] \"\n\t\t\t\t       \"(%b)\", descr, level, bh);\n\n\t\tif (!buffer_uptodate(bh))\n\t\t\treiserfs_panic(sb, \"jmacd-2\", \"buffer is not up \"\n\t\t\t\t       \"to date %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\n\t\tif (!B_IS_IN_TREE(bh))\n\t\t\treiserfs_panic(sb, \"jmacd-3\", \"buffer is not \"\n\t\t\t\t       \"in tree %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\n\t\tif (bh->b_bdev != sb->s_bdev)\n\t\t\treiserfs_panic(sb, \"jmacd-4\", \"buffer has wrong \"\n\t\t\t\t       \"device %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\n\t\tif (bh->b_size != sb->s_blocksize)\n\t\t\treiserfs_panic(sb, \"jmacd-5\", \"buffer has wrong \"\n\t\t\t\t       \"blocksize %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\n\t\tif (bh->b_blocknr > SB_BLOCK_COUNT(sb))\n\t\t\treiserfs_panic(sb, \"jmacd-6\", \"buffer block \"\n\t\t\t\t       \"number too high %s[%d] (%b)\",\n\t\t\t\t       descr, level, bh);\n\t}\n}"
  },
  {
    "function_name": "get_mem_for_virtual_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "2268-2314",
    "snippet": "static int get_mem_for_virtual_node(struct tree_balance *tb)\n{\n\tint check_fs = 0;\n\tint size;\n\tchar *buf;\n\n\tsize = get_virtual_node_size(tb->tb_sb, PATH_PLAST_BUFFER(tb->tb_path));\n\n\t/* we have to allocate more memory for virtual node */\n\tif (size > tb->vn_buf_size) {\n\t\tif (tb->vn_buf) {\n\t\t\t/* free memory allocated before */\n\t\t\tkfree(tb->vn_buf);\n\t\t\t/* this is not needed if kfree is atomic */\n\t\t\tcheck_fs = 1;\n\t\t}\n\n\t\t/* virtual node requires now more memory */\n\t\ttb->vn_buf_size = size;\n\n\t\t/* get memory for virtual item */\n\t\tbuf = kmalloc(size, GFP_ATOMIC | __GFP_NOWARN);\n\t\tif (!buf) {\n\t\t\t/*\n\t\t\t * getting memory with GFP_KERNEL priority may involve\n\t\t\t * balancing now (due to indirect_to_direct conversion\n\t\t\t * on dcache shrinking). So, release path and collected\n\t\t\t * resources here\n\t\t\t */\n\t\t\tfree_buffers_in_tb(tb);\n\t\t\tbuf = kmalloc(size, GFP_NOFS);\n\t\t\tif (!buf) {\n\t\t\t\ttb->vn_buf_size = 0;\n\t\t\t}\n\t\t\ttb->vn_buf = buf;\n\t\t\tschedule();\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t\ttb->vn_buf = buf;\n\t}\n\n\tif (check_fs && FILESYSTEM_CHANGED_TB(tb))\n\t\treturn REPEAT_SEARCH;\n\n\treturn CARRY_ON;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_NOFS"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_buffers_in_tb",
          "args": [
            "tb"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "free_buffers_in_tb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "799-820",
          "snippet": "static void free_buffers_in_tb(struct tree_balance *tb)\n{\n\tint i;\n\n\tpathrelse(tb->tb_path);\n\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\n\t\ttb->L[i] = NULL;\n\t\ttb->R[i] = NULL;\n\t\ttb->FL[i] = NULL;\n\t\ttb->FR[i] = NULL;\n\t\ttb->CFL[i] = NULL;\n\t\ttb->CFR[i] = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void free_buffers_in_tb(struct tree_balance *tb)\n{\n\tint i;\n\n\tpathrelse(tb->tb_path);\n\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\n\t\ttb->L[i] = NULL;\n\t\ttb->R[i] = NULL;\n\t\ttb->FL[i] = NULL;\n\t\ttb->FR[i] = NULL;\n\t\ttb->CFL[i] = NULL;\n\t\ttb->CFR[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tb->vn_buf"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_virtual_node_size",
          "args": [
            "tb->tb_sb",
            "PATH_PLAST_BUFFER(tb->tb_path)"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "get_virtual_node_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2245-2261",
          "snippet": "static int get_virtual_node_size(struct super_block *sb, struct buffer_head *bh)\n{\n\tint max_num_of_items;\n\tint max_num_of_entries;\n\tunsigned long blocksize = sb->s_blocksize;\n\n#define MIN_NAME_LEN 1\n\n\tmax_num_of_items = (blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN);\n\tmax_num_of_entries = (blocksize - BLKH_SIZE - IH_SIZE) /\n\t    (DEH_SIZE + MIN_NAME_LEN);\n\n\treturn sizeof(struct virtual_node) +\n\t    max(max_num_of_items * sizeof(struct virtual_item),\n\t\tsizeof(struct virtual_item) + sizeof(struct direntry_uarea) +\n\t\t(max_num_of_entries - 1) * sizeof(__u16));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define MIN_NAME_LEN 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#define MIN_NAME_LEN 1\n\nstatic int get_virtual_node_size(struct super_block *sb, struct buffer_head *bh)\n{\n\tint max_num_of_items;\n\tint max_num_of_entries;\n\tunsigned long blocksize = sb->s_blocksize;\n\n#define MIN_NAME_LEN 1\n\n\tmax_num_of_items = (blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN);\n\tmax_num_of_entries = (blocksize - BLKH_SIZE - IH_SIZE) /\n\t    (DEH_SIZE + MIN_NAME_LEN);\n\n\treturn sizeof(struct virtual_node) +\n\t    max(max_num_of_items * sizeof(struct virtual_item),\n\t\tsizeof(struct virtual_item) + sizeof(struct direntry_uarea) +\n\t\t(max_num_of_entries - 1) * sizeof(__u16));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_mem_for_virtual_node(struct tree_balance *tb)\n{\n\tint check_fs = 0;\n\tint size;\n\tchar *buf;\n\n\tsize = get_virtual_node_size(tb->tb_sb, PATH_PLAST_BUFFER(tb->tb_path));\n\n\t/* we have to allocate more memory for virtual node */\n\tif (size > tb->vn_buf_size) {\n\t\tif (tb->vn_buf) {\n\t\t\t/* free memory allocated before */\n\t\t\tkfree(tb->vn_buf);\n\t\t\t/* this is not needed if kfree is atomic */\n\t\t\tcheck_fs = 1;\n\t\t}\n\n\t\t/* virtual node requires now more memory */\n\t\ttb->vn_buf_size = size;\n\n\t\t/* get memory for virtual item */\n\t\tbuf = kmalloc(size, GFP_ATOMIC | __GFP_NOWARN);\n\t\tif (!buf) {\n\t\t\t/*\n\t\t\t * getting memory with GFP_KERNEL priority may involve\n\t\t\t * balancing now (due to indirect_to_direct conversion\n\t\t\t * on dcache shrinking). So, release path and collected\n\t\t\t * resources here\n\t\t\t */\n\t\t\tfree_buffers_in_tb(tb);\n\t\t\tbuf = kmalloc(size, GFP_NOFS);\n\t\t\tif (!buf) {\n\t\t\t\ttb->vn_buf_size = 0;\n\t\t\t}\n\t\t\ttb->vn_buf = buf;\n\t\t\tschedule();\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t\ttb->vn_buf = buf;\n\t}\n\n\tif (check_fs && FILESYSTEM_CHANGED_TB(tb))\n\t\treturn REPEAT_SEARCH;\n\n\treturn CARRY_ON;\n}"
  },
  {
    "function_name": "get_virtual_node_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "2245-2261",
    "snippet": "static int get_virtual_node_size(struct super_block *sb, struct buffer_head *bh)\n{\n\tint max_num_of_items;\n\tint max_num_of_entries;\n\tunsigned long blocksize = sb->s_blocksize;\n\n#define MIN_NAME_LEN 1\n\n\tmax_num_of_items = (blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN);\n\tmax_num_of_entries = (blocksize - BLKH_SIZE - IH_SIZE) /\n\t    (DEH_SIZE + MIN_NAME_LEN);\n\n\treturn sizeof(struct virtual_node) +\n\t    max(max_num_of_items * sizeof(struct virtual_item),\n\t\tsizeof(struct virtual_item) + sizeof(struct direntry_uarea) +\n\t\t(max_num_of_entries - 1) * sizeof(__u16));\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define MIN_NAME_LEN 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "max_num_of_items * sizeof(struct virtual_item)",
            "sizeof(struct virtual_item) + sizeof(struct direntry_uarea) +\n\t\t(max_num_of_entries - 1) * sizeof(__u16)"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#define MIN_NAME_LEN 1\n\nstatic int get_virtual_node_size(struct super_block *sb, struct buffer_head *bh)\n{\n\tint max_num_of_items;\n\tint max_num_of_entries;\n\tunsigned long blocksize = sb->s_blocksize;\n\n#define MIN_NAME_LEN 1\n\n\tmax_num_of_items = (blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN);\n\tmax_num_of_entries = (blocksize - BLKH_SIZE - IH_SIZE) /\n\t    (DEH_SIZE + MIN_NAME_LEN);\n\n\treturn sizeof(struct virtual_node) +\n\t    max(max_num_of_items * sizeof(struct virtual_item),\n\t\tsizeof(struct virtual_item) + sizeof(struct direntry_uarea) +\n\t\t(max_num_of_entries - 1) * sizeof(__u16));\n}"
  },
  {
    "function_name": "get_neighbors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "2155-2243",
    "snippet": "static int get_neighbors(struct tree_balance *tb, int h)\n{\n\tint child_position,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h + 1);\n\tunsigned long son_number;\n\tstruct super_block *sb = tb->tb_sb;\n\tstruct buffer_head *bh;\n\tint depth;\n\n\tPROC_INFO_INC(sb, get_neighbors[h]);\n\n\tif (tb->lnum[h]) {\n\t\t/* We need left neighbor to balance S[h]. */\n\t\tPROC_INFO_INC(sb, need_l_neighbor[h]);\n\t\tbh = PATH_OFFSET_PBUFFER(tb->tb_path, path_offset);\n\n\t\tRFALSE(bh == tb->FL[h] &&\n\t\t       !PATH_OFFSET_POSITION(tb->tb_path, path_offset),\n\t\t       \"PAP-8270: invalid position in the parent\");\n\n\t\tchild_position =\n\t\t    (bh ==\n\t\t     tb->FL[h]) ? tb->lkey[h] : B_NR_ITEMS(tb->\n\t\t\t\t\t\t\t\t       FL[h]);\n\t\tson_number = B_N_CHILD_NUM(tb->FL[h], child_position);\n\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\tbh = sb_bread(sb, son_number);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (!bh)\n\t\t\treturn IO_ERROR;\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(bh);\n\t\t\tPROC_INFO_INC(sb, get_neighbors_restart[h]);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t\tRFALSE(!B_IS_IN_TREE(tb->FL[h]) ||\n\t\t       child_position > B_NR_ITEMS(tb->FL[h]) ||\n\t\t       B_N_CHILD_NUM(tb->FL[h], child_position) !=\n\t\t       bh->b_blocknr, \"PAP-8275: invalid parent\");\n\t\tRFALSE(!B_IS_IN_TREE(bh), \"PAP-8280: invalid child\");\n\t\tRFALSE(!h &&\n\t\t       B_FREE_SPACE(bh) !=\n\t\t       MAX_CHILD_SIZE(bh) -\n\t\t       dc_size(B_N_CHILD(tb->FL[0], child_position)),\n\t\t       \"PAP-8290: invalid child size of left neighbor\");\n\n\t\tbrelse(tb->L[h]);\n\t\ttb->L[h] = bh;\n\t}\n\n\t/* We need right neighbor to balance S[path_offset]. */\n\tif (tb->rnum[h]) {\n\t\tPROC_INFO_INC(sb, need_r_neighbor[h]);\n\t\tbh = PATH_OFFSET_PBUFFER(tb->tb_path, path_offset);\n\n\t\tRFALSE(bh == tb->FR[h] &&\n\t\t       PATH_OFFSET_POSITION(tb->tb_path,\n\t\t\t\t\t    path_offset) >=\n\t\t       B_NR_ITEMS(bh),\n\t\t       \"PAP-8295: invalid position in the parent\");\n\n\t\tchild_position =\n\t\t    (bh == tb->FR[h]) ? tb->rkey[h] + 1 : 0;\n\t\tson_number = B_N_CHILD_NUM(tb->FR[h], child_position);\n\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\tbh = sb_bread(sb, son_number);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (!bh)\n\t\t\treturn IO_ERROR;\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(bh);\n\t\t\tPROC_INFO_INC(sb, get_neighbors_restart[h]);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\t\tbrelse(tb->R[h]);\n\t\ttb->R[h] = bh;\n\n\t\tRFALSE(!h\n\t\t       && B_FREE_SPACE(bh) !=\n\t\t       MAX_CHILD_SIZE(bh) -\n\t\t       dc_size(B_N_CHILD(tb->FR[0], child_position)),\n\t\t       \"PAP-8300: invalid child size of right neighbor (%d != %d - %d)\",\n\t\t       B_FREE_SPACE(bh), MAX_CHILD_SIZE(bh),\n\t\t       dc_size(B_N_CHILD(tb->FR[0], child_position)));\n\n\t}\n\treturn CARRY_ON;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!h\n\t\t       && B_FREE_SPACE(bh) !=\n\t\t       MAX_CHILD_SIZE(bh) -\n\t\t       dc_size(B_N_CHILD(tb->FR[0], child_position))",
            "\"PAP-8300: invalid child size of right neighbor (%d != %d - %d)\"",
            "B_FREE_SPACE(bh)",
            "MAX_CHILD_SIZE(bh)",
            "dc_size(B_N_CHILD(tb->FR[0], child_position))"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD(tb->FR[0], child_position)"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "tb->FR[0]",
            "child_position"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "bh"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "bh"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD(tb->FR[0], child_position)"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "tb->FR[0]",
            "child_position"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "bh"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "bh"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "tb->R[h]"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "get_neighbors_restart[h]"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "tb->tb_sb",
            "depth"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "son_number"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "tb->tb_sb"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_N_CHILD_NUM",
          "args": [
            "tb->FR[h]",
            "child_position"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "bh == tb->FR[h] &&\n\t\t       PATH_OFFSET_POSITION(tb->tb_path,\n\t\t\t\t\t    path_offset) >=\n\t\t       B_NR_ITEMS(bh)",
            "\"PAP-8295: invalid position in the parent\""
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_POSITION",
          "args": [
            "tb->tb_path",
            "path_offset"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "tb->tb_path",
            "path_offset"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "need_r_neighbor[h]"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!h &&\n\t\t       B_FREE_SPACE(bh) !=\n\t\t       MAX_CHILD_SIZE(bh) -\n\t\t       dc_size(B_N_CHILD(tb->FL[0], child_position))",
            "\"PAP-8290: invalid child size of left neighbor\""
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD(tb->FL[0], child_position)"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "tb->FL[0]",
            "child_position"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "bh"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "bh"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!B_IS_IN_TREE(bh)",
            "\"PAP-8280: invalid child\""
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "bh"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!B_IS_IN_TREE(tb->FL[h]) ||\n\t\t       child_position > B_NR_ITEMS(tb->FL[h]) ||\n\t\t       B_N_CHILD_NUM(tb->FL[h], child_position) !=\n\t\t       bh->b_blocknr",
            "\"PAP-8275: invalid parent\""
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD_NUM",
          "args": [
            "tb->FL[h]",
            "child_position"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->FL[h]"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "get_neighbors_restart[h]"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "son_number"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD_NUM",
          "args": [
            "tb->FL[h]",
            "child_position"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->\n\t\t\t\t\t\t\t\t       FL[h]"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "bh == tb->FL[h] &&\n\t\t       !PATH_OFFSET_POSITION(tb->tb_path, path_offset)",
            "\"PAP-8270: invalid position in the parent\""
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_POSITION",
          "args": [
            "tb->tb_path",
            "path_offset"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "tb->tb_path",
            "path_offset"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "need_l_neighbor[h]"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "get_neighbors[h]"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PATH_OFFSET",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_neighbors(struct tree_balance *tb, int h)\n{\n\tint child_position,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h + 1);\n\tunsigned long son_number;\n\tstruct super_block *sb = tb->tb_sb;\n\tstruct buffer_head *bh;\n\tint depth;\n\n\tPROC_INFO_INC(sb, get_neighbors[h]);\n\n\tif (tb->lnum[h]) {\n\t\t/* We need left neighbor to balance S[h]. */\n\t\tPROC_INFO_INC(sb, need_l_neighbor[h]);\n\t\tbh = PATH_OFFSET_PBUFFER(tb->tb_path, path_offset);\n\n\t\tRFALSE(bh == tb->FL[h] &&\n\t\t       !PATH_OFFSET_POSITION(tb->tb_path, path_offset),\n\t\t       \"PAP-8270: invalid position in the parent\");\n\n\t\tchild_position =\n\t\t    (bh ==\n\t\t     tb->FL[h]) ? tb->lkey[h] : B_NR_ITEMS(tb->\n\t\t\t\t\t\t\t\t       FL[h]);\n\t\tson_number = B_N_CHILD_NUM(tb->FL[h], child_position);\n\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\tbh = sb_bread(sb, son_number);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (!bh)\n\t\t\treturn IO_ERROR;\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(bh);\n\t\t\tPROC_INFO_INC(sb, get_neighbors_restart[h]);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\n\t\tRFALSE(!B_IS_IN_TREE(tb->FL[h]) ||\n\t\t       child_position > B_NR_ITEMS(tb->FL[h]) ||\n\t\t       B_N_CHILD_NUM(tb->FL[h], child_position) !=\n\t\t       bh->b_blocknr, \"PAP-8275: invalid parent\");\n\t\tRFALSE(!B_IS_IN_TREE(bh), \"PAP-8280: invalid child\");\n\t\tRFALSE(!h &&\n\t\t       B_FREE_SPACE(bh) !=\n\t\t       MAX_CHILD_SIZE(bh) -\n\t\t       dc_size(B_N_CHILD(tb->FL[0], child_position)),\n\t\t       \"PAP-8290: invalid child size of left neighbor\");\n\n\t\tbrelse(tb->L[h]);\n\t\ttb->L[h] = bh;\n\t}\n\n\t/* We need right neighbor to balance S[path_offset]. */\n\tif (tb->rnum[h]) {\n\t\tPROC_INFO_INC(sb, need_r_neighbor[h]);\n\t\tbh = PATH_OFFSET_PBUFFER(tb->tb_path, path_offset);\n\n\t\tRFALSE(bh == tb->FR[h] &&\n\t\t       PATH_OFFSET_POSITION(tb->tb_path,\n\t\t\t\t\t    path_offset) >=\n\t\t       B_NR_ITEMS(bh),\n\t\t       \"PAP-8295: invalid position in the parent\");\n\n\t\tchild_position =\n\t\t    (bh == tb->FR[h]) ? tb->rkey[h] + 1 : 0;\n\t\tson_number = B_N_CHILD_NUM(tb->FR[h], child_position);\n\t\tdepth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\tbh = sb_bread(sb, son_number);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (!bh)\n\t\t\treturn IO_ERROR;\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(bh);\n\t\t\tPROC_INFO_INC(sb, get_neighbors_restart[h]);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\t\tbrelse(tb->R[h]);\n\t\ttb->R[h] = bh;\n\n\t\tRFALSE(!h\n\t\t       && B_FREE_SPACE(bh) !=\n\t\t       MAX_CHILD_SIZE(bh) -\n\t\t       dc_size(B_N_CHILD(tb->FR[0], child_position)),\n\t\t       \"PAP-8300: invalid child size of right neighbor (%d != %d - %d)\",\n\t\t       B_FREE_SPACE(bh), MAX_CHILD_SIZE(bh),\n\t\t       dc_size(B_N_CHILD(tb->FR[0], child_position)));\n\n\t}\n\treturn CARRY_ON;\n}"
  },
  {
    "function_name": "get_direct_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "2094-2146",
    "snippet": "static int get_direct_parent(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *bh;\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\n\t/* We are in the root or in the new root. */\n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET - 1,\n\t\t       \"PAP-8260: invalid offset in the path\");\n\n\t\tif (PATH_OFFSET_PBUFFER(path, FIRST_PATH_ELEMENT_OFFSET)->\n\t\t    b_blocknr == SB_ROOT_BLOCK(tb->tb_sb)) {\n\t\t\t/* Root is not changed. */\n\t\t\tPATH_OFFSET_PBUFFER(path, path_offset - 1) = NULL;\n\t\t\tPATH_OFFSET_POSITION(path, path_offset - 1) = 0;\n\t\t\treturn CARRY_ON;\n\t\t}\n\t\t/* Root is changed and we must recalculate the path. */\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\t/* Parent in the path is not in the tree. */\n\tif (!B_IS_IN_TREE\n\t    (bh = PATH_OFFSET_PBUFFER(path, path_offset - 1)))\n\t\treturn REPEAT_SEARCH;\n\n\tif ((position =\n\t     PATH_OFFSET_POSITION(path,\n\t\t\t\t  path_offset - 1)) > B_NR_ITEMS(bh))\n\t\treturn REPEAT_SEARCH;\n\n\t/* Parent in the path is not parent of the current node in the tree. */\n\tif (B_N_CHILD_NUM(bh, position) !=\n\t    PATH_OFFSET_PBUFFER(path, path_offset)->b_blocknr)\n\t\treturn REPEAT_SEARCH;\n\n\tif (buffer_locked(bh)) {\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(bh);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\treturn REPEAT_SEARCH;\n\t}\n\n\t/*\n\t * Parent in the path is unlocked and really parent\n\t * of the current node.\n\t */\n\treturn CARRY_ON;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "tb->tb_sb",
            "depth"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "tb->tb_sb"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "path",
            "path_offset"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD_NUM",
          "args": [
            "bh",
            "position"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_POSITION",
          "args": [
            "path",
            "path_offset - 1"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "bh = PATH_OFFSET_PBUFFER(path, path_offset - 1)"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "path",
            "path_offset - 1"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_POSITION",
          "args": [
            "path",
            "path_offset - 1"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "path",
            "path_offset - 1"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ROOT_BLOCK",
          "args": [
            "tb->tb_sb"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "path",
            "FIRST_PATH_ELEMENT_OFFSET"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "path_offset < FIRST_PATH_ELEMENT_OFFSET - 1",
            "\"PAP-8260: invalid offset in the path\""
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PATH_OFFSET",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_direct_parent(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *bh;\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\n\t/* We are in the root or in the new root. */\n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\n\t\tRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET - 1,\n\t\t       \"PAP-8260: invalid offset in the path\");\n\n\t\tif (PATH_OFFSET_PBUFFER(path, FIRST_PATH_ELEMENT_OFFSET)->\n\t\t    b_blocknr == SB_ROOT_BLOCK(tb->tb_sb)) {\n\t\t\t/* Root is not changed. */\n\t\t\tPATH_OFFSET_PBUFFER(path, path_offset - 1) = NULL;\n\t\t\tPATH_OFFSET_POSITION(path, path_offset - 1) = 0;\n\t\t\treturn CARRY_ON;\n\t\t}\n\t\t/* Root is changed and we must recalculate the path. */\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\t/* Parent in the path is not in the tree. */\n\tif (!B_IS_IN_TREE\n\t    (bh = PATH_OFFSET_PBUFFER(path, path_offset - 1)))\n\t\treturn REPEAT_SEARCH;\n\n\tif ((position =\n\t     PATH_OFFSET_POSITION(path,\n\t\t\t\t  path_offset - 1)) > B_NR_ITEMS(bh))\n\t\treturn REPEAT_SEARCH;\n\n\t/* Parent in the path is not parent of the current node in the tree. */\n\tif (B_N_CHILD_NUM(bh, position) !=\n\t    PATH_OFFSET_PBUFFER(path, path_offset)->b_blocknr)\n\t\treturn REPEAT_SEARCH;\n\n\tif (buffer_locked(bh)) {\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(bh);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb))\n\t\t\treturn REPEAT_SEARCH;\n\t}\n\n\t/*\n\t * Parent in the path is unlocked and really parent\n\t * of the current node.\n\t */\n\treturn CARRY_ON;\n}"
  },
  {
    "function_name": "check_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "2065-2091",
    "snippet": "static int check_balance(int mode,\n\t\t\t struct tree_balance *tb,\n\t\t\t int h,\n\t\t\t int inum,\n\t\t\t int pos_in_item,\n\t\t\t struct item_head *ins_ih, const void *data)\n{\n\tstruct virtual_node *vn;\n\n\tvn = tb->tb_vn = (struct virtual_node *)(tb->vn_buf);\n\tvn->vn_free_ptr = (char *)(tb->tb_vn + 1);\n\tvn->vn_mode = mode;\n\tvn->vn_affected_item_num = inum;\n\tvn->vn_pos_in_item = pos_in_item;\n\tvn->vn_ins_ih = ins_ih;\n\tvn->vn_data = data;\n\n\tRFALSE(mode == M_INSERT && !vn->vn_ins_ih,\n\t       \"vs-8255: ins_ih can not be 0 in insert mode\");\n\n\t/* Calculate balance parameters when size of node is increasing. */\n\tif (tb->insert_size[h] > 0)\n\t\treturn ip_check_balance(tb, h);\n\n\t/* Calculate balance parameters when  size of node is decreasing. */\n\treturn dc_check_balance(tb, h);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_check_balance",
          "args": [
            "tb",
            "h"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "dc_check_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2035-2044",
          "snippet": "static int dc_check_balance(struct tree_balance *tb, int h)\n{\n\tRFALSE(!(PATH_H_PBUFFER(tb->tb_path, h)),\n\t       \"vs-8250: S is not initialized\");\n\n\tif (h)\n\t\treturn dc_check_balance_internal(tb, h);\n\telse\n\t\treturn dc_check_balance_leaf(tb, h);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int dc_check_balance(struct tree_balance *tb, int h)\n{\n\tRFALSE(!(PATH_H_PBUFFER(tb->tb_path, h)),\n\t       \"vs-8250: S is not initialized\");\n\n\tif (h)\n\t\treturn dc_check_balance_internal(tb, h);\n\telse\n\t\treturn dc_check_balance_leaf(tb, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip_check_balance",
          "args": [
            "tb",
            "h"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "ip_check_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "1326-1709",
          "snippet": "static int ip_check_balance(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\t/*\n\t * Number of bytes that must be inserted into (value is negative\n\t * if bytes are deleted) buffer which contains node being balanced.\n\t * The mnemonic is that the attempted change in node space used\n\t * level is levbytes bytes.\n\t */\n\tint levbytes;\n\tint ret;\n\n\tint lfree, sfree, rfree /* free space in L, S and R */ ;\n\n\t/*\n\t * nver is short for number of vertixes, and lnver is the number if\n\t * we shift to the left, rnver is the number if we shift to the\n\t * right, and lrnver is the number if we shift in both directions.\n\t * The goal is to minimize first the number of vertixes, and second,\n\t * the number of vertixes whose contents are changed by shifting,\n\t * and third the number of uncached vertixes whose contents are\n\t * changed by shifting and must be read from disk.\n\t */\n\tint nver, lnver, rnver, lrnver;\n\n\t/*\n\t * used at leaf level only, S0 = S[0] is the node being balanced,\n\t * sInum [ I = 0,1,2 ] is the number of items that will\n\t * remain in node SI after balancing.  S1 and S2 are new\n\t * nodes that might be created.\n\t */\n\n\t/*\n\t * we perform 8 calls to get_num_ver().  For each call we\n\t * calculate five parameters.  where 4th parameter is s1bytes\n\t * and 5th - s2bytes\n\t *\n\t * s0num, s1num, s2num for 8 cases\n\t * 0,1 - do not shift and do not shift but bottle\n\t * 2   - shift only whole item to left\n\t * 3   - shift to left and bottle as much as possible\n\t * 4,5 - shift to right (whole items and as much as possible\n\t * 6,7 - shift to both directions (whole items and as much as possible)\n\t */\n\tshort snum012[40] = { 0, };\n\n\t/* Sh is the node whose balance is currently being checked */\n\tstruct buffer_head *Sh;\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tlevbytes = tb->insert_size[h];\n\n\t/* Calculate balance parameters for creating new root. */\n\tif (!Sh) {\n\t\tif (!h)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8210\",\n\t\t\t\t       \"S[0] can not be 0\");\n\t\tswitch (ret = get_empty_nodes(tb, h)) {\n\t\t/* no balancing for higher levels needed */\n\t\tcase CARRY_ON:\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\n\t\tcase NO_DISK_SPACE:\n\t\tcase REPEAT_SEARCH:\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8215\", \"incorrect \"\n\t\t\t\t       \"return value of get_empty_nodes\");\n\t\t}\n\t}\n\n\t/* get parents of S[h] neighbors. */\n\tret = get_parents(tb, h);\n\tif (ret != CARRY_ON)\n\t\treturn ret;\n\n\tsfree = B_FREE_SPACE(Sh);\n\n\t/* get free space of neighbors */\n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\t/* and new item fits into node S[h] without any shifting */\n\tif (can_node_be_removed(vn->vn_mode, lfree, sfree, rfree, tb, h) ==\n\t    NO_BALANCING_NEEDED)\n\t\treturn NO_BALANCING_NEEDED;\n\n\tcreate_virtual_node(tb, h);\n\n\t/*\n\t * determine maximal number of items we can shift to the left\n\t * neighbor (in tb structure) and the maximal number of bytes\n\t * that can flow to the left neighbor from the left most liquid\n\t * item that cannot be shifted from S[0] entirely (returned value)\n\t */\n\tcheck_left(tb, h, lfree);\n\n\t/*\n\t * determine maximal number of items we can shift to the right\n\t * neighbor (in tb structure) and the maximal number of bytes\n\t * that can flow to the right neighbor from the right most liquid\n\t * item that cannot be shifted from S[0] entirely (returned value)\n\t */\n\tcheck_right(tb, h, rfree);\n\n\t/*\n\t * all contents of internal node S[h] can be moved into its\n\t * neighbors, S[h] will be removed after balancing\n\t */\n\tif (h && (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1)) {\n\t\tint to_r;\n\n\t\t/*\n\t\t * Since we are working on internal nodes, and our internal\n\t\t * nodes have fixed size entries, then we can balance by the\n\t\t * number of items rather than the space they consume.  In this\n\t\t * routine we set the left node equal to the right node,\n\t\t * allowing a difference of less than or equal to 1 child\n\t\t * pointer.\n\t\t */\n\t\tto_r =\n\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] - tb->rnum[h] +\n\t\t     vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 -\n\t\t\t\t\t\ttb->rnum[h]);\n\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL,\n\t\t\t       -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/*\n\t * this checks balance condition, that any two neighboring nodes\n\t * can not fit in one node\n\t */\n\tRFALSE(h &&\n\t       (tb->lnum[h] >= vn->vn_nr_item + 1 ||\n\t\ttb->rnum[h] >= vn->vn_nr_item + 1),\n\t       \"vs-8220: tree is not balanced on internal level\");\n\tRFALSE(!h && ((tb->lnum[h] >= vn->vn_nr_item && (tb->lbytes == -1)) ||\n\t\t      (tb->rnum[h] >= vn->vn_nr_item && (tb->rbytes == -1))),\n\t       \"vs-8225: tree is not balanced on leaf level\");\n\n\t/*\n\t * all contents of S[0] can be moved into its neighbors\n\t * S[0] will be removed after balancing.\n\t */\n\tif (!h && is_leaf_removable(tb))\n\t\treturn CARRY_ON;\n\n\t/*\n\t * why do we perform this check here rather than earlier??\n\t * Answer: we can win 1 node in some cases above. Moreover we\n\t * checked it above, when we checked, that S[0] is not removable\n\t * in principle\n\t */\n\n\t /* new item fits into node S[h] without any shifting */\n\tif (sfree >= levbytes) {\n\t\tif (!h)\n\t\t\ttb->s0num = vn->vn_nr_item;\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\t{\n\t\tint lpar, rpar, nset, lset, rset, lrset;\n\t\t/* regular overflowing of the node */\n\n\t\t/*\n\t\t * get_num_ver works in 2 modes (FLOW & NO_FLOW)\n\t\t * lpar, rpar - number of items we can shift to left/right\n\t\t *              neighbor (including splitting item)\n\t\t * nset, lset, rset, lrset - shows, whether flowing items\n\t\t *                           give better packing\n\t\t */\n#define FLOW 1\n#define NO_FLOW 0\t\t/* do not any splitting */\n\n\t\t/* we choose one of the following */\n#define NOTHING_SHIFT_NO_FLOW\t0\n#define NOTHING_SHIFT_FLOW\t5\n#define LEFT_SHIFT_NO_FLOW\t10\n#define LEFT_SHIFT_FLOW\t\t15\n#define RIGHT_SHIFT_NO_FLOW\t20\n#define RIGHT_SHIFT_FLOW\t25\n#define LR_SHIFT_NO_FLOW\t30\n#define LR_SHIFT_FLOW\t\t35\n\n\t\tlpar = tb->lnum[h];\n\t\trpar = tb->rnum[h];\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * nothing is shifted to the neighbors, as well as number of\n\t\t * items in each part of the split node (s012 numbers),\n\t\t * and number of bytes (s1bytes) of the shared drop which\n\t\t * flow to S1 if any\n\t\t */\n\t\tnset = NOTHING_SHIFT_NO_FLOW;\n\t\tnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t   0, -1, h ? vn->vn_nr_item : 0, -1,\n\t\t\t\t   snum012, NO_FLOW);\n\n\t\tif (!h) {\n\t\t\tint nver1;\n\n\t\t\t/*\n\t\t\t * note, that in this case we try to bottle\n\t\t\t * between S[0] and S1 (S1 - the first new node)\n\t\t\t */\n\t\t\tnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t    0, -1, 0, -1,\n\t\t\t\t\t    snum012 + NOTHING_SHIFT_FLOW, FLOW);\n\t\t\tif (nver > nver1)\n\t\t\t\tnset = NOTHING_SHIFT_FLOW, nver = nver1;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * l_shift_num first items and l_shift_bytes of the right\n\t\t * most liquid item to be shifted are shifted to the left\n\t\t * neighbor, as well as number of items in each part of the\n\t\t * splitted node (s012 numbers), and number of bytes\n\t\t * (s1bytes) of the shared drop which flow to S1 if any\n\t\t */\n\t\tlset = LEFT_SHIFT_NO_FLOW;\n\t\tlnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t    lpar - ((h || tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t    -1, h ? vn->vn_nr_item : 0, -1,\n\t\t\t\t    snum012 + LEFT_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint lnver1;\n\n\t\t\tlnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t     lpar -\n\t\t\t\t\t     ((tb->lbytes != -1) ? 1 : 0),\n\t\t\t\t\t     tb->lbytes, 0, -1,\n\t\t\t\t\t     snum012 + LEFT_SHIFT_FLOW, FLOW);\n\t\t\tif (lnver > lnver1)\n\t\t\t\tlset = LEFT_SHIFT_FLOW, lnver = lnver1;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * r_shift_num first items and r_shift_bytes of the left most\n\t\t * liquid item to be shifted are shifted to the right neighbor,\n\t\t * as well as number of items in each part of the splitted\n\t\t * node (s012 numbers), and number of bytes (s1bytes) of the\n\t\t * shared drop which flow to S1 if any\n\t\t */\n\t\trset = RIGHT_SHIFT_NO_FLOW;\n\t\trnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t    0, -1,\n\t\t\t\t    h ? (vn->vn_nr_item - rpar) : (rpar -\n\t\t\t\t\t\t\t\t   ((tb->\n\t\t\t\t\t\t\t\t     rbytes !=\n\t\t\t\t\t\t\t\t     -1) ? 1 :\n\t\t\t\t\t\t\t\t    0)), -1,\n\t\t\t\t    snum012 + RIGHT_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint rnver1;\n\n\t\t\trnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t     0, -1,\n\t\t\t\t\t     (rpar -\n\t\t\t\t\t      ((tb->rbytes != -1) ? 1 : 0)),\n\t\t\t\t\t     tb->rbytes,\n\t\t\t\t\t     snum012 + RIGHT_SHIFT_FLOW, FLOW);\n\n\t\t\tif (rnver > rnver1)\n\t\t\t\trset = RIGHT_SHIFT_FLOW, rnver = rnver1;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * items are shifted in both directions, as well as number\n\t\t * of items in each part of the splitted node (s012 numbers),\n\t\t * and number of bytes (s1bytes) of the shared drop which\n\t\t * flow to S1 if any\n\t\t */\n\t\tlrset = LR_SHIFT_NO_FLOW;\n\t\tlrnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t     lpar - ((h || tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t     -1,\n\t\t\t\t     h ? (vn->vn_nr_item - rpar) : (rpar -\n\t\t\t\t\t\t\t\t    ((tb->\n\t\t\t\t\t\t\t\t      rbytes !=\n\t\t\t\t\t\t\t\t      -1) ? 1 :\n\t\t\t\t\t\t\t\t     0)), -1,\n\t\t\t\t     snum012 + LR_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint lrnver1;\n\n\t\t\tlrnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t      lpar -\n\t\t\t\t\t      ((tb->lbytes != -1) ? 1 : 0),\n\t\t\t\t\t      tb->lbytes,\n\t\t\t\t\t      (rpar -\n\t\t\t\t\t       ((tb->rbytes != -1) ? 1 : 0)),\n\t\t\t\t\t      tb->rbytes,\n\t\t\t\t\t      snum012 + LR_SHIFT_FLOW, FLOW);\n\t\t\tif (lrnver > lrnver1)\n\t\t\t\tlrset = LR_SHIFT_FLOW, lrnver = lrnver1;\n\t\t}\n\n\t\t/*\n\t\t * Our general shifting strategy is:\n\t\t * 1) to minimized number of new nodes;\n\t\t * 2) to minimized number of neighbors involved in shifting;\n\t\t * 3) to minimized number of disk reads;\n\t\t */\n\n\t\t/* we can win TWO or ONE nodes by shifting in both directions */\n\t\tif (lrnver < lnver && lrnver < rnver) {\n\t\t\tRFALSE(h &&\n\t\t\t       (tb->lnum[h] != 1 ||\n\t\t\t\ttb->rnum[h] != 1 ||\n\t\t\t\tlrnver != 1 || rnver != 2 || lnver != 2\n\t\t\t\t|| h != 1), \"vs-8230: bad h\");\n\t\t\tif (lrset == LR_SHIFT_FLOW)\n\t\t\t\tset_parameters(tb, h, tb->lnum[h], tb->rnum[h],\n\t\t\t\t\t       lrnver, snum012 + lrset,\n\t\t\t\t\t       tb->lbytes, tb->rbytes);\n\t\t\telse\n\t\t\t\tset_parameters(tb, h,\n\t\t\t\t\t       tb->lnum[h] -\n\t\t\t\t\t       ((tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t\t       tb->rnum[h] -\n\t\t\t\t\t       ((tb->rbytes == -1) ? 0 : 1),\n\t\t\t\t\t       lrnver, snum012 + lrset, -1, -1);\n\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * if shifting doesn't lead to better packing\n\t\t * then don't shift\n\t\t */\n\t\tif (nver == lrnver) {\n\t\t\tset_parameters(tb, h, 0, 0, nver, snum012 + nset, -1,\n\t\t\t\t       -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * now we know that for better packing shifting in only one\n\t\t * direction either to the left or to the right is required\n\t\t */\n\n\t\t/*\n\t\t * if shifting to the left is better than\n\t\t * shifting to the right\n\t\t */\n\t\tif (lnver < rnver) {\n\t\t\tSET_PAR_SHIFT_LEFT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * if shifting to the right is better than\n\t\t * shifting to the left\n\t\t */\n\t\tif (lnver > rnver) {\n\t\t\tSET_PAR_SHIFT_RIGHT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * now shifting in either direction gives the same number\n\t\t * of nodes and we can make use of the cached neighbors\n\t\t */\n\t\tif (is_left_neighbor_in_cache(tb, h)) {\n\t\t\tSET_PAR_SHIFT_LEFT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * shift to the right independently on whether the\n\t\t * right neighbor in cache or not\n\t\t */\n\t\tSET_PAR_SHIFT_RIGHT;\n\t\treturn CARRY_ON;\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define LR_SHIFT_FLOW\t\t35",
            "#define LR_SHIFT_NO_FLOW\t30",
            "#define RIGHT_SHIFT_FLOW\t25",
            "#define RIGHT_SHIFT_NO_FLOW\t20",
            "#define LEFT_SHIFT_FLOW\t\t15",
            "#define LEFT_SHIFT_NO_FLOW\t10",
            "#define NOTHING_SHIFT_FLOW\t5",
            "#define NOTHING_SHIFT_NO_FLOW\t0",
            "#define NO_FLOW 0\t\t/* do not any splitting */",
            "#define FLOW 1",
            "#define SET_PAR_SHIFT_RIGHT \\\nif (h)\\\n{\\\n   int to_r;\\\n   \\\n   to_r = (MAX_NR_KEY(Sh)+1 - rpar + vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 - rpar);\\\n   \\\n   set_parameters (tb, h, 0, to_r, rnver, NULL, -1, -1);\\\n}\\\nelse \\\n{\\\n   if (rset==RIGHT_SHIFT_FLOW)\\\n     set_parameters (tb, h, 0, rpar, rnver, snum012+rset,\\\n\t\t  -1, tb->rbytes);\\\n   else\\\n     set_parameters (tb, h, 0, rpar - (tb->rbytes!=-1), rnver, snum012+rset,\\\n\t\t  -1, -1);\\\n}",
            "#define SET_PAR_SHIFT_LEFT \\\nif (h)\\\n{\\\n   int to_l;\\\n   \\\n   to_l = (MAX_NR_KEY(Sh)+1 - lpar + vn->vn_nr_item + 1) / 2 -\\\n\t      (MAX_NR_KEY(Sh) + 1 - lpar);\\\n\t      \\\n\t      set_parameters (tb, h, to_l, 0, lnver, NULL, -1, -1);\\\n}\\\nelse \\\n{\\\n   if (lset==LEFT_SHIFT_FLOW)\\\n     set_parameters (tb, h, lpar, 0, lnver, snum012+lset,\\\n\t\t     tb->lbytes, -1);\\\n   else\\\n     set_parameters (tb, h, lpar - (tb->lbytes!=-1), 0, lnver, snum012+lset,\\\n\t\t     -1, -1);\\\n}"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#define LR_SHIFT_FLOW\t\t35\n#define LR_SHIFT_NO_FLOW\t30\n#define RIGHT_SHIFT_FLOW\t25\n#define RIGHT_SHIFT_NO_FLOW\t20\n#define LEFT_SHIFT_FLOW\t\t15\n#define LEFT_SHIFT_NO_FLOW\t10\n#define NOTHING_SHIFT_FLOW\t5\n#define NOTHING_SHIFT_NO_FLOW\t0\n#define NO_FLOW 0\t\t/* do not any splitting */\n#define FLOW 1\n#define SET_PAR_SHIFT_RIGHT \\\nif (h)\\\n{\\\n   int to_r;\\\n   \\\n   to_r = (MAX_NR_KEY(Sh)+1 - rpar + vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 - rpar);\\\n   \\\n   set_parameters (tb, h, 0, to_r, rnver, NULL, -1, -1);\\\n}\\\nelse \\\n{\\\n   if (rset==RIGHT_SHIFT_FLOW)\\\n     set_parameters (tb, h, 0, rpar, rnver, snum012+rset,\\\n\t\t  -1, tb->rbytes);\\\n   else\\\n     set_parameters (tb, h, 0, rpar - (tb->rbytes!=-1), rnver, snum012+rset,\\\n\t\t  -1, -1);\\\n}\n#define SET_PAR_SHIFT_LEFT \\\nif (h)\\\n{\\\n   int to_l;\\\n   \\\n   to_l = (MAX_NR_KEY(Sh)+1 - lpar + vn->vn_nr_item + 1) / 2 -\\\n\t      (MAX_NR_KEY(Sh) + 1 - lpar);\\\n\t      \\\n\t      set_parameters (tb, h, to_l, 0, lnver, NULL, -1, -1);\\\n}\\\nelse \\\n{\\\n   if (lset==LEFT_SHIFT_FLOW)\\\n     set_parameters (tb, h, lpar, 0, lnver, snum012+lset,\\\n\t\t     tb->lbytes, -1);\\\n   else\\\n     set_parameters (tb, h, lpar - (tb->lbytes!=-1), 0, lnver, snum012+lset,\\\n\t\t     -1, -1);\\\n}\n\nstatic int ip_check_balance(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\t/*\n\t * Number of bytes that must be inserted into (value is negative\n\t * if bytes are deleted) buffer which contains node being balanced.\n\t * The mnemonic is that the attempted change in node space used\n\t * level is levbytes bytes.\n\t */\n\tint levbytes;\n\tint ret;\n\n\tint lfree, sfree, rfree /* free space in L, S and R */ ;\n\n\t/*\n\t * nver is short for number of vertixes, and lnver is the number if\n\t * we shift to the left, rnver is the number if we shift to the\n\t * right, and lrnver is the number if we shift in both directions.\n\t * The goal is to minimize first the number of vertixes, and second,\n\t * the number of vertixes whose contents are changed by shifting,\n\t * and third the number of uncached vertixes whose contents are\n\t * changed by shifting and must be read from disk.\n\t */\n\tint nver, lnver, rnver, lrnver;\n\n\t/*\n\t * used at leaf level only, S0 = S[0] is the node being balanced,\n\t * sInum [ I = 0,1,2 ] is the number of items that will\n\t * remain in node SI after balancing.  S1 and S2 are new\n\t * nodes that might be created.\n\t */\n\n\t/*\n\t * we perform 8 calls to get_num_ver().  For each call we\n\t * calculate five parameters.  where 4th parameter is s1bytes\n\t * and 5th - s2bytes\n\t *\n\t * s0num, s1num, s2num for 8 cases\n\t * 0,1 - do not shift and do not shift but bottle\n\t * 2   - shift only whole item to left\n\t * 3   - shift to left and bottle as much as possible\n\t * 4,5 - shift to right (whole items and as much as possible\n\t * 6,7 - shift to both directions (whole items and as much as possible)\n\t */\n\tshort snum012[40] = { 0, };\n\n\t/* Sh is the node whose balance is currently being checked */\n\tstruct buffer_head *Sh;\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tlevbytes = tb->insert_size[h];\n\n\t/* Calculate balance parameters for creating new root. */\n\tif (!Sh) {\n\t\tif (!h)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8210\",\n\t\t\t\t       \"S[0] can not be 0\");\n\t\tswitch (ret = get_empty_nodes(tb, h)) {\n\t\t/* no balancing for higher levels needed */\n\t\tcase CARRY_ON:\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\n\t\tcase NO_DISK_SPACE:\n\t\tcase REPEAT_SEARCH:\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8215\", \"incorrect \"\n\t\t\t\t       \"return value of get_empty_nodes\");\n\t\t}\n\t}\n\n\t/* get parents of S[h] neighbors. */\n\tret = get_parents(tb, h);\n\tif (ret != CARRY_ON)\n\t\treturn ret;\n\n\tsfree = B_FREE_SPACE(Sh);\n\n\t/* get free space of neighbors */\n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\t/* and new item fits into node S[h] without any shifting */\n\tif (can_node_be_removed(vn->vn_mode, lfree, sfree, rfree, tb, h) ==\n\t    NO_BALANCING_NEEDED)\n\t\treturn NO_BALANCING_NEEDED;\n\n\tcreate_virtual_node(tb, h);\n\n\t/*\n\t * determine maximal number of items we can shift to the left\n\t * neighbor (in tb structure) and the maximal number of bytes\n\t * that can flow to the left neighbor from the left most liquid\n\t * item that cannot be shifted from S[0] entirely (returned value)\n\t */\n\tcheck_left(tb, h, lfree);\n\n\t/*\n\t * determine maximal number of items we can shift to the right\n\t * neighbor (in tb structure) and the maximal number of bytes\n\t * that can flow to the right neighbor from the right most liquid\n\t * item that cannot be shifted from S[0] entirely (returned value)\n\t */\n\tcheck_right(tb, h, rfree);\n\n\t/*\n\t * all contents of internal node S[h] can be moved into its\n\t * neighbors, S[h] will be removed after balancing\n\t */\n\tif (h && (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1)) {\n\t\tint to_r;\n\n\t\t/*\n\t\t * Since we are working on internal nodes, and our internal\n\t\t * nodes have fixed size entries, then we can balance by the\n\t\t * number of items rather than the space they consume.  In this\n\t\t * routine we set the left node equal to the right node,\n\t\t * allowing a difference of less than or equal to 1 child\n\t\t * pointer.\n\t\t */\n\t\tto_r =\n\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] - tb->rnum[h] +\n\t\t     vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 -\n\t\t\t\t\t\ttb->rnum[h]);\n\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL,\n\t\t\t       -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/*\n\t * this checks balance condition, that any two neighboring nodes\n\t * can not fit in one node\n\t */\n\tRFALSE(h &&\n\t       (tb->lnum[h] >= vn->vn_nr_item + 1 ||\n\t\ttb->rnum[h] >= vn->vn_nr_item + 1),\n\t       \"vs-8220: tree is not balanced on internal level\");\n\tRFALSE(!h && ((tb->lnum[h] >= vn->vn_nr_item && (tb->lbytes == -1)) ||\n\t\t      (tb->rnum[h] >= vn->vn_nr_item && (tb->rbytes == -1))),\n\t       \"vs-8225: tree is not balanced on leaf level\");\n\n\t/*\n\t * all contents of S[0] can be moved into its neighbors\n\t * S[0] will be removed after balancing.\n\t */\n\tif (!h && is_leaf_removable(tb))\n\t\treturn CARRY_ON;\n\n\t/*\n\t * why do we perform this check here rather than earlier??\n\t * Answer: we can win 1 node in some cases above. Moreover we\n\t * checked it above, when we checked, that S[0] is not removable\n\t * in principle\n\t */\n\n\t /* new item fits into node S[h] without any shifting */\n\tif (sfree >= levbytes) {\n\t\tif (!h)\n\t\t\ttb->s0num = vn->vn_nr_item;\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\t{\n\t\tint lpar, rpar, nset, lset, rset, lrset;\n\t\t/* regular overflowing of the node */\n\n\t\t/*\n\t\t * get_num_ver works in 2 modes (FLOW & NO_FLOW)\n\t\t * lpar, rpar - number of items we can shift to left/right\n\t\t *              neighbor (including splitting item)\n\t\t * nset, lset, rset, lrset - shows, whether flowing items\n\t\t *                           give better packing\n\t\t */\n#define FLOW 1\n#define NO_FLOW 0\t\t/* do not any splitting */\n\n\t\t/* we choose one of the following */\n#define NOTHING_SHIFT_NO_FLOW\t0\n#define NOTHING_SHIFT_FLOW\t5\n#define LEFT_SHIFT_NO_FLOW\t10\n#define LEFT_SHIFT_FLOW\t\t15\n#define RIGHT_SHIFT_NO_FLOW\t20\n#define RIGHT_SHIFT_FLOW\t25\n#define LR_SHIFT_NO_FLOW\t30\n#define LR_SHIFT_FLOW\t\t35\n\n\t\tlpar = tb->lnum[h];\n\t\trpar = tb->rnum[h];\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * nothing is shifted to the neighbors, as well as number of\n\t\t * items in each part of the split node (s012 numbers),\n\t\t * and number of bytes (s1bytes) of the shared drop which\n\t\t * flow to S1 if any\n\t\t */\n\t\tnset = NOTHING_SHIFT_NO_FLOW;\n\t\tnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t   0, -1, h ? vn->vn_nr_item : 0, -1,\n\t\t\t\t   snum012, NO_FLOW);\n\n\t\tif (!h) {\n\t\t\tint nver1;\n\n\t\t\t/*\n\t\t\t * note, that in this case we try to bottle\n\t\t\t * between S[0] and S1 (S1 - the first new node)\n\t\t\t */\n\t\t\tnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t    0, -1, 0, -1,\n\t\t\t\t\t    snum012 + NOTHING_SHIFT_FLOW, FLOW);\n\t\t\tif (nver > nver1)\n\t\t\t\tnset = NOTHING_SHIFT_FLOW, nver = nver1;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * l_shift_num first items and l_shift_bytes of the right\n\t\t * most liquid item to be shifted are shifted to the left\n\t\t * neighbor, as well as number of items in each part of the\n\t\t * splitted node (s012 numbers), and number of bytes\n\t\t * (s1bytes) of the shared drop which flow to S1 if any\n\t\t */\n\t\tlset = LEFT_SHIFT_NO_FLOW;\n\t\tlnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t    lpar - ((h || tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t    -1, h ? vn->vn_nr_item : 0, -1,\n\t\t\t\t    snum012 + LEFT_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint lnver1;\n\n\t\t\tlnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t     lpar -\n\t\t\t\t\t     ((tb->lbytes != -1) ? 1 : 0),\n\t\t\t\t\t     tb->lbytes, 0, -1,\n\t\t\t\t\t     snum012 + LEFT_SHIFT_FLOW, FLOW);\n\t\t\tif (lnver > lnver1)\n\t\t\t\tlset = LEFT_SHIFT_FLOW, lnver = lnver1;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * r_shift_num first items and r_shift_bytes of the left most\n\t\t * liquid item to be shifted are shifted to the right neighbor,\n\t\t * as well as number of items in each part of the splitted\n\t\t * node (s012 numbers), and number of bytes (s1bytes) of the\n\t\t * shared drop which flow to S1 if any\n\t\t */\n\t\trset = RIGHT_SHIFT_NO_FLOW;\n\t\trnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t    0, -1,\n\t\t\t\t    h ? (vn->vn_nr_item - rpar) : (rpar -\n\t\t\t\t\t\t\t\t   ((tb->\n\t\t\t\t\t\t\t\t     rbytes !=\n\t\t\t\t\t\t\t\t     -1) ? 1 :\n\t\t\t\t\t\t\t\t    0)), -1,\n\t\t\t\t    snum012 + RIGHT_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint rnver1;\n\n\t\t\trnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t     0, -1,\n\t\t\t\t\t     (rpar -\n\t\t\t\t\t      ((tb->rbytes != -1) ? 1 : 0)),\n\t\t\t\t\t     tb->rbytes,\n\t\t\t\t\t     snum012 + RIGHT_SHIFT_FLOW, FLOW);\n\n\t\t\tif (rnver > rnver1)\n\t\t\t\trset = RIGHT_SHIFT_FLOW, rnver = rnver1;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * items are shifted in both directions, as well as number\n\t\t * of items in each part of the splitted node (s012 numbers),\n\t\t * and number of bytes (s1bytes) of the shared drop which\n\t\t * flow to S1 if any\n\t\t */\n\t\tlrset = LR_SHIFT_NO_FLOW;\n\t\tlrnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t     lpar - ((h || tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t     -1,\n\t\t\t\t     h ? (vn->vn_nr_item - rpar) : (rpar -\n\t\t\t\t\t\t\t\t    ((tb->\n\t\t\t\t\t\t\t\t      rbytes !=\n\t\t\t\t\t\t\t\t      -1) ? 1 :\n\t\t\t\t\t\t\t\t     0)), -1,\n\t\t\t\t     snum012 + LR_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint lrnver1;\n\n\t\t\tlrnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t      lpar -\n\t\t\t\t\t      ((tb->lbytes != -1) ? 1 : 0),\n\t\t\t\t\t      tb->lbytes,\n\t\t\t\t\t      (rpar -\n\t\t\t\t\t       ((tb->rbytes != -1) ? 1 : 0)),\n\t\t\t\t\t      tb->rbytes,\n\t\t\t\t\t      snum012 + LR_SHIFT_FLOW, FLOW);\n\t\t\tif (lrnver > lrnver1)\n\t\t\t\tlrset = LR_SHIFT_FLOW, lrnver = lrnver1;\n\t\t}\n\n\t\t/*\n\t\t * Our general shifting strategy is:\n\t\t * 1) to minimized number of new nodes;\n\t\t * 2) to minimized number of neighbors involved in shifting;\n\t\t * 3) to minimized number of disk reads;\n\t\t */\n\n\t\t/* we can win TWO or ONE nodes by shifting in both directions */\n\t\tif (lrnver < lnver && lrnver < rnver) {\n\t\t\tRFALSE(h &&\n\t\t\t       (tb->lnum[h] != 1 ||\n\t\t\t\ttb->rnum[h] != 1 ||\n\t\t\t\tlrnver != 1 || rnver != 2 || lnver != 2\n\t\t\t\t|| h != 1), \"vs-8230: bad h\");\n\t\t\tif (lrset == LR_SHIFT_FLOW)\n\t\t\t\tset_parameters(tb, h, tb->lnum[h], tb->rnum[h],\n\t\t\t\t\t       lrnver, snum012 + lrset,\n\t\t\t\t\t       tb->lbytes, tb->rbytes);\n\t\t\telse\n\t\t\t\tset_parameters(tb, h,\n\t\t\t\t\t       tb->lnum[h] -\n\t\t\t\t\t       ((tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t\t       tb->rnum[h] -\n\t\t\t\t\t       ((tb->rbytes == -1) ? 0 : 1),\n\t\t\t\t\t       lrnver, snum012 + lrset, -1, -1);\n\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * if shifting doesn't lead to better packing\n\t\t * then don't shift\n\t\t */\n\t\tif (nver == lrnver) {\n\t\t\tset_parameters(tb, h, 0, 0, nver, snum012 + nset, -1,\n\t\t\t\t       -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * now we know that for better packing shifting in only one\n\t\t * direction either to the left or to the right is required\n\t\t */\n\n\t\t/*\n\t\t * if shifting to the left is better than\n\t\t * shifting to the right\n\t\t */\n\t\tif (lnver < rnver) {\n\t\t\tSET_PAR_SHIFT_LEFT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * if shifting to the right is better than\n\t\t * shifting to the left\n\t\t */\n\t\tif (lnver > rnver) {\n\t\t\tSET_PAR_SHIFT_RIGHT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * now shifting in either direction gives the same number\n\t\t * of nodes and we can make use of the cached neighbors\n\t\t */\n\t\tif (is_left_neighbor_in_cache(tb, h)) {\n\t\t\tSET_PAR_SHIFT_LEFT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * shift to the right independently on whether the\n\t\t * right neighbor in cache or not\n\t\t */\n\t\tSET_PAR_SHIFT_RIGHT;\n\t\treturn CARRY_ON;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "mode == M_INSERT && !vn->vn_ins_ih",
            "\"vs-8255: ins_ih can not be 0 in insert mode\""
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int check_balance(int mode,\n\t\t\t struct tree_balance *tb,\n\t\t\t int h,\n\t\t\t int inum,\n\t\t\t int pos_in_item,\n\t\t\t struct item_head *ins_ih, const void *data)\n{\n\tstruct virtual_node *vn;\n\n\tvn = tb->tb_vn = (struct virtual_node *)(tb->vn_buf);\n\tvn->vn_free_ptr = (char *)(tb->tb_vn + 1);\n\tvn->vn_mode = mode;\n\tvn->vn_affected_item_num = inum;\n\tvn->vn_pos_in_item = pos_in_item;\n\tvn->vn_ins_ih = ins_ih;\n\tvn->vn_data = data;\n\n\tRFALSE(mode == M_INSERT && !vn->vn_ins_ih,\n\t       \"vs-8255: ins_ih can not be 0 in insert mode\");\n\n\t/* Calculate balance parameters when size of node is increasing. */\n\tif (tb->insert_size[h] > 0)\n\t\treturn ip_check_balance(tb, h);\n\n\t/* Calculate balance parameters when  size of node is decreasing. */\n\treturn dc_check_balance(tb, h);\n}"
  },
  {
    "function_name": "dc_check_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "2035-2044",
    "snippet": "static int dc_check_balance(struct tree_balance *tb, int h)\n{\n\tRFALSE(!(PATH_H_PBUFFER(tb->tb_path, h)),\n\t       \"vs-8250: S is not initialized\");\n\n\tif (h)\n\t\treturn dc_check_balance_internal(tb, h);\n\telse\n\t\treturn dc_check_balance_leaf(tb, h);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_check_balance_leaf",
          "args": [
            "tb",
            "h"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "dc_check_balance_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "1929-2019",
          "snippet": "static int dc_check_balance_leaf(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\n\t/*\n\t * Number of bytes that must be deleted from\n\t * (value is negative if bytes are deleted) buffer which\n\t * contains node being balanced.  The mnemonic is that the\n\t * attempted change in node space used level is levbytes bytes.\n\t */\n\tint levbytes;\n\n\t/* the maximal item size */\n\tint maxsize, ret;\n\n\t/*\n\t * S0 is the node whose balance is currently being checked,\n\t * and F0 is its father.\n\t */\n\tstruct buffer_head *S0, *F0;\n\tint lfree, rfree /* free space in L and R */ ;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\tF0 = PATH_H_PPARENT(tb->tb_path, 0);\n\n\tlevbytes = tb->insert_size[h];\n\n\tmaxsize = MAX_CHILD_SIZE(S0);\t/* maximal possible size of an item */\n\n\tif (!F0) {\t\t/* S[0] is the root now. */\n\n\t\tRFALSE(-levbytes >= maxsize - B_FREE_SPACE(S0),\n\t\t       \"vs-8240: attempt to create empty buffer tree\");\n\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\tif ((ret = get_parents(tb, h)) != CARRY_ON)\n\t\treturn ret;\n\n\t/* get free space of neighbors */\n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\tcreate_virtual_node(tb, h);\n\n\t/* if 3 leaves can be merge to one, set parameters and return */\n\tif (are_leaves_removable(tb, lfree, rfree))\n\t\treturn CARRY_ON;\n\n\t/*\n\t * determine maximal number of items we can shift to the left/right\n\t * neighbor and the maximal number of bytes that can flow to the\n\t * left/right neighbor from the left/right most liquid item that\n\t * cannot be shifted from S[0] entirely\n\t */\n\tcheck_left(tb, h, lfree);\n\tcheck_right(tb, h, rfree);\n\n\t/* check whether we can merge S with left neighbor. */\n\tif (tb->lnum[0] >= vn->vn_nr_item && tb->lbytes == -1)\n\t\tif (is_left_neighbor_in_cache(tb, h) || ((tb->rnum[0] - ((tb->rbytes == -1) ? 0 : 1)) < vn->vn_nr_item) ||\t/* S can not be merged with R */\n\t\t    !tb->FR[h]) {\n\n\t\t\tRFALSE(!tb->FL[h],\n\t\t\t       \"vs-8245: dc_check_balance_leaf: FL[h] must exist\");\n\n\t\t\t/* set parameter to merge S[0] with its left neighbor */\n\t\t\tset_parameters(tb, h, -1, 0, 0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t/* check whether we can merge S[0] with right neighbor. */\n\tif (tb->rnum[0] >= vn->vn_nr_item && tb->rbytes == -1) {\n\t\tset_parameters(tb, h, 0, -1, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/*\n\t * All contents of S[0] can be moved to the neighbors (L[0] & R[0]).\n\t * Set parameters and return\n\t */\n\tif (is_leaf_removable(tb))\n\t\treturn CARRY_ON;\n\n\t/* Balancing is not required. */\n\ttb->s0num = vn->vn_nr_item;\n\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\treturn NO_BALANCING_NEEDED;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int dc_check_balance_leaf(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\n\t/*\n\t * Number of bytes that must be deleted from\n\t * (value is negative if bytes are deleted) buffer which\n\t * contains node being balanced.  The mnemonic is that the\n\t * attempted change in node space used level is levbytes bytes.\n\t */\n\tint levbytes;\n\n\t/* the maximal item size */\n\tint maxsize, ret;\n\n\t/*\n\t * S0 is the node whose balance is currently being checked,\n\t * and F0 is its father.\n\t */\n\tstruct buffer_head *S0, *F0;\n\tint lfree, rfree /* free space in L and R */ ;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\tF0 = PATH_H_PPARENT(tb->tb_path, 0);\n\n\tlevbytes = tb->insert_size[h];\n\n\tmaxsize = MAX_CHILD_SIZE(S0);\t/* maximal possible size of an item */\n\n\tif (!F0) {\t\t/* S[0] is the root now. */\n\n\t\tRFALSE(-levbytes >= maxsize - B_FREE_SPACE(S0),\n\t\t       \"vs-8240: attempt to create empty buffer tree\");\n\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\tif ((ret = get_parents(tb, h)) != CARRY_ON)\n\t\treturn ret;\n\n\t/* get free space of neighbors */\n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\tcreate_virtual_node(tb, h);\n\n\t/* if 3 leaves can be merge to one, set parameters and return */\n\tif (are_leaves_removable(tb, lfree, rfree))\n\t\treturn CARRY_ON;\n\n\t/*\n\t * determine maximal number of items we can shift to the left/right\n\t * neighbor and the maximal number of bytes that can flow to the\n\t * left/right neighbor from the left/right most liquid item that\n\t * cannot be shifted from S[0] entirely\n\t */\n\tcheck_left(tb, h, lfree);\n\tcheck_right(tb, h, rfree);\n\n\t/* check whether we can merge S with left neighbor. */\n\tif (tb->lnum[0] >= vn->vn_nr_item && tb->lbytes == -1)\n\t\tif (is_left_neighbor_in_cache(tb, h) || ((tb->rnum[0] - ((tb->rbytes == -1) ? 0 : 1)) < vn->vn_nr_item) ||\t/* S can not be merged with R */\n\t\t    !tb->FR[h]) {\n\n\t\t\tRFALSE(!tb->FL[h],\n\t\t\t       \"vs-8245: dc_check_balance_leaf: FL[h] must exist\");\n\n\t\t\t/* set parameter to merge S[0] with its left neighbor */\n\t\t\tset_parameters(tb, h, -1, 0, 0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t/* check whether we can merge S[0] with right neighbor. */\n\tif (tb->rnum[0] >= vn->vn_nr_item && tb->rbytes == -1) {\n\t\tset_parameters(tb, h, 0, -1, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/*\n\t * All contents of S[0] can be moved to the neighbors (L[0] & R[0]).\n\t * Set parameters and return\n\t */\n\tif (is_leaf_removable(tb))\n\t\treturn CARRY_ON;\n\n\t/* Balancing is not required. */\n\ttb->s0num = vn->vn_nr_item;\n\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\treturn NO_BALANCING_NEEDED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_check_balance_internal",
          "args": [
            "tb",
            "h"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "dc_check_balance_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "1728-1913",
          "snippet": "static int dc_check_balance_internal(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\n\t/*\n\t * Sh is the node whose balance is currently being checked,\n\t * and Fh is its father.\n\t */\n\tstruct buffer_head *Sh, *Fh;\n\tint maxsize, ret;\n\tint lfree, rfree /* free space in L and R */ ;\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tFh = PATH_H_PPARENT(tb->tb_path, h);\n\n\tmaxsize = MAX_CHILD_SIZE(Sh);\n\n\t/*\n\t * using tb->insert_size[h], which is negative in this case,\n\t * create_virtual_node calculates:\n\t * new_nr_item = number of items node would have if operation is\n\t * performed without balancing (new_nr_item);\n\t */\n\tcreate_virtual_node(tb, h);\n\n\tif (!Fh) {\t\t/* S[h] is the root. */\n\t\t/* no balancing for higher levels needed */\n\t\tif (vn->vn_nr_item > 0) {\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\t\t}\n\t\t/*\n\t\t * new_nr_item == 0.\n\t\t * Current root will be deleted resulting in\n\t\t * decrementing the tree height.\n\t\t */\n\t\tset_parameters(tb, h, 0, 0, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\tif ((ret = get_parents(tb, h)) != CARRY_ON)\n\t\treturn ret;\n\n\t/* get free space of neighbors */\n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\t/* determine maximal number of items we can fit into neighbors */\n\tcheck_left(tb, h, lfree);\n\tcheck_right(tb, h, rfree);\n\n\t/*\n\t * Balance condition for the internal node is valid.\n\t * In this case we balance only if it leads to better packing.\n\t */\n\tif (vn->vn_nr_item >= MIN_NR_KEY(Sh)) {\n\t\t/*\n\t\t * Here we join S[h] with one of its neighbors,\n\t\t * which is impossible with greater values of new_nr_item.\n\t\t */\n\t\tif (vn->vn_nr_item == MIN_NR_KEY(Sh)) {\n\t\t\t/* All contents of S[h] can be moved to L[h]. */\n\t\t\tif (tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\t\t\tint n;\n\t\t\t\tint order_L;\n\n\t\t\t\torder_L =\n\t\t\t\t    ((n =\n\t\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t\t  h)) ==\n\t\t\t\t     0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;\n\t\t\t\tn = dc_size(B_N_CHILD(tb->FL[h], order_L)) /\n\t\t\t\t    (DC_SIZE + KEY_SIZE);\n\t\t\t\tset_parameters(tb, h, -n - 1, 0, 0, NULL, -1,\n\t\t\t\t\t       -1);\n\t\t\t\treturn CARRY_ON;\n\t\t\t}\n\n\t\t\t/* All contents of S[h] can be moved to R[h]. */\n\t\t\tif (tb->rnum[h] >= vn->vn_nr_item + 1) {\n\t\t\t\tint n;\n\t\t\t\tint order_R;\n\n\t\t\t\torder_R =\n\t\t\t\t    ((n =\n\t\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t\t  h)) ==\n\t\t\t\t     B_NR_ITEMS(Fh)) ? 0 : n + 1;\n\t\t\t\tn = dc_size(B_N_CHILD(tb->FR[h], order_R)) /\n\t\t\t\t    (DC_SIZE + KEY_SIZE);\n\t\t\t\tset_parameters(tb, h, 0, -n - 1, 0, NULL, -1,\n\t\t\t\t\t       -1);\n\t\t\t\treturn CARRY_ON;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * All contents of S[h] can be moved to the neighbors\n\t\t * (L[h] & R[h]).\n\t\t */\n\t\tif (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\t\tint to_r;\n\n\t\t\tto_r =\n\t\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] -\n\t\t\t     tb->rnum[h] + vn->vn_nr_item + 1) / 2 -\n\t\t\t    (MAX_NR_KEY(Sh) + 1 - tb->rnum[h]);\n\t\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r,\n\t\t\t\t       0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/* Balancing does not lead to better packing. */\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\t/*\n\t * Current node contain insufficient number of items.\n\t * Balancing is required.\n\t */\n\t/* Check whether we can merge S[h] with left neighbor. */\n\tif (tb->lnum[h] >= vn->vn_nr_item + 1)\n\t\tif (is_left_neighbor_in_cache(tb, h)\n\t\t    || tb->rnum[h] < vn->vn_nr_item + 1 || !tb->FR[h]) {\n\t\t\tint n;\n\t\t\tint order_L;\n\n\t\t\torder_L =\n\t\t\t    ((n =\n\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t  h)) ==\n\t\t\t     0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;\n\t\t\tn = dc_size(B_N_CHILD(tb->FL[h], order_L)) / (DC_SIZE +\n\t\t\t\t\t\t\t\t      KEY_SIZE);\n\t\t\tset_parameters(tb, h, -n - 1, 0, 0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t/* Check whether we can merge S[h] with right neighbor. */\n\tif (tb->rnum[h] >= vn->vn_nr_item + 1) {\n\t\tint n;\n\t\tint order_R;\n\n\t\torder_R =\n\t\t    ((n =\n\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t  h)) == B_NR_ITEMS(Fh)) ? 0 : (n + 1);\n\t\tn = dc_size(B_N_CHILD(tb->FR[h], order_R)) / (DC_SIZE +\n\t\t\t\t\t\t\t      KEY_SIZE);\n\t\tset_parameters(tb, h, 0, -n - 1, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/* All contents of S[h] can be moved to the neighbors (L[h] & R[h]). */\n\tif (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\tint to_r;\n\n\t\tto_r =\n\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] - tb->rnum[h] +\n\t\t     vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 -\n\t\t\t\t\t\ttb->rnum[h]);\n\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL,\n\t\t\t       -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/* For internal nodes try to borrow item from a neighbor */\n\tRFALSE(!tb->FL[h] && !tb->FR[h], \"vs-8235: trying to borrow for root\");\n\n\t/* Borrow one or two items from caching neighbor */\n\tif (is_left_neighbor_in_cache(tb, h) || !tb->FR[h]) {\n\t\tint from_l;\n\n\t\tfrom_l =\n\t\t    (MAX_NR_KEY(Sh) + 1 - tb->lnum[h] + vn->vn_nr_item +\n\t\t     1) / 2 - (vn->vn_nr_item + 1);\n\t\tset_parameters(tb, h, -from_l, 0, 1, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\tset_parameters(tb, h, 0,\n\t\t       -((MAX_NR_KEY(Sh) + 1 - tb->rnum[h] + vn->vn_nr_item +\n\t\t\t  1) / 2 - (vn->vn_nr_item + 1)), 1, NULL, -1, -1);\n\treturn CARRY_ON;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int dc_check_balance_internal(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\n\t/*\n\t * Sh is the node whose balance is currently being checked,\n\t * and Fh is its father.\n\t */\n\tstruct buffer_head *Sh, *Fh;\n\tint maxsize, ret;\n\tint lfree, rfree /* free space in L and R */ ;\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tFh = PATH_H_PPARENT(tb->tb_path, h);\n\n\tmaxsize = MAX_CHILD_SIZE(Sh);\n\n\t/*\n\t * using tb->insert_size[h], which is negative in this case,\n\t * create_virtual_node calculates:\n\t * new_nr_item = number of items node would have if operation is\n\t * performed without balancing (new_nr_item);\n\t */\n\tcreate_virtual_node(tb, h);\n\n\tif (!Fh) {\t\t/* S[h] is the root. */\n\t\t/* no balancing for higher levels needed */\n\t\tif (vn->vn_nr_item > 0) {\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\t\t}\n\t\t/*\n\t\t * new_nr_item == 0.\n\t\t * Current root will be deleted resulting in\n\t\t * decrementing the tree height.\n\t\t */\n\t\tset_parameters(tb, h, 0, 0, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\tif ((ret = get_parents(tb, h)) != CARRY_ON)\n\t\treturn ret;\n\n\t/* get free space of neighbors */\n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\t/* determine maximal number of items we can fit into neighbors */\n\tcheck_left(tb, h, lfree);\n\tcheck_right(tb, h, rfree);\n\n\t/*\n\t * Balance condition for the internal node is valid.\n\t * In this case we balance only if it leads to better packing.\n\t */\n\tif (vn->vn_nr_item >= MIN_NR_KEY(Sh)) {\n\t\t/*\n\t\t * Here we join S[h] with one of its neighbors,\n\t\t * which is impossible with greater values of new_nr_item.\n\t\t */\n\t\tif (vn->vn_nr_item == MIN_NR_KEY(Sh)) {\n\t\t\t/* All contents of S[h] can be moved to L[h]. */\n\t\t\tif (tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\t\t\tint n;\n\t\t\t\tint order_L;\n\n\t\t\t\torder_L =\n\t\t\t\t    ((n =\n\t\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t\t  h)) ==\n\t\t\t\t     0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;\n\t\t\t\tn = dc_size(B_N_CHILD(tb->FL[h], order_L)) /\n\t\t\t\t    (DC_SIZE + KEY_SIZE);\n\t\t\t\tset_parameters(tb, h, -n - 1, 0, 0, NULL, -1,\n\t\t\t\t\t       -1);\n\t\t\t\treturn CARRY_ON;\n\t\t\t}\n\n\t\t\t/* All contents of S[h] can be moved to R[h]. */\n\t\t\tif (tb->rnum[h] >= vn->vn_nr_item + 1) {\n\t\t\t\tint n;\n\t\t\t\tint order_R;\n\n\t\t\t\torder_R =\n\t\t\t\t    ((n =\n\t\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t\t  h)) ==\n\t\t\t\t     B_NR_ITEMS(Fh)) ? 0 : n + 1;\n\t\t\t\tn = dc_size(B_N_CHILD(tb->FR[h], order_R)) /\n\t\t\t\t    (DC_SIZE + KEY_SIZE);\n\t\t\t\tset_parameters(tb, h, 0, -n - 1, 0, NULL, -1,\n\t\t\t\t\t       -1);\n\t\t\t\treturn CARRY_ON;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * All contents of S[h] can be moved to the neighbors\n\t\t * (L[h] & R[h]).\n\t\t */\n\t\tif (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\t\tint to_r;\n\n\t\t\tto_r =\n\t\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] -\n\t\t\t     tb->rnum[h] + vn->vn_nr_item + 1) / 2 -\n\t\t\t    (MAX_NR_KEY(Sh) + 1 - tb->rnum[h]);\n\t\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r,\n\t\t\t\t       0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/* Balancing does not lead to better packing. */\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\t/*\n\t * Current node contain insufficient number of items.\n\t * Balancing is required.\n\t */\n\t/* Check whether we can merge S[h] with left neighbor. */\n\tif (tb->lnum[h] >= vn->vn_nr_item + 1)\n\t\tif (is_left_neighbor_in_cache(tb, h)\n\t\t    || tb->rnum[h] < vn->vn_nr_item + 1 || !tb->FR[h]) {\n\t\t\tint n;\n\t\t\tint order_L;\n\n\t\t\torder_L =\n\t\t\t    ((n =\n\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t  h)) ==\n\t\t\t     0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;\n\t\t\tn = dc_size(B_N_CHILD(tb->FL[h], order_L)) / (DC_SIZE +\n\t\t\t\t\t\t\t\t      KEY_SIZE);\n\t\t\tset_parameters(tb, h, -n - 1, 0, 0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t/* Check whether we can merge S[h] with right neighbor. */\n\tif (tb->rnum[h] >= vn->vn_nr_item + 1) {\n\t\tint n;\n\t\tint order_R;\n\n\t\torder_R =\n\t\t    ((n =\n\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t  h)) == B_NR_ITEMS(Fh)) ? 0 : (n + 1);\n\t\tn = dc_size(B_N_CHILD(tb->FR[h], order_R)) / (DC_SIZE +\n\t\t\t\t\t\t\t      KEY_SIZE);\n\t\tset_parameters(tb, h, 0, -n - 1, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/* All contents of S[h] can be moved to the neighbors (L[h] & R[h]). */\n\tif (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\tint to_r;\n\n\t\tto_r =\n\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] - tb->rnum[h] +\n\t\t     vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 -\n\t\t\t\t\t\ttb->rnum[h]);\n\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL,\n\t\t\t       -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/* For internal nodes try to borrow item from a neighbor */\n\tRFALSE(!tb->FL[h] && !tb->FR[h], \"vs-8235: trying to borrow for root\");\n\n\t/* Borrow one or two items from caching neighbor */\n\tif (is_left_neighbor_in_cache(tb, h) || !tb->FR[h]) {\n\t\tint from_l;\n\n\t\tfrom_l =\n\t\t    (MAX_NR_KEY(Sh) + 1 - tb->lnum[h] + vn->vn_nr_item +\n\t\t     1) / 2 - (vn->vn_nr_item + 1);\n\t\tset_parameters(tb, h, -from_l, 0, 1, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\tset_parameters(tb, h, 0,\n\t\t       -((MAX_NR_KEY(Sh) + 1 - tb->rnum[h] + vn->vn_nr_item +\n\t\t\t  1) / 2 - (vn->vn_nr_item + 1)), 1, NULL, -1, -1);\n\treturn CARRY_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!(PATH_H_PBUFFER(tb->tb_path, h))",
            "\"vs-8250: S is not initialized\""
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int dc_check_balance(struct tree_balance *tb, int h)\n{\n\tRFALSE(!(PATH_H_PBUFFER(tb->tb_path, h)),\n\t       \"vs-8250: S is not initialized\");\n\n\tif (h)\n\t\treturn dc_check_balance_internal(tb, h);\n\telse\n\t\treturn dc_check_balance_leaf(tb, h);\n}"
  },
  {
    "function_name": "dc_check_balance_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "1929-2019",
    "snippet": "static int dc_check_balance_leaf(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\n\t/*\n\t * Number of bytes that must be deleted from\n\t * (value is negative if bytes are deleted) buffer which\n\t * contains node being balanced.  The mnemonic is that the\n\t * attempted change in node space used level is levbytes bytes.\n\t */\n\tint levbytes;\n\n\t/* the maximal item size */\n\tint maxsize, ret;\n\n\t/*\n\t * S0 is the node whose balance is currently being checked,\n\t * and F0 is its father.\n\t */\n\tstruct buffer_head *S0, *F0;\n\tint lfree, rfree /* free space in L and R */ ;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\tF0 = PATH_H_PPARENT(tb->tb_path, 0);\n\n\tlevbytes = tb->insert_size[h];\n\n\tmaxsize = MAX_CHILD_SIZE(S0);\t/* maximal possible size of an item */\n\n\tif (!F0) {\t\t/* S[0] is the root now. */\n\n\t\tRFALSE(-levbytes >= maxsize - B_FREE_SPACE(S0),\n\t\t       \"vs-8240: attempt to create empty buffer tree\");\n\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\tif ((ret = get_parents(tb, h)) != CARRY_ON)\n\t\treturn ret;\n\n\t/* get free space of neighbors */\n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\tcreate_virtual_node(tb, h);\n\n\t/* if 3 leaves can be merge to one, set parameters and return */\n\tif (are_leaves_removable(tb, lfree, rfree))\n\t\treturn CARRY_ON;\n\n\t/*\n\t * determine maximal number of items we can shift to the left/right\n\t * neighbor and the maximal number of bytes that can flow to the\n\t * left/right neighbor from the left/right most liquid item that\n\t * cannot be shifted from S[0] entirely\n\t */\n\tcheck_left(tb, h, lfree);\n\tcheck_right(tb, h, rfree);\n\n\t/* check whether we can merge S with left neighbor. */\n\tif (tb->lnum[0] >= vn->vn_nr_item && tb->lbytes == -1)\n\t\tif (is_left_neighbor_in_cache(tb, h) || ((tb->rnum[0] - ((tb->rbytes == -1) ? 0 : 1)) < vn->vn_nr_item) ||\t/* S can not be merged with R */\n\t\t    !tb->FR[h]) {\n\n\t\t\tRFALSE(!tb->FL[h],\n\t\t\t       \"vs-8245: dc_check_balance_leaf: FL[h] must exist\");\n\n\t\t\t/* set parameter to merge S[0] with its left neighbor */\n\t\t\tset_parameters(tb, h, -1, 0, 0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t/* check whether we can merge S[0] with right neighbor. */\n\tif (tb->rnum[0] >= vn->vn_nr_item && tb->rbytes == -1) {\n\t\tset_parameters(tb, h, 0, -1, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/*\n\t * All contents of S[0] can be moved to the neighbors (L[0] & R[0]).\n\t * Set parameters and return\n\t */\n\tif (is_leaf_removable(tb))\n\t\treturn CARRY_ON;\n\n\t/* Balancing is not required. */\n\ttb->s0num = vn->vn_nr_item;\n\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\treturn NO_BALANCING_NEEDED;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_parameters",
          "args": [
            "tb",
            "h",
            "0",
            "0",
            "1",
            "NULL",
            "-1",
            "-1"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "set_parameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "623-648",
          "snippet": "static void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_leaf_removable",
          "args": [
            "tb"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "is_leaf_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "654-695",
          "snippet": "static int is_leaf_removable(struct tree_balance *tb)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint to_left, to_right;\n\tint size;\n\tint remain_items;\n\n\t/*\n\t * number of items that will be shifted to left (right) neighbor\n\t * entirely\n\t */\n\tto_left = tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0);\n\tto_right = tb->rnum[0] - ((tb->rbytes != -1) ? 1 : 0);\n\tremain_items = vn->vn_nr_item;\n\n\t/* how many items remain in S[0] after shiftings to neighbors */\n\tremain_items -= (to_left + to_right);\n\n\t/* all content of node can be shifted to neighbors */\n\tif (remain_items < 1) {\n\t\tset_parameters(tb, 0, to_left, vn->vn_nr_item - to_left, 0,\n\t\t\t       NULL, -1, -1);\n\t\treturn 1;\n\t}\n\n\t/* S[0] is not removable */\n\tif (remain_items > 1 || tb->lbytes == -1 || tb->rbytes == -1)\n\t\treturn 0;\n\n\t/* check whether we can divide 1 remaining item between neighbors */\n\n\t/* get size of remaining item (in item units) */\n\tsize = op_unit_num(&vn->vn_vi[to_left]);\n\n\tif (tb->lbytes + tb->rbytes >= size) {\n\t\tset_parameters(tb, 0, to_left + 1, to_right + 1, 0, NULL,\n\t\t\t       tb->lbytes, -1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int is_leaf_removable(struct tree_balance *tb)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint to_left, to_right;\n\tint size;\n\tint remain_items;\n\n\t/*\n\t * number of items that will be shifted to left (right) neighbor\n\t * entirely\n\t */\n\tto_left = tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0);\n\tto_right = tb->rnum[0] - ((tb->rbytes != -1) ? 1 : 0);\n\tremain_items = vn->vn_nr_item;\n\n\t/* how many items remain in S[0] after shiftings to neighbors */\n\tremain_items -= (to_left + to_right);\n\n\t/* all content of node can be shifted to neighbors */\n\tif (remain_items < 1) {\n\t\tset_parameters(tb, 0, to_left, vn->vn_nr_item - to_left, 0,\n\t\t\t       NULL, -1, -1);\n\t\treturn 1;\n\t}\n\n\t/* S[0] is not removable */\n\tif (remain_items > 1 || tb->lbytes == -1 || tb->rbytes == -1)\n\t\treturn 0;\n\n\t/* check whether we can divide 1 remaining item between neighbors */\n\n\t/* get size of remaining item (in item units) */\n\tsize = op_unit_num(&vn->vn_vi[to_left]);\n\n\tif (tb->lbytes + tb->rbytes >= size) {\n\t\tset_parameters(tb, 0, to_left + 1, to_right + 1, 0, NULL,\n\t\t\t       tb->lbytes, -1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!tb->FL[h]",
            "\"vs-8245: dc_check_balance_leaf: FL[h] must exist\""
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_left_neighbor_in_cache",
          "args": [
            "tb",
            "h"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "is_left_neighbor_in_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "961-1003",
          "snippet": "static int is_left_neighbor_in_cache(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *father, *left;\n\tstruct super_block *sb = tb->tb_sb;\n\tb_blocknr_t left_neighbor_blocknr;\n\tint left_neighbor_position;\n\n\t/* Father of the left neighbor does not exist. */\n\tif (!tb->FL[h])\n\t\treturn 0;\n\n\t/* Calculate father of the node to be balanced. */\n\tfather = PATH_H_PBUFFER(tb->tb_path, h + 1);\n\n\tRFALSE(!father ||\n\t       !B_IS_IN_TREE(father) ||\n\t       !B_IS_IN_TREE(tb->FL[h]) ||\n\t       !buffer_uptodate(father) ||\n\t       !buffer_uptodate(tb->FL[h]),\n\t       \"vs-8165: F[h] (%b) or FL[h] (%b) is invalid\",\n\t       father, tb->FL[h]);\n\n\t/*\n\t * Get position of the pointer to the left neighbor\n\t * into the left father.\n\t */\n\tleft_neighbor_position = (father == tb->FL[h]) ?\n\t    tb->lkey[h] : B_NR_ITEMS(tb->FL[h]);\n\t/* Get left neighbor block number. */\n\tleft_neighbor_blocknr =\n\t    B_N_CHILD_NUM(tb->FL[h], left_neighbor_position);\n\t/* Look for the left neighbor in the cache. */\n\tif ((left = sb_find_get_block(sb, left_neighbor_blocknr))) {\n\n\t\tRFALSE(buffer_uptodate(left) && !B_IS_IN_TREE(left),\n\t\t       \"vs-8170: left neighbor (%b %z) is not in the tree\",\n\t\t       left, left);\n\t\tput_bh(left);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int is_left_neighbor_in_cache(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *father, *left;\n\tstruct super_block *sb = tb->tb_sb;\n\tb_blocknr_t left_neighbor_blocknr;\n\tint left_neighbor_position;\n\n\t/* Father of the left neighbor does not exist. */\n\tif (!tb->FL[h])\n\t\treturn 0;\n\n\t/* Calculate father of the node to be balanced. */\n\tfather = PATH_H_PBUFFER(tb->tb_path, h + 1);\n\n\tRFALSE(!father ||\n\t       !B_IS_IN_TREE(father) ||\n\t       !B_IS_IN_TREE(tb->FL[h]) ||\n\t       !buffer_uptodate(father) ||\n\t       !buffer_uptodate(tb->FL[h]),\n\t       \"vs-8165: F[h] (%b) or FL[h] (%b) is invalid\",\n\t       father, tb->FL[h]);\n\n\t/*\n\t * Get position of the pointer to the left neighbor\n\t * into the left father.\n\t */\n\tleft_neighbor_position = (father == tb->FL[h]) ?\n\t    tb->lkey[h] : B_NR_ITEMS(tb->FL[h]);\n\t/* Get left neighbor block number. */\n\tleft_neighbor_blocknr =\n\t    B_N_CHILD_NUM(tb->FL[h], left_neighbor_position);\n\t/* Look for the left neighbor in the cache. */\n\tif ((left = sb_find_get_block(sb, left_neighbor_blocknr))) {\n\n\t\tRFALSE(buffer_uptodate(left) && !B_IS_IN_TREE(left),\n\t\t       \"vs-8170: left neighbor (%b %z) is not in the tree\",\n\t\t       left, left);\n\t\tput_bh(left);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_right",
          "args": [
            "tb",
            "h",
            "rfree"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "check_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "280-364",
          "snippet": "static void check_right(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8070: cur_free < 0\");\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->rnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space  */\n\t\ttb->rnum[h] = 0;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8075: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi + vn->vn_nr_item - 1;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_RIGHT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into R[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8080: invalid mode or balance condition failed\");\n\n\t\ttb->rnum[h] = vn->vn_nr_item;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* last item may be merge with first item in right neighbor */\n\tif (vi->vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\td_size = -(int)IH_SIZE, ih_size = 0;\n\n\ttb->rnum[0] = 0;\n\tfor (i = vn->vn_nr_item - 1; i >= 0;\n\t     i--, d_size = 0, ih_size = IH_SIZE, vi--) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->rnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * check whether R[0] can hold ih and at least one\n\t\t * byte of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->rbytes = -1;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * R[0] can hold the header of the item and at least\n\t\t * one byte of its body\n\t\t */\n\t\tcur_free -= ih_size;\t/* cur_free is still > 0 */\n\n\t\ttb->rbytes = op_check_right(vi, cur_free);\n\t\tif (tb->rbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->rnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void check_right(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8070: cur_free < 0\");\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->rnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space  */\n\t\ttb->rnum[h] = 0;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8075: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi + vn->vn_nr_item - 1;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_RIGHT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into R[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8080: invalid mode or balance condition failed\");\n\n\t\ttb->rnum[h] = vn->vn_nr_item;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* last item may be merge with first item in right neighbor */\n\tif (vi->vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\td_size = -(int)IH_SIZE, ih_size = 0;\n\n\ttb->rnum[0] = 0;\n\tfor (i = vn->vn_nr_item - 1; i >= 0;\n\t     i--, d_size = 0, ih_size = IH_SIZE, vi--) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->rnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * check whether R[0] can hold ih and at least one\n\t\t * byte of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->rbytes = -1;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * R[0] can hold the header of the item and at least\n\t\t * one byte of its body\n\t\t */\n\t\tcur_free -= ih_size;\t/* cur_free is still > 0 */\n\n\t\ttb->rbytes = op_check_right(vi, cur_free);\n\t\tif (tb->rbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->rnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_left",
          "args": [
            "tb",
            "h",
            "lfree"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "check_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "194-274",
          "snippet": "static void check_left(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8050: cur_free (%d) < 0\", cur_free);\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->lnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space or nothing to move */\n\t\ttb->lnum[h] = 0;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8055: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_LEFT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into L[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8055: invalid mode or balance condition failed\");\n\n\t\ttb->lnum[0] = vn->vn_nr_item;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* first item may be merge with last item in left neighbor */\n\tif (vi->vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\td_size = -((int)IH_SIZE), ih_size = 0;\n\n\ttb->lnum[0] = 0;\n\tfor (i = 0; i < vn->vn_nr_item;\n\t     i++, ih_size = IH_SIZE, d_size = 0, vi++) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->lnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* the item cannot be shifted entirely, try to split it */\n\t\t/*\n\t\t * check whether L[0] can hold ih and at least one byte\n\t\t * of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->lbytes = -1;\n\t\t\treturn;\n\t\t}\n\t\tcur_free -= ih_size;\n\n\t\ttb->lbytes = op_check_left(vi, cur_free, 0, 0);\n\t\tif (tb->lbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->lnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void check_left(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8050: cur_free (%d) < 0\", cur_free);\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->lnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space or nothing to move */\n\t\ttb->lnum[h] = 0;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8055: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_LEFT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into L[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8055: invalid mode or balance condition failed\");\n\n\t\ttb->lnum[0] = vn->vn_nr_item;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* first item may be merge with last item in left neighbor */\n\tif (vi->vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\td_size = -((int)IH_SIZE), ih_size = 0;\n\n\ttb->lnum[0] = 0;\n\tfor (i = 0; i < vn->vn_nr_item;\n\t     i++, ih_size = IH_SIZE, d_size = 0, vi++) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->lnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* the item cannot be shifted entirely, try to split it */\n\t\t/*\n\t\t * check whether L[0] can hold ih and at least one byte\n\t\t * of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->lbytes = -1;\n\t\t\treturn;\n\t\t}\n\t\tcur_free -= ih_size;\n\n\t\ttb->lbytes = op_check_left(vi, cur_free, 0, 0);\n\t\tif (tb->lbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->lnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "are_leaves_removable",
          "args": [
            "tb",
            "lfree",
            "rfree"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_virtual_node",
          "args": [
            "tb",
            "h"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "create_virtual_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "51-188",
          "snippet": "static void create_virtual_node(struct tree_balance *tb, int h)\n{\n\tstruct item_head *ih;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint new_num;\n\tstruct buffer_head *Sh;\t/* this comes from tb->S[h] */\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\n\t/* size of changed node */\n\tvn->vn_size =\n\t    MAX_CHILD_SIZE(Sh) - B_FREE_SPACE(Sh) + tb->insert_size[h];\n\n\t/* for internal nodes array if virtual items is not created */\n\tif (h) {\n\t\tvn->vn_nr_item = (vn->vn_size - DC_SIZE) / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* number of items in virtual node  */\n\tvn->vn_nr_item =\n\t    B_NR_ITEMS(Sh) + ((vn->vn_mode == M_INSERT) ? 1 : 0) -\n\t    ((vn->vn_mode == M_DELETE) ? 1 : 0);\n\n\t/* first virtual item */\n\tvn->vn_vi = (struct virtual_item *)(tb->tb_vn + 1);\n\tmemset(vn->vn_vi, 0, vn->vn_nr_item * sizeof(struct virtual_item));\n\tvn->vn_free_ptr += vn->vn_nr_item * sizeof(struct virtual_item);\n\n\t/* first item in the node */\n\tih = item_head(Sh, 0);\n\n\t/* define the mergeability for 0-th item (if it is not being deleted) */\n\tif (op_is_left_mergeable(&ih->ih_key, Sh->b_size)\n\t    && (vn->vn_mode != M_DELETE || vn->vn_affected_item_num))\n\t\tvn->vn_vi[0].vi_type |= VI_TYPE_LEFT_MERGEABLE;\n\n\t/*\n\t * go through all items that remain in the virtual\n\t * node (except for the new (inserted) one)\n\t */\n\tfor (new_num = 0; new_num < vn->vn_nr_item; new_num++) {\n\t\tint j;\n\t\tstruct virtual_item *vi = vn->vn_vi + new_num;\n\t\tint is_affected =\n\t\t    ((new_num != vn->vn_affected_item_num) ? 0 : 1);\n\n\t\tif (is_affected && vn->vn_mode == M_INSERT)\n\t\t\tcontinue;\n\n\t\t/* get item number in source node */\n\t\tj = old_item_num(new_num, vn->vn_affected_item_num,\n\t\t\t\t vn->vn_mode);\n\n\t\tvi->vi_item_len += ih_item_len(ih + j) + IH_SIZE;\n\t\tvi->vi_ih = ih + j;\n\t\tvi->vi_item = ih_item_body(Sh, ih + j);\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\t/*\n\t\t * FIXME: there is no check that item operation did not\n\t\t * consume too much memory\n\t\t */\n\t\tvn->vn_free_ptr +=\n\t\t    op_create_vi(vn, vi, is_affected, tb->insert_size[0]);\n\t\tif (tb->vn_buf + tb->vn_buf_size < vn->vn_free_ptr)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8030\",\n\t\t\t\t       \"virtual node space consumed\");\n\n\t\tif (!is_affected)\n\t\t\t/* this is not being changed */\n\t\t\tcontinue;\n\n\t\tif (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT) {\n\t\t\tvn->vn_vi[new_num].vi_item_len += tb->insert_size[0];\n\t\t\t/* pointer to data which is going to be pasted */\n\t\t\tvi->vi_new_data = vn->vn_data;\n\t\t}\n\t}\n\n\t/* virtual inserted item is not defined yet */\n\tif (vn->vn_mode == M_INSERT) {\n\t\tstruct virtual_item *vi = vn->vn_vi + vn->vn_affected_item_num;\n\n\t\tRFALSE(vn->vn_ins_ih == NULL,\n\t\t       \"vs-8040: item header of inserted item is not specified\");\n\t\tvi->vi_item_len = tb->insert_size[0];\n\t\tvi->vi_ih = vn->vn_ins_ih;\n\t\tvi->vi_item = vn->vn_data;\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\top_create_vi(vn, vi, 0 /*not pasted or cut */ ,\n\t\t\t     tb->insert_size[0]);\n\t}\n\n\t/*\n\t * set right merge flag we take right delimiting key and\n\t * check whether it is a mergeable item\n\t */\n\tif (tb->CFR[0]) {\n\t\tstruct reiserfs_key *key;\n\n\t\tkey = internal_key(tb->CFR[0], tb->rkey[0]);\n\t\tif (op_is_left_mergeable(key, Sh->b_size)\n\t\t    && (vn->vn_mode != M_DELETE\n\t\t\t|| vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1))\n\t\t\tvn->vn_vi[vn->vn_nr_item - 1].vi_type |=\n\t\t\t    VI_TYPE_RIGHT_MERGEABLE;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (op_is_left_mergeable(key, Sh->b_size) &&\n\t\t    !(vn->vn_mode != M_DELETE\n\t\t      || vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1)) {\n\t\t\t/*\n\t\t\t * we delete last item and it could be merged\n\t\t\t * with right neighbor's first item\n\t\t\t */\n\t\t\tif (!\n\t\t\t    (B_NR_ITEMS(Sh) == 1\n\t\t\t     && is_direntry_le_ih(item_head(Sh, 0))\n\t\t\t     && ih_entry_count(item_head(Sh, 0)) == 1)) {\n\t\t\t\t/*\n\t\t\t\t * node contains more than 1 item, or item\n\t\t\t\t * is not directory item, or this item\n\t\t\t\t * contains more than 1 entry\n\t\t\t\t */\n\t\t\t\tprint_block(Sh, 0, -1, -1);\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-8045\",\n\t\t\t\t\t       \"rdkey %k, affected item==%d \"\n\t\t\t\t\t       \"(mode==%c) Must be %c\",\n\t\t\t\t\t       key, vn->vn_affected_item_num,\n\t\t\t\t\t       vn->vn_mode, M_DELETE);\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void create_virtual_node(struct tree_balance *tb, int h)\n{\n\tstruct item_head *ih;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint new_num;\n\tstruct buffer_head *Sh;\t/* this comes from tb->S[h] */\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\n\t/* size of changed node */\n\tvn->vn_size =\n\t    MAX_CHILD_SIZE(Sh) - B_FREE_SPACE(Sh) + tb->insert_size[h];\n\n\t/* for internal nodes array if virtual items is not created */\n\tif (h) {\n\t\tvn->vn_nr_item = (vn->vn_size - DC_SIZE) / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* number of items in virtual node  */\n\tvn->vn_nr_item =\n\t    B_NR_ITEMS(Sh) + ((vn->vn_mode == M_INSERT) ? 1 : 0) -\n\t    ((vn->vn_mode == M_DELETE) ? 1 : 0);\n\n\t/* first virtual item */\n\tvn->vn_vi = (struct virtual_item *)(tb->tb_vn + 1);\n\tmemset(vn->vn_vi, 0, vn->vn_nr_item * sizeof(struct virtual_item));\n\tvn->vn_free_ptr += vn->vn_nr_item * sizeof(struct virtual_item);\n\n\t/* first item in the node */\n\tih = item_head(Sh, 0);\n\n\t/* define the mergeability for 0-th item (if it is not being deleted) */\n\tif (op_is_left_mergeable(&ih->ih_key, Sh->b_size)\n\t    && (vn->vn_mode != M_DELETE || vn->vn_affected_item_num))\n\t\tvn->vn_vi[0].vi_type |= VI_TYPE_LEFT_MERGEABLE;\n\n\t/*\n\t * go through all items that remain in the virtual\n\t * node (except for the new (inserted) one)\n\t */\n\tfor (new_num = 0; new_num < vn->vn_nr_item; new_num++) {\n\t\tint j;\n\t\tstruct virtual_item *vi = vn->vn_vi + new_num;\n\t\tint is_affected =\n\t\t    ((new_num != vn->vn_affected_item_num) ? 0 : 1);\n\n\t\tif (is_affected && vn->vn_mode == M_INSERT)\n\t\t\tcontinue;\n\n\t\t/* get item number in source node */\n\t\tj = old_item_num(new_num, vn->vn_affected_item_num,\n\t\t\t\t vn->vn_mode);\n\n\t\tvi->vi_item_len += ih_item_len(ih + j) + IH_SIZE;\n\t\tvi->vi_ih = ih + j;\n\t\tvi->vi_item = ih_item_body(Sh, ih + j);\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\t/*\n\t\t * FIXME: there is no check that item operation did not\n\t\t * consume too much memory\n\t\t */\n\t\tvn->vn_free_ptr +=\n\t\t    op_create_vi(vn, vi, is_affected, tb->insert_size[0]);\n\t\tif (tb->vn_buf + tb->vn_buf_size < vn->vn_free_ptr)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8030\",\n\t\t\t\t       \"virtual node space consumed\");\n\n\t\tif (!is_affected)\n\t\t\t/* this is not being changed */\n\t\t\tcontinue;\n\n\t\tif (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT) {\n\t\t\tvn->vn_vi[new_num].vi_item_len += tb->insert_size[0];\n\t\t\t/* pointer to data which is going to be pasted */\n\t\t\tvi->vi_new_data = vn->vn_data;\n\t\t}\n\t}\n\n\t/* virtual inserted item is not defined yet */\n\tif (vn->vn_mode == M_INSERT) {\n\t\tstruct virtual_item *vi = vn->vn_vi + vn->vn_affected_item_num;\n\n\t\tRFALSE(vn->vn_ins_ih == NULL,\n\t\t       \"vs-8040: item header of inserted item is not specified\");\n\t\tvi->vi_item_len = tb->insert_size[0];\n\t\tvi->vi_ih = vn->vn_ins_ih;\n\t\tvi->vi_item = vn->vn_data;\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\top_create_vi(vn, vi, 0 /*not pasted or cut */ ,\n\t\t\t     tb->insert_size[0]);\n\t}\n\n\t/*\n\t * set right merge flag we take right delimiting key and\n\t * check whether it is a mergeable item\n\t */\n\tif (tb->CFR[0]) {\n\t\tstruct reiserfs_key *key;\n\n\t\tkey = internal_key(tb->CFR[0], tb->rkey[0]);\n\t\tif (op_is_left_mergeable(key, Sh->b_size)\n\t\t    && (vn->vn_mode != M_DELETE\n\t\t\t|| vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1))\n\t\t\tvn->vn_vi[vn->vn_nr_item - 1].vi_type |=\n\t\t\t    VI_TYPE_RIGHT_MERGEABLE;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (op_is_left_mergeable(key, Sh->b_size) &&\n\t\t    !(vn->vn_mode != M_DELETE\n\t\t      || vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1)) {\n\t\t\t/*\n\t\t\t * we delete last item and it could be merged\n\t\t\t * with right neighbor's first item\n\t\t\t */\n\t\t\tif (!\n\t\t\t    (B_NR_ITEMS(Sh) == 1\n\t\t\t     && is_direntry_le_ih(item_head(Sh, 0))\n\t\t\t     && ih_entry_count(item_head(Sh, 0)) == 1)) {\n\t\t\t\t/*\n\t\t\t\t * node contains more than 1 item, or item\n\t\t\t\t * is not directory item, or this item\n\t\t\t\t * contains more than 1 entry\n\t\t\t\t */\n\t\t\t\tprint_block(Sh, 0, -1, -1);\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-8045\",\n\t\t\t\t\t       \"rdkey %k, affected item==%d \"\n\t\t\t\t\t       \"(mode==%c) Must be %c\",\n\t\t\t\t\t       key, vn->vn_affected_item_num,\n\t\t\t\t\t       vn->vn_mode, M_DELETE);\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lfree",
          "args": [
            "tb",
            "h"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "get_lfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "917-934",
          "snippet": "static int get_lfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *l, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (l = tb->FL[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == l)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) - 1;\n\telse {\n\t\torder = B_NR_ITEMS(l);\n\t\tf = l;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_lfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *l, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (l = tb->FL[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == l)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) - 1;\n\telse {\n\t\torder = B_NR_ITEMS(l);\n\t\tf = l;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfree",
          "args": [
            "tb",
            "h"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "940-958",
          "snippet": "static int get_rfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *r, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (r = tb->FR[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == r)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) + 1;\n\telse {\n\t\torder = 0;\n\t\tf = r;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_rfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *r, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (r = tb->FR[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == r)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) + 1;\n\telse {\n\t\torder = 0;\n\t\tf = r;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_parents",
          "args": [
            "tb",
            "h"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "get_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "1174-1269",
          "snippet": "static int get_parents(struct tree_balance *tb, int h)\n{\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    ret,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\tstruct buffer_head *curf, *curcf;\n\n\t/* Current node is the root of the tree or will be root of the tree */\n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\t\t/*\n\t\t * The root can not have parents.\n\t\t * Release nodes which previously were obtained as\n\t\t * parents of the current node neighbors.\n\t\t */\n\t\tbrelse(tb->FL[h]);\n\t\tbrelse(tb->CFL[h]);\n\t\tbrelse(tb->FR[h]);\n\t\tbrelse(tb->CFR[h]);\n\t\ttb->FL[h]  = NULL;\n\t\ttb->CFL[h] = NULL;\n\t\ttb->FR[h]  = NULL;\n\t\ttb->CFR[h] = NULL;\n\t\treturn CARRY_ON;\n\t}\n\n\t/* Get parent FL[path_offset] of L[path_offset]. */\n\tposition = PATH_OFFSET_POSITION(path, path_offset - 1);\n\tif (position) {\n\t\t/* Current node is not the first child of its parent. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->lkey[h] = position - 1;\n\t} else {\n\t\t/*\n\t\t * Calculate current parent of L[path_offset], which is the\n\t\t * left neighbor of the current node.  Calculate current\n\t\t * common parent of L[path_offset] and the current node.\n\t\t * Note that CFL[path_offset] not equal FL[path_offset] and\n\t\t * CFL[path_offset] not equal F[path_offset].\n\t\t * Calculate lkey[path_offset].\n\t\t */\n\t\tif ((ret = get_far_parent(tb, h + 1, &curf,\n\t\t\t\t\t\t  &curcf,\n\t\t\t\t\t\t  LEFT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t}\n\n\tbrelse(tb->FL[h]);\n\ttb->FL[h] = curf;\t/* New initialization of FL[h]. */\n\tbrelse(tb->CFL[h]);\n\ttb->CFL[h] = curcf;\t/* New initialization of CFL[h]. */\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8195: FL (%b) or CFL (%b) is invalid\", curf, curcf);\n\n\t/* Get parent FR[h] of R[h]. */\n\n\t/* Current node is the last child of F[h]. FR[h] != F[h]. */\n\tif (position == B_NR_ITEMS(PATH_H_PBUFFER(path, h + 1))) {\n\t\t/*\n\t\t * Calculate current parent of R[h], which is the right\n\t\t * neighbor of F[h].  Calculate current common parent of\n\t\t * R[h] and current node. Note that CFR[h] not equal\n\t\t * FR[path_offset] and CFR[h] not equal F[h].\n\t\t */\n\t\tif ((ret =\n\t\t     get_far_parent(tb, h + 1, &curf, &curcf,\n\t\t\t\t    RIGHT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t} else {\n\t\t/* Current node is not the last child of its parent F[h]. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->rkey[h] = position;\n\t}\n\n\tbrelse(tb->FR[h]);\n\t/* New initialization of FR[path_offset]. */\n\ttb->FR[h] = curf;\n\n\tbrelse(tb->CFR[h]);\n\t/* New initialization of CFR[path_offset]. */\n\ttb->CFR[h] = curcf;\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8205: FR (%b) or CFR (%b) is invalid\", curf, curcf);\n\n\treturn CARRY_ON;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define RIGHT_PARENTS 'r'",
            "#define LEFT_PARENTS  'l'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#define RIGHT_PARENTS 'r'\n#define LEFT_PARENTS  'l'\n\nstatic int get_parents(struct tree_balance *tb, int h)\n{\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    ret,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\tstruct buffer_head *curf, *curcf;\n\n\t/* Current node is the root of the tree or will be root of the tree */\n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\t\t/*\n\t\t * The root can not have parents.\n\t\t * Release nodes which previously were obtained as\n\t\t * parents of the current node neighbors.\n\t\t */\n\t\tbrelse(tb->FL[h]);\n\t\tbrelse(tb->CFL[h]);\n\t\tbrelse(tb->FR[h]);\n\t\tbrelse(tb->CFR[h]);\n\t\ttb->FL[h]  = NULL;\n\t\ttb->CFL[h] = NULL;\n\t\ttb->FR[h]  = NULL;\n\t\ttb->CFR[h] = NULL;\n\t\treturn CARRY_ON;\n\t}\n\n\t/* Get parent FL[path_offset] of L[path_offset]. */\n\tposition = PATH_OFFSET_POSITION(path, path_offset - 1);\n\tif (position) {\n\t\t/* Current node is not the first child of its parent. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->lkey[h] = position - 1;\n\t} else {\n\t\t/*\n\t\t * Calculate current parent of L[path_offset], which is the\n\t\t * left neighbor of the current node.  Calculate current\n\t\t * common parent of L[path_offset] and the current node.\n\t\t * Note that CFL[path_offset] not equal FL[path_offset] and\n\t\t * CFL[path_offset] not equal F[path_offset].\n\t\t * Calculate lkey[path_offset].\n\t\t */\n\t\tif ((ret = get_far_parent(tb, h + 1, &curf,\n\t\t\t\t\t\t  &curcf,\n\t\t\t\t\t\t  LEFT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t}\n\n\tbrelse(tb->FL[h]);\n\ttb->FL[h] = curf;\t/* New initialization of FL[h]. */\n\tbrelse(tb->CFL[h]);\n\ttb->CFL[h] = curcf;\t/* New initialization of CFL[h]. */\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8195: FL (%b) or CFL (%b) is invalid\", curf, curcf);\n\n\t/* Get parent FR[h] of R[h]. */\n\n\t/* Current node is the last child of F[h]. FR[h] != F[h]. */\n\tif (position == B_NR_ITEMS(PATH_H_PBUFFER(path, h + 1))) {\n\t\t/*\n\t\t * Calculate current parent of R[h], which is the right\n\t\t * neighbor of F[h].  Calculate current common parent of\n\t\t * R[h] and current node. Note that CFR[h] not equal\n\t\t * FR[path_offset] and CFR[h] not equal F[h].\n\t\t */\n\t\tif ((ret =\n\t\t     get_far_parent(tb, h + 1, &curf, &curcf,\n\t\t\t\t    RIGHT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t} else {\n\t\t/* Current node is not the last child of its parent F[h]. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->rkey[h] = position;\n\t}\n\n\tbrelse(tb->FR[h]);\n\t/* New initialization of FR[path_offset]. */\n\ttb->FR[h] = curf;\n\n\tbrelse(tb->CFR[h]);\n\t/* New initialization of CFR[path_offset]. */\n\ttb->CFR[h] = curcf;\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8205: FR (%b) or CFR (%b) is invalid\", curf, curcf);\n\n\treturn CARRY_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "-levbytes >= maxsize - B_FREE_SPACE(S0)",
            "\"vs-8240: attempt to create empty buffer tree\""
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "S0"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "S0"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int dc_check_balance_leaf(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\n\t/*\n\t * Number of bytes that must be deleted from\n\t * (value is negative if bytes are deleted) buffer which\n\t * contains node being balanced.  The mnemonic is that the\n\t * attempted change in node space used level is levbytes bytes.\n\t */\n\tint levbytes;\n\n\t/* the maximal item size */\n\tint maxsize, ret;\n\n\t/*\n\t * S0 is the node whose balance is currently being checked,\n\t * and F0 is its father.\n\t */\n\tstruct buffer_head *S0, *F0;\n\tint lfree, rfree /* free space in L and R */ ;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\tF0 = PATH_H_PPARENT(tb->tb_path, 0);\n\n\tlevbytes = tb->insert_size[h];\n\n\tmaxsize = MAX_CHILD_SIZE(S0);\t/* maximal possible size of an item */\n\n\tif (!F0) {\t\t/* S[0] is the root now. */\n\n\t\tRFALSE(-levbytes >= maxsize - B_FREE_SPACE(S0),\n\t\t       \"vs-8240: attempt to create empty buffer tree\");\n\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\tif ((ret = get_parents(tb, h)) != CARRY_ON)\n\t\treturn ret;\n\n\t/* get free space of neighbors */\n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\tcreate_virtual_node(tb, h);\n\n\t/* if 3 leaves can be merge to one, set parameters and return */\n\tif (are_leaves_removable(tb, lfree, rfree))\n\t\treturn CARRY_ON;\n\n\t/*\n\t * determine maximal number of items we can shift to the left/right\n\t * neighbor and the maximal number of bytes that can flow to the\n\t * left/right neighbor from the left/right most liquid item that\n\t * cannot be shifted from S[0] entirely\n\t */\n\tcheck_left(tb, h, lfree);\n\tcheck_right(tb, h, rfree);\n\n\t/* check whether we can merge S with left neighbor. */\n\tif (tb->lnum[0] >= vn->vn_nr_item && tb->lbytes == -1)\n\t\tif (is_left_neighbor_in_cache(tb, h) || ((tb->rnum[0] - ((tb->rbytes == -1) ? 0 : 1)) < vn->vn_nr_item) ||\t/* S can not be merged with R */\n\t\t    !tb->FR[h]) {\n\n\t\t\tRFALSE(!tb->FL[h],\n\t\t\t       \"vs-8245: dc_check_balance_leaf: FL[h] must exist\");\n\n\t\t\t/* set parameter to merge S[0] with its left neighbor */\n\t\t\tset_parameters(tb, h, -1, 0, 0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t/* check whether we can merge S[0] with right neighbor. */\n\tif (tb->rnum[0] >= vn->vn_nr_item && tb->rbytes == -1) {\n\t\tset_parameters(tb, h, 0, -1, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/*\n\t * All contents of S[0] can be moved to the neighbors (L[0] & R[0]).\n\t * Set parameters and return\n\t */\n\tif (is_leaf_removable(tb))\n\t\treturn CARRY_ON;\n\n\t/* Balancing is not required. */\n\ttb->s0num = vn->vn_nr_item;\n\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\treturn NO_BALANCING_NEEDED;\n}"
  },
  {
    "function_name": "dc_check_balance_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "1728-1913",
    "snippet": "static int dc_check_balance_internal(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\n\t/*\n\t * Sh is the node whose balance is currently being checked,\n\t * and Fh is its father.\n\t */\n\tstruct buffer_head *Sh, *Fh;\n\tint maxsize, ret;\n\tint lfree, rfree /* free space in L and R */ ;\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tFh = PATH_H_PPARENT(tb->tb_path, h);\n\n\tmaxsize = MAX_CHILD_SIZE(Sh);\n\n\t/*\n\t * using tb->insert_size[h], which is negative in this case,\n\t * create_virtual_node calculates:\n\t * new_nr_item = number of items node would have if operation is\n\t * performed without balancing (new_nr_item);\n\t */\n\tcreate_virtual_node(tb, h);\n\n\tif (!Fh) {\t\t/* S[h] is the root. */\n\t\t/* no balancing for higher levels needed */\n\t\tif (vn->vn_nr_item > 0) {\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\t\t}\n\t\t/*\n\t\t * new_nr_item == 0.\n\t\t * Current root will be deleted resulting in\n\t\t * decrementing the tree height.\n\t\t */\n\t\tset_parameters(tb, h, 0, 0, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\tif ((ret = get_parents(tb, h)) != CARRY_ON)\n\t\treturn ret;\n\n\t/* get free space of neighbors */\n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\t/* determine maximal number of items we can fit into neighbors */\n\tcheck_left(tb, h, lfree);\n\tcheck_right(tb, h, rfree);\n\n\t/*\n\t * Balance condition for the internal node is valid.\n\t * In this case we balance only if it leads to better packing.\n\t */\n\tif (vn->vn_nr_item >= MIN_NR_KEY(Sh)) {\n\t\t/*\n\t\t * Here we join S[h] with one of its neighbors,\n\t\t * which is impossible with greater values of new_nr_item.\n\t\t */\n\t\tif (vn->vn_nr_item == MIN_NR_KEY(Sh)) {\n\t\t\t/* All contents of S[h] can be moved to L[h]. */\n\t\t\tif (tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\t\t\tint n;\n\t\t\t\tint order_L;\n\n\t\t\t\torder_L =\n\t\t\t\t    ((n =\n\t\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t\t  h)) ==\n\t\t\t\t     0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;\n\t\t\t\tn = dc_size(B_N_CHILD(tb->FL[h], order_L)) /\n\t\t\t\t    (DC_SIZE + KEY_SIZE);\n\t\t\t\tset_parameters(tb, h, -n - 1, 0, 0, NULL, -1,\n\t\t\t\t\t       -1);\n\t\t\t\treturn CARRY_ON;\n\t\t\t}\n\n\t\t\t/* All contents of S[h] can be moved to R[h]. */\n\t\t\tif (tb->rnum[h] >= vn->vn_nr_item + 1) {\n\t\t\t\tint n;\n\t\t\t\tint order_R;\n\n\t\t\t\torder_R =\n\t\t\t\t    ((n =\n\t\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t\t  h)) ==\n\t\t\t\t     B_NR_ITEMS(Fh)) ? 0 : n + 1;\n\t\t\t\tn = dc_size(B_N_CHILD(tb->FR[h], order_R)) /\n\t\t\t\t    (DC_SIZE + KEY_SIZE);\n\t\t\t\tset_parameters(tb, h, 0, -n - 1, 0, NULL, -1,\n\t\t\t\t\t       -1);\n\t\t\t\treturn CARRY_ON;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * All contents of S[h] can be moved to the neighbors\n\t\t * (L[h] & R[h]).\n\t\t */\n\t\tif (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\t\tint to_r;\n\n\t\t\tto_r =\n\t\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] -\n\t\t\t     tb->rnum[h] + vn->vn_nr_item + 1) / 2 -\n\t\t\t    (MAX_NR_KEY(Sh) + 1 - tb->rnum[h]);\n\t\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r,\n\t\t\t\t       0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/* Balancing does not lead to better packing. */\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\t/*\n\t * Current node contain insufficient number of items.\n\t * Balancing is required.\n\t */\n\t/* Check whether we can merge S[h] with left neighbor. */\n\tif (tb->lnum[h] >= vn->vn_nr_item + 1)\n\t\tif (is_left_neighbor_in_cache(tb, h)\n\t\t    || tb->rnum[h] < vn->vn_nr_item + 1 || !tb->FR[h]) {\n\t\t\tint n;\n\t\t\tint order_L;\n\n\t\t\torder_L =\n\t\t\t    ((n =\n\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t  h)) ==\n\t\t\t     0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;\n\t\t\tn = dc_size(B_N_CHILD(tb->FL[h], order_L)) / (DC_SIZE +\n\t\t\t\t\t\t\t\t      KEY_SIZE);\n\t\t\tset_parameters(tb, h, -n - 1, 0, 0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t/* Check whether we can merge S[h] with right neighbor. */\n\tif (tb->rnum[h] >= vn->vn_nr_item + 1) {\n\t\tint n;\n\t\tint order_R;\n\n\t\torder_R =\n\t\t    ((n =\n\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t  h)) == B_NR_ITEMS(Fh)) ? 0 : (n + 1);\n\t\tn = dc_size(B_N_CHILD(tb->FR[h], order_R)) / (DC_SIZE +\n\t\t\t\t\t\t\t      KEY_SIZE);\n\t\tset_parameters(tb, h, 0, -n - 1, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/* All contents of S[h] can be moved to the neighbors (L[h] & R[h]). */\n\tif (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\tint to_r;\n\n\t\tto_r =\n\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] - tb->rnum[h] +\n\t\t     vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 -\n\t\t\t\t\t\ttb->rnum[h]);\n\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL,\n\t\t\t       -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/* For internal nodes try to borrow item from a neighbor */\n\tRFALSE(!tb->FL[h] && !tb->FR[h], \"vs-8235: trying to borrow for root\");\n\n\t/* Borrow one or two items from caching neighbor */\n\tif (is_left_neighbor_in_cache(tb, h) || !tb->FR[h]) {\n\t\tint from_l;\n\n\t\tfrom_l =\n\t\t    (MAX_NR_KEY(Sh) + 1 - tb->lnum[h] + vn->vn_nr_item +\n\t\t     1) / 2 - (vn->vn_nr_item + 1);\n\t\tset_parameters(tb, h, -from_l, 0, 1, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\tset_parameters(tb, h, 0,\n\t\t       -((MAX_NR_KEY(Sh) + 1 - tb->rnum[h] + vn->vn_nr_item +\n\t\t\t  1) / 2 - (vn->vn_nr_item + 1)), 1, NULL, -1, -1);\n\treturn CARRY_ON;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_parameters",
          "args": [
            "tb",
            "h",
            "0",
            "-((MAX_NR_KEY(Sh) + 1 - tb->rnum[h] + vn->vn_nr_item +\n\t\t\t  1) / 2 - (vn->vn_nr_item + 1))",
            "1",
            "NULL",
            "-1",
            "-1"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "set_parameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "623-648",
          "snippet": "static void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_NR_KEY",
          "args": [
            "Sh"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_NR_KEY",
          "args": [
            "Sh"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_left_neighbor_in_cache",
          "args": [
            "tb",
            "h"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "is_left_neighbor_in_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "961-1003",
          "snippet": "static int is_left_neighbor_in_cache(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *father, *left;\n\tstruct super_block *sb = tb->tb_sb;\n\tb_blocknr_t left_neighbor_blocknr;\n\tint left_neighbor_position;\n\n\t/* Father of the left neighbor does not exist. */\n\tif (!tb->FL[h])\n\t\treturn 0;\n\n\t/* Calculate father of the node to be balanced. */\n\tfather = PATH_H_PBUFFER(tb->tb_path, h + 1);\n\n\tRFALSE(!father ||\n\t       !B_IS_IN_TREE(father) ||\n\t       !B_IS_IN_TREE(tb->FL[h]) ||\n\t       !buffer_uptodate(father) ||\n\t       !buffer_uptodate(tb->FL[h]),\n\t       \"vs-8165: F[h] (%b) or FL[h] (%b) is invalid\",\n\t       father, tb->FL[h]);\n\n\t/*\n\t * Get position of the pointer to the left neighbor\n\t * into the left father.\n\t */\n\tleft_neighbor_position = (father == tb->FL[h]) ?\n\t    tb->lkey[h] : B_NR_ITEMS(tb->FL[h]);\n\t/* Get left neighbor block number. */\n\tleft_neighbor_blocknr =\n\t    B_N_CHILD_NUM(tb->FL[h], left_neighbor_position);\n\t/* Look for the left neighbor in the cache. */\n\tif ((left = sb_find_get_block(sb, left_neighbor_blocknr))) {\n\n\t\tRFALSE(buffer_uptodate(left) && !B_IS_IN_TREE(left),\n\t\t       \"vs-8170: left neighbor (%b %z) is not in the tree\",\n\t\t       left, left);\n\t\tput_bh(left);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int is_left_neighbor_in_cache(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *father, *left;\n\tstruct super_block *sb = tb->tb_sb;\n\tb_blocknr_t left_neighbor_blocknr;\n\tint left_neighbor_position;\n\n\t/* Father of the left neighbor does not exist. */\n\tif (!tb->FL[h])\n\t\treturn 0;\n\n\t/* Calculate father of the node to be balanced. */\n\tfather = PATH_H_PBUFFER(tb->tb_path, h + 1);\n\n\tRFALSE(!father ||\n\t       !B_IS_IN_TREE(father) ||\n\t       !B_IS_IN_TREE(tb->FL[h]) ||\n\t       !buffer_uptodate(father) ||\n\t       !buffer_uptodate(tb->FL[h]),\n\t       \"vs-8165: F[h] (%b) or FL[h] (%b) is invalid\",\n\t       father, tb->FL[h]);\n\n\t/*\n\t * Get position of the pointer to the left neighbor\n\t * into the left father.\n\t */\n\tleft_neighbor_position = (father == tb->FL[h]) ?\n\t    tb->lkey[h] : B_NR_ITEMS(tb->FL[h]);\n\t/* Get left neighbor block number. */\n\tleft_neighbor_blocknr =\n\t    B_N_CHILD_NUM(tb->FL[h], left_neighbor_position);\n\t/* Look for the left neighbor in the cache. */\n\tif ((left = sb_find_get_block(sb, left_neighbor_blocknr))) {\n\n\t\tRFALSE(buffer_uptodate(left) && !B_IS_IN_TREE(left),\n\t\t       \"vs-8170: left neighbor (%b %z) is not in the tree\",\n\t\t       left, left);\n\t\tput_bh(left);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!tb->FL[h] && !tb->FR[h]",
            "\"vs-8235: trying to borrow for root\""
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_NR_KEY",
          "args": [
            "Sh"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_NR_KEY",
          "args": [
            "Sh"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD(tb->FR[h], order_R)"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "tb->FR[h]",
            "order_R"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "Fh"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_B_ITEM_ORDER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD(tb->FL[h], order_L)"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "tb->FL[h]",
            "order_L"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->FL[h]"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_B_ITEM_ORDER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_NR_KEY",
          "args": [
            "Sh"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_NR_KEY",
          "args": [
            "Sh"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD(tb->FR[h], order_R)"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "tb->FR[h]",
            "order_R"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "Fh"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_B_ITEM_ORDER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD(tb->FL[h], order_L)"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "tb->FL[h]",
            "order_L"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->FL[h]"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_B_ITEM_ORDER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN_NR_KEY",
          "args": [
            "Sh"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN_NR_KEY",
          "args": [
            "Sh"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_right",
          "args": [
            "tb",
            "h",
            "rfree"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "check_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "280-364",
          "snippet": "static void check_right(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8070: cur_free < 0\");\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->rnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space  */\n\t\ttb->rnum[h] = 0;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8075: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi + vn->vn_nr_item - 1;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_RIGHT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into R[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8080: invalid mode or balance condition failed\");\n\n\t\ttb->rnum[h] = vn->vn_nr_item;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* last item may be merge with first item in right neighbor */\n\tif (vi->vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\td_size = -(int)IH_SIZE, ih_size = 0;\n\n\ttb->rnum[0] = 0;\n\tfor (i = vn->vn_nr_item - 1; i >= 0;\n\t     i--, d_size = 0, ih_size = IH_SIZE, vi--) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->rnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * check whether R[0] can hold ih and at least one\n\t\t * byte of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->rbytes = -1;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * R[0] can hold the header of the item and at least\n\t\t * one byte of its body\n\t\t */\n\t\tcur_free -= ih_size;\t/* cur_free is still > 0 */\n\n\t\ttb->rbytes = op_check_right(vi, cur_free);\n\t\tif (tb->rbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->rnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void check_right(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8070: cur_free < 0\");\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->rnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space  */\n\t\ttb->rnum[h] = 0;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8075: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi + vn->vn_nr_item - 1;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_RIGHT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into R[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8080: invalid mode or balance condition failed\");\n\n\t\ttb->rnum[h] = vn->vn_nr_item;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* last item may be merge with first item in right neighbor */\n\tif (vi->vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\td_size = -(int)IH_SIZE, ih_size = 0;\n\n\ttb->rnum[0] = 0;\n\tfor (i = vn->vn_nr_item - 1; i >= 0;\n\t     i--, d_size = 0, ih_size = IH_SIZE, vi--) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->rnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * check whether R[0] can hold ih and at least one\n\t\t * byte of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->rbytes = -1;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * R[0] can hold the header of the item and at least\n\t\t * one byte of its body\n\t\t */\n\t\tcur_free -= ih_size;\t/* cur_free is still > 0 */\n\n\t\ttb->rbytes = op_check_right(vi, cur_free);\n\t\tif (tb->rbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->rnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_left",
          "args": [
            "tb",
            "h",
            "lfree"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "check_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "194-274",
          "snippet": "static void check_left(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8050: cur_free (%d) < 0\", cur_free);\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->lnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space or nothing to move */\n\t\ttb->lnum[h] = 0;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8055: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_LEFT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into L[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8055: invalid mode or balance condition failed\");\n\n\t\ttb->lnum[0] = vn->vn_nr_item;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* first item may be merge with last item in left neighbor */\n\tif (vi->vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\td_size = -((int)IH_SIZE), ih_size = 0;\n\n\ttb->lnum[0] = 0;\n\tfor (i = 0; i < vn->vn_nr_item;\n\t     i++, ih_size = IH_SIZE, d_size = 0, vi++) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->lnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* the item cannot be shifted entirely, try to split it */\n\t\t/*\n\t\t * check whether L[0] can hold ih and at least one byte\n\t\t * of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->lbytes = -1;\n\t\t\treturn;\n\t\t}\n\t\tcur_free -= ih_size;\n\n\t\ttb->lbytes = op_check_left(vi, cur_free, 0, 0);\n\t\tif (tb->lbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->lnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void check_left(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8050: cur_free (%d) < 0\", cur_free);\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->lnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space or nothing to move */\n\t\ttb->lnum[h] = 0;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8055: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_LEFT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into L[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8055: invalid mode or balance condition failed\");\n\n\t\ttb->lnum[0] = vn->vn_nr_item;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* first item may be merge with last item in left neighbor */\n\tif (vi->vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\td_size = -((int)IH_SIZE), ih_size = 0;\n\n\ttb->lnum[0] = 0;\n\tfor (i = 0; i < vn->vn_nr_item;\n\t     i++, ih_size = IH_SIZE, d_size = 0, vi++) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->lnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* the item cannot be shifted entirely, try to split it */\n\t\t/*\n\t\t * check whether L[0] can hold ih and at least one byte\n\t\t * of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->lbytes = -1;\n\t\t\treturn;\n\t\t}\n\t\tcur_free -= ih_size;\n\n\t\ttb->lbytes = op_check_left(vi, cur_free, 0, 0);\n\t\tif (tb->lbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->lnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lfree",
          "args": [
            "tb",
            "h"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "get_lfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "917-934",
          "snippet": "static int get_lfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *l, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (l = tb->FL[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == l)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) - 1;\n\telse {\n\t\torder = B_NR_ITEMS(l);\n\t\tf = l;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_lfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *l, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (l = tb->FL[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == l)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) - 1;\n\telse {\n\t\torder = B_NR_ITEMS(l);\n\t\tf = l;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfree",
          "args": [
            "tb",
            "h"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "940-958",
          "snippet": "static int get_rfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *r, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (r = tb->FR[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == r)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) + 1;\n\telse {\n\t\torder = 0;\n\t\tf = r;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_rfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *r, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (r = tb->FR[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == r)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) + 1;\n\telse {\n\t\torder = 0;\n\t\tf = r;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_parents",
          "args": [
            "tb",
            "h"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "get_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "1174-1269",
          "snippet": "static int get_parents(struct tree_balance *tb, int h)\n{\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    ret,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\tstruct buffer_head *curf, *curcf;\n\n\t/* Current node is the root of the tree or will be root of the tree */\n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\t\t/*\n\t\t * The root can not have parents.\n\t\t * Release nodes which previously were obtained as\n\t\t * parents of the current node neighbors.\n\t\t */\n\t\tbrelse(tb->FL[h]);\n\t\tbrelse(tb->CFL[h]);\n\t\tbrelse(tb->FR[h]);\n\t\tbrelse(tb->CFR[h]);\n\t\ttb->FL[h]  = NULL;\n\t\ttb->CFL[h] = NULL;\n\t\ttb->FR[h]  = NULL;\n\t\ttb->CFR[h] = NULL;\n\t\treturn CARRY_ON;\n\t}\n\n\t/* Get parent FL[path_offset] of L[path_offset]. */\n\tposition = PATH_OFFSET_POSITION(path, path_offset - 1);\n\tif (position) {\n\t\t/* Current node is not the first child of its parent. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->lkey[h] = position - 1;\n\t} else {\n\t\t/*\n\t\t * Calculate current parent of L[path_offset], which is the\n\t\t * left neighbor of the current node.  Calculate current\n\t\t * common parent of L[path_offset] and the current node.\n\t\t * Note that CFL[path_offset] not equal FL[path_offset] and\n\t\t * CFL[path_offset] not equal F[path_offset].\n\t\t * Calculate lkey[path_offset].\n\t\t */\n\t\tif ((ret = get_far_parent(tb, h + 1, &curf,\n\t\t\t\t\t\t  &curcf,\n\t\t\t\t\t\t  LEFT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t}\n\n\tbrelse(tb->FL[h]);\n\ttb->FL[h] = curf;\t/* New initialization of FL[h]. */\n\tbrelse(tb->CFL[h]);\n\ttb->CFL[h] = curcf;\t/* New initialization of CFL[h]. */\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8195: FL (%b) or CFL (%b) is invalid\", curf, curcf);\n\n\t/* Get parent FR[h] of R[h]. */\n\n\t/* Current node is the last child of F[h]. FR[h] != F[h]. */\n\tif (position == B_NR_ITEMS(PATH_H_PBUFFER(path, h + 1))) {\n\t\t/*\n\t\t * Calculate current parent of R[h], which is the right\n\t\t * neighbor of F[h].  Calculate current common parent of\n\t\t * R[h] and current node. Note that CFR[h] not equal\n\t\t * FR[path_offset] and CFR[h] not equal F[h].\n\t\t */\n\t\tif ((ret =\n\t\t     get_far_parent(tb, h + 1, &curf, &curcf,\n\t\t\t\t    RIGHT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t} else {\n\t\t/* Current node is not the last child of its parent F[h]. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->rkey[h] = position;\n\t}\n\n\tbrelse(tb->FR[h]);\n\t/* New initialization of FR[path_offset]. */\n\ttb->FR[h] = curf;\n\n\tbrelse(tb->CFR[h]);\n\t/* New initialization of CFR[path_offset]. */\n\ttb->CFR[h] = curcf;\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8205: FR (%b) or CFR (%b) is invalid\", curf, curcf);\n\n\treturn CARRY_ON;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define RIGHT_PARENTS 'r'",
            "#define LEFT_PARENTS  'l'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#define RIGHT_PARENTS 'r'\n#define LEFT_PARENTS  'l'\n\nstatic int get_parents(struct tree_balance *tb, int h)\n{\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    ret,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\tstruct buffer_head *curf, *curcf;\n\n\t/* Current node is the root of the tree or will be root of the tree */\n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\t\t/*\n\t\t * The root can not have parents.\n\t\t * Release nodes which previously were obtained as\n\t\t * parents of the current node neighbors.\n\t\t */\n\t\tbrelse(tb->FL[h]);\n\t\tbrelse(tb->CFL[h]);\n\t\tbrelse(tb->FR[h]);\n\t\tbrelse(tb->CFR[h]);\n\t\ttb->FL[h]  = NULL;\n\t\ttb->CFL[h] = NULL;\n\t\ttb->FR[h]  = NULL;\n\t\ttb->CFR[h] = NULL;\n\t\treturn CARRY_ON;\n\t}\n\n\t/* Get parent FL[path_offset] of L[path_offset]. */\n\tposition = PATH_OFFSET_POSITION(path, path_offset - 1);\n\tif (position) {\n\t\t/* Current node is not the first child of its parent. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->lkey[h] = position - 1;\n\t} else {\n\t\t/*\n\t\t * Calculate current parent of L[path_offset], which is the\n\t\t * left neighbor of the current node.  Calculate current\n\t\t * common parent of L[path_offset] and the current node.\n\t\t * Note that CFL[path_offset] not equal FL[path_offset] and\n\t\t * CFL[path_offset] not equal F[path_offset].\n\t\t * Calculate lkey[path_offset].\n\t\t */\n\t\tif ((ret = get_far_parent(tb, h + 1, &curf,\n\t\t\t\t\t\t  &curcf,\n\t\t\t\t\t\t  LEFT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t}\n\n\tbrelse(tb->FL[h]);\n\ttb->FL[h] = curf;\t/* New initialization of FL[h]. */\n\tbrelse(tb->CFL[h]);\n\ttb->CFL[h] = curcf;\t/* New initialization of CFL[h]. */\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8195: FL (%b) or CFL (%b) is invalid\", curf, curcf);\n\n\t/* Get parent FR[h] of R[h]. */\n\n\t/* Current node is the last child of F[h]. FR[h] != F[h]. */\n\tif (position == B_NR_ITEMS(PATH_H_PBUFFER(path, h + 1))) {\n\t\t/*\n\t\t * Calculate current parent of R[h], which is the right\n\t\t * neighbor of F[h].  Calculate current common parent of\n\t\t * R[h] and current node. Note that CFR[h] not equal\n\t\t * FR[path_offset] and CFR[h] not equal F[h].\n\t\t */\n\t\tif ((ret =\n\t\t     get_far_parent(tb, h + 1, &curf, &curcf,\n\t\t\t\t    RIGHT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t} else {\n\t\t/* Current node is not the last child of its parent F[h]. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->rkey[h] = position;\n\t}\n\n\tbrelse(tb->FR[h]);\n\t/* New initialization of FR[path_offset]. */\n\ttb->FR[h] = curf;\n\n\tbrelse(tb->CFR[h]);\n\t/* New initialization of CFR[path_offset]. */\n\ttb->CFR[h] = curcf;\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8205: FR (%b) or CFR (%b) is invalid\", curf, curcf);\n\n\treturn CARRY_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_virtual_node",
          "args": [
            "tb",
            "h"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "create_virtual_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "51-188",
          "snippet": "static void create_virtual_node(struct tree_balance *tb, int h)\n{\n\tstruct item_head *ih;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint new_num;\n\tstruct buffer_head *Sh;\t/* this comes from tb->S[h] */\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\n\t/* size of changed node */\n\tvn->vn_size =\n\t    MAX_CHILD_SIZE(Sh) - B_FREE_SPACE(Sh) + tb->insert_size[h];\n\n\t/* for internal nodes array if virtual items is not created */\n\tif (h) {\n\t\tvn->vn_nr_item = (vn->vn_size - DC_SIZE) / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* number of items in virtual node  */\n\tvn->vn_nr_item =\n\t    B_NR_ITEMS(Sh) + ((vn->vn_mode == M_INSERT) ? 1 : 0) -\n\t    ((vn->vn_mode == M_DELETE) ? 1 : 0);\n\n\t/* first virtual item */\n\tvn->vn_vi = (struct virtual_item *)(tb->tb_vn + 1);\n\tmemset(vn->vn_vi, 0, vn->vn_nr_item * sizeof(struct virtual_item));\n\tvn->vn_free_ptr += vn->vn_nr_item * sizeof(struct virtual_item);\n\n\t/* first item in the node */\n\tih = item_head(Sh, 0);\n\n\t/* define the mergeability for 0-th item (if it is not being deleted) */\n\tif (op_is_left_mergeable(&ih->ih_key, Sh->b_size)\n\t    && (vn->vn_mode != M_DELETE || vn->vn_affected_item_num))\n\t\tvn->vn_vi[0].vi_type |= VI_TYPE_LEFT_MERGEABLE;\n\n\t/*\n\t * go through all items that remain in the virtual\n\t * node (except for the new (inserted) one)\n\t */\n\tfor (new_num = 0; new_num < vn->vn_nr_item; new_num++) {\n\t\tint j;\n\t\tstruct virtual_item *vi = vn->vn_vi + new_num;\n\t\tint is_affected =\n\t\t    ((new_num != vn->vn_affected_item_num) ? 0 : 1);\n\n\t\tif (is_affected && vn->vn_mode == M_INSERT)\n\t\t\tcontinue;\n\n\t\t/* get item number in source node */\n\t\tj = old_item_num(new_num, vn->vn_affected_item_num,\n\t\t\t\t vn->vn_mode);\n\n\t\tvi->vi_item_len += ih_item_len(ih + j) + IH_SIZE;\n\t\tvi->vi_ih = ih + j;\n\t\tvi->vi_item = ih_item_body(Sh, ih + j);\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\t/*\n\t\t * FIXME: there is no check that item operation did not\n\t\t * consume too much memory\n\t\t */\n\t\tvn->vn_free_ptr +=\n\t\t    op_create_vi(vn, vi, is_affected, tb->insert_size[0]);\n\t\tif (tb->vn_buf + tb->vn_buf_size < vn->vn_free_ptr)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8030\",\n\t\t\t\t       \"virtual node space consumed\");\n\n\t\tif (!is_affected)\n\t\t\t/* this is not being changed */\n\t\t\tcontinue;\n\n\t\tif (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT) {\n\t\t\tvn->vn_vi[new_num].vi_item_len += tb->insert_size[0];\n\t\t\t/* pointer to data which is going to be pasted */\n\t\t\tvi->vi_new_data = vn->vn_data;\n\t\t}\n\t}\n\n\t/* virtual inserted item is not defined yet */\n\tif (vn->vn_mode == M_INSERT) {\n\t\tstruct virtual_item *vi = vn->vn_vi + vn->vn_affected_item_num;\n\n\t\tRFALSE(vn->vn_ins_ih == NULL,\n\t\t       \"vs-8040: item header of inserted item is not specified\");\n\t\tvi->vi_item_len = tb->insert_size[0];\n\t\tvi->vi_ih = vn->vn_ins_ih;\n\t\tvi->vi_item = vn->vn_data;\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\top_create_vi(vn, vi, 0 /*not pasted or cut */ ,\n\t\t\t     tb->insert_size[0]);\n\t}\n\n\t/*\n\t * set right merge flag we take right delimiting key and\n\t * check whether it is a mergeable item\n\t */\n\tif (tb->CFR[0]) {\n\t\tstruct reiserfs_key *key;\n\n\t\tkey = internal_key(tb->CFR[0], tb->rkey[0]);\n\t\tif (op_is_left_mergeable(key, Sh->b_size)\n\t\t    && (vn->vn_mode != M_DELETE\n\t\t\t|| vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1))\n\t\t\tvn->vn_vi[vn->vn_nr_item - 1].vi_type |=\n\t\t\t    VI_TYPE_RIGHT_MERGEABLE;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (op_is_left_mergeable(key, Sh->b_size) &&\n\t\t    !(vn->vn_mode != M_DELETE\n\t\t      || vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1)) {\n\t\t\t/*\n\t\t\t * we delete last item and it could be merged\n\t\t\t * with right neighbor's first item\n\t\t\t */\n\t\t\tif (!\n\t\t\t    (B_NR_ITEMS(Sh) == 1\n\t\t\t     && is_direntry_le_ih(item_head(Sh, 0))\n\t\t\t     && ih_entry_count(item_head(Sh, 0)) == 1)) {\n\t\t\t\t/*\n\t\t\t\t * node contains more than 1 item, or item\n\t\t\t\t * is not directory item, or this item\n\t\t\t\t * contains more than 1 entry\n\t\t\t\t */\n\t\t\t\tprint_block(Sh, 0, -1, -1);\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-8045\",\n\t\t\t\t\t       \"rdkey %k, affected item==%d \"\n\t\t\t\t\t       \"(mode==%c) Must be %c\",\n\t\t\t\t\t       key, vn->vn_affected_item_num,\n\t\t\t\t\t       vn->vn_mode, M_DELETE);\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void create_virtual_node(struct tree_balance *tb, int h)\n{\n\tstruct item_head *ih;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint new_num;\n\tstruct buffer_head *Sh;\t/* this comes from tb->S[h] */\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\n\t/* size of changed node */\n\tvn->vn_size =\n\t    MAX_CHILD_SIZE(Sh) - B_FREE_SPACE(Sh) + tb->insert_size[h];\n\n\t/* for internal nodes array if virtual items is not created */\n\tif (h) {\n\t\tvn->vn_nr_item = (vn->vn_size - DC_SIZE) / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* number of items in virtual node  */\n\tvn->vn_nr_item =\n\t    B_NR_ITEMS(Sh) + ((vn->vn_mode == M_INSERT) ? 1 : 0) -\n\t    ((vn->vn_mode == M_DELETE) ? 1 : 0);\n\n\t/* first virtual item */\n\tvn->vn_vi = (struct virtual_item *)(tb->tb_vn + 1);\n\tmemset(vn->vn_vi, 0, vn->vn_nr_item * sizeof(struct virtual_item));\n\tvn->vn_free_ptr += vn->vn_nr_item * sizeof(struct virtual_item);\n\n\t/* first item in the node */\n\tih = item_head(Sh, 0);\n\n\t/* define the mergeability for 0-th item (if it is not being deleted) */\n\tif (op_is_left_mergeable(&ih->ih_key, Sh->b_size)\n\t    && (vn->vn_mode != M_DELETE || vn->vn_affected_item_num))\n\t\tvn->vn_vi[0].vi_type |= VI_TYPE_LEFT_MERGEABLE;\n\n\t/*\n\t * go through all items that remain in the virtual\n\t * node (except for the new (inserted) one)\n\t */\n\tfor (new_num = 0; new_num < vn->vn_nr_item; new_num++) {\n\t\tint j;\n\t\tstruct virtual_item *vi = vn->vn_vi + new_num;\n\t\tint is_affected =\n\t\t    ((new_num != vn->vn_affected_item_num) ? 0 : 1);\n\n\t\tif (is_affected && vn->vn_mode == M_INSERT)\n\t\t\tcontinue;\n\n\t\t/* get item number in source node */\n\t\tj = old_item_num(new_num, vn->vn_affected_item_num,\n\t\t\t\t vn->vn_mode);\n\n\t\tvi->vi_item_len += ih_item_len(ih + j) + IH_SIZE;\n\t\tvi->vi_ih = ih + j;\n\t\tvi->vi_item = ih_item_body(Sh, ih + j);\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\t/*\n\t\t * FIXME: there is no check that item operation did not\n\t\t * consume too much memory\n\t\t */\n\t\tvn->vn_free_ptr +=\n\t\t    op_create_vi(vn, vi, is_affected, tb->insert_size[0]);\n\t\tif (tb->vn_buf + tb->vn_buf_size < vn->vn_free_ptr)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8030\",\n\t\t\t\t       \"virtual node space consumed\");\n\n\t\tif (!is_affected)\n\t\t\t/* this is not being changed */\n\t\t\tcontinue;\n\n\t\tif (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT) {\n\t\t\tvn->vn_vi[new_num].vi_item_len += tb->insert_size[0];\n\t\t\t/* pointer to data which is going to be pasted */\n\t\t\tvi->vi_new_data = vn->vn_data;\n\t\t}\n\t}\n\n\t/* virtual inserted item is not defined yet */\n\tif (vn->vn_mode == M_INSERT) {\n\t\tstruct virtual_item *vi = vn->vn_vi + vn->vn_affected_item_num;\n\n\t\tRFALSE(vn->vn_ins_ih == NULL,\n\t\t       \"vs-8040: item header of inserted item is not specified\");\n\t\tvi->vi_item_len = tb->insert_size[0];\n\t\tvi->vi_ih = vn->vn_ins_ih;\n\t\tvi->vi_item = vn->vn_data;\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\top_create_vi(vn, vi, 0 /*not pasted or cut */ ,\n\t\t\t     tb->insert_size[0]);\n\t}\n\n\t/*\n\t * set right merge flag we take right delimiting key and\n\t * check whether it is a mergeable item\n\t */\n\tif (tb->CFR[0]) {\n\t\tstruct reiserfs_key *key;\n\n\t\tkey = internal_key(tb->CFR[0], tb->rkey[0]);\n\t\tif (op_is_left_mergeable(key, Sh->b_size)\n\t\t    && (vn->vn_mode != M_DELETE\n\t\t\t|| vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1))\n\t\t\tvn->vn_vi[vn->vn_nr_item - 1].vi_type |=\n\t\t\t    VI_TYPE_RIGHT_MERGEABLE;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (op_is_left_mergeable(key, Sh->b_size) &&\n\t\t    !(vn->vn_mode != M_DELETE\n\t\t      || vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1)) {\n\t\t\t/*\n\t\t\t * we delete last item and it could be merged\n\t\t\t * with right neighbor's first item\n\t\t\t */\n\t\t\tif (!\n\t\t\t    (B_NR_ITEMS(Sh) == 1\n\t\t\t     && is_direntry_le_ih(item_head(Sh, 0))\n\t\t\t     && ih_entry_count(item_head(Sh, 0)) == 1)) {\n\t\t\t\t/*\n\t\t\t\t * node contains more than 1 item, or item\n\t\t\t\t * is not directory item, or this item\n\t\t\t\t * contains more than 1 entry\n\t\t\t\t */\n\t\t\t\tprint_block(Sh, 0, -1, -1);\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-8045\",\n\t\t\t\t\t       \"rdkey %k, affected item==%d \"\n\t\t\t\t\t       \"(mode==%c) Must be %c\",\n\t\t\t\t\t       key, vn->vn_affected_item_num,\n\t\t\t\t\t       vn->vn_mode, M_DELETE);\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "Sh"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int dc_check_balance_internal(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\n\t/*\n\t * Sh is the node whose balance is currently being checked,\n\t * and Fh is its father.\n\t */\n\tstruct buffer_head *Sh, *Fh;\n\tint maxsize, ret;\n\tint lfree, rfree /* free space in L and R */ ;\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tFh = PATH_H_PPARENT(tb->tb_path, h);\n\n\tmaxsize = MAX_CHILD_SIZE(Sh);\n\n\t/*\n\t * using tb->insert_size[h], which is negative in this case,\n\t * create_virtual_node calculates:\n\t * new_nr_item = number of items node would have if operation is\n\t * performed without balancing (new_nr_item);\n\t */\n\tcreate_virtual_node(tb, h);\n\n\tif (!Fh) {\t\t/* S[h] is the root. */\n\t\t/* no balancing for higher levels needed */\n\t\tif (vn->vn_nr_item > 0) {\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\t\t}\n\t\t/*\n\t\t * new_nr_item == 0.\n\t\t * Current root will be deleted resulting in\n\t\t * decrementing the tree height.\n\t\t */\n\t\tset_parameters(tb, h, 0, 0, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\tif ((ret = get_parents(tb, h)) != CARRY_ON)\n\t\treturn ret;\n\n\t/* get free space of neighbors */\n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\t/* determine maximal number of items we can fit into neighbors */\n\tcheck_left(tb, h, lfree);\n\tcheck_right(tb, h, rfree);\n\n\t/*\n\t * Balance condition for the internal node is valid.\n\t * In this case we balance only if it leads to better packing.\n\t */\n\tif (vn->vn_nr_item >= MIN_NR_KEY(Sh)) {\n\t\t/*\n\t\t * Here we join S[h] with one of its neighbors,\n\t\t * which is impossible with greater values of new_nr_item.\n\t\t */\n\t\tif (vn->vn_nr_item == MIN_NR_KEY(Sh)) {\n\t\t\t/* All contents of S[h] can be moved to L[h]. */\n\t\t\tif (tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\t\t\tint n;\n\t\t\t\tint order_L;\n\n\t\t\t\torder_L =\n\t\t\t\t    ((n =\n\t\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t\t  h)) ==\n\t\t\t\t     0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;\n\t\t\t\tn = dc_size(B_N_CHILD(tb->FL[h], order_L)) /\n\t\t\t\t    (DC_SIZE + KEY_SIZE);\n\t\t\t\tset_parameters(tb, h, -n - 1, 0, 0, NULL, -1,\n\t\t\t\t\t       -1);\n\t\t\t\treturn CARRY_ON;\n\t\t\t}\n\n\t\t\t/* All contents of S[h] can be moved to R[h]. */\n\t\t\tif (tb->rnum[h] >= vn->vn_nr_item + 1) {\n\t\t\t\tint n;\n\t\t\t\tint order_R;\n\n\t\t\t\torder_R =\n\t\t\t\t    ((n =\n\t\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t\t  h)) ==\n\t\t\t\t     B_NR_ITEMS(Fh)) ? 0 : n + 1;\n\t\t\t\tn = dc_size(B_N_CHILD(tb->FR[h], order_R)) /\n\t\t\t\t    (DC_SIZE + KEY_SIZE);\n\t\t\t\tset_parameters(tb, h, 0, -n - 1, 0, NULL, -1,\n\t\t\t\t\t       -1);\n\t\t\t\treturn CARRY_ON;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * All contents of S[h] can be moved to the neighbors\n\t\t * (L[h] & R[h]).\n\t\t */\n\t\tif (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\t\tint to_r;\n\n\t\t\tto_r =\n\t\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] -\n\t\t\t     tb->rnum[h] + vn->vn_nr_item + 1) / 2 -\n\t\t\t    (MAX_NR_KEY(Sh) + 1 - tb->rnum[h]);\n\t\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r,\n\t\t\t\t       0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/* Balancing does not lead to better packing. */\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\t/*\n\t * Current node contain insufficient number of items.\n\t * Balancing is required.\n\t */\n\t/* Check whether we can merge S[h] with left neighbor. */\n\tif (tb->lnum[h] >= vn->vn_nr_item + 1)\n\t\tif (is_left_neighbor_in_cache(tb, h)\n\t\t    || tb->rnum[h] < vn->vn_nr_item + 1 || !tb->FR[h]) {\n\t\t\tint n;\n\t\t\tint order_L;\n\n\t\t\torder_L =\n\t\t\t    ((n =\n\t\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t\t  h)) ==\n\t\t\t     0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;\n\t\t\tn = dc_size(B_N_CHILD(tb->FL[h], order_L)) / (DC_SIZE +\n\t\t\t\t\t\t\t\t      KEY_SIZE);\n\t\t\tset_parameters(tb, h, -n - 1, 0, 0, NULL, -1, -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t/* Check whether we can merge S[h] with right neighbor. */\n\tif (tb->rnum[h] >= vn->vn_nr_item + 1) {\n\t\tint n;\n\t\tint order_R;\n\n\t\torder_R =\n\t\t    ((n =\n\t\t      PATH_H_B_ITEM_ORDER(tb->tb_path,\n\t\t\t\t\t  h)) == B_NR_ITEMS(Fh)) ? 0 : (n + 1);\n\t\tn = dc_size(B_N_CHILD(tb->FR[h], order_R)) / (DC_SIZE +\n\t\t\t\t\t\t\t      KEY_SIZE);\n\t\tset_parameters(tb, h, 0, -n - 1, 0, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/* All contents of S[h] can be moved to the neighbors (L[h] & R[h]). */\n\tif (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1) {\n\t\tint to_r;\n\n\t\tto_r =\n\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] - tb->rnum[h] +\n\t\t     vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 -\n\t\t\t\t\t\ttb->rnum[h]);\n\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL,\n\t\t\t       -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/* For internal nodes try to borrow item from a neighbor */\n\tRFALSE(!tb->FL[h] && !tb->FR[h], \"vs-8235: trying to borrow for root\");\n\n\t/* Borrow one or two items from caching neighbor */\n\tif (is_left_neighbor_in_cache(tb, h) || !tb->FR[h]) {\n\t\tint from_l;\n\n\t\tfrom_l =\n\t\t    (MAX_NR_KEY(Sh) + 1 - tb->lnum[h] + vn->vn_nr_item +\n\t\t     1) / 2 - (vn->vn_nr_item + 1);\n\t\tset_parameters(tb, h, -from_l, 0, 1, NULL, -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\tset_parameters(tb, h, 0,\n\t\t       -((MAX_NR_KEY(Sh) + 1 - tb->rnum[h] + vn->vn_nr_item +\n\t\t\t  1) / 2 - (vn->vn_nr_item + 1)), 1, NULL, -1, -1);\n\treturn CARRY_ON;\n}"
  },
  {
    "function_name": "ip_check_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "1326-1709",
    "snippet": "static int ip_check_balance(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\t/*\n\t * Number of bytes that must be inserted into (value is negative\n\t * if bytes are deleted) buffer which contains node being balanced.\n\t * The mnemonic is that the attempted change in node space used\n\t * level is levbytes bytes.\n\t */\n\tint levbytes;\n\tint ret;\n\n\tint lfree, sfree, rfree /* free space in L, S and R */ ;\n\n\t/*\n\t * nver is short for number of vertixes, and lnver is the number if\n\t * we shift to the left, rnver is the number if we shift to the\n\t * right, and lrnver is the number if we shift in both directions.\n\t * The goal is to minimize first the number of vertixes, and second,\n\t * the number of vertixes whose contents are changed by shifting,\n\t * and third the number of uncached vertixes whose contents are\n\t * changed by shifting and must be read from disk.\n\t */\n\tint nver, lnver, rnver, lrnver;\n\n\t/*\n\t * used at leaf level only, S0 = S[0] is the node being balanced,\n\t * sInum [ I = 0,1,2 ] is the number of items that will\n\t * remain in node SI after balancing.  S1 and S2 are new\n\t * nodes that might be created.\n\t */\n\n\t/*\n\t * we perform 8 calls to get_num_ver().  For each call we\n\t * calculate five parameters.  where 4th parameter is s1bytes\n\t * and 5th - s2bytes\n\t *\n\t * s0num, s1num, s2num for 8 cases\n\t * 0,1 - do not shift and do not shift but bottle\n\t * 2   - shift only whole item to left\n\t * 3   - shift to left and bottle as much as possible\n\t * 4,5 - shift to right (whole items and as much as possible\n\t * 6,7 - shift to both directions (whole items and as much as possible)\n\t */\n\tshort snum012[40] = { 0, };\n\n\t/* Sh is the node whose balance is currently being checked */\n\tstruct buffer_head *Sh;\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tlevbytes = tb->insert_size[h];\n\n\t/* Calculate balance parameters for creating new root. */\n\tif (!Sh) {\n\t\tif (!h)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8210\",\n\t\t\t\t       \"S[0] can not be 0\");\n\t\tswitch (ret = get_empty_nodes(tb, h)) {\n\t\t/* no balancing for higher levels needed */\n\t\tcase CARRY_ON:\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\n\t\tcase NO_DISK_SPACE:\n\t\tcase REPEAT_SEARCH:\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8215\", \"incorrect \"\n\t\t\t\t       \"return value of get_empty_nodes\");\n\t\t}\n\t}\n\n\t/* get parents of S[h] neighbors. */\n\tret = get_parents(tb, h);\n\tif (ret != CARRY_ON)\n\t\treturn ret;\n\n\tsfree = B_FREE_SPACE(Sh);\n\n\t/* get free space of neighbors */\n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\t/* and new item fits into node S[h] without any shifting */\n\tif (can_node_be_removed(vn->vn_mode, lfree, sfree, rfree, tb, h) ==\n\t    NO_BALANCING_NEEDED)\n\t\treturn NO_BALANCING_NEEDED;\n\n\tcreate_virtual_node(tb, h);\n\n\t/*\n\t * determine maximal number of items we can shift to the left\n\t * neighbor (in tb structure) and the maximal number of bytes\n\t * that can flow to the left neighbor from the left most liquid\n\t * item that cannot be shifted from S[0] entirely (returned value)\n\t */\n\tcheck_left(tb, h, lfree);\n\n\t/*\n\t * determine maximal number of items we can shift to the right\n\t * neighbor (in tb structure) and the maximal number of bytes\n\t * that can flow to the right neighbor from the right most liquid\n\t * item that cannot be shifted from S[0] entirely (returned value)\n\t */\n\tcheck_right(tb, h, rfree);\n\n\t/*\n\t * all contents of internal node S[h] can be moved into its\n\t * neighbors, S[h] will be removed after balancing\n\t */\n\tif (h && (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1)) {\n\t\tint to_r;\n\n\t\t/*\n\t\t * Since we are working on internal nodes, and our internal\n\t\t * nodes have fixed size entries, then we can balance by the\n\t\t * number of items rather than the space they consume.  In this\n\t\t * routine we set the left node equal to the right node,\n\t\t * allowing a difference of less than or equal to 1 child\n\t\t * pointer.\n\t\t */\n\t\tto_r =\n\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] - tb->rnum[h] +\n\t\t     vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 -\n\t\t\t\t\t\ttb->rnum[h]);\n\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL,\n\t\t\t       -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/*\n\t * this checks balance condition, that any two neighboring nodes\n\t * can not fit in one node\n\t */\n\tRFALSE(h &&\n\t       (tb->lnum[h] >= vn->vn_nr_item + 1 ||\n\t\ttb->rnum[h] >= vn->vn_nr_item + 1),\n\t       \"vs-8220: tree is not balanced on internal level\");\n\tRFALSE(!h && ((tb->lnum[h] >= vn->vn_nr_item && (tb->lbytes == -1)) ||\n\t\t      (tb->rnum[h] >= vn->vn_nr_item && (tb->rbytes == -1))),\n\t       \"vs-8225: tree is not balanced on leaf level\");\n\n\t/*\n\t * all contents of S[0] can be moved into its neighbors\n\t * S[0] will be removed after balancing.\n\t */\n\tif (!h && is_leaf_removable(tb))\n\t\treturn CARRY_ON;\n\n\t/*\n\t * why do we perform this check here rather than earlier??\n\t * Answer: we can win 1 node in some cases above. Moreover we\n\t * checked it above, when we checked, that S[0] is not removable\n\t * in principle\n\t */\n\n\t /* new item fits into node S[h] without any shifting */\n\tif (sfree >= levbytes) {\n\t\tif (!h)\n\t\t\ttb->s0num = vn->vn_nr_item;\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\t{\n\t\tint lpar, rpar, nset, lset, rset, lrset;\n\t\t/* regular overflowing of the node */\n\n\t\t/*\n\t\t * get_num_ver works in 2 modes (FLOW & NO_FLOW)\n\t\t * lpar, rpar - number of items we can shift to left/right\n\t\t *              neighbor (including splitting item)\n\t\t * nset, lset, rset, lrset - shows, whether flowing items\n\t\t *                           give better packing\n\t\t */\n#define FLOW 1\n#define NO_FLOW 0\t\t/* do not any splitting */\n\n\t\t/* we choose one of the following */\n#define NOTHING_SHIFT_NO_FLOW\t0\n#define NOTHING_SHIFT_FLOW\t5\n#define LEFT_SHIFT_NO_FLOW\t10\n#define LEFT_SHIFT_FLOW\t\t15\n#define RIGHT_SHIFT_NO_FLOW\t20\n#define RIGHT_SHIFT_FLOW\t25\n#define LR_SHIFT_NO_FLOW\t30\n#define LR_SHIFT_FLOW\t\t35\n\n\t\tlpar = tb->lnum[h];\n\t\trpar = tb->rnum[h];\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * nothing is shifted to the neighbors, as well as number of\n\t\t * items in each part of the split node (s012 numbers),\n\t\t * and number of bytes (s1bytes) of the shared drop which\n\t\t * flow to S1 if any\n\t\t */\n\t\tnset = NOTHING_SHIFT_NO_FLOW;\n\t\tnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t   0, -1, h ? vn->vn_nr_item : 0, -1,\n\t\t\t\t   snum012, NO_FLOW);\n\n\t\tif (!h) {\n\t\t\tint nver1;\n\n\t\t\t/*\n\t\t\t * note, that in this case we try to bottle\n\t\t\t * between S[0] and S1 (S1 - the first new node)\n\t\t\t */\n\t\t\tnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t    0, -1, 0, -1,\n\t\t\t\t\t    snum012 + NOTHING_SHIFT_FLOW, FLOW);\n\t\t\tif (nver > nver1)\n\t\t\t\tnset = NOTHING_SHIFT_FLOW, nver = nver1;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * l_shift_num first items and l_shift_bytes of the right\n\t\t * most liquid item to be shifted are shifted to the left\n\t\t * neighbor, as well as number of items in each part of the\n\t\t * splitted node (s012 numbers), and number of bytes\n\t\t * (s1bytes) of the shared drop which flow to S1 if any\n\t\t */\n\t\tlset = LEFT_SHIFT_NO_FLOW;\n\t\tlnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t    lpar - ((h || tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t    -1, h ? vn->vn_nr_item : 0, -1,\n\t\t\t\t    snum012 + LEFT_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint lnver1;\n\n\t\t\tlnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t     lpar -\n\t\t\t\t\t     ((tb->lbytes != -1) ? 1 : 0),\n\t\t\t\t\t     tb->lbytes, 0, -1,\n\t\t\t\t\t     snum012 + LEFT_SHIFT_FLOW, FLOW);\n\t\t\tif (lnver > lnver1)\n\t\t\t\tlset = LEFT_SHIFT_FLOW, lnver = lnver1;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * r_shift_num first items and r_shift_bytes of the left most\n\t\t * liquid item to be shifted are shifted to the right neighbor,\n\t\t * as well as number of items in each part of the splitted\n\t\t * node (s012 numbers), and number of bytes (s1bytes) of the\n\t\t * shared drop which flow to S1 if any\n\t\t */\n\t\trset = RIGHT_SHIFT_NO_FLOW;\n\t\trnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t    0, -1,\n\t\t\t\t    h ? (vn->vn_nr_item - rpar) : (rpar -\n\t\t\t\t\t\t\t\t   ((tb->\n\t\t\t\t\t\t\t\t     rbytes !=\n\t\t\t\t\t\t\t\t     -1) ? 1 :\n\t\t\t\t\t\t\t\t    0)), -1,\n\t\t\t\t    snum012 + RIGHT_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint rnver1;\n\n\t\t\trnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t     0, -1,\n\t\t\t\t\t     (rpar -\n\t\t\t\t\t      ((tb->rbytes != -1) ? 1 : 0)),\n\t\t\t\t\t     tb->rbytes,\n\t\t\t\t\t     snum012 + RIGHT_SHIFT_FLOW, FLOW);\n\n\t\t\tif (rnver > rnver1)\n\t\t\t\trset = RIGHT_SHIFT_FLOW, rnver = rnver1;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * items are shifted in both directions, as well as number\n\t\t * of items in each part of the splitted node (s012 numbers),\n\t\t * and number of bytes (s1bytes) of the shared drop which\n\t\t * flow to S1 if any\n\t\t */\n\t\tlrset = LR_SHIFT_NO_FLOW;\n\t\tlrnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t     lpar - ((h || tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t     -1,\n\t\t\t\t     h ? (vn->vn_nr_item - rpar) : (rpar -\n\t\t\t\t\t\t\t\t    ((tb->\n\t\t\t\t\t\t\t\t      rbytes !=\n\t\t\t\t\t\t\t\t      -1) ? 1 :\n\t\t\t\t\t\t\t\t     0)), -1,\n\t\t\t\t     snum012 + LR_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint lrnver1;\n\n\t\t\tlrnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t      lpar -\n\t\t\t\t\t      ((tb->lbytes != -1) ? 1 : 0),\n\t\t\t\t\t      tb->lbytes,\n\t\t\t\t\t      (rpar -\n\t\t\t\t\t       ((tb->rbytes != -1) ? 1 : 0)),\n\t\t\t\t\t      tb->rbytes,\n\t\t\t\t\t      snum012 + LR_SHIFT_FLOW, FLOW);\n\t\t\tif (lrnver > lrnver1)\n\t\t\t\tlrset = LR_SHIFT_FLOW, lrnver = lrnver1;\n\t\t}\n\n\t\t/*\n\t\t * Our general shifting strategy is:\n\t\t * 1) to minimized number of new nodes;\n\t\t * 2) to minimized number of neighbors involved in shifting;\n\t\t * 3) to minimized number of disk reads;\n\t\t */\n\n\t\t/* we can win TWO or ONE nodes by shifting in both directions */\n\t\tif (lrnver < lnver && lrnver < rnver) {\n\t\t\tRFALSE(h &&\n\t\t\t       (tb->lnum[h] != 1 ||\n\t\t\t\ttb->rnum[h] != 1 ||\n\t\t\t\tlrnver != 1 || rnver != 2 || lnver != 2\n\t\t\t\t|| h != 1), \"vs-8230: bad h\");\n\t\t\tif (lrset == LR_SHIFT_FLOW)\n\t\t\t\tset_parameters(tb, h, tb->lnum[h], tb->rnum[h],\n\t\t\t\t\t       lrnver, snum012 + lrset,\n\t\t\t\t\t       tb->lbytes, tb->rbytes);\n\t\t\telse\n\t\t\t\tset_parameters(tb, h,\n\t\t\t\t\t       tb->lnum[h] -\n\t\t\t\t\t       ((tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t\t       tb->rnum[h] -\n\t\t\t\t\t       ((tb->rbytes == -1) ? 0 : 1),\n\t\t\t\t\t       lrnver, snum012 + lrset, -1, -1);\n\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * if shifting doesn't lead to better packing\n\t\t * then don't shift\n\t\t */\n\t\tif (nver == lrnver) {\n\t\t\tset_parameters(tb, h, 0, 0, nver, snum012 + nset, -1,\n\t\t\t\t       -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * now we know that for better packing shifting in only one\n\t\t * direction either to the left or to the right is required\n\t\t */\n\n\t\t/*\n\t\t * if shifting to the left is better than\n\t\t * shifting to the right\n\t\t */\n\t\tif (lnver < rnver) {\n\t\t\tSET_PAR_SHIFT_LEFT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * if shifting to the right is better than\n\t\t * shifting to the left\n\t\t */\n\t\tif (lnver > rnver) {\n\t\t\tSET_PAR_SHIFT_RIGHT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * now shifting in either direction gives the same number\n\t\t * of nodes and we can make use of the cached neighbors\n\t\t */\n\t\tif (is_left_neighbor_in_cache(tb, h)) {\n\t\t\tSET_PAR_SHIFT_LEFT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * shift to the right independently on whether the\n\t\t * right neighbor in cache or not\n\t\t */\n\t\tSET_PAR_SHIFT_RIGHT;\n\t\treturn CARRY_ON;\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define LR_SHIFT_FLOW\t\t35",
      "#define LR_SHIFT_NO_FLOW\t30",
      "#define RIGHT_SHIFT_FLOW\t25",
      "#define RIGHT_SHIFT_NO_FLOW\t20",
      "#define LEFT_SHIFT_FLOW\t\t15",
      "#define LEFT_SHIFT_NO_FLOW\t10",
      "#define NOTHING_SHIFT_FLOW\t5",
      "#define NOTHING_SHIFT_NO_FLOW\t0",
      "#define NO_FLOW 0\t\t/* do not any splitting */",
      "#define FLOW 1",
      "#define SET_PAR_SHIFT_RIGHT \\\nif (h)\\\n{\\\n   int to_r;\\\n   \\\n   to_r = (MAX_NR_KEY(Sh)+1 - rpar + vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 - rpar);\\\n   \\\n   set_parameters (tb, h, 0, to_r, rnver, NULL, -1, -1);\\\n}\\\nelse \\\n{\\\n   if (rset==RIGHT_SHIFT_FLOW)\\\n     set_parameters (tb, h, 0, rpar, rnver, snum012+rset,\\\n\t\t  -1, tb->rbytes);\\\n   else\\\n     set_parameters (tb, h, 0, rpar - (tb->rbytes!=-1), rnver, snum012+rset,\\\n\t\t  -1, -1);\\\n}",
      "#define SET_PAR_SHIFT_LEFT \\\nif (h)\\\n{\\\n   int to_l;\\\n   \\\n   to_l = (MAX_NR_KEY(Sh)+1 - lpar + vn->vn_nr_item + 1) / 2 -\\\n\t      (MAX_NR_KEY(Sh) + 1 - lpar);\\\n\t      \\\n\t      set_parameters (tb, h, to_l, 0, lnver, NULL, -1, -1);\\\n}\\\nelse \\\n{\\\n   if (lset==LEFT_SHIFT_FLOW)\\\n     set_parameters (tb, h, lpar, 0, lnver, snum012+lset,\\\n\t\t     tb->lbytes, -1);\\\n   else\\\n     set_parameters (tb, h, lpar - (tb->lbytes!=-1), 0, lnver, snum012+lset,\\\n\t\t     -1, -1);\\\n}"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_left_neighbor_in_cache",
          "args": [
            "tb",
            "h"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "is_left_neighbor_in_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "961-1003",
          "snippet": "static int is_left_neighbor_in_cache(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *father, *left;\n\tstruct super_block *sb = tb->tb_sb;\n\tb_blocknr_t left_neighbor_blocknr;\n\tint left_neighbor_position;\n\n\t/* Father of the left neighbor does not exist. */\n\tif (!tb->FL[h])\n\t\treturn 0;\n\n\t/* Calculate father of the node to be balanced. */\n\tfather = PATH_H_PBUFFER(tb->tb_path, h + 1);\n\n\tRFALSE(!father ||\n\t       !B_IS_IN_TREE(father) ||\n\t       !B_IS_IN_TREE(tb->FL[h]) ||\n\t       !buffer_uptodate(father) ||\n\t       !buffer_uptodate(tb->FL[h]),\n\t       \"vs-8165: F[h] (%b) or FL[h] (%b) is invalid\",\n\t       father, tb->FL[h]);\n\n\t/*\n\t * Get position of the pointer to the left neighbor\n\t * into the left father.\n\t */\n\tleft_neighbor_position = (father == tb->FL[h]) ?\n\t    tb->lkey[h] : B_NR_ITEMS(tb->FL[h]);\n\t/* Get left neighbor block number. */\n\tleft_neighbor_blocknr =\n\t    B_N_CHILD_NUM(tb->FL[h], left_neighbor_position);\n\t/* Look for the left neighbor in the cache. */\n\tif ((left = sb_find_get_block(sb, left_neighbor_blocknr))) {\n\n\t\tRFALSE(buffer_uptodate(left) && !B_IS_IN_TREE(left),\n\t\t       \"vs-8170: left neighbor (%b %z) is not in the tree\",\n\t\t       left, left);\n\t\tput_bh(left);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int is_left_neighbor_in_cache(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *father, *left;\n\tstruct super_block *sb = tb->tb_sb;\n\tb_blocknr_t left_neighbor_blocknr;\n\tint left_neighbor_position;\n\n\t/* Father of the left neighbor does not exist. */\n\tif (!tb->FL[h])\n\t\treturn 0;\n\n\t/* Calculate father of the node to be balanced. */\n\tfather = PATH_H_PBUFFER(tb->tb_path, h + 1);\n\n\tRFALSE(!father ||\n\t       !B_IS_IN_TREE(father) ||\n\t       !B_IS_IN_TREE(tb->FL[h]) ||\n\t       !buffer_uptodate(father) ||\n\t       !buffer_uptodate(tb->FL[h]),\n\t       \"vs-8165: F[h] (%b) or FL[h] (%b) is invalid\",\n\t       father, tb->FL[h]);\n\n\t/*\n\t * Get position of the pointer to the left neighbor\n\t * into the left father.\n\t */\n\tleft_neighbor_position = (father == tb->FL[h]) ?\n\t    tb->lkey[h] : B_NR_ITEMS(tb->FL[h]);\n\t/* Get left neighbor block number. */\n\tleft_neighbor_blocknr =\n\t    B_N_CHILD_NUM(tb->FL[h], left_neighbor_position);\n\t/* Look for the left neighbor in the cache. */\n\tif ((left = sb_find_get_block(sb, left_neighbor_blocknr))) {\n\n\t\tRFALSE(buffer_uptodate(left) && !B_IS_IN_TREE(left),\n\t\t       \"vs-8170: left neighbor (%b %z) is not in the tree\",\n\t\t       left, left);\n\t\tput_bh(left);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_parameters",
          "args": [
            "tb",
            "h",
            "0",
            "0",
            "nver",
            "snum012 + nset",
            "-1",
            "-1"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "set_parameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "623-648",
          "snippet": "static void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "h &&\n\t\t\t       (tb->lnum[h] != 1 ||\n\t\t\t\ttb->rnum[h] != 1 ||\n\t\t\t\tlrnver != 1 || rnver != 2 || lnver != 2\n\t\t\t\t|| h != 1)",
            "\"vs-8230: bad h\""
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_num_ver",
          "args": [
            "vn->vn_mode",
            "tb",
            "h",
            "lpar -\n\t\t\t\t\t      ((tb->lbytes != -1) ? 1 : 0)",
            "tb->lbytes",
            "(rpar -\n\t\t\t\t\t       ((tb->rbytes != -1) ? 1 : 0))",
            "tb->rbytes",
            "snum012 + LR_SHIFT_FLOW",
            "FLOW"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "get_num_ver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "374-601",
          "snippet": "static int get_num_ver(int mode, struct tree_balance *tb, int h,\n\t\t       int from, int from_bytes,\n\t\t       int to, int to_bytes, short *snum012, int flow)\n{\n\tint i;\n\tint cur_free;\n\tint units;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint total_node_size, max_node_size, current_item_size;\n\tint needed_nodes;\n\n\t/* position of item we start filling node from */\n\tint start_item;\n\n\t/* position of item we finish filling node by */\n\tint end_item;\n\n\t/*\n\t * number of first bytes (entries for directory) of start_item-th item\n\t * we do not include into node that is being filled\n\t */\n\tint start_bytes;\n\n\t/*\n\t * number of last bytes (entries for directory) of end_item-th item\n\t * we do node include into node that is being filled\n\t */\n\tint end_bytes;\n\n\t/*\n\t * these are positions in virtual item of items, that are split\n\t * between S[0] and S1new and S1new and S2new\n\t */\n\tint split_item_positions[2];\n\n\tsplit_item_positions[0] = -1;\n\tsplit_item_positions[1] = -1;\n\n\t/*\n\t * We only create additional nodes if we are in insert or paste mode\n\t * or we are in replace mode at the internal level. If h is 0 and\n\t * the mode is M_REPLACE then in fix_nodes we change the mode to\n\t * paste or insert before we get here in the code.\n\t */\n\tRFALSE(tb->insert_size[h] < 0 || (mode != M_INSERT && mode != M_PASTE),\n\t       \"vs-8100: insert_size < 0 in overflow\");\n\n\tmax_node_size = MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, h));\n\n\t/*\n\t * snum012 [0-2] - number of items, that lay\n\t * to S[0], first new node and second new node\n\t */\n\tsnum012[3] = -1;\t/* s1bytes */\n\tsnum012[4] = -1;\t/* s2bytes */\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ti = ((to - from) * (KEY_SIZE + DC_SIZE) + DC_SIZE);\n\t\tif (i == max_node_size)\n\t\t\treturn 1;\n\t\treturn (i / max_node_size + 1);\n\t}\n\n\t/* leaf level */\n\tneeded_nodes = 1;\n\ttotal_node_size = 0;\n\tcur_free = max_node_size;\n\n\t/* start from 'from'-th item */\n\tstart_item = from;\n\t/* skip its first 'start_bytes' units */\n\tstart_bytes = ((from_bytes != -1) ? from_bytes : 0);\n\n\t/* last included item is the 'end_item'-th one */\n\tend_item = vn->vn_nr_item - to - 1;\n\t/* do not count last 'end_bytes' units of 'end_item'-th item */\n\tend_bytes = (to_bytes != -1) ? to_bytes : 0;\n\n\t/*\n\t * go through all item beginning from the start_item-th item\n\t * and ending by the end_item-th item. Do not count first\n\t * 'start_bytes' units of 'start_item'-th item and last\n\t * 'end_bytes' of 'end_item'-th item\n\t */\n\tfor (i = start_item; i <= end_item; i++) {\n\t\tstruct virtual_item *vi = vn->vn_vi + i;\n\t\tint skip_from_end = ((i == end_item) ? end_bytes : 0);\n\n\t\tRFALSE(needed_nodes > 3, \"vs-8105: too many nodes are needed\");\n\n\t\t/* get size of current item */\n\t\tcurrent_item_size = vi->vi_item_len;\n\n\t\t/*\n\t\t * do not take in calculation head part (from_bytes)\n\t\t * of from-th item\n\t\t */\n\t\tcurrent_item_size -=\n\t\t    op_part_size(vi, 0 /*from start */ , start_bytes);\n\n\t\t/* do not take in calculation tail part of last item */\n\t\tcurrent_item_size -=\n\t\t    op_part_size(vi, 1 /*from end */ , skip_from_end);\n\n\t\t/* if item fits into current node entierly */\n\t\tif (total_node_size + current_item_size <= max_node_size) {\n\t\t\tsnum012[needed_nodes - 1]++;\n\t\t\ttotal_node_size += current_item_size;\n\t\t\tstart_bytes = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * virtual item length is longer, than max size of item in\n\t\t * a node. It is impossible for direct item\n\t\t */\n\t\tif (current_item_size > max_node_size) {\n\t\t\tRFALSE(is_direct_le_ih(vi->vi_ih),\n\t\t\t       \"vs-8110: \"\n\t\t\t       \"direct item length is %d. It can not be longer than %d\",\n\t\t\t       current_item_size, max_node_size);\n\t\t\t/* we will try to split it */\n\t\t\tflow = 1;\n\t\t}\n\n\t\t/* as we do not split items, take new node and continue */\n\t\tif (!flow) {\n\t\t\tneeded_nodes++;\n\t\t\ti--;\n\t\t\ttotal_node_size = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of item units which fit into node being\n\t\t * filled\n\t\t */\n\t\t{\n\t\t\tint free_space;\n\n\t\t\tfree_space = max_node_size - total_node_size - IH_SIZE;\n\t\t\tunits =\n\t\t\t    op_check_left(vi, free_space, start_bytes,\n\t\t\t\t\t  skip_from_end);\n\t\t\t/*\n\t\t\t * nothing fits into current node, take new\n\t\t\t * node and continue\n\t\t\t */\n\t\t\tif (units == -1) {\n\t\t\t\tneeded_nodes++, i--, total_node_size = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* something fits into the current node */\n\t\tstart_bytes += units;\n\t\tsnum012[needed_nodes - 1 + 3] = units;\n\n\t\tif (needed_nodes > 2)\n\t\t\treiserfs_warning(tb->tb_sb, \"vs-8111\",\n\t\t\t\t\t \"split_item_position is out of range\");\n\t\tsnum012[needed_nodes - 1]++;\n\t\tsplit_item_positions[needed_nodes - 1] = i;\n\t\tneeded_nodes++;\n\t\t/* continue from the same item with start_bytes != -1 */\n\t\tstart_item = i;\n\t\ti--;\n\t\ttotal_node_size = 0;\n\t}\n\n\t/*\n\t * sum012[4] (if it is not -1) contains number of units of which\n\t * are to be in S1new, snum012[3] - to be in S0. They are supposed\n\t * to be S1bytes and S2bytes correspondingly, so recalculate\n\t */\n\tif (snum012[4] > 0) {\n\t\tint split_item_num;\n\t\tint bytes_to_r, bytes_to_l;\n\t\tint bytes_to_S1new;\n\n\t\tsplit_item_num = split_item_positions[1];\n\t\tbytes_to_l =\n\t\t    ((from == split_item_num\n\t\t      && from_bytes != -1) ? from_bytes : 0);\n\t\tbytes_to_r =\n\t\t    ((end_item == split_item_num\n\t\t      && end_bytes != -1) ? end_bytes : 0);\n\t\tbytes_to_S1new =\n\t\t    ((split_item_positions[0] ==\n\t\t      split_item_positions[1]) ? snum012[3] : 0);\n\n\t\t/* s2bytes */\n\t\tsnum012[4] =\n\t\t    op_unit_num(&vn->vn_vi[split_item_num]) - snum012[4] -\n\t\t    bytes_to_r - bytes_to_l - bytes_to_S1new;\n\n\t\tif (vn->vn_vi[split_item_num].vi_index != TYPE_DIRENTRY &&\n\t\t    vn->vn_vi[split_item_num].vi_index != TYPE_INDIRECT)\n\t\t\treiserfs_warning(tb->tb_sb, \"vs-8115\",\n\t\t\t\t\t \"not directory or indirect item\");\n\t}\n\n\t/* now we know S2bytes, calculate S1bytes */\n\tif (snum012[3] > 0) {\n\t\tint split_item_num;\n\t\tint bytes_to_r, bytes_to_l;\n\t\tint bytes_to_S2new;\n\n\t\tsplit_item_num = split_item_positions[0];\n\t\tbytes_to_l =\n\t\t    ((from == split_item_num\n\t\t      && from_bytes != -1) ? from_bytes : 0);\n\t\tbytes_to_r =\n\t\t    ((end_item == split_item_num\n\t\t      && end_bytes != -1) ? end_bytes : 0);\n\t\tbytes_to_S2new =\n\t\t    ((split_item_positions[0] == split_item_positions[1]\n\t\t      && snum012[4] != -1) ? snum012[4] : 0);\n\n\t\t/* s1bytes */\n\t\tsnum012[3] =\n\t\t    op_unit_num(&vn->vn_vi[split_item_num]) - snum012[3] -\n\t\t    bytes_to_r - bytes_to_l - bytes_to_S2new;\n\t}\n\n\treturn needed_nodes;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_num_ver(int mode, struct tree_balance *tb, int h,\n\t\t       int from, int from_bytes,\n\t\t       int to, int to_bytes, short *snum012, int flow)\n{\n\tint i;\n\tint cur_free;\n\tint units;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint total_node_size, max_node_size, current_item_size;\n\tint needed_nodes;\n\n\t/* position of item we start filling node from */\n\tint start_item;\n\n\t/* position of item we finish filling node by */\n\tint end_item;\n\n\t/*\n\t * number of first bytes (entries for directory) of start_item-th item\n\t * we do not include into node that is being filled\n\t */\n\tint start_bytes;\n\n\t/*\n\t * number of last bytes (entries for directory) of end_item-th item\n\t * we do node include into node that is being filled\n\t */\n\tint end_bytes;\n\n\t/*\n\t * these are positions in virtual item of items, that are split\n\t * between S[0] and S1new and S1new and S2new\n\t */\n\tint split_item_positions[2];\n\n\tsplit_item_positions[0] = -1;\n\tsplit_item_positions[1] = -1;\n\n\t/*\n\t * We only create additional nodes if we are in insert or paste mode\n\t * or we are in replace mode at the internal level. If h is 0 and\n\t * the mode is M_REPLACE then in fix_nodes we change the mode to\n\t * paste or insert before we get here in the code.\n\t */\n\tRFALSE(tb->insert_size[h] < 0 || (mode != M_INSERT && mode != M_PASTE),\n\t       \"vs-8100: insert_size < 0 in overflow\");\n\n\tmax_node_size = MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, h));\n\n\t/*\n\t * snum012 [0-2] - number of items, that lay\n\t * to S[0], first new node and second new node\n\t */\n\tsnum012[3] = -1;\t/* s1bytes */\n\tsnum012[4] = -1;\t/* s2bytes */\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ti = ((to - from) * (KEY_SIZE + DC_SIZE) + DC_SIZE);\n\t\tif (i == max_node_size)\n\t\t\treturn 1;\n\t\treturn (i / max_node_size + 1);\n\t}\n\n\t/* leaf level */\n\tneeded_nodes = 1;\n\ttotal_node_size = 0;\n\tcur_free = max_node_size;\n\n\t/* start from 'from'-th item */\n\tstart_item = from;\n\t/* skip its first 'start_bytes' units */\n\tstart_bytes = ((from_bytes != -1) ? from_bytes : 0);\n\n\t/* last included item is the 'end_item'-th one */\n\tend_item = vn->vn_nr_item - to - 1;\n\t/* do not count last 'end_bytes' units of 'end_item'-th item */\n\tend_bytes = (to_bytes != -1) ? to_bytes : 0;\n\n\t/*\n\t * go through all item beginning from the start_item-th item\n\t * and ending by the end_item-th item. Do not count first\n\t * 'start_bytes' units of 'start_item'-th item and last\n\t * 'end_bytes' of 'end_item'-th item\n\t */\n\tfor (i = start_item; i <= end_item; i++) {\n\t\tstruct virtual_item *vi = vn->vn_vi + i;\n\t\tint skip_from_end = ((i == end_item) ? end_bytes : 0);\n\n\t\tRFALSE(needed_nodes > 3, \"vs-8105: too many nodes are needed\");\n\n\t\t/* get size of current item */\n\t\tcurrent_item_size = vi->vi_item_len;\n\n\t\t/*\n\t\t * do not take in calculation head part (from_bytes)\n\t\t * of from-th item\n\t\t */\n\t\tcurrent_item_size -=\n\t\t    op_part_size(vi, 0 /*from start */ , start_bytes);\n\n\t\t/* do not take in calculation tail part of last item */\n\t\tcurrent_item_size -=\n\t\t    op_part_size(vi, 1 /*from end */ , skip_from_end);\n\n\t\t/* if item fits into current node entierly */\n\t\tif (total_node_size + current_item_size <= max_node_size) {\n\t\t\tsnum012[needed_nodes - 1]++;\n\t\t\ttotal_node_size += current_item_size;\n\t\t\tstart_bytes = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * virtual item length is longer, than max size of item in\n\t\t * a node. It is impossible for direct item\n\t\t */\n\t\tif (current_item_size > max_node_size) {\n\t\t\tRFALSE(is_direct_le_ih(vi->vi_ih),\n\t\t\t       \"vs-8110: \"\n\t\t\t       \"direct item length is %d. It can not be longer than %d\",\n\t\t\t       current_item_size, max_node_size);\n\t\t\t/* we will try to split it */\n\t\t\tflow = 1;\n\t\t}\n\n\t\t/* as we do not split items, take new node and continue */\n\t\tif (!flow) {\n\t\t\tneeded_nodes++;\n\t\t\ti--;\n\t\t\ttotal_node_size = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of item units which fit into node being\n\t\t * filled\n\t\t */\n\t\t{\n\t\t\tint free_space;\n\n\t\t\tfree_space = max_node_size - total_node_size - IH_SIZE;\n\t\t\tunits =\n\t\t\t    op_check_left(vi, free_space, start_bytes,\n\t\t\t\t\t  skip_from_end);\n\t\t\t/*\n\t\t\t * nothing fits into current node, take new\n\t\t\t * node and continue\n\t\t\t */\n\t\t\tif (units == -1) {\n\t\t\t\tneeded_nodes++, i--, total_node_size = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* something fits into the current node */\n\t\tstart_bytes += units;\n\t\tsnum012[needed_nodes - 1 + 3] = units;\n\n\t\tif (needed_nodes > 2)\n\t\t\treiserfs_warning(tb->tb_sb, \"vs-8111\",\n\t\t\t\t\t \"split_item_position is out of range\");\n\t\tsnum012[needed_nodes - 1]++;\n\t\tsplit_item_positions[needed_nodes - 1] = i;\n\t\tneeded_nodes++;\n\t\t/* continue from the same item with start_bytes != -1 */\n\t\tstart_item = i;\n\t\ti--;\n\t\ttotal_node_size = 0;\n\t}\n\n\t/*\n\t * sum012[4] (if it is not -1) contains number of units of which\n\t * are to be in S1new, snum012[3] - to be in S0. They are supposed\n\t * to be S1bytes and S2bytes correspondingly, so recalculate\n\t */\n\tif (snum012[4] > 0) {\n\t\tint split_item_num;\n\t\tint bytes_to_r, bytes_to_l;\n\t\tint bytes_to_S1new;\n\n\t\tsplit_item_num = split_item_positions[1];\n\t\tbytes_to_l =\n\t\t    ((from == split_item_num\n\t\t      && from_bytes != -1) ? from_bytes : 0);\n\t\tbytes_to_r =\n\t\t    ((end_item == split_item_num\n\t\t      && end_bytes != -1) ? end_bytes : 0);\n\t\tbytes_to_S1new =\n\t\t    ((split_item_positions[0] ==\n\t\t      split_item_positions[1]) ? snum012[3] : 0);\n\n\t\t/* s2bytes */\n\t\tsnum012[4] =\n\t\t    op_unit_num(&vn->vn_vi[split_item_num]) - snum012[4] -\n\t\t    bytes_to_r - bytes_to_l - bytes_to_S1new;\n\n\t\tif (vn->vn_vi[split_item_num].vi_index != TYPE_DIRENTRY &&\n\t\t    vn->vn_vi[split_item_num].vi_index != TYPE_INDIRECT)\n\t\t\treiserfs_warning(tb->tb_sb, \"vs-8115\",\n\t\t\t\t\t \"not directory or indirect item\");\n\t}\n\n\t/* now we know S2bytes, calculate S1bytes */\n\tif (snum012[3] > 0) {\n\t\tint split_item_num;\n\t\tint bytes_to_r, bytes_to_l;\n\t\tint bytes_to_S2new;\n\n\t\tsplit_item_num = split_item_positions[0];\n\t\tbytes_to_l =\n\t\t    ((from == split_item_num\n\t\t      && from_bytes != -1) ? from_bytes : 0);\n\t\tbytes_to_r =\n\t\t    ((end_item == split_item_num\n\t\t      && end_bytes != -1) ? end_bytes : 0);\n\t\tbytes_to_S2new =\n\t\t    ((split_item_positions[0] == split_item_positions[1]\n\t\t      && snum012[4] != -1) ? snum012[4] : 0);\n\n\t\t/* s1bytes */\n\t\tsnum012[3] =\n\t\t    op_unit_num(&vn->vn_vi[split_item_num]) - snum012[3] -\n\t\t    bytes_to_r - bytes_to_l - bytes_to_S2new;\n\t}\n\n\treturn needed_nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_leaf_removable",
          "args": [
            "tb"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "is_leaf_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "654-695",
          "snippet": "static int is_leaf_removable(struct tree_balance *tb)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint to_left, to_right;\n\tint size;\n\tint remain_items;\n\n\t/*\n\t * number of items that will be shifted to left (right) neighbor\n\t * entirely\n\t */\n\tto_left = tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0);\n\tto_right = tb->rnum[0] - ((tb->rbytes != -1) ? 1 : 0);\n\tremain_items = vn->vn_nr_item;\n\n\t/* how many items remain in S[0] after shiftings to neighbors */\n\tremain_items -= (to_left + to_right);\n\n\t/* all content of node can be shifted to neighbors */\n\tif (remain_items < 1) {\n\t\tset_parameters(tb, 0, to_left, vn->vn_nr_item - to_left, 0,\n\t\t\t       NULL, -1, -1);\n\t\treturn 1;\n\t}\n\n\t/* S[0] is not removable */\n\tif (remain_items > 1 || tb->lbytes == -1 || tb->rbytes == -1)\n\t\treturn 0;\n\n\t/* check whether we can divide 1 remaining item between neighbors */\n\n\t/* get size of remaining item (in item units) */\n\tsize = op_unit_num(&vn->vn_vi[to_left]);\n\n\tif (tb->lbytes + tb->rbytes >= size) {\n\t\tset_parameters(tb, 0, to_left + 1, to_right + 1, 0, NULL,\n\t\t\t       tb->lbytes, -1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int is_leaf_removable(struct tree_balance *tb)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint to_left, to_right;\n\tint size;\n\tint remain_items;\n\n\t/*\n\t * number of items that will be shifted to left (right) neighbor\n\t * entirely\n\t */\n\tto_left = tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0);\n\tto_right = tb->rnum[0] - ((tb->rbytes != -1) ? 1 : 0);\n\tremain_items = vn->vn_nr_item;\n\n\t/* how many items remain in S[0] after shiftings to neighbors */\n\tremain_items -= (to_left + to_right);\n\n\t/* all content of node can be shifted to neighbors */\n\tif (remain_items < 1) {\n\t\tset_parameters(tb, 0, to_left, vn->vn_nr_item - to_left, 0,\n\t\t\t       NULL, -1, -1);\n\t\treturn 1;\n\t}\n\n\t/* S[0] is not removable */\n\tif (remain_items > 1 || tb->lbytes == -1 || tb->rbytes == -1)\n\t\treturn 0;\n\n\t/* check whether we can divide 1 remaining item between neighbors */\n\n\t/* get size of remaining item (in item units) */\n\tsize = op_unit_num(&vn->vn_vi[to_left]);\n\n\tif (tb->lbytes + tb->rbytes >= size) {\n\t\tset_parameters(tb, 0, to_left + 1, to_right + 1, 0, NULL,\n\t\t\t       tb->lbytes, -1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!h && ((tb->lnum[h] >= vn->vn_nr_item && (tb->lbytes == -1)) ||\n\t\t      (tb->rnum[h] >= vn->vn_nr_item && (tb->rbytes == -1)))",
            "\"vs-8225: tree is not balanced on leaf level\""
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "h &&\n\t       (tb->lnum[h] >= vn->vn_nr_item + 1 ||\n\t\ttb->rnum[h] >= vn->vn_nr_item + 1)",
            "\"vs-8220: tree is not balanced on internal level\""
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_NR_KEY",
          "args": [
            "Sh"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_NR_KEY",
          "args": [
            "Sh"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_right",
          "args": [
            "tb",
            "h",
            "rfree"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "check_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "280-364",
          "snippet": "static void check_right(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8070: cur_free < 0\");\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->rnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space  */\n\t\ttb->rnum[h] = 0;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8075: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi + vn->vn_nr_item - 1;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_RIGHT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into R[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8080: invalid mode or balance condition failed\");\n\n\t\ttb->rnum[h] = vn->vn_nr_item;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* last item may be merge with first item in right neighbor */\n\tif (vi->vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\td_size = -(int)IH_SIZE, ih_size = 0;\n\n\ttb->rnum[0] = 0;\n\tfor (i = vn->vn_nr_item - 1; i >= 0;\n\t     i--, d_size = 0, ih_size = IH_SIZE, vi--) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->rnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * check whether R[0] can hold ih and at least one\n\t\t * byte of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->rbytes = -1;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * R[0] can hold the header of the item and at least\n\t\t * one byte of its body\n\t\t */\n\t\tcur_free -= ih_size;\t/* cur_free is still > 0 */\n\n\t\ttb->rbytes = op_check_right(vi, cur_free);\n\t\tif (tb->rbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->rnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void check_right(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8070: cur_free < 0\");\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->rnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space  */\n\t\ttb->rnum[h] = 0;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8075: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi + vn->vn_nr_item - 1;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_RIGHT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into R[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8080: invalid mode or balance condition failed\");\n\n\t\ttb->rnum[h] = vn->vn_nr_item;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* last item may be merge with first item in right neighbor */\n\tif (vi->vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\td_size = -(int)IH_SIZE, ih_size = 0;\n\n\ttb->rnum[0] = 0;\n\tfor (i = vn->vn_nr_item - 1; i >= 0;\n\t     i--, d_size = 0, ih_size = IH_SIZE, vi--) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->rnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * check whether R[0] can hold ih and at least one\n\t\t * byte of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->rbytes = -1;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * R[0] can hold the header of the item and at least\n\t\t * one byte of its body\n\t\t */\n\t\tcur_free -= ih_size;\t/* cur_free is still > 0 */\n\n\t\ttb->rbytes = op_check_right(vi, cur_free);\n\t\tif (tb->rbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->rnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_left",
          "args": [
            "tb",
            "h",
            "lfree"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "check_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "194-274",
          "snippet": "static void check_left(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8050: cur_free (%d) < 0\", cur_free);\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->lnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space or nothing to move */\n\t\ttb->lnum[h] = 0;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8055: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_LEFT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into L[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8055: invalid mode or balance condition failed\");\n\n\t\ttb->lnum[0] = vn->vn_nr_item;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* first item may be merge with last item in left neighbor */\n\tif (vi->vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\td_size = -((int)IH_SIZE), ih_size = 0;\n\n\ttb->lnum[0] = 0;\n\tfor (i = 0; i < vn->vn_nr_item;\n\t     i++, ih_size = IH_SIZE, d_size = 0, vi++) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->lnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* the item cannot be shifted entirely, try to split it */\n\t\t/*\n\t\t * check whether L[0] can hold ih and at least one byte\n\t\t * of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->lbytes = -1;\n\t\t\treturn;\n\t\t}\n\t\tcur_free -= ih_size;\n\n\t\ttb->lbytes = op_check_left(vi, cur_free, 0, 0);\n\t\tif (tb->lbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->lnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void check_left(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8050: cur_free (%d) < 0\", cur_free);\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->lnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space or nothing to move */\n\t\ttb->lnum[h] = 0;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8055: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_LEFT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into L[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8055: invalid mode or balance condition failed\");\n\n\t\ttb->lnum[0] = vn->vn_nr_item;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* first item may be merge with last item in left neighbor */\n\tif (vi->vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\td_size = -((int)IH_SIZE), ih_size = 0;\n\n\ttb->lnum[0] = 0;\n\tfor (i = 0; i < vn->vn_nr_item;\n\t     i++, ih_size = IH_SIZE, d_size = 0, vi++) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->lnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* the item cannot be shifted entirely, try to split it */\n\t\t/*\n\t\t * check whether L[0] can hold ih and at least one byte\n\t\t * of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->lbytes = -1;\n\t\t\treturn;\n\t\t}\n\t\tcur_free -= ih_size;\n\n\t\ttb->lbytes = op_check_left(vi, cur_free, 0, 0);\n\t\tif (tb->lbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->lnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_virtual_node",
          "args": [
            "tb",
            "h"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "create_virtual_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "51-188",
          "snippet": "static void create_virtual_node(struct tree_balance *tb, int h)\n{\n\tstruct item_head *ih;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint new_num;\n\tstruct buffer_head *Sh;\t/* this comes from tb->S[h] */\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\n\t/* size of changed node */\n\tvn->vn_size =\n\t    MAX_CHILD_SIZE(Sh) - B_FREE_SPACE(Sh) + tb->insert_size[h];\n\n\t/* for internal nodes array if virtual items is not created */\n\tif (h) {\n\t\tvn->vn_nr_item = (vn->vn_size - DC_SIZE) / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* number of items in virtual node  */\n\tvn->vn_nr_item =\n\t    B_NR_ITEMS(Sh) + ((vn->vn_mode == M_INSERT) ? 1 : 0) -\n\t    ((vn->vn_mode == M_DELETE) ? 1 : 0);\n\n\t/* first virtual item */\n\tvn->vn_vi = (struct virtual_item *)(tb->tb_vn + 1);\n\tmemset(vn->vn_vi, 0, vn->vn_nr_item * sizeof(struct virtual_item));\n\tvn->vn_free_ptr += vn->vn_nr_item * sizeof(struct virtual_item);\n\n\t/* first item in the node */\n\tih = item_head(Sh, 0);\n\n\t/* define the mergeability for 0-th item (if it is not being deleted) */\n\tif (op_is_left_mergeable(&ih->ih_key, Sh->b_size)\n\t    && (vn->vn_mode != M_DELETE || vn->vn_affected_item_num))\n\t\tvn->vn_vi[0].vi_type |= VI_TYPE_LEFT_MERGEABLE;\n\n\t/*\n\t * go through all items that remain in the virtual\n\t * node (except for the new (inserted) one)\n\t */\n\tfor (new_num = 0; new_num < vn->vn_nr_item; new_num++) {\n\t\tint j;\n\t\tstruct virtual_item *vi = vn->vn_vi + new_num;\n\t\tint is_affected =\n\t\t    ((new_num != vn->vn_affected_item_num) ? 0 : 1);\n\n\t\tif (is_affected && vn->vn_mode == M_INSERT)\n\t\t\tcontinue;\n\n\t\t/* get item number in source node */\n\t\tj = old_item_num(new_num, vn->vn_affected_item_num,\n\t\t\t\t vn->vn_mode);\n\n\t\tvi->vi_item_len += ih_item_len(ih + j) + IH_SIZE;\n\t\tvi->vi_ih = ih + j;\n\t\tvi->vi_item = ih_item_body(Sh, ih + j);\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\t/*\n\t\t * FIXME: there is no check that item operation did not\n\t\t * consume too much memory\n\t\t */\n\t\tvn->vn_free_ptr +=\n\t\t    op_create_vi(vn, vi, is_affected, tb->insert_size[0]);\n\t\tif (tb->vn_buf + tb->vn_buf_size < vn->vn_free_ptr)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8030\",\n\t\t\t\t       \"virtual node space consumed\");\n\n\t\tif (!is_affected)\n\t\t\t/* this is not being changed */\n\t\t\tcontinue;\n\n\t\tif (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT) {\n\t\t\tvn->vn_vi[new_num].vi_item_len += tb->insert_size[0];\n\t\t\t/* pointer to data which is going to be pasted */\n\t\t\tvi->vi_new_data = vn->vn_data;\n\t\t}\n\t}\n\n\t/* virtual inserted item is not defined yet */\n\tif (vn->vn_mode == M_INSERT) {\n\t\tstruct virtual_item *vi = vn->vn_vi + vn->vn_affected_item_num;\n\n\t\tRFALSE(vn->vn_ins_ih == NULL,\n\t\t       \"vs-8040: item header of inserted item is not specified\");\n\t\tvi->vi_item_len = tb->insert_size[0];\n\t\tvi->vi_ih = vn->vn_ins_ih;\n\t\tvi->vi_item = vn->vn_data;\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\top_create_vi(vn, vi, 0 /*not pasted or cut */ ,\n\t\t\t     tb->insert_size[0]);\n\t}\n\n\t/*\n\t * set right merge flag we take right delimiting key and\n\t * check whether it is a mergeable item\n\t */\n\tif (tb->CFR[0]) {\n\t\tstruct reiserfs_key *key;\n\n\t\tkey = internal_key(tb->CFR[0], tb->rkey[0]);\n\t\tif (op_is_left_mergeable(key, Sh->b_size)\n\t\t    && (vn->vn_mode != M_DELETE\n\t\t\t|| vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1))\n\t\t\tvn->vn_vi[vn->vn_nr_item - 1].vi_type |=\n\t\t\t    VI_TYPE_RIGHT_MERGEABLE;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (op_is_left_mergeable(key, Sh->b_size) &&\n\t\t    !(vn->vn_mode != M_DELETE\n\t\t      || vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1)) {\n\t\t\t/*\n\t\t\t * we delete last item and it could be merged\n\t\t\t * with right neighbor's first item\n\t\t\t */\n\t\t\tif (!\n\t\t\t    (B_NR_ITEMS(Sh) == 1\n\t\t\t     && is_direntry_le_ih(item_head(Sh, 0))\n\t\t\t     && ih_entry_count(item_head(Sh, 0)) == 1)) {\n\t\t\t\t/*\n\t\t\t\t * node contains more than 1 item, or item\n\t\t\t\t * is not directory item, or this item\n\t\t\t\t * contains more than 1 entry\n\t\t\t\t */\n\t\t\t\tprint_block(Sh, 0, -1, -1);\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-8045\",\n\t\t\t\t\t       \"rdkey %k, affected item==%d \"\n\t\t\t\t\t       \"(mode==%c) Must be %c\",\n\t\t\t\t\t       key, vn->vn_affected_item_num,\n\t\t\t\t\t       vn->vn_mode, M_DELETE);\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void create_virtual_node(struct tree_balance *tb, int h)\n{\n\tstruct item_head *ih;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint new_num;\n\tstruct buffer_head *Sh;\t/* this comes from tb->S[h] */\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\n\t/* size of changed node */\n\tvn->vn_size =\n\t    MAX_CHILD_SIZE(Sh) - B_FREE_SPACE(Sh) + tb->insert_size[h];\n\n\t/* for internal nodes array if virtual items is not created */\n\tif (h) {\n\t\tvn->vn_nr_item = (vn->vn_size - DC_SIZE) / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* number of items in virtual node  */\n\tvn->vn_nr_item =\n\t    B_NR_ITEMS(Sh) + ((vn->vn_mode == M_INSERT) ? 1 : 0) -\n\t    ((vn->vn_mode == M_DELETE) ? 1 : 0);\n\n\t/* first virtual item */\n\tvn->vn_vi = (struct virtual_item *)(tb->tb_vn + 1);\n\tmemset(vn->vn_vi, 0, vn->vn_nr_item * sizeof(struct virtual_item));\n\tvn->vn_free_ptr += vn->vn_nr_item * sizeof(struct virtual_item);\n\n\t/* first item in the node */\n\tih = item_head(Sh, 0);\n\n\t/* define the mergeability for 0-th item (if it is not being deleted) */\n\tif (op_is_left_mergeable(&ih->ih_key, Sh->b_size)\n\t    && (vn->vn_mode != M_DELETE || vn->vn_affected_item_num))\n\t\tvn->vn_vi[0].vi_type |= VI_TYPE_LEFT_MERGEABLE;\n\n\t/*\n\t * go through all items that remain in the virtual\n\t * node (except for the new (inserted) one)\n\t */\n\tfor (new_num = 0; new_num < vn->vn_nr_item; new_num++) {\n\t\tint j;\n\t\tstruct virtual_item *vi = vn->vn_vi + new_num;\n\t\tint is_affected =\n\t\t    ((new_num != vn->vn_affected_item_num) ? 0 : 1);\n\n\t\tif (is_affected && vn->vn_mode == M_INSERT)\n\t\t\tcontinue;\n\n\t\t/* get item number in source node */\n\t\tj = old_item_num(new_num, vn->vn_affected_item_num,\n\t\t\t\t vn->vn_mode);\n\n\t\tvi->vi_item_len += ih_item_len(ih + j) + IH_SIZE;\n\t\tvi->vi_ih = ih + j;\n\t\tvi->vi_item = ih_item_body(Sh, ih + j);\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\t/*\n\t\t * FIXME: there is no check that item operation did not\n\t\t * consume too much memory\n\t\t */\n\t\tvn->vn_free_ptr +=\n\t\t    op_create_vi(vn, vi, is_affected, tb->insert_size[0]);\n\t\tif (tb->vn_buf + tb->vn_buf_size < vn->vn_free_ptr)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8030\",\n\t\t\t\t       \"virtual node space consumed\");\n\n\t\tif (!is_affected)\n\t\t\t/* this is not being changed */\n\t\t\tcontinue;\n\n\t\tif (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT) {\n\t\t\tvn->vn_vi[new_num].vi_item_len += tb->insert_size[0];\n\t\t\t/* pointer to data which is going to be pasted */\n\t\t\tvi->vi_new_data = vn->vn_data;\n\t\t}\n\t}\n\n\t/* virtual inserted item is not defined yet */\n\tif (vn->vn_mode == M_INSERT) {\n\t\tstruct virtual_item *vi = vn->vn_vi + vn->vn_affected_item_num;\n\n\t\tRFALSE(vn->vn_ins_ih == NULL,\n\t\t       \"vs-8040: item header of inserted item is not specified\");\n\t\tvi->vi_item_len = tb->insert_size[0];\n\t\tvi->vi_ih = vn->vn_ins_ih;\n\t\tvi->vi_item = vn->vn_data;\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\top_create_vi(vn, vi, 0 /*not pasted or cut */ ,\n\t\t\t     tb->insert_size[0]);\n\t}\n\n\t/*\n\t * set right merge flag we take right delimiting key and\n\t * check whether it is a mergeable item\n\t */\n\tif (tb->CFR[0]) {\n\t\tstruct reiserfs_key *key;\n\n\t\tkey = internal_key(tb->CFR[0], tb->rkey[0]);\n\t\tif (op_is_left_mergeable(key, Sh->b_size)\n\t\t    && (vn->vn_mode != M_DELETE\n\t\t\t|| vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1))\n\t\t\tvn->vn_vi[vn->vn_nr_item - 1].vi_type |=\n\t\t\t    VI_TYPE_RIGHT_MERGEABLE;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (op_is_left_mergeable(key, Sh->b_size) &&\n\t\t    !(vn->vn_mode != M_DELETE\n\t\t      || vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1)) {\n\t\t\t/*\n\t\t\t * we delete last item and it could be merged\n\t\t\t * with right neighbor's first item\n\t\t\t */\n\t\t\tif (!\n\t\t\t    (B_NR_ITEMS(Sh) == 1\n\t\t\t     && is_direntry_le_ih(item_head(Sh, 0))\n\t\t\t     && ih_entry_count(item_head(Sh, 0)) == 1)) {\n\t\t\t\t/*\n\t\t\t\t * node contains more than 1 item, or item\n\t\t\t\t * is not directory item, or this item\n\t\t\t\t * contains more than 1 entry\n\t\t\t\t */\n\t\t\t\tprint_block(Sh, 0, -1, -1);\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-8045\",\n\t\t\t\t\t       \"rdkey %k, affected item==%d \"\n\t\t\t\t\t       \"(mode==%c) Must be %c\",\n\t\t\t\t\t       key, vn->vn_affected_item_num,\n\t\t\t\t\t       vn->vn_mode, M_DELETE);\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_node_be_removed",
          "args": [
            "vn->vn_mode",
            "lfree",
            "sfree",
            "rfree",
            "tb",
            "h"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "can_node_be_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "1275-1309",
          "snippet": "static inline int can_node_be_removed(int mode, int lfree, int sfree, int rfree,\n\t\t\t\t      struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *Sh = PATH_H_PBUFFER(tb->tb_path, h);\n\tint levbytes = tb->insert_size[h];\n\tstruct item_head *ih;\n\tstruct reiserfs_key *r_key = NULL;\n\n\tih = item_head(Sh, 0);\n\tif (tb->CFR[h])\n\t\tr_key = internal_key(tb->CFR[h], tb->rkey[h]);\n\n\tif (lfree + rfree + sfree < MAX_CHILD_SIZE(Sh) + levbytes\n\t    /* shifting may merge items which might save space */\n\t    -\n\t    ((!h\n\t      && op_is_left_mergeable(&ih->ih_key, Sh->b_size)) ? IH_SIZE : 0)\n\t    -\n\t    ((!h && r_key\n\t      && op_is_left_mergeable(r_key, Sh->b_size)) ? IH_SIZE : 0)\n\t    + ((h) ? KEY_SIZE : 0)) {\n\t\t/* node can not be removed */\n\t\tif (sfree >= levbytes) {\n\t\t\t/* new item fits into node S[h] without any shifting */\n\t\t\tif (!h)\n\t\t\t\ttb->s0num =\n\t\t\t\t    B_NR_ITEMS(Sh) +\n\t\t\t\t    ((mode == M_INSERT) ? 1 : 0);\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\t\t}\n\t}\n\tPROC_INFO_INC(tb->tb_sb, can_node_be_removed[h]);\n\treturn !NO_BALANCING_NEEDED;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic inline int can_node_be_removed(int mode, int lfree, int sfree, int rfree,\n\t\t\t\t      struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *Sh = PATH_H_PBUFFER(tb->tb_path, h);\n\tint levbytes = tb->insert_size[h];\n\tstruct item_head *ih;\n\tstruct reiserfs_key *r_key = NULL;\n\n\tih = item_head(Sh, 0);\n\tif (tb->CFR[h])\n\t\tr_key = internal_key(tb->CFR[h], tb->rkey[h]);\n\n\tif (lfree + rfree + sfree < MAX_CHILD_SIZE(Sh) + levbytes\n\t    /* shifting may merge items which might save space */\n\t    -\n\t    ((!h\n\t      && op_is_left_mergeable(&ih->ih_key, Sh->b_size)) ? IH_SIZE : 0)\n\t    -\n\t    ((!h && r_key\n\t      && op_is_left_mergeable(r_key, Sh->b_size)) ? IH_SIZE : 0)\n\t    + ((h) ? KEY_SIZE : 0)) {\n\t\t/* node can not be removed */\n\t\tif (sfree >= levbytes) {\n\t\t\t/* new item fits into node S[h] without any shifting */\n\t\t\tif (!h)\n\t\t\t\ttb->s0num =\n\t\t\t\t    B_NR_ITEMS(Sh) +\n\t\t\t\t    ((mode == M_INSERT) ? 1 : 0);\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\t\t}\n\t}\n\tPROC_INFO_INC(tb->tb_sb, can_node_be_removed[h]);\n\treturn !NO_BALANCING_NEEDED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lfree",
          "args": [
            "tb",
            "h"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "get_lfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "917-934",
          "snippet": "static int get_lfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *l, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (l = tb->FL[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == l)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) - 1;\n\telse {\n\t\torder = B_NR_ITEMS(l);\n\t\tf = l;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_lfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *l, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (l = tb->FL[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == l)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) - 1;\n\telse {\n\t\torder = B_NR_ITEMS(l);\n\t\tf = l;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfree",
          "args": [
            "tb",
            "h"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "940-958",
          "snippet": "static int get_rfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *r, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (r = tb->FR[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == r)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) + 1;\n\telse {\n\t\torder = 0;\n\t\tf = r;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_rfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *r, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (r = tb->FR[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == r)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) + 1;\n\telse {\n\t\torder = 0;\n\t\tf = r;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "Sh"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_parents",
          "args": [
            "tb",
            "h"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "get_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "1174-1269",
          "snippet": "static int get_parents(struct tree_balance *tb, int h)\n{\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    ret,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\tstruct buffer_head *curf, *curcf;\n\n\t/* Current node is the root of the tree or will be root of the tree */\n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\t\t/*\n\t\t * The root can not have parents.\n\t\t * Release nodes which previously were obtained as\n\t\t * parents of the current node neighbors.\n\t\t */\n\t\tbrelse(tb->FL[h]);\n\t\tbrelse(tb->CFL[h]);\n\t\tbrelse(tb->FR[h]);\n\t\tbrelse(tb->CFR[h]);\n\t\ttb->FL[h]  = NULL;\n\t\ttb->CFL[h] = NULL;\n\t\ttb->FR[h]  = NULL;\n\t\ttb->CFR[h] = NULL;\n\t\treturn CARRY_ON;\n\t}\n\n\t/* Get parent FL[path_offset] of L[path_offset]. */\n\tposition = PATH_OFFSET_POSITION(path, path_offset - 1);\n\tif (position) {\n\t\t/* Current node is not the first child of its parent. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->lkey[h] = position - 1;\n\t} else {\n\t\t/*\n\t\t * Calculate current parent of L[path_offset], which is the\n\t\t * left neighbor of the current node.  Calculate current\n\t\t * common parent of L[path_offset] and the current node.\n\t\t * Note that CFL[path_offset] not equal FL[path_offset] and\n\t\t * CFL[path_offset] not equal F[path_offset].\n\t\t * Calculate lkey[path_offset].\n\t\t */\n\t\tif ((ret = get_far_parent(tb, h + 1, &curf,\n\t\t\t\t\t\t  &curcf,\n\t\t\t\t\t\t  LEFT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t}\n\n\tbrelse(tb->FL[h]);\n\ttb->FL[h] = curf;\t/* New initialization of FL[h]. */\n\tbrelse(tb->CFL[h]);\n\ttb->CFL[h] = curcf;\t/* New initialization of CFL[h]. */\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8195: FL (%b) or CFL (%b) is invalid\", curf, curcf);\n\n\t/* Get parent FR[h] of R[h]. */\n\n\t/* Current node is the last child of F[h]. FR[h] != F[h]. */\n\tif (position == B_NR_ITEMS(PATH_H_PBUFFER(path, h + 1))) {\n\t\t/*\n\t\t * Calculate current parent of R[h], which is the right\n\t\t * neighbor of F[h].  Calculate current common parent of\n\t\t * R[h] and current node. Note that CFR[h] not equal\n\t\t * FR[path_offset] and CFR[h] not equal F[h].\n\t\t */\n\t\tif ((ret =\n\t\t     get_far_parent(tb, h + 1, &curf, &curcf,\n\t\t\t\t    RIGHT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t} else {\n\t\t/* Current node is not the last child of its parent F[h]. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->rkey[h] = position;\n\t}\n\n\tbrelse(tb->FR[h]);\n\t/* New initialization of FR[path_offset]. */\n\ttb->FR[h] = curf;\n\n\tbrelse(tb->CFR[h]);\n\t/* New initialization of CFR[path_offset]. */\n\ttb->CFR[h] = curcf;\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8205: FR (%b) or CFR (%b) is invalid\", curf, curcf);\n\n\treturn CARRY_ON;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define RIGHT_PARENTS 'r'",
            "#define LEFT_PARENTS  'l'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#define RIGHT_PARENTS 'r'\n#define LEFT_PARENTS  'l'\n\nstatic int get_parents(struct tree_balance *tb, int h)\n{\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    ret,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\tstruct buffer_head *curf, *curcf;\n\n\t/* Current node is the root of the tree or will be root of the tree */\n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\t\t/*\n\t\t * The root can not have parents.\n\t\t * Release nodes which previously were obtained as\n\t\t * parents of the current node neighbors.\n\t\t */\n\t\tbrelse(tb->FL[h]);\n\t\tbrelse(tb->CFL[h]);\n\t\tbrelse(tb->FR[h]);\n\t\tbrelse(tb->CFR[h]);\n\t\ttb->FL[h]  = NULL;\n\t\ttb->CFL[h] = NULL;\n\t\ttb->FR[h]  = NULL;\n\t\ttb->CFR[h] = NULL;\n\t\treturn CARRY_ON;\n\t}\n\n\t/* Get parent FL[path_offset] of L[path_offset]. */\n\tposition = PATH_OFFSET_POSITION(path, path_offset - 1);\n\tif (position) {\n\t\t/* Current node is not the first child of its parent. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->lkey[h] = position - 1;\n\t} else {\n\t\t/*\n\t\t * Calculate current parent of L[path_offset], which is the\n\t\t * left neighbor of the current node.  Calculate current\n\t\t * common parent of L[path_offset] and the current node.\n\t\t * Note that CFL[path_offset] not equal FL[path_offset] and\n\t\t * CFL[path_offset] not equal F[path_offset].\n\t\t * Calculate lkey[path_offset].\n\t\t */\n\t\tif ((ret = get_far_parent(tb, h + 1, &curf,\n\t\t\t\t\t\t  &curcf,\n\t\t\t\t\t\t  LEFT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t}\n\n\tbrelse(tb->FL[h]);\n\ttb->FL[h] = curf;\t/* New initialization of FL[h]. */\n\tbrelse(tb->CFL[h]);\n\ttb->CFL[h] = curcf;\t/* New initialization of CFL[h]. */\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8195: FL (%b) or CFL (%b) is invalid\", curf, curcf);\n\n\t/* Get parent FR[h] of R[h]. */\n\n\t/* Current node is the last child of F[h]. FR[h] != F[h]. */\n\tif (position == B_NR_ITEMS(PATH_H_PBUFFER(path, h + 1))) {\n\t\t/*\n\t\t * Calculate current parent of R[h], which is the right\n\t\t * neighbor of F[h].  Calculate current common parent of\n\t\t * R[h] and current node. Note that CFR[h] not equal\n\t\t * FR[path_offset] and CFR[h] not equal F[h].\n\t\t */\n\t\tif ((ret =\n\t\t     get_far_parent(tb, h + 1, &curf, &curcf,\n\t\t\t\t    RIGHT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t} else {\n\t\t/* Current node is not the last child of its parent F[h]. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->rkey[h] = position;\n\t}\n\n\tbrelse(tb->FR[h]);\n\t/* New initialization of FR[path_offset]. */\n\ttb->FR[h] = curf;\n\n\tbrelse(tb->CFR[h]);\n\t/* New initialization of CFR[path_offset]. */\n\ttb->CFR[h] = curcf;\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8205: FR (%b) or CFR (%b) is invalid\", curf, curcf);\n\n\treturn CARRY_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"vs-8215\"",
            "\"incorrect \"\n\t\t\t\t       \"return value of get_empty_nodes\""
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_empty_nodes",
          "args": [
            "tb",
            "h"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "get_empty_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "829-911",
          "snippet": "static int get_empty_nodes(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *new_bh, *Sh = PATH_H_PBUFFER(tb->tb_path, h);\n\tb_blocknr_t *blocknr, blocknrs[MAX_AMOUNT_NEEDED] = { 0, };\n\tint counter, number_of_freeblk;\n\tint  amount_needed;\t/* number of needed empty blocks */\n\tint  retval = CARRY_ON;\n\tstruct super_block *sb = tb->tb_sb;\n\n\t/*\n\t * number_of_freeblk is the number of empty blocks which have been\n\t * acquired for use by the balancing algorithm minus the number of\n\t * empty blocks used in the previous levels of the analysis,\n\t * number_of_freeblk = tb->cur_blknum can be non-zero if a schedule\n\t * occurs after empty blocks are acquired, and the balancing analysis\n\t * is then restarted, amount_needed is the number needed by this\n\t * level (h) of the balancing analysis.\n\t *\n\t * Note that for systems with many processes writing, it would be\n\t * more layout optimal to calculate the total number needed by all\n\t * levels and then to run reiserfs_new_blocks to get all of them at\n\t * once.\n\t */\n\n\t/*\n\t * Initiate number_of_freeblk to the amount acquired prior to the\n\t * restart of the analysis or 0 if not restarted, then subtract the\n\t * amount needed by all of the levels of the tree below h.\n\t */\n\t/* blknum includes S[h], so we subtract 1 in this calculation */\n\tfor (counter = 0, number_of_freeblk = tb->cur_blknum;\n\t     counter < h; counter++)\n\t\tnumber_of_freeblk -=\n\t\t    (tb->blknum[counter]) ? (tb->blknum[counter] -\n\t\t\t\t\t\t   1) : 0;\n\n\t/* Allocate missing empty blocks. */\n\t/* if Sh == 0  then we are getting a new root */\n\tamount_needed = (Sh) ? (tb->blknum[h] - 1) : 1;\n\t/*\n\t * Amount_needed = the amount that we need more than the\n\t * amount that we have.\n\t */\n\tif (amount_needed > number_of_freeblk)\n\t\tamount_needed -= number_of_freeblk;\n\telse\t/* If we have enough already then there is nothing to do. */\n\t\treturn CARRY_ON;\n\n\t/*\n\t * No need to check quota - is not allocated for blocks used\n\t * for formatted nodes\n\t */\n\tif (reiserfs_new_form_blocknrs(tb, blocknrs,\n\t\t\t\t       amount_needed) == NO_DISK_SPACE)\n\t\treturn NO_DISK_SPACE;\n\n\t/* for each blocknumber we just got, get a buffer and stick it on FEB */\n\tfor (blocknr = blocknrs, counter = 0;\n\t     counter < amount_needed; blocknr++, counter++) {\n\n\t\tRFALSE(!*blocknr,\n\t\t       \"PAP-8135: reiserfs_new_blocknrs failed when got new blocks\");\n\n\t\tnew_bh = sb_getblk(sb, *blocknr);\n\t\tRFALSE(buffer_dirty(new_bh) ||\n\t\t       buffer_journaled(new_bh) ||\n\t\t       buffer_journal_dirty(new_bh),\n\t\t       \"PAP-8140: journaled or dirty buffer %b for the new block\",\n\t\t       new_bh);\n\n\t\t/* Put empty buffers into the array. */\n\t\tRFALSE(tb->FEB[tb->cur_blknum],\n\t\t       \"PAP-8141: busy slot for new buffer\");\n\n\t\tset_buffer_journal_new(new_bh);\n\t\ttb->FEB[tb->cur_blknum++] = new_bh;\n\t}\n\n\tif (retval == CARRY_ON && FILESYSTEM_CHANGED_TB(tb))\n\t\tretval = REPEAT_SEARCH;\n\n\treturn retval;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_empty_nodes(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *new_bh, *Sh = PATH_H_PBUFFER(tb->tb_path, h);\n\tb_blocknr_t *blocknr, blocknrs[MAX_AMOUNT_NEEDED] = { 0, };\n\tint counter, number_of_freeblk;\n\tint  amount_needed;\t/* number of needed empty blocks */\n\tint  retval = CARRY_ON;\n\tstruct super_block *sb = tb->tb_sb;\n\n\t/*\n\t * number_of_freeblk is the number of empty blocks which have been\n\t * acquired for use by the balancing algorithm minus the number of\n\t * empty blocks used in the previous levels of the analysis,\n\t * number_of_freeblk = tb->cur_blknum can be non-zero if a schedule\n\t * occurs after empty blocks are acquired, and the balancing analysis\n\t * is then restarted, amount_needed is the number needed by this\n\t * level (h) of the balancing analysis.\n\t *\n\t * Note that for systems with many processes writing, it would be\n\t * more layout optimal to calculate the total number needed by all\n\t * levels and then to run reiserfs_new_blocks to get all of them at\n\t * once.\n\t */\n\n\t/*\n\t * Initiate number_of_freeblk to the amount acquired prior to the\n\t * restart of the analysis or 0 if not restarted, then subtract the\n\t * amount needed by all of the levels of the tree below h.\n\t */\n\t/* blknum includes S[h], so we subtract 1 in this calculation */\n\tfor (counter = 0, number_of_freeblk = tb->cur_blknum;\n\t     counter < h; counter++)\n\t\tnumber_of_freeblk -=\n\t\t    (tb->blknum[counter]) ? (tb->blknum[counter] -\n\t\t\t\t\t\t   1) : 0;\n\n\t/* Allocate missing empty blocks. */\n\t/* if Sh == 0  then we are getting a new root */\n\tamount_needed = (Sh) ? (tb->blknum[h] - 1) : 1;\n\t/*\n\t * Amount_needed = the amount that we need more than the\n\t * amount that we have.\n\t */\n\tif (amount_needed > number_of_freeblk)\n\t\tamount_needed -= number_of_freeblk;\n\telse\t/* If we have enough already then there is nothing to do. */\n\t\treturn CARRY_ON;\n\n\t/*\n\t * No need to check quota - is not allocated for blocks used\n\t * for formatted nodes\n\t */\n\tif (reiserfs_new_form_blocknrs(tb, blocknrs,\n\t\t\t\t       amount_needed) == NO_DISK_SPACE)\n\t\treturn NO_DISK_SPACE;\n\n\t/* for each blocknumber we just got, get a buffer and stick it on FEB */\n\tfor (blocknr = blocknrs, counter = 0;\n\t     counter < amount_needed; blocknr++, counter++) {\n\n\t\tRFALSE(!*blocknr,\n\t\t       \"PAP-8135: reiserfs_new_blocknrs failed when got new blocks\");\n\n\t\tnew_bh = sb_getblk(sb, *blocknr);\n\t\tRFALSE(buffer_dirty(new_bh) ||\n\t\t       buffer_journaled(new_bh) ||\n\t\t       buffer_journal_dirty(new_bh),\n\t\t       \"PAP-8140: journaled or dirty buffer %b for the new block\",\n\t\t       new_bh);\n\n\t\t/* Put empty buffers into the array. */\n\t\tRFALSE(tb->FEB[tb->cur_blknum],\n\t\t       \"PAP-8141: busy slot for new buffer\");\n\n\t\tset_buffer_journal_new(new_bh);\n\t\ttb->FEB[tb->cur_blknum++] = new_bh;\n\t}\n\n\tif (retval == CARRY_ON && FILESYSTEM_CHANGED_TB(tb))\n\t\tretval = REPEAT_SEARCH;\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"vs-8210\"",
            "\"S[0] can not be 0\""
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#define LR_SHIFT_FLOW\t\t35\n#define LR_SHIFT_NO_FLOW\t30\n#define RIGHT_SHIFT_FLOW\t25\n#define RIGHT_SHIFT_NO_FLOW\t20\n#define LEFT_SHIFT_FLOW\t\t15\n#define LEFT_SHIFT_NO_FLOW\t10\n#define NOTHING_SHIFT_FLOW\t5\n#define NOTHING_SHIFT_NO_FLOW\t0\n#define NO_FLOW 0\t\t/* do not any splitting */\n#define FLOW 1\n#define SET_PAR_SHIFT_RIGHT \\\nif (h)\\\n{\\\n   int to_r;\\\n   \\\n   to_r = (MAX_NR_KEY(Sh)+1 - rpar + vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 - rpar);\\\n   \\\n   set_parameters (tb, h, 0, to_r, rnver, NULL, -1, -1);\\\n}\\\nelse \\\n{\\\n   if (rset==RIGHT_SHIFT_FLOW)\\\n     set_parameters (tb, h, 0, rpar, rnver, snum012+rset,\\\n\t\t  -1, tb->rbytes);\\\n   else\\\n     set_parameters (tb, h, 0, rpar - (tb->rbytes!=-1), rnver, snum012+rset,\\\n\t\t  -1, -1);\\\n}\n#define SET_PAR_SHIFT_LEFT \\\nif (h)\\\n{\\\n   int to_l;\\\n   \\\n   to_l = (MAX_NR_KEY(Sh)+1 - lpar + vn->vn_nr_item + 1) / 2 -\\\n\t      (MAX_NR_KEY(Sh) + 1 - lpar);\\\n\t      \\\n\t      set_parameters (tb, h, to_l, 0, lnver, NULL, -1, -1);\\\n}\\\nelse \\\n{\\\n   if (lset==LEFT_SHIFT_FLOW)\\\n     set_parameters (tb, h, lpar, 0, lnver, snum012+lset,\\\n\t\t     tb->lbytes, -1);\\\n   else\\\n     set_parameters (tb, h, lpar - (tb->lbytes!=-1), 0, lnver, snum012+lset,\\\n\t\t     -1, -1);\\\n}\n\nstatic int ip_check_balance(struct tree_balance *tb, int h)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\t/*\n\t * Number of bytes that must be inserted into (value is negative\n\t * if bytes are deleted) buffer which contains node being balanced.\n\t * The mnemonic is that the attempted change in node space used\n\t * level is levbytes bytes.\n\t */\n\tint levbytes;\n\tint ret;\n\n\tint lfree, sfree, rfree /* free space in L, S and R */ ;\n\n\t/*\n\t * nver is short for number of vertixes, and lnver is the number if\n\t * we shift to the left, rnver is the number if we shift to the\n\t * right, and lrnver is the number if we shift in both directions.\n\t * The goal is to minimize first the number of vertixes, and second,\n\t * the number of vertixes whose contents are changed by shifting,\n\t * and third the number of uncached vertixes whose contents are\n\t * changed by shifting and must be read from disk.\n\t */\n\tint nver, lnver, rnver, lrnver;\n\n\t/*\n\t * used at leaf level only, S0 = S[0] is the node being balanced,\n\t * sInum [ I = 0,1,2 ] is the number of items that will\n\t * remain in node SI after balancing.  S1 and S2 are new\n\t * nodes that might be created.\n\t */\n\n\t/*\n\t * we perform 8 calls to get_num_ver().  For each call we\n\t * calculate five parameters.  where 4th parameter is s1bytes\n\t * and 5th - s2bytes\n\t *\n\t * s0num, s1num, s2num for 8 cases\n\t * 0,1 - do not shift and do not shift but bottle\n\t * 2   - shift only whole item to left\n\t * 3   - shift to left and bottle as much as possible\n\t * 4,5 - shift to right (whole items and as much as possible\n\t * 6,7 - shift to both directions (whole items and as much as possible)\n\t */\n\tshort snum012[40] = { 0, };\n\n\t/* Sh is the node whose balance is currently being checked */\n\tstruct buffer_head *Sh;\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tlevbytes = tb->insert_size[h];\n\n\t/* Calculate balance parameters for creating new root. */\n\tif (!Sh) {\n\t\tif (!h)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8210\",\n\t\t\t\t       \"S[0] can not be 0\");\n\t\tswitch (ret = get_empty_nodes(tb, h)) {\n\t\t/* no balancing for higher levels needed */\n\t\tcase CARRY_ON:\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\n\t\tcase NO_DISK_SPACE:\n\t\tcase REPEAT_SEARCH:\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8215\", \"incorrect \"\n\t\t\t\t       \"return value of get_empty_nodes\");\n\t\t}\n\t}\n\n\t/* get parents of S[h] neighbors. */\n\tret = get_parents(tb, h);\n\tif (ret != CARRY_ON)\n\t\treturn ret;\n\n\tsfree = B_FREE_SPACE(Sh);\n\n\t/* get free space of neighbors */\n\trfree = get_rfree(tb, h);\n\tlfree = get_lfree(tb, h);\n\n\t/* and new item fits into node S[h] without any shifting */\n\tif (can_node_be_removed(vn->vn_mode, lfree, sfree, rfree, tb, h) ==\n\t    NO_BALANCING_NEEDED)\n\t\treturn NO_BALANCING_NEEDED;\n\n\tcreate_virtual_node(tb, h);\n\n\t/*\n\t * determine maximal number of items we can shift to the left\n\t * neighbor (in tb structure) and the maximal number of bytes\n\t * that can flow to the left neighbor from the left most liquid\n\t * item that cannot be shifted from S[0] entirely (returned value)\n\t */\n\tcheck_left(tb, h, lfree);\n\n\t/*\n\t * determine maximal number of items we can shift to the right\n\t * neighbor (in tb structure) and the maximal number of bytes\n\t * that can flow to the right neighbor from the right most liquid\n\t * item that cannot be shifted from S[0] entirely (returned value)\n\t */\n\tcheck_right(tb, h, rfree);\n\n\t/*\n\t * all contents of internal node S[h] can be moved into its\n\t * neighbors, S[h] will be removed after balancing\n\t */\n\tif (h && (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1)) {\n\t\tint to_r;\n\n\t\t/*\n\t\t * Since we are working on internal nodes, and our internal\n\t\t * nodes have fixed size entries, then we can balance by the\n\t\t * number of items rather than the space they consume.  In this\n\t\t * routine we set the left node equal to the right node,\n\t\t * allowing a difference of less than or equal to 1 child\n\t\t * pointer.\n\t\t */\n\t\tto_r =\n\t\t    ((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] - tb->rnum[h] +\n\t\t     vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 -\n\t\t\t\t\t\ttb->rnum[h]);\n\t\tset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL,\n\t\t\t       -1, -1);\n\t\treturn CARRY_ON;\n\t}\n\n\t/*\n\t * this checks balance condition, that any two neighboring nodes\n\t * can not fit in one node\n\t */\n\tRFALSE(h &&\n\t       (tb->lnum[h] >= vn->vn_nr_item + 1 ||\n\t\ttb->rnum[h] >= vn->vn_nr_item + 1),\n\t       \"vs-8220: tree is not balanced on internal level\");\n\tRFALSE(!h && ((tb->lnum[h] >= vn->vn_nr_item && (tb->lbytes == -1)) ||\n\t\t      (tb->rnum[h] >= vn->vn_nr_item && (tb->rbytes == -1))),\n\t       \"vs-8225: tree is not balanced on leaf level\");\n\n\t/*\n\t * all contents of S[0] can be moved into its neighbors\n\t * S[0] will be removed after balancing.\n\t */\n\tif (!h && is_leaf_removable(tb))\n\t\treturn CARRY_ON;\n\n\t/*\n\t * why do we perform this check here rather than earlier??\n\t * Answer: we can win 1 node in some cases above. Moreover we\n\t * checked it above, when we checked, that S[0] is not removable\n\t * in principle\n\t */\n\n\t /* new item fits into node S[h] without any shifting */\n\tif (sfree >= levbytes) {\n\t\tif (!h)\n\t\t\ttb->s0num = vn->vn_nr_item;\n\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\treturn NO_BALANCING_NEEDED;\n\t}\n\n\t{\n\t\tint lpar, rpar, nset, lset, rset, lrset;\n\t\t/* regular overflowing of the node */\n\n\t\t/*\n\t\t * get_num_ver works in 2 modes (FLOW & NO_FLOW)\n\t\t * lpar, rpar - number of items we can shift to left/right\n\t\t *              neighbor (including splitting item)\n\t\t * nset, lset, rset, lrset - shows, whether flowing items\n\t\t *                           give better packing\n\t\t */\n#define FLOW 1\n#define NO_FLOW 0\t\t/* do not any splitting */\n\n\t\t/* we choose one of the following */\n#define NOTHING_SHIFT_NO_FLOW\t0\n#define NOTHING_SHIFT_FLOW\t5\n#define LEFT_SHIFT_NO_FLOW\t10\n#define LEFT_SHIFT_FLOW\t\t15\n#define RIGHT_SHIFT_NO_FLOW\t20\n#define RIGHT_SHIFT_FLOW\t25\n#define LR_SHIFT_NO_FLOW\t30\n#define LR_SHIFT_FLOW\t\t35\n\n\t\tlpar = tb->lnum[h];\n\t\trpar = tb->rnum[h];\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * nothing is shifted to the neighbors, as well as number of\n\t\t * items in each part of the split node (s012 numbers),\n\t\t * and number of bytes (s1bytes) of the shared drop which\n\t\t * flow to S1 if any\n\t\t */\n\t\tnset = NOTHING_SHIFT_NO_FLOW;\n\t\tnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t   0, -1, h ? vn->vn_nr_item : 0, -1,\n\t\t\t\t   snum012, NO_FLOW);\n\n\t\tif (!h) {\n\t\t\tint nver1;\n\n\t\t\t/*\n\t\t\t * note, that in this case we try to bottle\n\t\t\t * between S[0] and S1 (S1 - the first new node)\n\t\t\t */\n\t\t\tnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t    0, -1, 0, -1,\n\t\t\t\t\t    snum012 + NOTHING_SHIFT_FLOW, FLOW);\n\t\t\tif (nver > nver1)\n\t\t\t\tnset = NOTHING_SHIFT_FLOW, nver = nver1;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * l_shift_num first items and l_shift_bytes of the right\n\t\t * most liquid item to be shifted are shifted to the left\n\t\t * neighbor, as well as number of items in each part of the\n\t\t * splitted node (s012 numbers), and number of bytes\n\t\t * (s1bytes) of the shared drop which flow to S1 if any\n\t\t */\n\t\tlset = LEFT_SHIFT_NO_FLOW;\n\t\tlnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t    lpar - ((h || tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t    -1, h ? vn->vn_nr_item : 0, -1,\n\t\t\t\t    snum012 + LEFT_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint lnver1;\n\n\t\t\tlnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t     lpar -\n\t\t\t\t\t     ((tb->lbytes != -1) ? 1 : 0),\n\t\t\t\t\t     tb->lbytes, 0, -1,\n\t\t\t\t\t     snum012 + LEFT_SHIFT_FLOW, FLOW);\n\t\t\tif (lnver > lnver1)\n\t\t\t\tlset = LEFT_SHIFT_FLOW, lnver = lnver1;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * r_shift_num first items and r_shift_bytes of the left most\n\t\t * liquid item to be shifted are shifted to the right neighbor,\n\t\t * as well as number of items in each part of the splitted\n\t\t * node (s012 numbers), and number of bytes (s1bytes) of the\n\t\t * shared drop which flow to S1 if any\n\t\t */\n\t\trset = RIGHT_SHIFT_NO_FLOW;\n\t\trnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t    0, -1,\n\t\t\t\t    h ? (vn->vn_nr_item - rpar) : (rpar -\n\t\t\t\t\t\t\t\t   ((tb->\n\t\t\t\t\t\t\t\t     rbytes !=\n\t\t\t\t\t\t\t\t     -1) ? 1 :\n\t\t\t\t\t\t\t\t    0)), -1,\n\t\t\t\t    snum012 + RIGHT_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint rnver1;\n\n\t\t\trnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t     0, -1,\n\t\t\t\t\t     (rpar -\n\t\t\t\t\t      ((tb->rbytes != -1) ? 1 : 0)),\n\t\t\t\t\t     tb->rbytes,\n\t\t\t\t\t     snum012 + RIGHT_SHIFT_FLOW, FLOW);\n\n\t\t\tif (rnver > rnver1)\n\t\t\t\trset = RIGHT_SHIFT_FLOW, rnver = rnver1;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of blocks S[h] must be split into when\n\t\t * items are shifted in both directions, as well as number\n\t\t * of items in each part of the splitted node (s012 numbers),\n\t\t * and number of bytes (s1bytes) of the shared drop which\n\t\t * flow to S1 if any\n\t\t */\n\t\tlrset = LR_SHIFT_NO_FLOW;\n\t\tlrnver = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t     lpar - ((h || tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t     -1,\n\t\t\t\t     h ? (vn->vn_nr_item - rpar) : (rpar -\n\t\t\t\t\t\t\t\t    ((tb->\n\t\t\t\t\t\t\t\t      rbytes !=\n\t\t\t\t\t\t\t\t      -1) ? 1 :\n\t\t\t\t\t\t\t\t     0)), -1,\n\t\t\t\t     snum012 + LR_SHIFT_NO_FLOW, NO_FLOW);\n\t\tif (!h) {\n\t\t\tint lrnver1;\n\n\t\t\tlrnver1 = get_num_ver(vn->vn_mode, tb, h,\n\t\t\t\t\t      lpar -\n\t\t\t\t\t      ((tb->lbytes != -1) ? 1 : 0),\n\t\t\t\t\t      tb->lbytes,\n\t\t\t\t\t      (rpar -\n\t\t\t\t\t       ((tb->rbytes != -1) ? 1 : 0)),\n\t\t\t\t\t      tb->rbytes,\n\t\t\t\t\t      snum012 + LR_SHIFT_FLOW, FLOW);\n\t\t\tif (lrnver > lrnver1)\n\t\t\t\tlrset = LR_SHIFT_FLOW, lrnver = lrnver1;\n\t\t}\n\n\t\t/*\n\t\t * Our general shifting strategy is:\n\t\t * 1) to minimized number of new nodes;\n\t\t * 2) to minimized number of neighbors involved in shifting;\n\t\t * 3) to minimized number of disk reads;\n\t\t */\n\n\t\t/* we can win TWO or ONE nodes by shifting in both directions */\n\t\tif (lrnver < lnver && lrnver < rnver) {\n\t\t\tRFALSE(h &&\n\t\t\t       (tb->lnum[h] != 1 ||\n\t\t\t\ttb->rnum[h] != 1 ||\n\t\t\t\tlrnver != 1 || rnver != 2 || lnver != 2\n\t\t\t\t|| h != 1), \"vs-8230: bad h\");\n\t\t\tif (lrset == LR_SHIFT_FLOW)\n\t\t\t\tset_parameters(tb, h, tb->lnum[h], tb->rnum[h],\n\t\t\t\t\t       lrnver, snum012 + lrset,\n\t\t\t\t\t       tb->lbytes, tb->rbytes);\n\t\t\telse\n\t\t\t\tset_parameters(tb, h,\n\t\t\t\t\t       tb->lnum[h] -\n\t\t\t\t\t       ((tb->lbytes == -1) ? 0 : 1),\n\t\t\t\t\t       tb->rnum[h] -\n\t\t\t\t\t       ((tb->rbytes == -1) ? 0 : 1),\n\t\t\t\t\t       lrnver, snum012 + lrset, -1, -1);\n\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * if shifting doesn't lead to better packing\n\t\t * then don't shift\n\t\t */\n\t\tif (nver == lrnver) {\n\t\t\tset_parameters(tb, h, 0, 0, nver, snum012 + nset, -1,\n\t\t\t\t       -1);\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * now we know that for better packing shifting in only one\n\t\t * direction either to the left or to the right is required\n\t\t */\n\n\t\t/*\n\t\t * if shifting to the left is better than\n\t\t * shifting to the right\n\t\t */\n\t\tif (lnver < rnver) {\n\t\t\tSET_PAR_SHIFT_LEFT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * if shifting to the right is better than\n\t\t * shifting to the left\n\t\t */\n\t\tif (lnver > rnver) {\n\t\t\tSET_PAR_SHIFT_RIGHT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * now shifting in either direction gives the same number\n\t\t * of nodes and we can make use of the cached neighbors\n\t\t */\n\t\tif (is_left_neighbor_in_cache(tb, h)) {\n\t\t\tSET_PAR_SHIFT_LEFT;\n\t\t\treturn CARRY_ON;\n\t\t}\n\n\t\t/*\n\t\t * shift to the right independently on whether the\n\t\t * right neighbor in cache or not\n\t\t */\n\t\tSET_PAR_SHIFT_RIGHT;\n\t\treturn CARRY_ON;\n\t}\n}"
  },
  {
    "function_name": "can_node_be_removed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "1275-1309",
    "snippet": "static inline int can_node_be_removed(int mode, int lfree, int sfree, int rfree,\n\t\t\t\t      struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *Sh = PATH_H_PBUFFER(tb->tb_path, h);\n\tint levbytes = tb->insert_size[h];\n\tstruct item_head *ih;\n\tstruct reiserfs_key *r_key = NULL;\n\n\tih = item_head(Sh, 0);\n\tif (tb->CFR[h])\n\t\tr_key = internal_key(tb->CFR[h], tb->rkey[h]);\n\n\tif (lfree + rfree + sfree < MAX_CHILD_SIZE(Sh) + levbytes\n\t    /* shifting may merge items which might save space */\n\t    -\n\t    ((!h\n\t      && op_is_left_mergeable(&ih->ih_key, Sh->b_size)) ? IH_SIZE : 0)\n\t    -\n\t    ((!h && r_key\n\t      && op_is_left_mergeable(r_key, Sh->b_size)) ? IH_SIZE : 0)\n\t    + ((h) ? KEY_SIZE : 0)) {\n\t\t/* node can not be removed */\n\t\tif (sfree >= levbytes) {\n\t\t\t/* new item fits into node S[h] without any shifting */\n\t\t\tif (!h)\n\t\t\t\ttb->s0num =\n\t\t\t\t    B_NR_ITEMS(Sh) +\n\t\t\t\t    ((mode == M_INSERT) ? 1 : 0);\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\t\t}\n\t}\n\tPROC_INFO_INC(tb->tb_sb, can_node_be_removed[h]);\n\treturn !NO_BALANCING_NEEDED;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "tb->tb_sb",
            "can_node_be_removed[h]"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_parameters",
          "args": [
            "tb",
            "h",
            "0",
            "0",
            "1",
            "NULL",
            "-1",
            "-1"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "set_parameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "623-648",
          "snippet": "static void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "Sh"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_is_left_mergeable",
          "args": [
            "r_key",
            "Sh->b_size"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_is_left_mergeable",
          "args": [
            "&ih->ih_key",
            "Sh->b_size"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "Sh"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "tb->CFR[h]",
            "tb->rkey[h]"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "Sh",
            "0"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic inline int can_node_be_removed(int mode, int lfree, int sfree, int rfree,\n\t\t\t\t      struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *Sh = PATH_H_PBUFFER(tb->tb_path, h);\n\tint levbytes = tb->insert_size[h];\n\tstruct item_head *ih;\n\tstruct reiserfs_key *r_key = NULL;\n\n\tih = item_head(Sh, 0);\n\tif (tb->CFR[h])\n\t\tr_key = internal_key(tb->CFR[h], tb->rkey[h]);\n\n\tif (lfree + rfree + sfree < MAX_CHILD_SIZE(Sh) + levbytes\n\t    /* shifting may merge items which might save space */\n\t    -\n\t    ((!h\n\t      && op_is_left_mergeable(&ih->ih_key, Sh->b_size)) ? IH_SIZE : 0)\n\t    -\n\t    ((!h && r_key\n\t      && op_is_left_mergeable(r_key, Sh->b_size)) ? IH_SIZE : 0)\n\t    + ((h) ? KEY_SIZE : 0)) {\n\t\t/* node can not be removed */\n\t\tif (sfree >= levbytes) {\n\t\t\t/* new item fits into node S[h] without any shifting */\n\t\t\tif (!h)\n\t\t\t\ttb->s0num =\n\t\t\t\t    B_NR_ITEMS(Sh) +\n\t\t\t\t    ((mode == M_INSERT) ? 1 : 0);\n\t\t\tset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\n\t\t\treturn NO_BALANCING_NEEDED;\n\t\t}\n\t}\n\tPROC_INFO_INC(tb->tb_sb, can_node_be_removed[h]);\n\treturn !NO_BALANCING_NEEDED;\n}"
  },
  {
    "function_name": "get_parents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "1174-1269",
    "snippet": "static int get_parents(struct tree_balance *tb, int h)\n{\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    ret,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\tstruct buffer_head *curf, *curcf;\n\n\t/* Current node is the root of the tree or will be root of the tree */\n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\t\t/*\n\t\t * The root can not have parents.\n\t\t * Release nodes which previously were obtained as\n\t\t * parents of the current node neighbors.\n\t\t */\n\t\tbrelse(tb->FL[h]);\n\t\tbrelse(tb->CFL[h]);\n\t\tbrelse(tb->FR[h]);\n\t\tbrelse(tb->CFR[h]);\n\t\ttb->FL[h]  = NULL;\n\t\ttb->CFL[h] = NULL;\n\t\ttb->FR[h]  = NULL;\n\t\ttb->CFR[h] = NULL;\n\t\treturn CARRY_ON;\n\t}\n\n\t/* Get parent FL[path_offset] of L[path_offset]. */\n\tposition = PATH_OFFSET_POSITION(path, path_offset - 1);\n\tif (position) {\n\t\t/* Current node is not the first child of its parent. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->lkey[h] = position - 1;\n\t} else {\n\t\t/*\n\t\t * Calculate current parent of L[path_offset], which is the\n\t\t * left neighbor of the current node.  Calculate current\n\t\t * common parent of L[path_offset] and the current node.\n\t\t * Note that CFL[path_offset] not equal FL[path_offset] and\n\t\t * CFL[path_offset] not equal F[path_offset].\n\t\t * Calculate lkey[path_offset].\n\t\t */\n\t\tif ((ret = get_far_parent(tb, h + 1, &curf,\n\t\t\t\t\t\t  &curcf,\n\t\t\t\t\t\t  LEFT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t}\n\n\tbrelse(tb->FL[h]);\n\ttb->FL[h] = curf;\t/* New initialization of FL[h]. */\n\tbrelse(tb->CFL[h]);\n\ttb->CFL[h] = curcf;\t/* New initialization of CFL[h]. */\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8195: FL (%b) or CFL (%b) is invalid\", curf, curcf);\n\n\t/* Get parent FR[h] of R[h]. */\n\n\t/* Current node is the last child of F[h]. FR[h] != F[h]. */\n\tif (position == B_NR_ITEMS(PATH_H_PBUFFER(path, h + 1))) {\n\t\t/*\n\t\t * Calculate current parent of R[h], which is the right\n\t\t * neighbor of F[h].  Calculate current common parent of\n\t\t * R[h] and current node. Note that CFR[h] not equal\n\t\t * FR[path_offset] and CFR[h] not equal F[h].\n\t\t */\n\t\tif ((ret =\n\t\t     get_far_parent(tb, h + 1, &curf, &curcf,\n\t\t\t\t    RIGHT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t} else {\n\t\t/* Current node is not the last child of its parent F[h]. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->rkey[h] = position;\n\t}\n\n\tbrelse(tb->FR[h]);\n\t/* New initialization of FR[path_offset]. */\n\ttb->FR[h] = curf;\n\n\tbrelse(tb->CFR[h]);\n\t/* New initialization of CFR[path_offset]. */\n\ttb->CFR[h] = curcf;\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8205: FR (%b) or CFR (%b) is invalid\", curf, curcf);\n\n\treturn CARRY_ON;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define RIGHT_PARENTS 'r'",
      "#define LEFT_PARENTS  'l'"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "(curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf))",
            "\"PAP-8205: FR (%b) or CFR (%b) is invalid\"",
            "curf",
            "curcf"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "curcf"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "tb->CFR[h]"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "curf"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "curf"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "path",
            "path_offset - 1"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "path",
            "path_offset - 1"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_far_parent",
          "args": [
            "tb",
            "h + 1",
            "&curf",
            "&curcf",
            "RIGHT_PARENTS"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "get_far_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "1025-1162",
          "snippet": "static int get_far_parent(struct tree_balance *tb,\n\t\t\t  int h,\n\t\t\t  struct buffer_head **pfather,\n\t\t\t  struct buffer_head **pcom_father, char c_lr_par)\n{\n\tstruct buffer_head *parent;\n\tINITIALIZE_PATH(s_path_to_neighbor_father);\n\tstruct treepath *path = tb->tb_path;\n\tstruct cpu_key s_lr_father_key;\n\tint counter,\n\t    position = INT_MAX,\n\t    first_last_position = 0,\n\t    path_offset = PATH_H_PATH_OFFSET(path, h);\n\n\t/*\n\t * Starting from F[h] go upwards in the tree, and look for the common\n\t * ancestor of F[h], and its neighbor l/r, that should be obtained.\n\t */\n\n\tcounter = path_offset;\n\n\tRFALSE(counter < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-8180: invalid path length\");\n\n\tfor (; counter > FIRST_PATH_ELEMENT_OFFSET; counter--) {\n\t\t/*\n\t\t * Check whether parent of the current buffer in the path\n\t\t * is really parent in the tree.\n\t\t */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent = PATH_OFFSET_PBUFFER(path, counter - 1)))\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(path,\n\t\t\t\t\t  counter - 1)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t/*\n\t\t * Check whether parent at the path really points\n\t\t * to the child.\n\t\t */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(path, counter)->b_blocknr)\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t/*\n\t\t * Return delimiting key if position in the parent is not\n\t\t * equal to first/last one.\n\t\t */\n\t\tif (c_lr_par == RIGHT_PARENTS)\n\t\t\tfirst_last_position = B_NR_ITEMS(parent);\n\t\tif (position != first_last_position) {\n\t\t\t*pcom_father = parent;\n\t\t\tget_bh(*pcom_father);\n\t\t\t/*(*pcom_father = parent)->b_count++; */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* if we are in the root of the tree, then there is no common father */\n\tif (counter == FIRST_PATH_ELEMENT_OFFSET) {\n\t\t/*\n\t\t * Check whether first buffer in the path is the\n\t\t * root of the tree.\n\t\t */\n\t\tif (PATH_OFFSET_PBUFFER\n\t\t    (tb->tb_path,\n\t\t     FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==\n\t\t    SB_ROOT_BLOCK(tb->tb_sb)) {\n\t\t\t*pfather = *pcom_father = NULL;\n\t\t\treturn CARRY_ON;\n\t\t}\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\tRFALSE(B_LEVEL(*pcom_father) <= DISK_LEAF_NODE_LEVEL,\n\t       \"PAP-8185: (%b %z) level too small\",\n\t       *pcom_father, *pcom_father);\n\n\t/* Check whether the common parent is locked. */\n\n\tif (buffer_locked(*pcom_father)) {\n\n\t\t/* Release the write lock while the buffer is busy */\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(*pcom_father);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(*pcom_father);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\t}\n\n\t/*\n\t * So, we got common parent of the current node and its\n\t * left/right neighbor.  Now we are getting the parent of the\n\t * left/right neighbor.\n\t */\n\n\t/* Form key to get parent of the left/right neighbor. */\n\tle_key2cpu_key(&s_lr_father_key,\n\t\t       internal_key(*pcom_father,\n\t\t\t\t      (c_lr_par ==\n\t\t\t\t       LEFT_PARENTS) ? (tb->lkey[h - 1] =\n\t\t\t\t\t\t\tposition -\n\t\t\t\t\t\t\t1) : (tb->rkey[h -\n\t\t\t\t\t\t\t\t\t   1] =\n\t\t\t\t\t\t\t      position)));\n\n\tif (c_lr_par == LEFT_PARENTS)\n\t\tdecrement_key(&s_lr_father_key);\n\n\tif (search_by_key\n\t    (tb->tb_sb, &s_lr_father_key, &s_path_to_neighbor_father,\n\t     h + 1) == IO_ERROR)\n\t\t/* path is released */\n\t\treturn IO_ERROR;\n\n\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\tpathrelse(&s_path_to_neighbor_father);\n\t\tbrelse(*pcom_father);\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\t*pfather = PATH_PLAST_BUFFER(&s_path_to_neighbor_father);\n\n\tRFALSE(B_LEVEL(*pfather) != h + 1,\n\t       \"PAP-8190: (%b %z) level too small\", *pfather, *pfather);\n\tRFALSE(s_path_to_neighbor_father.path_length <\n\t       FIRST_PATH_ELEMENT_OFFSET, \"PAP-8192: path length is too small\");\n\n\ts_path_to_neighbor_father.path_length--;\n\tpathrelse(&s_path_to_neighbor_father);\n\treturn CARRY_ON;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define RIGHT_PARENTS 'r'",
            "#define LEFT_PARENTS  'l'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#define RIGHT_PARENTS 'r'\n#define LEFT_PARENTS  'l'\n\nstatic int get_far_parent(struct tree_balance *tb,\n\t\t\t  int h,\n\t\t\t  struct buffer_head **pfather,\n\t\t\t  struct buffer_head **pcom_father, char c_lr_par)\n{\n\tstruct buffer_head *parent;\n\tINITIALIZE_PATH(s_path_to_neighbor_father);\n\tstruct treepath *path = tb->tb_path;\n\tstruct cpu_key s_lr_father_key;\n\tint counter,\n\t    position = INT_MAX,\n\t    first_last_position = 0,\n\t    path_offset = PATH_H_PATH_OFFSET(path, h);\n\n\t/*\n\t * Starting from F[h] go upwards in the tree, and look for the common\n\t * ancestor of F[h], and its neighbor l/r, that should be obtained.\n\t */\n\n\tcounter = path_offset;\n\n\tRFALSE(counter < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-8180: invalid path length\");\n\n\tfor (; counter > FIRST_PATH_ELEMENT_OFFSET; counter--) {\n\t\t/*\n\t\t * Check whether parent of the current buffer in the path\n\t\t * is really parent in the tree.\n\t\t */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent = PATH_OFFSET_PBUFFER(path, counter - 1)))\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(path,\n\t\t\t\t\t  counter - 1)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t/*\n\t\t * Check whether parent at the path really points\n\t\t * to the child.\n\t\t */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(path, counter)->b_blocknr)\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t/*\n\t\t * Return delimiting key if position in the parent is not\n\t\t * equal to first/last one.\n\t\t */\n\t\tif (c_lr_par == RIGHT_PARENTS)\n\t\t\tfirst_last_position = B_NR_ITEMS(parent);\n\t\tif (position != first_last_position) {\n\t\t\t*pcom_father = parent;\n\t\t\tget_bh(*pcom_father);\n\t\t\t/*(*pcom_father = parent)->b_count++; */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* if we are in the root of the tree, then there is no common father */\n\tif (counter == FIRST_PATH_ELEMENT_OFFSET) {\n\t\t/*\n\t\t * Check whether first buffer in the path is the\n\t\t * root of the tree.\n\t\t */\n\t\tif (PATH_OFFSET_PBUFFER\n\t\t    (tb->tb_path,\n\t\t     FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==\n\t\t    SB_ROOT_BLOCK(tb->tb_sb)) {\n\t\t\t*pfather = *pcom_father = NULL;\n\t\t\treturn CARRY_ON;\n\t\t}\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\tRFALSE(B_LEVEL(*pcom_father) <= DISK_LEAF_NODE_LEVEL,\n\t       \"PAP-8185: (%b %z) level too small\",\n\t       *pcom_father, *pcom_father);\n\n\t/* Check whether the common parent is locked. */\n\n\tif (buffer_locked(*pcom_father)) {\n\n\t\t/* Release the write lock while the buffer is busy */\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(*pcom_father);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(*pcom_father);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\t}\n\n\t/*\n\t * So, we got common parent of the current node and its\n\t * left/right neighbor.  Now we are getting the parent of the\n\t * left/right neighbor.\n\t */\n\n\t/* Form key to get parent of the left/right neighbor. */\n\tle_key2cpu_key(&s_lr_father_key,\n\t\t       internal_key(*pcom_father,\n\t\t\t\t      (c_lr_par ==\n\t\t\t\t       LEFT_PARENTS) ? (tb->lkey[h - 1] =\n\t\t\t\t\t\t\tposition -\n\t\t\t\t\t\t\t1) : (tb->rkey[h -\n\t\t\t\t\t\t\t\t\t   1] =\n\t\t\t\t\t\t\t      position)));\n\n\tif (c_lr_par == LEFT_PARENTS)\n\t\tdecrement_key(&s_lr_father_key);\n\n\tif (search_by_key\n\t    (tb->tb_sb, &s_lr_father_key, &s_path_to_neighbor_father,\n\t     h + 1) == IO_ERROR)\n\t\t/* path is released */\n\t\treturn IO_ERROR;\n\n\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\tpathrelse(&s_path_to_neighbor_father);\n\t\tbrelse(*pcom_father);\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\t*pfather = PATH_PLAST_BUFFER(&s_path_to_neighbor_father);\n\n\tRFALSE(B_LEVEL(*pfather) != h + 1,\n\t       \"PAP-8190: (%b %z) level too small\", *pfather, *pfather);\n\tRFALSE(s_path_to_neighbor_father.path_length <\n\t       FIRST_PATH_ELEMENT_OFFSET, \"PAP-8192: path length is too small\");\n\n\ts_path_to_neighbor_father.path_length--;\n\tpathrelse(&s_path_to_neighbor_father);\n\treturn CARRY_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "PATH_H_PBUFFER(path, h + 1)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "path",
            "h + 1"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "(curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf))",
            "\"PAP-8195: FL (%b) or CFL (%b) is invalid\"",
            "curf",
            "curcf"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "curf"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "curf"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "path",
            "path_offset - 1"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "path",
            "path_offset - 1"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_POSITION",
          "args": [
            "path",
            "path_offset - 1"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PATH_OFFSET",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#define RIGHT_PARENTS 'r'\n#define LEFT_PARENTS  'l'\n\nstatic int get_parents(struct tree_balance *tb, int h)\n{\n\tstruct treepath *path = tb->tb_path;\n\tint position,\n\t    ret,\n\t    path_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\n\tstruct buffer_head *curf, *curcf;\n\n\t/* Current node is the root of the tree or will be root of the tree */\n\tif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\n\t\t/*\n\t\t * The root can not have parents.\n\t\t * Release nodes which previously were obtained as\n\t\t * parents of the current node neighbors.\n\t\t */\n\t\tbrelse(tb->FL[h]);\n\t\tbrelse(tb->CFL[h]);\n\t\tbrelse(tb->FR[h]);\n\t\tbrelse(tb->CFR[h]);\n\t\ttb->FL[h]  = NULL;\n\t\ttb->CFL[h] = NULL;\n\t\ttb->FR[h]  = NULL;\n\t\ttb->CFR[h] = NULL;\n\t\treturn CARRY_ON;\n\t}\n\n\t/* Get parent FL[path_offset] of L[path_offset]. */\n\tposition = PATH_OFFSET_POSITION(path, path_offset - 1);\n\tif (position) {\n\t\t/* Current node is not the first child of its parent. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->lkey[h] = position - 1;\n\t} else {\n\t\t/*\n\t\t * Calculate current parent of L[path_offset], which is the\n\t\t * left neighbor of the current node.  Calculate current\n\t\t * common parent of L[path_offset] and the current node.\n\t\t * Note that CFL[path_offset] not equal FL[path_offset] and\n\t\t * CFL[path_offset] not equal F[path_offset].\n\t\t * Calculate lkey[path_offset].\n\t\t */\n\t\tif ((ret = get_far_parent(tb, h + 1, &curf,\n\t\t\t\t\t\t  &curcf,\n\t\t\t\t\t\t  LEFT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t}\n\n\tbrelse(tb->FL[h]);\n\ttb->FL[h] = curf;\t/* New initialization of FL[h]. */\n\tbrelse(tb->CFL[h]);\n\ttb->CFL[h] = curcf;\t/* New initialization of CFL[h]. */\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8195: FL (%b) or CFL (%b) is invalid\", curf, curcf);\n\n\t/* Get parent FR[h] of R[h]. */\n\n\t/* Current node is the last child of F[h]. FR[h] != F[h]. */\n\tif (position == B_NR_ITEMS(PATH_H_PBUFFER(path, h + 1))) {\n\t\t/*\n\t\t * Calculate current parent of R[h], which is the right\n\t\t * neighbor of F[h].  Calculate current common parent of\n\t\t * R[h] and current node. Note that CFR[h] not equal\n\t\t * FR[path_offset] and CFR[h] not equal F[h].\n\t\t */\n\t\tif ((ret =\n\t\t     get_far_parent(tb, h + 1, &curf, &curcf,\n\t\t\t\t    RIGHT_PARENTS)) != CARRY_ON)\n\t\t\treturn ret;\n\t} else {\n\t\t/* Current node is not the last child of its parent F[h]. */\n\t\tcurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tcurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\n\t\tget_bh(curf);\n\t\tget_bh(curf);\n\t\ttb->rkey[h] = position;\n\t}\n\n\tbrelse(tb->FR[h]);\n\t/* New initialization of FR[path_offset]. */\n\ttb->FR[h] = curf;\n\n\tbrelse(tb->CFR[h]);\n\t/* New initialization of CFR[path_offset]. */\n\ttb->CFR[h] = curcf;\n\n\tRFALSE((curf && !B_IS_IN_TREE(curf)) ||\n\t       (curcf && !B_IS_IN_TREE(curcf)),\n\t       \"PAP-8205: FR (%b) or CFR (%b) is invalid\", curf, curcf);\n\n\treturn CARRY_ON;\n}"
  },
  {
    "function_name": "get_far_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "1025-1162",
    "snippet": "static int get_far_parent(struct tree_balance *tb,\n\t\t\t  int h,\n\t\t\t  struct buffer_head **pfather,\n\t\t\t  struct buffer_head **pcom_father, char c_lr_par)\n{\n\tstruct buffer_head *parent;\n\tINITIALIZE_PATH(s_path_to_neighbor_father);\n\tstruct treepath *path = tb->tb_path;\n\tstruct cpu_key s_lr_father_key;\n\tint counter,\n\t    position = INT_MAX,\n\t    first_last_position = 0,\n\t    path_offset = PATH_H_PATH_OFFSET(path, h);\n\n\t/*\n\t * Starting from F[h] go upwards in the tree, and look for the common\n\t * ancestor of F[h], and its neighbor l/r, that should be obtained.\n\t */\n\n\tcounter = path_offset;\n\n\tRFALSE(counter < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-8180: invalid path length\");\n\n\tfor (; counter > FIRST_PATH_ELEMENT_OFFSET; counter--) {\n\t\t/*\n\t\t * Check whether parent of the current buffer in the path\n\t\t * is really parent in the tree.\n\t\t */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent = PATH_OFFSET_PBUFFER(path, counter - 1)))\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(path,\n\t\t\t\t\t  counter - 1)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t/*\n\t\t * Check whether parent at the path really points\n\t\t * to the child.\n\t\t */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(path, counter)->b_blocknr)\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t/*\n\t\t * Return delimiting key if position in the parent is not\n\t\t * equal to first/last one.\n\t\t */\n\t\tif (c_lr_par == RIGHT_PARENTS)\n\t\t\tfirst_last_position = B_NR_ITEMS(parent);\n\t\tif (position != first_last_position) {\n\t\t\t*pcom_father = parent;\n\t\t\tget_bh(*pcom_father);\n\t\t\t/*(*pcom_father = parent)->b_count++; */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* if we are in the root of the tree, then there is no common father */\n\tif (counter == FIRST_PATH_ELEMENT_OFFSET) {\n\t\t/*\n\t\t * Check whether first buffer in the path is the\n\t\t * root of the tree.\n\t\t */\n\t\tif (PATH_OFFSET_PBUFFER\n\t\t    (tb->tb_path,\n\t\t     FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==\n\t\t    SB_ROOT_BLOCK(tb->tb_sb)) {\n\t\t\t*pfather = *pcom_father = NULL;\n\t\t\treturn CARRY_ON;\n\t\t}\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\tRFALSE(B_LEVEL(*pcom_father) <= DISK_LEAF_NODE_LEVEL,\n\t       \"PAP-8185: (%b %z) level too small\",\n\t       *pcom_father, *pcom_father);\n\n\t/* Check whether the common parent is locked. */\n\n\tif (buffer_locked(*pcom_father)) {\n\n\t\t/* Release the write lock while the buffer is busy */\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(*pcom_father);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(*pcom_father);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\t}\n\n\t/*\n\t * So, we got common parent of the current node and its\n\t * left/right neighbor.  Now we are getting the parent of the\n\t * left/right neighbor.\n\t */\n\n\t/* Form key to get parent of the left/right neighbor. */\n\tle_key2cpu_key(&s_lr_father_key,\n\t\t       internal_key(*pcom_father,\n\t\t\t\t      (c_lr_par ==\n\t\t\t\t       LEFT_PARENTS) ? (tb->lkey[h - 1] =\n\t\t\t\t\t\t\tposition -\n\t\t\t\t\t\t\t1) : (tb->rkey[h -\n\t\t\t\t\t\t\t\t\t   1] =\n\t\t\t\t\t\t\t      position)));\n\n\tif (c_lr_par == LEFT_PARENTS)\n\t\tdecrement_key(&s_lr_father_key);\n\n\tif (search_by_key\n\t    (tb->tb_sb, &s_lr_father_key, &s_path_to_neighbor_father,\n\t     h + 1) == IO_ERROR)\n\t\t/* path is released */\n\t\treturn IO_ERROR;\n\n\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\tpathrelse(&s_path_to_neighbor_father);\n\t\tbrelse(*pcom_father);\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\t*pfather = PATH_PLAST_BUFFER(&s_path_to_neighbor_father);\n\n\tRFALSE(B_LEVEL(*pfather) != h + 1,\n\t       \"PAP-8190: (%b %z) level too small\", *pfather, *pfather);\n\tRFALSE(s_path_to_neighbor_father.path_length <\n\t       FIRST_PATH_ELEMENT_OFFSET, \"PAP-8192: path length is too small\");\n\n\ts_path_to_neighbor_father.path_length--;\n\tpathrelse(&s_path_to_neighbor_father);\n\treturn CARRY_ON;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define RIGHT_PARENTS 'r'",
      "#define LEFT_PARENTS  'l'"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&s_path_to_neighbor_father"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "s_path_to_neighbor_father.path_length <\n\t       FIRST_PATH_ELEMENT_OFFSET",
            "\"PAP-8192: path length is too small\""
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "B_LEVEL(*pfather) != h + 1",
            "\"PAP-8190: (%b %z) level too small\"",
            "*pfather",
            "*pfather"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_LEVEL",
          "args": [
            "*pfather"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "&s_path_to_neighbor_father"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*pcom_father"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_by_key",
          "args": [
            "tb->tb_sb",
            "&s_lr_father_key",
            "&s_path_to_neighbor_father",
            "h + 1"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "search_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "587-811",
          "snippet": "int search_by_key(struct super_block *sb, const struct cpu_key *key,\n\t\t  struct treepath *search_path, int stop_level)\n{\n\tb_blocknr_t block_number;\n\tint expected_level;\n\tstruct buffer_head *bh;\n\tstruct path_element *last_element;\n\tint node_level, retval;\n\tint right_neighbor_of_leaf_node;\n\tint fs_gen;\n\tstruct buffer_head *reada_bh[SEARCH_BY_KEY_READA];\n\tb_blocknr_t reada_blocks[SEARCH_BY_KEY_READA];\n\tint reada_count = 0;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tint repeat_counter = 0;\n#endif\n\n\tPROC_INFO_INC(sb, search_by_key);\n\n\t/*\n\t * As we add each node to a path we increase its count.  This means\n\t * that we must be careful to release all nodes in a path before we\n\t * either discard the path struct or re-use the path struct, as we\n\t * do here.\n\t */\n\n\tpathrelse(search_path);\n\n\tright_neighbor_of_leaf_node = 0;\n\n\t/*\n\t * With each iteration of this loop we search through the items in the\n\t * current node, and calculate the next current node(next path element)\n\t * for the next iteration of this loop..\n\t */\n\tblock_number = SB_ROOT_BLOCK(sb);\n\texpected_level = -1;\n\twhile (1) {\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (!(++repeat_counter % 50000))\n\t\t\treiserfs_warning(sb, \"PAP-5100\",\n\t\t\t\t\t \"%s: there were %d iterations of \"\n\t\t\t\t\t \"while loop looking for key %K\",\n\t\t\t\t\t current->comm, repeat_counter,\n\t\t\t\t\t key);\n#endif\n\n\t\t/* prep path to have another element added to it. */\n\t\tlast_element =\n\t\t    PATH_OFFSET_PELEMENT(search_path,\n\t\t\t\t\t ++search_path->path_length);\n\t\tfs_gen = get_generation(sb);\n\n\t\t/*\n\t\t * Read the next tree node, and set the last element\n\t\t * in the path to have a pointer to it.\n\t\t */\n\t\tif ((bh = last_element->pe_buffer =\n\t\t     sb_getblk(sb, block_number))) {\n\n\t\t\t/*\n\t\t\t * We'll need to drop the lock if we encounter any\n\t\t\t * buffers that need to be read. If all of them are\n\t\t\t * already up to date, we don't need to drop the lock.\n\t\t\t */\n\t\t\tint depth = -1;\n\n\t\t\tif (!buffer_uptodate(bh) && reada_count > 1)\n\t\t\t\tdepth = search_by_key_reada(sb, reada_bh,\n\t\t\t\t\t\t    reada_blocks, reada_count);\n\n\t\t\tif (!buffer_uptodate(bh) && depth == -1)\n\t\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\twait_on_buffer(bh);\n\n\t\t\tif (depth != -1)\n\t\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tgoto io_error;\n\t\t} else {\nio_error:\n\t\t\tsearch_path->path_length--;\n\t\t\tpathrelse(search_path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\treada_count = 0;\n\t\tif (expected_level == -1)\n\t\t\texpected_level = SB_TREE_HEIGHT(sb);\n\t\texpected_level--;\n\n\t\t/*\n\t\t * It is possible that schedule occurred. We must check\n\t\t * whether the key to search is still in the tree rooted\n\t\t * from the current buffer. If not then repeat search\n\t\t * from the root.\n\t\t */\n\t\tif (fs_changed(fs_gen, sb) &&\n\t\t    (!B_IS_IN_TREE(bh) ||\n\t\t     B_LEVEL(bh) != expected_level ||\n\t\t     !key_in_buffer(search_path, key, sb))) {\n\t\t\tPROC_INFO_INC(sb, search_by_key_fs_changed);\n\t\t\tPROC_INFO_INC(sb, search_by_key_restarted);\n\t\t\tPROC_INFO_INC(sb,\n\t\t\t\t      sbk_restarted[expected_level - 1]);\n\t\t\tpathrelse(search_path);\n\n\t\t\t/*\n\t\t\t * Get the root block number so that we can\n\t\t\t * repeat the search starting from the root.\n\t\t\t */\n\t\t\tblock_number = SB_ROOT_BLOCK(sb);\n\t\t\texpected_level = -1;\n\t\t\tright_neighbor_of_leaf_node = 0;\n\n\t\t\t/* repeat search from the root */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * only check that the key is in the buffer if key is not\n\t\t * equal to the MAX_KEY. Latter case is only possible in\n\t\t * \"finish_unfinished()\" processing during mount.\n\t\t */\n\t\tRFALSE(comp_keys(&MAX_KEY, key) &&\n\t\t       !key_in_buffer(search_path, key, sb),\n\t\t       \"PAP-5130: key is not in the buffer\");\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (REISERFS_SB(sb)->cur_tb) {\n\t\t\tprint_cur_tb(\"5140\");\n\t\t\treiserfs_panic(sb, \"PAP-5140\",\n\t\t\t\t       \"schedule occurred in do_balance!\");\n\t\t}\n#endif\n\n\t\t/*\n\t\t * make sure, that the node contents look like a node of\n\t\t * certain level\n\t\t */\n\t\tif (!is_tree_node(bh, expected_level)) {\n\t\t\treiserfs_error(sb, \"vs-5150\",\n\t\t\t\t       \"invalid format found in block %ld. \"\n\t\t\t\t       \"Fsck?\", bh->b_blocknr);\n\t\t\tpathrelse(search_path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* ok, we have acquired next formatted node in the tree */\n\t\tnode_level = B_LEVEL(bh);\n\n\t\tPROC_INFO_BH_STAT(sb, bh, node_level - 1);\n\n\t\tRFALSE(node_level < stop_level,\n\t\t       \"vs-5152: tree level (%d) is less than stop level (%d)\",\n\t\t       node_level, stop_level);\n\n\t\tretval = bin_search(key, item_head(bh, 0),\n\t\t\t\t      B_NR_ITEMS(bh),\n\t\t\t\t      (node_level ==\n\t\t\t\t       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :\n\t\t\t\t      KEY_SIZE,\n\t\t\t\t      &last_element->pe_position);\n\t\tif (node_level == stop_level) {\n\t\t\treturn retval;\n\t\t}\n\n\t\t/* we are not in the stop level */\n\t\t/*\n\t\t * item has been found, so we choose the pointer which\n\t\t * is to the right of the found one\n\t\t */\n\t\tif (retval == ITEM_FOUND)\n\t\t\tlast_element->pe_position++;\n\n\t\t/*\n\t\t * if item was not found we choose the position which is to\n\t\t * the left of the found item. This requires no code,\n\t\t * bin_search did it already.\n\t\t */\n\n\t\t/*\n\t\t * So we have chosen a position in the current node which is\n\t\t * an internal node.  Now we calculate child block number by\n\t\t * position in the node.\n\t\t */\n\t\tblock_number =\n\t\t    B_N_CHILD_NUM(bh, last_element->pe_position);\n\n\t\t/*\n\t\t * if we are going to read leaf nodes, try for read\n\t\t * ahead as well\n\t\t */\n\t\tif ((search_path->reada & PATH_READA) &&\n\t\t    node_level == DISK_LEAF_NODE_LEVEL + 1) {\n\t\t\tint pos = last_element->pe_position;\n\t\t\tint limit = B_NR_ITEMS(bh);\n\t\t\tstruct reiserfs_key *le_key;\n\n\t\t\tif (search_path->reada & PATH_READA_BACK)\n\t\t\t\tlimit = 0;\n\t\t\twhile (reada_count < SEARCH_BY_KEY_READA) {\n\t\t\t\tif (pos == limit)\n\t\t\t\t\tbreak;\n\t\t\t\treada_blocks[reada_count++] =\n\t\t\t\t    B_N_CHILD_NUM(bh, pos);\n\t\t\t\tif (search_path->reada & PATH_READA_BACK)\n\t\t\t\t\tpos--;\n\t\t\t\telse\n\t\t\t\t\tpos++;\n\n\t\t\t\t/*\n\t\t\t\t * check to make sure we're in the same object\n\t\t\t\t */\n\t\t\t\tle_key = internal_key(bh, pos);\n\t\t\t\tif (le32_to_cpu(le_key->k_objectid) !=\n\t\t\t\t    key->on_disk_key.k_objectid) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define SEARCH_BY_KEY_READA 16"
          ],
          "globals_used": [
            "static const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\n#define SEARCH_BY_KEY_READA 16\n\nstatic const struct reiserfs_key MAX_KEY = {\n\tcpu_to_le32(0xffffffff),\n\tcpu_to_le32(0xffffffff),\n\t{{cpu_to_le32(0xffffffff),\n\t  cpu_to_le32(0xffffffff)},}\n};\n\nint search_by_key(struct super_block *sb, const struct cpu_key *key,\n\t\t  struct treepath *search_path, int stop_level)\n{\n\tb_blocknr_t block_number;\n\tint expected_level;\n\tstruct buffer_head *bh;\n\tstruct path_element *last_element;\n\tint node_level, retval;\n\tint right_neighbor_of_leaf_node;\n\tint fs_gen;\n\tstruct buffer_head *reada_bh[SEARCH_BY_KEY_READA];\n\tb_blocknr_t reada_blocks[SEARCH_BY_KEY_READA];\n\tint reada_count = 0;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tint repeat_counter = 0;\n#endif\n\n\tPROC_INFO_INC(sb, search_by_key);\n\n\t/*\n\t * As we add each node to a path we increase its count.  This means\n\t * that we must be careful to release all nodes in a path before we\n\t * either discard the path struct or re-use the path struct, as we\n\t * do here.\n\t */\n\n\tpathrelse(search_path);\n\n\tright_neighbor_of_leaf_node = 0;\n\n\t/*\n\t * With each iteration of this loop we search through the items in the\n\t * current node, and calculate the next current node(next path element)\n\t * for the next iteration of this loop..\n\t */\n\tblock_number = SB_ROOT_BLOCK(sb);\n\texpected_level = -1;\n\twhile (1) {\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (!(++repeat_counter % 50000))\n\t\t\treiserfs_warning(sb, \"PAP-5100\",\n\t\t\t\t\t \"%s: there were %d iterations of \"\n\t\t\t\t\t \"while loop looking for key %K\",\n\t\t\t\t\t current->comm, repeat_counter,\n\t\t\t\t\t key);\n#endif\n\n\t\t/* prep path to have another element added to it. */\n\t\tlast_element =\n\t\t    PATH_OFFSET_PELEMENT(search_path,\n\t\t\t\t\t ++search_path->path_length);\n\t\tfs_gen = get_generation(sb);\n\n\t\t/*\n\t\t * Read the next tree node, and set the last element\n\t\t * in the path to have a pointer to it.\n\t\t */\n\t\tif ((bh = last_element->pe_buffer =\n\t\t     sb_getblk(sb, block_number))) {\n\n\t\t\t/*\n\t\t\t * We'll need to drop the lock if we encounter any\n\t\t\t * buffers that need to be read. If all of them are\n\t\t\t * already up to date, we don't need to drop the lock.\n\t\t\t */\n\t\t\tint depth = -1;\n\n\t\t\tif (!buffer_uptodate(bh) && reada_count > 1)\n\t\t\t\tdepth = search_by_key_reada(sb, reada_bh,\n\t\t\t\t\t\t    reada_blocks, reada_count);\n\n\t\t\tif (!buffer_uptodate(bh) && depth == -1)\n\t\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\twait_on_buffer(bh);\n\n\t\t\tif (depth != -1)\n\t\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tgoto io_error;\n\t\t} else {\nio_error:\n\t\t\tsearch_path->path_length--;\n\t\t\tpathrelse(search_path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\treada_count = 0;\n\t\tif (expected_level == -1)\n\t\t\texpected_level = SB_TREE_HEIGHT(sb);\n\t\texpected_level--;\n\n\t\t/*\n\t\t * It is possible that schedule occurred. We must check\n\t\t * whether the key to search is still in the tree rooted\n\t\t * from the current buffer. If not then repeat search\n\t\t * from the root.\n\t\t */\n\t\tif (fs_changed(fs_gen, sb) &&\n\t\t    (!B_IS_IN_TREE(bh) ||\n\t\t     B_LEVEL(bh) != expected_level ||\n\t\t     !key_in_buffer(search_path, key, sb))) {\n\t\t\tPROC_INFO_INC(sb, search_by_key_fs_changed);\n\t\t\tPROC_INFO_INC(sb, search_by_key_restarted);\n\t\t\tPROC_INFO_INC(sb,\n\t\t\t\t      sbk_restarted[expected_level - 1]);\n\t\t\tpathrelse(search_path);\n\n\t\t\t/*\n\t\t\t * Get the root block number so that we can\n\t\t\t * repeat the search starting from the root.\n\t\t\t */\n\t\t\tblock_number = SB_ROOT_BLOCK(sb);\n\t\t\texpected_level = -1;\n\t\t\tright_neighbor_of_leaf_node = 0;\n\n\t\t\t/* repeat search from the root */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * only check that the key is in the buffer if key is not\n\t\t * equal to the MAX_KEY. Latter case is only possible in\n\t\t * \"finish_unfinished()\" processing during mount.\n\t\t */\n\t\tRFALSE(comp_keys(&MAX_KEY, key) &&\n\t\t       !key_in_buffer(search_path, key, sb),\n\t\t       \"PAP-5130: key is not in the buffer\");\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (REISERFS_SB(sb)->cur_tb) {\n\t\t\tprint_cur_tb(\"5140\");\n\t\t\treiserfs_panic(sb, \"PAP-5140\",\n\t\t\t\t       \"schedule occurred in do_balance!\");\n\t\t}\n#endif\n\n\t\t/*\n\t\t * make sure, that the node contents look like a node of\n\t\t * certain level\n\t\t */\n\t\tif (!is_tree_node(bh, expected_level)) {\n\t\t\treiserfs_error(sb, \"vs-5150\",\n\t\t\t\t       \"invalid format found in block %ld. \"\n\t\t\t\t       \"Fsck?\", bh->b_blocknr);\n\t\t\tpathrelse(search_path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* ok, we have acquired next formatted node in the tree */\n\t\tnode_level = B_LEVEL(bh);\n\n\t\tPROC_INFO_BH_STAT(sb, bh, node_level - 1);\n\n\t\tRFALSE(node_level < stop_level,\n\t\t       \"vs-5152: tree level (%d) is less than stop level (%d)\",\n\t\t       node_level, stop_level);\n\n\t\tretval = bin_search(key, item_head(bh, 0),\n\t\t\t\t      B_NR_ITEMS(bh),\n\t\t\t\t      (node_level ==\n\t\t\t\t       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :\n\t\t\t\t      KEY_SIZE,\n\t\t\t\t      &last_element->pe_position);\n\t\tif (node_level == stop_level) {\n\t\t\treturn retval;\n\t\t}\n\n\t\t/* we are not in the stop level */\n\t\t/*\n\t\t * item has been found, so we choose the pointer which\n\t\t * is to the right of the found one\n\t\t */\n\t\tif (retval == ITEM_FOUND)\n\t\t\tlast_element->pe_position++;\n\n\t\t/*\n\t\t * if item was not found we choose the position which is to\n\t\t * the left of the found item. This requires no code,\n\t\t * bin_search did it already.\n\t\t */\n\n\t\t/*\n\t\t * So we have chosen a position in the current node which is\n\t\t * an internal node.  Now we calculate child block number by\n\t\t * position in the node.\n\t\t */\n\t\tblock_number =\n\t\t    B_N_CHILD_NUM(bh, last_element->pe_position);\n\n\t\t/*\n\t\t * if we are going to read leaf nodes, try for read\n\t\t * ahead as well\n\t\t */\n\t\tif ((search_path->reada & PATH_READA) &&\n\t\t    node_level == DISK_LEAF_NODE_LEVEL + 1) {\n\t\t\tint pos = last_element->pe_position;\n\t\t\tint limit = B_NR_ITEMS(bh);\n\t\t\tstruct reiserfs_key *le_key;\n\n\t\t\tif (search_path->reada & PATH_READA_BACK)\n\t\t\t\tlimit = 0;\n\t\t\twhile (reada_count < SEARCH_BY_KEY_READA) {\n\t\t\t\tif (pos == limit)\n\t\t\t\t\tbreak;\n\t\t\t\treada_blocks[reada_count++] =\n\t\t\t\t    B_N_CHILD_NUM(bh, pos);\n\t\t\t\tif (search_path->reada & PATH_READA_BACK)\n\t\t\t\t\tpos--;\n\t\t\t\telse\n\t\t\t\t\tpos++;\n\n\t\t\t\t/*\n\t\t\t\t * check to make sure we're in the same object\n\t\t\t\t */\n\t\t\t\tle_key = internal_key(bh, pos);\n\t\t\t\tif (le32_to_cpu(le_key->k_objectid) !=\n\t\t\t\t    key->on_disk_key.k_objectid) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "decrement_key",
          "args": [
            "&s_lr_father_key"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "decrement_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "1008-1012",
          "snippet": "static void decrement_key(struct cpu_key *key)\n{\n\t/* call item specific function for this key */\n\titem_ops[cpu_key_k_type(key)]->decrement_key(key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void decrement_key(struct cpu_key *key)\n{\n\t/* call item specific function for this key */\n\titem_ops[cpu_key_k_type(key)]->decrement_key(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_key2cpu_key",
          "args": [
            "&s_lr_father_key",
            "internal_key(*pcom_father,\n\t\t\t\t      (c_lr_par ==\n\t\t\t\t       LEFT_PARENTS) ? (tb->lkey[h - 1] =\n\t\t\t\t\t\t\tposition -\n\t\t\t\t\t\t\t1) : (tb->rkey[h -\n\t\t\t\t\t\t\t\t\t   1] =\n\t\t\t\t\t\t\t      position))"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "le_key2cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "114-125",
          "snippet": "inline void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from)\n{\n\tint version;\n\tto->on_disk_key.k_dir_id = le32_to_cpu(from->k_dir_id);\n\tto->on_disk_key.k_objectid = le32_to_cpu(from->k_objectid);\n\n\t/* find out version of the key */\n\tversion = le_key_version(from);\n\tto->version = version;\n\tto->on_disk_key.k_offset = le_key_k_offset(version, from);\n\tto->on_disk_key.k_type = le_key_k_type(version, from);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from)\n{\n\tint version;\n\tto->on_disk_key.k_dir_id = le32_to_cpu(from->k_dir_id);\n\tto->on_disk_key.k_objectid = le32_to_cpu(from->k_objectid);\n\n\t/* find out version of the key */\n\tversion = le_key_version(from);\n\tto->version = version;\n\tto->on_disk_key.k_offset = le_key_k_offset(version, from);\n\tto->on_disk_key.k_type = le_key_k_type(version, from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "*pcom_father",
            "(c_lr_par ==\n\t\t\t\t       LEFT_PARENTS) ? (tb->lkey[h - 1] =\n\t\t\t\t\t\t\tposition -\n\t\t\t\t\t\t\t1) : (tb->rkey[h -\n\t\t\t\t\t\t\t\t\t   1] =\n\t\t\t\t\t\t\t      position)"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "tb->tb_sb",
            "depth"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wait_on_buffer",
          "args": [
            "*pcom_father"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "tb->tb_sb"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "*pcom_father"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "B_LEVEL(*pcom_father) <= DISK_LEAF_NODE_LEVEL",
            "\"PAP-8185: (%b %z) level too small\"",
            "*pcom_father",
            "*pcom_father"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_LEVEL",
          "args": [
            "*pcom_father"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ROOT_BLOCK",
          "args": [
            "tb->tb_sb"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "tb->tb_path",
            "FIRST_PATH_ELEMENT_OFFSET"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "*pcom_father"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "parent"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "path",
            "counter"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD_NUM",
          "args": [
            "parent",
            "position"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "parent"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_POSITION",
          "args": [
            "path",
            "counter - 1"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "parent = PATH_OFFSET_PBUFFER(path, counter - 1)"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "path",
            "counter - 1"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "counter < FIRST_PATH_ELEMENT_OFFSET",
            "\"PAP-8180: invalid path length\""
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PATH_OFFSET",
          "args": [
            "path",
            "h"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "s_path_to_neighbor_father"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#define RIGHT_PARENTS 'r'\n#define LEFT_PARENTS  'l'\n\nstatic int get_far_parent(struct tree_balance *tb,\n\t\t\t  int h,\n\t\t\t  struct buffer_head **pfather,\n\t\t\t  struct buffer_head **pcom_father, char c_lr_par)\n{\n\tstruct buffer_head *parent;\n\tINITIALIZE_PATH(s_path_to_neighbor_father);\n\tstruct treepath *path = tb->tb_path;\n\tstruct cpu_key s_lr_father_key;\n\tint counter,\n\t    position = INT_MAX,\n\t    first_last_position = 0,\n\t    path_offset = PATH_H_PATH_OFFSET(path, h);\n\n\t/*\n\t * Starting from F[h] go upwards in the tree, and look for the common\n\t * ancestor of F[h], and its neighbor l/r, that should be obtained.\n\t */\n\n\tcounter = path_offset;\n\n\tRFALSE(counter < FIRST_PATH_ELEMENT_OFFSET,\n\t       \"PAP-8180: invalid path length\");\n\n\tfor (; counter > FIRST_PATH_ELEMENT_OFFSET; counter--) {\n\t\t/*\n\t\t * Check whether parent of the current buffer in the path\n\t\t * is really parent in the tree.\n\t\t */\n\t\tif (!B_IS_IN_TREE\n\t\t    (parent = PATH_OFFSET_PBUFFER(path, counter - 1)))\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t/* Check whether position in the parent is correct. */\n\t\tif ((position =\n\t\t     PATH_OFFSET_POSITION(path,\n\t\t\t\t\t  counter - 1)) >\n\t\t    B_NR_ITEMS(parent))\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t/*\n\t\t * Check whether parent at the path really points\n\t\t * to the child.\n\t\t */\n\t\tif (B_N_CHILD_NUM(parent, position) !=\n\t\t    PATH_OFFSET_PBUFFER(path, counter)->b_blocknr)\n\t\t\treturn REPEAT_SEARCH;\n\n\t\t/*\n\t\t * Return delimiting key if position in the parent is not\n\t\t * equal to first/last one.\n\t\t */\n\t\tif (c_lr_par == RIGHT_PARENTS)\n\t\t\tfirst_last_position = B_NR_ITEMS(parent);\n\t\tif (position != first_last_position) {\n\t\t\t*pcom_father = parent;\n\t\t\tget_bh(*pcom_father);\n\t\t\t/*(*pcom_father = parent)->b_count++; */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* if we are in the root of the tree, then there is no common father */\n\tif (counter == FIRST_PATH_ELEMENT_OFFSET) {\n\t\t/*\n\t\t * Check whether first buffer in the path is the\n\t\t * root of the tree.\n\t\t */\n\t\tif (PATH_OFFSET_PBUFFER\n\t\t    (tb->tb_path,\n\t\t     FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==\n\t\t    SB_ROOT_BLOCK(tb->tb_sb)) {\n\t\t\t*pfather = *pcom_father = NULL;\n\t\t\treturn CARRY_ON;\n\t\t}\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\tRFALSE(B_LEVEL(*pcom_father) <= DISK_LEAF_NODE_LEVEL,\n\t       \"PAP-8185: (%b %z) level too small\",\n\t       *pcom_father, *pcom_father);\n\n\t/* Check whether the common parent is locked. */\n\n\tif (buffer_locked(*pcom_father)) {\n\n\t\t/* Release the write lock while the buffer is busy */\n\t\tint depth = reiserfs_write_unlock_nested(tb->tb_sb);\n\t\t__wait_on_buffer(*pcom_father);\n\t\treiserfs_write_lock_nested(tb->tb_sb, depth);\n\t\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\t\tbrelse(*pcom_father);\n\t\t\treturn REPEAT_SEARCH;\n\t\t}\n\t}\n\n\t/*\n\t * So, we got common parent of the current node and its\n\t * left/right neighbor.  Now we are getting the parent of the\n\t * left/right neighbor.\n\t */\n\n\t/* Form key to get parent of the left/right neighbor. */\n\tle_key2cpu_key(&s_lr_father_key,\n\t\t       internal_key(*pcom_father,\n\t\t\t\t      (c_lr_par ==\n\t\t\t\t       LEFT_PARENTS) ? (tb->lkey[h - 1] =\n\t\t\t\t\t\t\tposition -\n\t\t\t\t\t\t\t1) : (tb->rkey[h -\n\t\t\t\t\t\t\t\t\t   1] =\n\t\t\t\t\t\t\t      position)));\n\n\tif (c_lr_par == LEFT_PARENTS)\n\t\tdecrement_key(&s_lr_father_key);\n\n\tif (search_by_key\n\t    (tb->tb_sb, &s_lr_father_key, &s_path_to_neighbor_father,\n\t     h + 1) == IO_ERROR)\n\t\t/* path is released */\n\t\treturn IO_ERROR;\n\n\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\tpathrelse(&s_path_to_neighbor_father);\n\t\tbrelse(*pcom_father);\n\t\treturn REPEAT_SEARCH;\n\t}\n\n\t*pfather = PATH_PLAST_BUFFER(&s_path_to_neighbor_father);\n\n\tRFALSE(B_LEVEL(*pfather) != h + 1,\n\t       \"PAP-8190: (%b %z) level too small\", *pfather, *pfather);\n\tRFALSE(s_path_to_neighbor_father.path_length <\n\t       FIRST_PATH_ELEMENT_OFFSET, \"PAP-8192: path length is too small\");\n\n\ts_path_to_neighbor_father.path_length--;\n\tpathrelse(&s_path_to_neighbor_father);\n\treturn CARRY_ON;\n}"
  },
  {
    "function_name": "decrement_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "1008-1012",
    "snippet": "static void decrement_key(struct cpu_key *key)\n{\n\t/* call item specific function for this key */\n\titem_ops[cpu_key_k_type(key)]->decrement_key(key);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "item_ops[cpu_key_k_type",
          "args": [
            "key"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_key_k_type",
          "args": [
            "key"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1588-1591",
          "snippet": "static inline loff_t cpu_key_k_type(const struct cpu_key *key)\n{\n\treturn key->on_disk_key.k_type;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t cpu_key_k_type(const struct cpu_key *key)\n{\n\treturn key->on_disk_key.k_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void decrement_key(struct cpu_key *key)\n{\n\t/* call item specific function for this key */\n\titem_ops[cpu_key_k_type(key)]->decrement_key(key);\n}"
  },
  {
    "function_name": "is_left_neighbor_in_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "961-1003",
    "snippet": "static int is_left_neighbor_in_cache(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *father, *left;\n\tstruct super_block *sb = tb->tb_sb;\n\tb_blocknr_t left_neighbor_blocknr;\n\tint left_neighbor_position;\n\n\t/* Father of the left neighbor does not exist. */\n\tif (!tb->FL[h])\n\t\treturn 0;\n\n\t/* Calculate father of the node to be balanced. */\n\tfather = PATH_H_PBUFFER(tb->tb_path, h + 1);\n\n\tRFALSE(!father ||\n\t       !B_IS_IN_TREE(father) ||\n\t       !B_IS_IN_TREE(tb->FL[h]) ||\n\t       !buffer_uptodate(father) ||\n\t       !buffer_uptodate(tb->FL[h]),\n\t       \"vs-8165: F[h] (%b) or FL[h] (%b) is invalid\",\n\t       father, tb->FL[h]);\n\n\t/*\n\t * Get position of the pointer to the left neighbor\n\t * into the left father.\n\t */\n\tleft_neighbor_position = (father == tb->FL[h]) ?\n\t    tb->lkey[h] : B_NR_ITEMS(tb->FL[h]);\n\t/* Get left neighbor block number. */\n\tleft_neighbor_blocknr =\n\t    B_N_CHILD_NUM(tb->FL[h], left_neighbor_position);\n\t/* Look for the left neighbor in the cache. */\n\tif ((left = sb_find_get_block(sb, left_neighbor_blocknr))) {\n\n\t\tRFALSE(buffer_uptodate(left) && !B_IS_IN_TREE(left),\n\t\t       \"vs-8170: left neighbor (%b %z) is not in the tree\",\n\t\t       left, left);\n\t\tput_bh(left);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "left"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "buffer_uptodate(left) && !B_IS_IN_TREE(left)",
            "\"vs-8170: left neighbor (%b %z) is not in the tree\"",
            "left",
            "left"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "left"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "left"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_find_get_block",
          "args": [
            "sb",
            "left_neighbor_blocknr"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD_NUM",
          "args": [
            "tb->FL[h]",
            "left_neighbor_position"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->FL[h]"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!father ||\n\t       !B_IS_IN_TREE(father) ||\n\t       !B_IS_IN_TREE(tb->FL[h]) ||\n\t       !buffer_uptodate(father) ||\n\t       !buffer_uptodate(tb->FL[h])",
            "\"vs-8165: F[h] (%b) or FL[h] (%b) is invalid\"",
            "father",
            "tb->FL[h]"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int is_left_neighbor_in_cache(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *father, *left;\n\tstruct super_block *sb = tb->tb_sb;\n\tb_blocknr_t left_neighbor_blocknr;\n\tint left_neighbor_position;\n\n\t/* Father of the left neighbor does not exist. */\n\tif (!tb->FL[h])\n\t\treturn 0;\n\n\t/* Calculate father of the node to be balanced. */\n\tfather = PATH_H_PBUFFER(tb->tb_path, h + 1);\n\n\tRFALSE(!father ||\n\t       !B_IS_IN_TREE(father) ||\n\t       !B_IS_IN_TREE(tb->FL[h]) ||\n\t       !buffer_uptodate(father) ||\n\t       !buffer_uptodate(tb->FL[h]),\n\t       \"vs-8165: F[h] (%b) or FL[h] (%b) is invalid\",\n\t       father, tb->FL[h]);\n\n\t/*\n\t * Get position of the pointer to the left neighbor\n\t * into the left father.\n\t */\n\tleft_neighbor_position = (father == tb->FL[h]) ?\n\t    tb->lkey[h] : B_NR_ITEMS(tb->FL[h]);\n\t/* Get left neighbor block number. */\n\tleft_neighbor_blocknr =\n\t    B_N_CHILD_NUM(tb->FL[h], left_neighbor_position);\n\t/* Look for the left neighbor in the cache. */\n\tif ((left = sb_find_get_block(sb, left_neighbor_blocknr))) {\n\n\t\tRFALSE(buffer_uptodate(left) && !B_IS_IN_TREE(left),\n\t\t       \"vs-8170: left neighbor (%b %z) is not in the tree\",\n\t\t       left, left);\n\t\tput_bh(left);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_rfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "940-958",
    "snippet": "static int get_rfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *r, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (r = tb->FR[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == r)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) + 1;\n\telse {\n\t\torder = 0;\n\t\tf = r;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD(f, order)"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "f",
            "order"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "f"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_B_ITEM_ORDER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_rfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *r, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (r = tb->FR[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == r)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) + 1;\n\telse {\n\t\torder = 0;\n\t\tf = r;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n\n}"
  },
  {
    "function_name": "get_lfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "917-934",
    "snippet": "static int get_lfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *l, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (l = tb->FL[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == l)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) - 1;\n\telse {\n\t\torder = B_NR_ITEMS(l);\n\t\tf = l;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD(f, order)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "f",
            "order"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "f"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "l"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_B_ITEM_ORDER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_lfree(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *l, *f;\n\tint order;\n\n\tif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\n\t    (l = tb->FL[h]) == NULL)\n\t\treturn 0;\n\n\tif (f == l)\n\t\torder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) - 1;\n\telse {\n\t\torder = B_NR_ITEMS(l);\n\t\tf = l;\n\t}\n\n\treturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\n}"
  },
  {
    "function_name": "get_empty_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "829-911",
    "snippet": "static int get_empty_nodes(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *new_bh, *Sh = PATH_H_PBUFFER(tb->tb_path, h);\n\tb_blocknr_t *blocknr, blocknrs[MAX_AMOUNT_NEEDED] = { 0, };\n\tint counter, number_of_freeblk;\n\tint  amount_needed;\t/* number of needed empty blocks */\n\tint  retval = CARRY_ON;\n\tstruct super_block *sb = tb->tb_sb;\n\n\t/*\n\t * number_of_freeblk is the number of empty blocks which have been\n\t * acquired for use by the balancing algorithm minus the number of\n\t * empty blocks used in the previous levels of the analysis,\n\t * number_of_freeblk = tb->cur_blknum can be non-zero if a schedule\n\t * occurs after empty blocks are acquired, and the balancing analysis\n\t * is then restarted, amount_needed is the number needed by this\n\t * level (h) of the balancing analysis.\n\t *\n\t * Note that for systems with many processes writing, it would be\n\t * more layout optimal to calculate the total number needed by all\n\t * levels and then to run reiserfs_new_blocks to get all of them at\n\t * once.\n\t */\n\n\t/*\n\t * Initiate number_of_freeblk to the amount acquired prior to the\n\t * restart of the analysis or 0 if not restarted, then subtract the\n\t * amount needed by all of the levels of the tree below h.\n\t */\n\t/* blknum includes S[h], so we subtract 1 in this calculation */\n\tfor (counter = 0, number_of_freeblk = tb->cur_blknum;\n\t     counter < h; counter++)\n\t\tnumber_of_freeblk -=\n\t\t    (tb->blknum[counter]) ? (tb->blknum[counter] -\n\t\t\t\t\t\t   1) : 0;\n\n\t/* Allocate missing empty blocks. */\n\t/* if Sh == 0  then we are getting a new root */\n\tamount_needed = (Sh) ? (tb->blknum[h] - 1) : 1;\n\t/*\n\t * Amount_needed = the amount that we need more than the\n\t * amount that we have.\n\t */\n\tif (amount_needed > number_of_freeblk)\n\t\tamount_needed -= number_of_freeblk;\n\telse\t/* If we have enough already then there is nothing to do. */\n\t\treturn CARRY_ON;\n\n\t/*\n\t * No need to check quota - is not allocated for blocks used\n\t * for formatted nodes\n\t */\n\tif (reiserfs_new_form_blocknrs(tb, blocknrs,\n\t\t\t\t       amount_needed) == NO_DISK_SPACE)\n\t\treturn NO_DISK_SPACE;\n\n\t/* for each blocknumber we just got, get a buffer and stick it on FEB */\n\tfor (blocknr = blocknrs, counter = 0;\n\t     counter < amount_needed; blocknr++, counter++) {\n\n\t\tRFALSE(!*blocknr,\n\t\t       \"PAP-8135: reiserfs_new_blocknrs failed when got new blocks\");\n\n\t\tnew_bh = sb_getblk(sb, *blocknr);\n\t\tRFALSE(buffer_dirty(new_bh) ||\n\t\t       buffer_journaled(new_bh) ||\n\t\t       buffer_journal_dirty(new_bh),\n\t\t       \"PAP-8140: journaled or dirty buffer %b for the new block\",\n\t\t       new_bh);\n\n\t\t/* Put empty buffers into the array. */\n\t\tRFALSE(tb->FEB[tb->cur_blknum],\n\t\t       \"PAP-8141: busy slot for new buffer\");\n\n\t\tset_buffer_journal_new(new_bh);\n\t\ttb->FEB[tb->cur_blknum++] = new_bh;\n\t}\n\n\tif (retval == CARRY_ON && FILESYSTEM_CHANGED_TB(tb))\n\t\tretval = REPEAT_SEARCH;\n\n\treturn retval;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_journal_new",
          "args": [
            "new_bh"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->FEB[tb->cur_blknum]",
            "\"PAP-8141: busy slot for new buffer\""
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "buffer_dirty(new_bh) ||\n\t\t       buffer_journaled(new_bh) ||\n\t\t       buffer_journal_dirty(new_bh)",
            "\"PAP-8140: journaled or dirty buffer %b for the new block\"",
            "new_bh"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "new_bh"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journaled",
          "args": [
            "new_bh"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "new_bh"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "*blocknr"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!*blocknr",
            "\"PAP-8135: reiserfs_new_blocknrs failed when got new blocks\""
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_new_form_blocknrs",
          "args": [
            "tb",
            "blocknrs",
            "amount_needed"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_new_form_blocknrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3329-3343",
          "snippet": "static inline int reiserfs_new_form_blocknrs(struct tree_balance *tb,\n\t\t\t\t\t     b_blocknr_t * new_blocknrs,\n\t\t\t\t\t     int amount_needed)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = tb->transaction_handle,\n\t\t.path = tb->tb_path,\n\t\t.inode = NULL,\n\t\t.key = tb->key,\n\t\t.block = 0,\n\t\t.formatted_node = 1\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, amount_needed,\n\t\t\t\t\t  0);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);",
            "void unfix_nodes(struct tree_balance *);",
            "void store_print_tb(struct tree_balance *tb);",
            "struct buffer_head *get_FEB(struct tree_balance *);",
            "int reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t *, int,\n\t\t\t       int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\nvoid unfix_nodes(struct tree_balance *);\nvoid store_print_tb(struct tree_balance *tb);\nstruct buffer_head *get_FEB(struct tree_balance *);\nint reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t *, int,\n\t\t\t       int);\n\nstatic inline int reiserfs_new_form_blocknrs(struct tree_balance *tb,\n\t\t\t\t\t     b_blocknr_t * new_blocknrs,\n\t\t\t\t\t     int amount_needed)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = tb->transaction_handle,\n\t\t.path = tb->tb_path,\n\t\t.inode = NULL,\n\t\t.key = tb->key,\n\t\t.block = 0,\n\t\t.formatted_node = 1\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, amount_needed,\n\t\t\t\t\t  0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_empty_nodes(struct tree_balance *tb, int h)\n{\n\tstruct buffer_head *new_bh, *Sh = PATH_H_PBUFFER(tb->tb_path, h);\n\tb_blocknr_t *blocknr, blocknrs[MAX_AMOUNT_NEEDED] = { 0, };\n\tint counter, number_of_freeblk;\n\tint  amount_needed;\t/* number of needed empty blocks */\n\tint  retval = CARRY_ON;\n\tstruct super_block *sb = tb->tb_sb;\n\n\t/*\n\t * number_of_freeblk is the number of empty blocks which have been\n\t * acquired for use by the balancing algorithm minus the number of\n\t * empty blocks used in the previous levels of the analysis,\n\t * number_of_freeblk = tb->cur_blknum can be non-zero if a schedule\n\t * occurs after empty blocks are acquired, and the balancing analysis\n\t * is then restarted, amount_needed is the number needed by this\n\t * level (h) of the balancing analysis.\n\t *\n\t * Note that for systems with many processes writing, it would be\n\t * more layout optimal to calculate the total number needed by all\n\t * levels and then to run reiserfs_new_blocks to get all of them at\n\t * once.\n\t */\n\n\t/*\n\t * Initiate number_of_freeblk to the amount acquired prior to the\n\t * restart of the analysis or 0 if not restarted, then subtract the\n\t * amount needed by all of the levels of the tree below h.\n\t */\n\t/* blknum includes S[h], so we subtract 1 in this calculation */\n\tfor (counter = 0, number_of_freeblk = tb->cur_blknum;\n\t     counter < h; counter++)\n\t\tnumber_of_freeblk -=\n\t\t    (tb->blknum[counter]) ? (tb->blknum[counter] -\n\t\t\t\t\t\t   1) : 0;\n\n\t/* Allocate missing empty blocks. */\n\t/* if Sh == 0  then we are getting a new root */\n\tamount_needed = (Sh) ? (tb->blknum[h] - 1) : 1;\n\t/*\n\t * Amount_needed = the amount that we need more than the\n\t * amount that we have.\n\t */\n\tif (amount_needed > number_of_freeblk)\n\t\tamount_needed -= number_of_freeblk;\n\telse\t/* If we have enough already then there is nothing to do. */\n\t\treturn CARRY_ON;\n\n\t/*\n\t * No need to check quota - is not allocated for blocks used\n\t * for formatted nodes\n\t */\n\tif (reiserfs_new_form_blocknrs(tb, blocknrs,\n\t\t\t\t       amount_needed) == NO_DISK_SPACE)\n\t\treturn NO_DISK_SPACE;\n\n\t/* for each blocknumber we just got, get a buffer and stick it on FEB */\n\tfor (blocknr = blocknrs, counter = 0;\n\t     counter < amount_needed; blocknr++, counter++) {\n\n\t\tRFALSE(!*blocknr,\n\t\t       \"PAP-8135: reiserfs_new_blocknrs failed when got new blocks\");\n\n\t\tnew_bh = sb_getblk(sb, *blocknr);\n\t\tRFALSE(buffer_dirty(new_bh) ||\n\t\t       buffer_journaled(new_bh) ||\n\t\t       buffer_journal_dirty(new_bh),\n\t\t       \"PAP-8140: journaled or dirty buffer %b for the new block\",\n\t\t       new_bh);\n\n\t\t/* Put empty buffers into the array. */\n\t\tRFALSE(tb->FEB[tb->cur_blknum],\n\t\t       \"PAP-8141: busy slot for new buffer\");\n\n\t\tset_buffer_journal_new(new_bh);\n\t\ttb->FEB[tb->cur_blknum++] = new_bh;\n\t}\n\n\tif (retval == CARRY_ON && FILESYSTEM_CHANGED_TB(tb))\n\t\tretval = REPEAT_SEARCH;\n\n\treturn retval;\n}"
  },
  {
    "function_name": "free_buffers_in_tb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "799-820",
    "snippet": "static void free_buffers_in_tb(struct tree_balance *tb)\n{\n\tint i;\n\n\tpathrelse(tb->tb_path);\n\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\n\t\ttb->L[i] = NULL;\n\t\ttb->R[i] = NULL;\n\t\ttb->FL[i] = NULL;\n\t\ttb->FR[i] = NULL;\n\t\ttb->CFL[i] = NULL;\n\t\ttb->CFR[i] = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "tb->CFR[i]"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "tb->tb_path"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void free_buffers_in_tb(struct tree_balance *tb)\n{\n\tint i;\n\n\tpathrelse(tb->tb_path);\n\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\n\t\ttb->L[i] = NULL;\n\t\ttb->R[i] = NULL;\n\t\ttb->FL[i] = NULL;\n\t\ttb->FR[i] = NULL;\n\t\ttb->CFL[i] = NULL;\n\t\ttb->CFR[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "are_leaves_removable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "698-757",
    "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "tb->tb_sb",
            "leaves_removable"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_parameters",
          "args": [
            "tb",
            "0",
            "-1",
            "-1",
            "-1",
            "NULL",
            "-1",
            "-1"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "set_parameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "623-648",
          "snippet": "static void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "S0"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "le_ih_k_offset(ih) == DOT_OFFSET",
            "\"vs-8130: first directory item can not be removed until directory is not empty\""
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "ih"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "ih"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "comp_short_le_keys",
          "args": [
            "&ih->ih_key",
            "internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "comp_short_le_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "97-112",
          "snippet": "inline int comp_short_le_keys(const struct reiserfs_key *key1,\n\t\t\t      const struct reiserfs_key *key2)\n{\n\t__u32 *k1_u32, *k2_u32;\n\tint key_length = REISERFS_SHORT_KEY_LEN;\n\n\tk1_u32 = (__u32 *) key1;\n\tk2_u32 = (__u32 *) key2;\n\tfor (; key_length--; ++k1_u32, ++k2_u32) {\n\t\tif (le32_to_cpu(*k1_u32) < le32_to_cpu(*k2_u32))\n\t\t\treturn -1;\n\t\tif (le32_to_cpu(*k1_u32) > le32_to_cpu(*k2_u32))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int comp_short_le_keys(const struct reiserfs_key *key1,\n\t\t\t      const struct reiserfs_key *key2)\n{\n\t__u32 *k1_u32, *k2_u32;\n\tint key_length = REISERFS_SHORT_KEY_LEN;\n\n\tk1_u32 = (__u32 *) key1;\n\tk2_u32 = (__u32 *) key2;\n\tfor (; key_length--; ++k1_u32, ++k2_u32) {\n\t\tif (le32_to_cpu(*k1_u32) < le32_to_cpu(*k2_u32))\n\t\t\treturn -1;\n\t\tif (le32_to_cpu(*k1_u32) > le32_to_cpu(*k2_u32))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "tb->CFR[0]",
            "tb->rkey[0]"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "S0",
            "0"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "B_NR_ITEMS(S0) != 1",
            "\"vs-8125: item number must be 1: it is %d\"",
            "B_NR_ITEMS(S0)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "S0"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "S0"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "function_name": "is_leaf_removable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "654-695",
    "snippet": "static int is_leaf_removable(struct tree_balance *tb)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint to_left, to_right;\n\tint size;\n\tint remain_items;\n\n\t/*\n\t * number of items that will be shifted to left (right) neighbor\n\t * entirely\n\t */\n\tto_left = tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0);\n\tto_right = tb->rnum[0] - ((tb->rbytes != -1) ? 1 : 0);\n\tremain_items = vn->vn_nr_item;\n\n\t/* how many items remain in S[0] after shiftings to neighbors */\n\tremain_items -= (to_left + to_right);\n\n\t/* all content of node can be shifted to neighbors */\n\tif (remain_items < 1) {\n\t\tset_parameters(tb, 0, to_left, vn->vn_nr_item - to_left, 0,\n\t\t\t       NULL, -1, -1);\n\t\treturn 1;\n\t}\n\n\t/* S[0] is not removable */\n\tif (remain_items > 1 || tb->lbytes == -1 || tb->rbytes == -1)\n\t\treturn 0;\n\n\t/* check whether we can divide 1 remaining item between neighbors */\n\n\t/* get size of remaining item (in item units) */\n\tsize = op_unit_num(&vn->vn_vi[to_left]);\n\n\tif (tb->lbytes + tb->rbytes >= size) {\n\t\tset_parameters(tb, 0, to_left + 1, to_right + 1, 0, NULL,\n\t\t\t       tb->lbytes, -1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_parameters",
          "args": [
            "tb",
            "0",
            "to_left + 1",
            "to_right + 1",
            "0",
            "NULL",
            "tb->lbytes",
            "-1"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "set_parameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "623-648",
          "snippet": "static void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "op_unit_num",
          "args": [
            "&vn->vn_vi[to_left]"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int is_leaf_removable(struct tree_balance *tb)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint to_left, to_right;\n\tint size;\n\tint remain_items;\n\n\t/*\n\t * number of items that will be shifted to left (right) neighbor\n\t * entirely\n\t */\n\tto_left = tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0);\n\tto_right = tb->rnum[0] - ((tb->rbytes != -1) ? 1 : 0);\n\tremain_items = vn->vn_nr_item;\n\n\t/* how many items remain in S[0] after shiftings to neighbors */\n\tremain_items -= (to_left + to_right);\n\n\t/* all content of node can be shifted to neighbors */\n\tif (remain_items < 1) {\n\t\tset_parameters(tb, 0, to_left, vn->vn_nr_item - to_left, 0,\n\t\t\t       NULL, -1, -1);\n\t\treturn 1;\n\t}\n\n\t/* S[0] is not removable */\n\tif (remain_items > 1 || tb->lbytes == -1 || tb->rbytes == -1)\n\t\treturn 0;\n\n\t/* check whether we can divide 1 remaining item between neighbors */\n\n\t/* get size of remaining item (in item units) */\n\tsize = op_unit_num(&vn->vn_vi[to_left]);\n\n\tif (tb->lbytes + tb->rbytes >= size) {\n\t\tset_parameters(tb, 0, to_left + 1, to_right + 1, 0, NULL,\n\t\t\t       tb->lbytes, -1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_parameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "623-648",
    "snippet": "static void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PROC_INFO_ADD",
          "args": [
            "tb->tb_sb",
            "rbytes[h]",
            "rb"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_ADD",
          "args": [
            "tb->tb_sb",
            "lbytes[h]",
            "lb"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_ADD",
          "args": [
            "tb->tb_sb",
            "rnum[h]",
            "rnum"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_ADD",
          "args": [
            "tb->tb_sb",
            "lnum[h]",
            "lnum"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void set_parameters(struct tree_balance *tb, int h, int lnum,\n\t\t\t   int rnum, int blk_num, short *s012, int lb, int rb)\n{\n\n\ttb->lnum[h] = lnum;\n\ttb->rnum[h] = rnum;\n\ttb->blknum[h] = blk_num;\n\n\t/* only for leaf level */\n\tif (h == 0) {\n\t\tif (s012 != NULL) {\n\t\t\ttb->s0num = *s012++;\n\t\t\ttb->snum[0] = *s012++;\n\t\t\ttb->snum[1] = *s012++;\n\t\t\ttb->sbytes[0] = *s012++;\n\t\t\ttb->sbytes[1] = *s012;\n\t\t}\n\t\ttb->lbytes = lb;\n\t\ttb->rbytes = rb;\n\t}\n\tPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\n\tPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\n\n\tPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\n\tPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\n}"
  },
  {
    "function_name": "get_num_ver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "374-601",
    "snippet": "static int get_num_ver(int mode, struct tree_balance *tb, int h,\n\t\t       int from, int from_bytes,\n\t\t       int to, int to_bytes, short *snum012, int flow)\n{\n\tint i;\n\tint cur_free;\n\tint units;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint total_node_size, max_node_size, current_item_size;\n\tint needed_nodes;\n\n\t/* position of item we start filling node from */\n\tint start_item;\n\n\t/* position of item we finish filling node by */\n\tint end_item;\n\n\t/*\n\t * number of first bytes (entries for directory) of start_item-th item\n\t * we do not include into node that is being filled\n\t */\n\tint start_bytes;\n\n\t/*\n\t * number of last bytes (entries for directory) of end_item-th item\n\t * we do node include into node that is being filled\n\t */\n\tint end_bytes;\n\n\t/*\n\t * these are positions in virtual item of items, that are split\n\t * between S[0] and S1new and S1new and S2new\n\t */\n\tint split_item_positions[2];\n\n\tsplit_item_positions[0] = -1;\n\tsplit_item_positions[1] = -1;\n\n\t/*\n\t * We only create additional nodes if we are in insert or paste mode\n\t * or we are in replace mode at the internal level. If h is 0 and\n\t * the mode is M_REPLACE then in fix_nodes we change the mode to\n\t * paste or insert before we get here in the code.\n\t */\n\tRFALSE(tb->insert_size[h] < 0 || (mode != M_INSERT && mode != M_PASTE),\n\t       \"vs-8100: insert_size < 0 in overflow\");\n\n\tmax_node_size = MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, h));\n\n\t/*\n\t * snum012 [0-2] - number of items, that lay\n\t * to S[0], first new node and second new node\n\t */\n\tsnum012[3] = -1;\t/* s1bytes */\n\tsnum012[4] = -1;\t/* s2bytes */\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ti = ((to - from) * (KEY_SIZE + DC_SIZE) + DC_SIZE);\n\t\tif (i == max_node_size)\n\t\t\treturn 1;\n\t\treturn (i / max_node_size + 1);\n\t}\n\n\t/* leaf level */\n\tneeded_nodes = 1;\n\ttotal_node_size = 0;\n\tcur_free = max_node_size;\n\n\t/* start from 'from'-th item */\n\tstart_item = from;\n\t/* skip its first 'start_bytes' units */\n\tstart_bytes = ((from_bytes != -1) ? from_bytes : 0);\n\n\t/* last included item is the 'end_item'-th one */\n\tend_item = vn->vn_nr_item - to - 1;\n\t/* do not count last 'end_bytes' units of 'end_item'-th item */\n\tend_bytes = (to_bytes != -1) ? to_bytes : 0;\n\n\t/*\n\t * go through all item beginning from the start_item-th item\n\t * and ending by the end_item-th item. Do not count first\n\t * 'start_bytes' units of 'start_item'-th item and last\n\t * 'end_bytes' of 'end_item'-th item\n\t */\n\tfor (i = start_item; i <= end_item; i++) {\n\t\tstruct virtual_item *vi = vn->vn_vi + i;\n\t\tint skip_from_end = ((i == end_item) ? end_bytes : 0);\n\n\t\tRFALSE(needed_nodes > 3, \"vs-8105: too many nodes are needed\");\n\n\t\t/* get size of current item */\n\t\tcurrent_item_size = vi->vi_item_len;\n\n\t\t/*\n\t\t * do not take in calculation head part (from_bytes)\n\t\t * of from-th item\n\t\t */\n\t\tcurrent_item_size -=\n\t\t    op_part_size(vi, 0 /*from start */ , start_bytes);\n\n\t\t/* do not take in calculation tail part of last item */\n\t\tcurrent_item_size -=\n\t\t    op_part_size(vi, 1 /*from end */ , skip_from_end);\n\n\t\t/* if item fits into current node entierly */\n\t\tif (total_node_size + current_item_size <= max_node_size) {\n\t\t\tsnum012[needed_nodes - 1]++;\n\t\t\ttotal_node_size += current_item_size;\n\t\t\tstart_bytes = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * virtual item length is longer, than max size of item in\n\t\t * a node. It is impossible for direct item\n\t\t */\n\t\tif (current_item_size > max_node_size) {\n\t\t\tRFALSE(is_direct_le_ih(vi->vi_ih),\n\t\t\t       \"vs-8110: \"\n\t\t\t       \"direct item length is %d. It can not be longer than %d\",\n\t\t\t       current_item_size, max_node_size);\n\t\t\t/* we will try to split it */\n\t\t\tflow = 1;\n\t\t}\n\n\t\t/* as we do not split items, take new node and continue */\n\t\tif (!flow) {\n\t\t\tneeded_nodes++;\n\t\t\ti--;\n\t\t\ttotal_node_size = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of item units which fit into node being\n\t\t * filled\n\t\t */\n\t\t{\n\t\t\tint free_space;\n\n\t\t\tfree_space = max_node_size - total_node_size - IH_SIZE;\n\t\t\tunits =\n\t\t\t    op_check_left(vi, free_space, start_bytes,\n\t\t\t\t\t  skip_from_end);\n\t\t\t/*\n\t\t\t * nothing fits into current node, take new\n\t\t\t * node and continue\n\t\t\t */\n\t\t\tif (units == -1) {\n\t\t\t\tneeded_nodes++, i--, total_node_size = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* something fits into the current node */\n\t\tstart_bytes += units;\n\t\tsnum012[needed_nodes - 1 + 3] = units;\n\n\t\tif (needed_nodes > 2)\n\t\t\treiserfs_warning(tb->tb_sb, \"vs-8111\",\n\t\t\t\t\t \"split_item_position is out of range\");\n\t\tsnum012[needed_nodes - 1]++;\n\t\tsplit_item_positions[needed_nodes - 1] = i;\n\t\tneeded_nodes++;\n\t\t/* continue from the same item with start_bytes != -1 */\n\t\tstart_item = i;\n\t\ti--;\n\t\ttotal_node_size = 0;\n\t}\n\n\t/*\n\t * sum012[4] (if it is not -1) contains number of units of which\n\t * are to be in S1new, snum012[3] - to be in S0. They are supposed\n\t * to be S1bytes and S2bytes correspondingly, so recalculate\n\t */\n\tif (snum012[4] > 0) {\n\t\tint split_item_num;\n\t\tint bytes_to_r, bytes_to_l;\n\t\tint bytes_to_S1new;\n\n\t\tsplit_item_num = split_item_positions[1];\n\t\tbytes_to_l =\n\t\t    ((from == split_item_num\n\t\t      && from_bytes != -1) ? from_bytes : 0);\n\t\tbytes_to_r =\n\t\t    ((end_item == split_item_num\n\t\t      && end_bytes != -1) ? end_bytes : 0);\n\t\tbytes_to_S1new =\n\t\t    ((split_item_positions[0] ==\n\t\t      split_item_positions[1]) ? snum012[3] : 0);\n\n\t\t/* s2bytes */\n\t\tsnum012[4] =\n\t\t    op_unit_num(&vn->vn_vi[split_item_num]) - snum012[4] -\n\t\t    bytes_to_r - bytes_to_l - bytes_to_S1new;\n\n\t\tif (vn->vn_vi[split_item_num].vi_index != TYPE_DIRENTRY &&\n\t\t    vn->vn_vi[split_item_num].vi_index != TYPE_INDIRECT)\n\t\t\treiserfs_warning(tb->tb_sb, \"vs-8115\",\n\t\t\t\t\t \"not directory or indirect item\");\n\t}\n\n\t/* now we know S2bytes, calculate S1bytes */\n\tif (snum012[3] > 0) {\n\t\tint split_item_num;\n\t\tint bytes_to_r, bytes_to_l;\n\t\tint bytes_to_S2new;\n\n\t\tsplit_item_num = split_item_positions[0];\n\t\tbytes_to_l =\n\t\t    ((from == split_item_num\n\t\t      && from_bytes != -1) ? from_bytes : 0);\n\t\tbytes_to_r =\n\t\t    ((end_item == split_item_num\n\t\t      && end_bytes != -1) ? end_bytes : 0);\n\t\tbytes_to_S2new =\n\t\t    ((split_item_positions[0] == split_item_positions[1]\n\t\t      && snum012[4] != -1) ? snum012[4] : 0);\n\n\t\t/* s1bytes */\n\t\tsnum012[3] =\n\t\t    op_unit_num(&vn->vn_vi[split_item_num]) - snum012[3] -\n\t\t    bytes_to_r - bytes_to_l - bytes_to_S2new;\n\t}\n\n\treturn needed_nodes;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "op_unit_num",
          "args": [
            "&vn->vn_vi[split_item_num]"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "tb->tb_sb",
            "\"vs-8115\"",
            "\"not directory or indirect item\""
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_unit_num",
          "args": [
            "&vn->vn_vi[split_item_num]"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "tb->tb_sb",
            "\"vs-8111\"",
            "\"split_item_position is out of range\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_check_left",
          "args": [
            "vi",
            "free_space",
            "start_bytes",
            "skip_from_end"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "is_direct_le_ih(vi->vi_ih)",
            "\"vs-8110: \"\n\t\t\t       \"direct item length is %d. It can not be longer than %d\"",
            "current_item_size",
            "max_node_size"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direct_le_ih",
          "args": [
            "vi->vi_ih"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1567-1570",
          "snippet": "static inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "op_part_size",
          "args": [
            "vi",
            "1/*from end */",
            "skip_from_end"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_part_size",
          "args": [
            "vi",
            "0/*from start */",
            "start_bytes"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "needed_nodes > 3",
            "\"vs-8105: too many nodes are needed\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "PATH_H_PBUFFER(tb->tb_path, h)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->insert_size[h] < 0 || (mode != M_INSERT && mode != M_PASTE)",
            "\"vs-8100: insert_size < 0 in overflow\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int get_num_ver(int mode, struct tree_balance *tb, int h,\n\t\t       int from, int from_bytes,\n\t\t       int to, int to_bytes, short *snum012, int flow)\n{\n\tint i;\n\tint cur_free;\n\tint units;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint total_node_size, max_node_size, current_item_size;\n\tint needed_nodes;\n\n\t/* position of item we start filling node from */\n\tint start_item;\n\n\t/* position of item we finish filling node by */\n\tint end_item;\n\n\t/*\n\t * number of first bytes (entries for directory) of start_item-th item\n\t * we do not include into node that is being filled\n\t */\n\tint start_bytes;\n\n\t/*\n\t * number of last bytes (entries for directory) of end_item-th item\n\t * we do node include into node that is being filled\n\t */\n\tint end_bytes;\n\n\t/*\n\t * these are positions in virtual item of items, that are split\n\t * between S[0] and S1new and S1new and S2new\n\t */\n\tint split_item_positions[2];\n\n\tsplit_item_positions[0] = -1;\n\tsplit_item_positions[1] = -1;\n\n\t/*\n\t * We only create additional nodes if we are in insert or paste mode\n\t * or we are in replace mode at the internal level. If h is 0 and\n\t * the mode is M_REPLACE then in fix_nodes we change the mode to\n\t * paste or insert before we get here in the code.\n\t */\n\tRFALSE(tb->insert_size[h] < 0 || (mode != M_INSERT && mode != M_PASTE),\n\t       \"vs-8100: insert_size < 0 in overflow\");\n\n\tmax_node_size = MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, h));\n\n\t/*\n\t * snum012 [0-2] - number of items, that lay\n\t * to S[0], first new node and second new node\n\t */\n\tsnum012[3] = -1;\t/* s1bytes */\n\tsnum012[4] = -1;\t/* s2bytes */\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ti = ((to - from) * (KEY_SIZE + DC_SIZE) + DC_SIZE);\n\t\tif (i == max_node_size)\n\t\t\treturn 1;\n\t\treturn (i / max_node_size + 1);\n\t}\n\n\t/* leaf level */\n\tneeded_nodes = 1;\n\ttotal_node_size = 0;\n\tcur_free = max_node_size;\n\n\t/* start from 'from'-th item */\n\tstart_item = from;\n\t/* skip its first 'start_bytes' units */\n\tstart_bytes = ((from_bytes != -1) ? from_bytes : 0);\n\n\t/* last included item is the 'end_item'-th one */\n\tend_item = vn->vn_nr_item - to - 1;\n\t/* do not count last 'end_bytes' units of 'end_item'-th item */\n\tend_bytes = (to_bytes != -1) ? to_bytes : 0;\n\n\t/*\n\t * go through all item beginning from the start_item-th item\n\t * and ending by the end_item-th item. Do not count first\n\t * 'start_bytes' units of 'start_item'-th item and last\n\t * 'end_bytes' of 'end_item'-th item\n\t */\n\tfor (i = start_item; i <= end_item; i++) {\n\t\tstruct virtual_item *vi = vn->vn_vi + i;\n\t\tint skip_from_end = ((i == end_item) ? end_bytes : 0);\n\n\t\tRFALSE(needed_nodes > 3, \"vs-8105: too many nodes are needed\");\n\n\t\t/* get size of current item */\n\t\tcurrent_item_size = vi->vi_item_len;\n\n\t\t/*\n\t\t * do not take in calculation head part (from_bytes)\n\t\t * of from-th item\n\t\t */\n\t\tcurrent_item_size -=\n\t\t    op_part_size(vi, 0 /*from start */ , start_bytes);\n\n\t\t/* do not take in calculation tail part of last item */\n\t\tcurrent_item_size -=\n\t\t    op_part_size(vi, 1 /*from end */ , skip_from_end);\n\n\t\t/* if item fits into current node entierly */\n\t\tif (total_node_size + current_item_size <= max_node_size) {\n\t\t\tsnum012[needed_nodes - 1]++;\n\t\t\ttotal_node_size += current_item_size;\n\t\t\tstart_bytes = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * virtual item length is longer, than max size of item in\n\t\t * a node. It is impossible for direct item\n\t\t */\n\t\tif (current_item_size > max_node_size) {\n\t\t\tRFALSE(is_direct_le_ih(vi->vi_ih),\n\t\t\t       \"vs-8110: \"\n\t\t\t       \"direct item length is %d. It can not be longer than %d\",\n\t\t\t       current_item_size, max_node_size);\n\t\t\t/* we will try to split it */\n\t\t\tflow = 1;\n\t\t}\n\n\t\t/* as we do not split items, take new node and continue */\n\t\tif (!flow) {\n\t\t\tneeded_nodes++;\n\t\t\ti--;\n\t\t\ttotal_node_size = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * calculate number of item units which fit into node being\n\t\t * filled\n\t\t */\n\t\t{\n\t\t\tint free_space;\n\n\t\t\tfree_space = max_node_size - total_node_size - IH_SIZE;\n\t\t\tunits =\n\t\t\t    op_check_left(vi, free_space, start_bytes,\n\t\t\t\t\t  skip_from_end);\n\t\t\t/*\n\t\t\t * nothing fits into current node, take new\n\t\t\t * node and continue\n\t\t\t */\n\t\t\tif (units == -1) {\n\t\t\t\tneeded_nodes++, i--, total_node_size = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* something fits into the current node */\n\t\tstart_bytes += units;\n\t\tsnum012[needed_nodes - 1 + 3] = units;\n\n\t\tif (needed_nodes > 2)\n\t\t\treiserfs_warning(tb->tb_sb, \"vs-8111\",\n\t\t\t\t\t \"split_item_position is out of range\");\n\t\tsnum012[needed_nodes - 1]++;\n\t\tsplit_item_positions[needed_nodes - 1] = i;\n\t\tneeded_nodes++;\n\t\t/* continue from the same item with start_bytes != -1 */\n\t\tstart_item = i;\n\t\ti--;\n\t\ttotal_node_size = 0;\n\t}\n\n\t/*\n\t * sum012[4] (if it is not -1) contains number of units of which\n\t * are to be in S1new, snum012[3] - to be in S0. They are supposed\n\t * to be S1bytes and S2bytes correspondingly, so recalculate\n\t */\n\tif (snum012[4] > 0) {\n\t\tint split_item_num;\n\t\tint bytes_to_r, bytes_to_l;\n\t\tint bytes_to_S1new;\n\n\t\tsplit_item_num = split_item_positions[1];\n\t\tbytes_to_l =\n\t\t    ((from == split_item_num\n\t\t      && from_bytes != -1) ? from_bytes : 0);\n\t\tbytes_to_r =\n\t\t    ((end_item == split_item_num\n\t\t      && end_bytes != -1) ? end_bytes : 0);\n\t\tbytes_to_S1new =\n\t\t    ((split_item_positions[0] ==\n\t\t      split_item_positions[1]) ? snum012[3] : 0);\n\n\t\t/* s2bytes */\n\t\tsnum012[4] =\n\t\t    op_unit_num(&vn->vn_vi[split_item_num]) - snum012[4] -\n\t\t    bytes_to_r - bytes_to_l - bytes_to_S1new;\n\n\t\tif (vn->vn_vi[split_item_num].vi_index != TYPE_DIRENTRY &&\n\t\t    vn->vn_vi[split_item_num].vi_index != TYPE_INDIRECT)\n\t\t\treiserfs_warning(tb->tb_sb, \"vs-8115\",\n\t\t\t\t\t \"not directory or indirect item\");\n\t}\n\n\t/* now we know S2bytes, calculate S1bytes */\n\tif (snum012[3] > 0) {\n\t\tint split_item_num;\n\t\tint bytes_to_r, bytes_to_l;\n\t\tint bytes_to_S2new;\n\n\t\tsplit_item_num = split_item_positions[0];\n\t\tbytes_to_l =\n\t\t    ((from == split_item_num\n\t\t      && from_bytes != -1) ? from_bytes : 0);\n\t\tbytes_to_r =\n\t\t    ((end_item == split_item_num\n\t\t      && end_bytes != -1) ? end_bytes : 0);\n\t\tbytes_to_S2new =\n\t\t    ((split_item_positions[0] == split_item_positions[1]\n\t\t      && snum012[4] != -1) ? snum012[4] : 0);\n\n\t\t/* s1bytes */\n\t\tsnum012[3] =\n\t\t    op_unit_num(&vn->vn_vi[split_item_num]) - snum012[3] -\n\t\t    bytes_to_r - bytes_to_l - bytes_to_S2new;\n\t}\n\n\treturn needed_nodes;\n}"
  },
  {
    "function_name": "check_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "280-364",
    "snippet": "static void check_right(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8070: cur_free < 0\");\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->rnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space  */\n\t\ttb->rnum[h] = 0;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8075: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi + vn->vn_nr_item - 1;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_RIGHT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into R[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8080: invalid mode or balance condition failed\");\n\n\t\ttb->rnum[h] = vn->vn_nr_item;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* last item may be merge with first item in right neighbor */\n\tif (vi->vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\td_size = -(int)IH_SIZE, ih_size = 0;\n\n\ttb->rnum[0] = 0;\n\tfor (i = vn->vn_nr_item - 1; i >= 0;\n\t     i--, d_size = 0, ih_size = IH_SIZE, vi--) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->rnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * check whether R[0] can hold ih and at least one\n\t\t * byte of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->rbytes = -1;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * R[0] can hold the header of the item and at least\n\t\t * one byte of its body\n\t\t */\n\t\tcur_free -= ih_size;\t/* cur_free is still > 0 */\n\n\t\ttb->rbytes = op_check_right(vi, cur_free);\n\t\tif (tb->rbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->rnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "op_check_right",
          "args": [
            "vi",
            "cur_free"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE",
            "\"vs-8080: invalid mode or balance condition failed\""
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!PATH_H_PPARENT(tb->tb_path, 0)",
            "\"vs-8075: parent does not exist or invalid\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "cur_free < 0",
            "\"vs-8070: cur_free < 0\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void check_right(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8070: cur_free < 0\");\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->rnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space  */\n\t\ttb->rnum[h] = 0;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8075: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi + vn->vn_nr_item - 1;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_RIGHT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into R[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8080: invalid mode or balance condition failed\");\n\n\t\ttb->rnum[h] = vn->vn_nr_item;\n\t\ttb->rbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* last item may be merge with first item in right neighbor */\n\tif (vi->vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\td_size = -(int)IH_SIZE, ih_size = 0;\n\n\ttb->rnum[0] = 0;\n\tfor (i = vn->vn_nr_item - 1; i >= 0;\n\t     i--, d_size = 0, ih_size = IH_SIZE, vi--) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->rnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * check whether R[0] can hold ih and at least one\n\t\t * byte of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->rbytes = -1;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * R[0] can hold the header of the item and at least\n\t\t * one byte of its body\n\t\t */\n\t\tcur_free -= ih_size;\t/* cur_free is still > 0 */\n\n\t\ttb->rbytes = op_check_right(vi, cur_free);\n\t\tif (tb->rbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->rnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "check_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "194-274",
    "snippet": "static void check_left(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8050: cur_free (%d) < 0\", cur_free);\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->lnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space or nothing to move */\n\t\ttb->lnum[h] = 0;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8055: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_LEFT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into L[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8055: invalid mode or balance condition failed\");\n\n\t\ttb->lnum[0] = vn->vn_nr_item;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* first item may be merge with last item in left neighbor */\n\tif (vi->vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\td_size = -((int)IH_SIZE), ih_size = 0;\n\n\ttb->lnum[0] = 0;\n\tfor (i = 0; i < vn->vn_nr_item;\n\t     i++, ih_size = IH_SIZE, d_size = 0, vi++) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->lnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* the item cannot be shifted entirely, try to split it */\n\t\t/*\n\t\t * check whether L[0] can hold ih and at least one byte\n\t\t * of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->lbytes = -1;\n\t\t\treturn;\n\t\t}\n\t\tcur_free -= ih_size;\n\n\t\ttb->lbytes = op_check_left(vi, cur_free, 0, 0);\n\t\tif (tb->lbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->lnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "op_check_left",
          "args": [
            "vi",
            "cur_free",
            "0",
            "0"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE",
            "\"vs-8055: invalid mode or balance condition failed\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!PATH_H_PPARENT(tb->tb_path, 0)",
            "\"vs-8055: parent does not exist or invalid\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "cur_free < 0",
            "\"vs-8050: cur_free (%d) < 0\"",
            "cur_free"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void check_left(struct tree_balance *tb, int h, int cur_free)\n{\n\tint i;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tstruct virtual_item *vi;\n\tint d_size, ih_size;\n\n\tRFALSE(cur_free < 0, \"vs-8050: cur_free (%d) < 0\", cur_free);\n\n\t/* internal level */\n\tif (h > 0) {\n\t\ttb->lnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* leaf level */\n\n\tif (!cur_free || !vn->vn_nr_item) {\n\t\t/* no free space or nothing to move */\n\t\ttb->lnum[h] = 0;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\tRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"vs-8055: parent does not exist or invalid\");\n\n\tvi = vn->vn_vi;\n\tif ((unsigned int)cur_free >=\n\t    (vn->vn_size -\n\t     ((vi->vi_type & VI_TYPE_LEFT_MERGEABLE) ? IH_SIZE : 0))) {\n\t\t/* all contents of S[0] fits into L[0] */\n\n\t\tRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\n\t\t       \"vs-8055: invalid mode or balance condition failed\");\n\n\t\ttb->lnum[0] = vn->vn_nr_item;\n\t\ttb->lbytes = -1;\n\t\treturn;\n\t}\n\n\td_size = 0, ih_size = IH_SIZE;\n\n\t/* first item may be merge with last item in left neighbor */\n\tif (vi->vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\td_size = -((int)IH_SIZE), ih_size = 0;\n\n\ttb->lnum[0] = 0;\n\tfor (i = 0; i < vn->vn_nr_item;\n\t     i++, ih_size = IH_SIZE, d_size = 0, vi++) {\n\t\td_size += vi->vi_item_len;\n\t\tif (cur_free >= d_size) {\n\t\t\t/* the item can be shifted entirely */\n\t\t\tcur_free -= d_size;\n\t\t\ttb->lnum[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* the item cannot be shifted entirely, try to split it */\n\t\t/*\n\t\t * check whether L[0] can hold ih and at least one byte\n\t\t * of the item body\n\t\t */\n\n\t\t/* cannot shift even a part of the current item */\n\t\tif (cur_free <= ih_size) {\n\t\t\ttb->lbytes = -1;\n\t\t\treturn;\n\t\t}\n\t\tcur_free -= ih_size;\n\n\t\ttb->lbytes = op_check_left(vi, cur_free, 0, 0);\n\t\tif (tb->lbytes != -1)\n\t\t\t/* count partially shifted item */\n\t\t\ttb->lnum[0]++;\n\n\t\tbreak;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "create_virtual_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "51-188",
    "snippet": "static void create_virtual_node(struct tree_balance *tb, int h)\n{\n\tstruct item_head *ih;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint new_num;\n\tstruct buffer_head *Sh;\t/* this comes from tb->S[h] */\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\n\t/* size of changed node */\n\tvn->vn_size =\n\t    MAX_CHILD_SIZE(Sh) - B_FREE_SPACE(Sh) + tb->insert_size[h];\n\n\t/* for internal nodes array if virtual items is not created */\n\tif (h) {\n\t\tvn->vn_nr_item = (vn->vn_size - DC_SIZE) / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* number of items in virtual node  */\n\tvn->vn_nr_item =\n\t    B_NR_ITEMS(Sh) + ((vn->vn_mode == M_INSERT) ? 1 : 0) -\n\t    ((vn->vn_mode == M_DELETE) ? 1 : 0);\n\n\t/* first virtual item */\n\tvn->vn_vi = (struct virtual_item *)(tb->tb_vn + 1);\n\tmemset(vn->vn_vi, 0, vn->vn_nr_item * sizeof(struct virtual_item));\n\tvn->vn_free_ptr += vn->vn_nr_item * sizeof(struct virtual_item);\n\n\t/* first item in the node */\n\tih = item_head(Sh, 0);\n\n\t/* define the mergeability for 0-th item (if it is not being deleted) */\n\tif (op_is_left_mergeable(&ih->ih_key, Sh->b_size)\n\t    && (vn->vn_mode != M_DELETE || vn->vn_affected_item_num))\n\t\tvn->vn_vi[0].vi_type |= VI_TYPE_LEFT_MERGEABLE;\n\n\t/*\n\t * go through all items that remain in the virtual\n\t * node (except for the new (inserted) one)\n\t */\n\tfor (new_num = 0; new_num < vn->vn_nr_item; new_num++) {\n\t\tint j;\n\t\tstruct virtual_item *vi = vn->vn_vi + new_num;\n\t\tint is_affected =\n\t\t    ((new_num != vn->vn_affected_item_num) ? 0 : 1);\n\n\t\tif (is_affected && vn->vn_mode == M_INSERT)\n\t\t\tcontinue;\n\n\t\t/* get item number in source node */\n\t\tj = old_item_num(new_num, vn->vn_affected_item_num,\n\t\t\t\t vn->vn_mode);\n\n\t\tvi->vi_item_len += ih_item_len(ih + j) + IH_SIZE;\n\t\tvi->vi_ih = ih + j;\n\t\tvi->vi_item = ih_item_body(Sh, ih + j);\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\t/*\n\t\t * FIXME: there is no check that item operation did not\n\t\t * consume too much memory\n\t\t */\n\t\tvn->vn_free_ptr +=\n\t\t    op_create_vi(vn, vi, is_affected, tb->insert_size[0]);\n\t\tif (tb->vn_buf + tb->vn_buf_size < vn->vn_free_ptr)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8030\",\n\t\t\t\t       \"virtual node space consumed\");\n\n\t\tif (!is_affected)\n\t\t\t/* this is not being changed */\n\t\t\tcontinue;\n\n\t\tif (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT) {\n\t\t\tvn->vn_vi[new_num].vi_item_len += tb->insert_size[0];\n\t\t\t/* pointer to data which is going to be pasted */\n\t\t\tvi->vi_new_data = vn->vn_data;\n\t\t}\n\t}\n\n\t/* virtual inserted item is not defined yet */\n\tif (vn->vn_mode == M_INSERT) {\n\t\tstruct virtual_item *vi = vn->vn_vi + vn->vn_affected_item_num;\n\n\t\tRFALSE(vn->vn_ins_ih == NULL,\n\t\t       \"vs-8040: item header of inserted item is not specified\");\n\t\tvi->vi_item_len = tb->insert_size[0];\n\t\tvi->vi_ih = vn->vn_ins_ih;\n\t\tvi->vi_item = vn->vn_data;\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\top_create_vi(vn, vi, 0 /*not pasted or cut */ ,\n\t\t\t     tb->insert_size[0]);\n\t}\n\n\t/*\n\t * set right merge flag we take right delimiting key and\n\t * check whether it is a mergeable item\n\t */\n\tif (tb->CFR[0]) {\n\t\tstruct reiserfs_key *key;\n\n\t\tkey = internal_key(tb->CFR[0], tb->rkey[0]);\n\t\tif (op_is_left_mergeable(key, Sh->b_size)\n\t\t    && (vn->vn_mode != M_DELETE\n\t\t\t|| vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1))\n\t\t\tvn->vn_vi[vn->vn_nr_item - 1].vi_type |=\n\t\t\t    VI_TYPE_RIGHT_MERGEABLE;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (op_is_left_mergeable(key, Sh->b_size) &&\n\t\t    !(vn->vn_mode != M_DELETE\n\t\t      || vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1)) {\n\t\t\t/*\n\t\t\t * we delete last item and it could be merged\n\t\t\t * with right neighbor's first item\n\t\t\t */\n\t\t\tif (!\n\t\t\t    (B_NR_ITEMS(Sh) == 1\n\t\t\t     && is_direntry_le_ih(item_head(Sh, 0))\n\t\t\t     && ih_entry_count(item_head(Sh, 0)) == 1)) {\n\t\t\t\t/*\n\t\t\t\t * node contains more than 1 item, or item\n\t\t\t\t * is not directory item, or this item\n\t\t\t\t * contains more than 1 entry\n\t\t\t\t */\n\t\t\t\tprint_block(Sh, 0, -1, -1);\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-8045\",\n\t\t\t\t\t       \"rdkey %k, affected item==%d \"\n\t\t\t\t\t       \"(mode==%c) Must be %c\",\n\t\t\t\t\t       key, vn->vn_affected_item_num,\n\t\t\t\t\t       vn->vn_mode, M_DELETE);\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"vs-8045\"",
            "\"rdkey %k, affected item==%d \"\n\t\t\t\t\t       \"(mode==%c) Must be %c\"",
            "key",
            "vn->vn_affected_item_num",
            "vn->vn_mode",
            "M_DELETE"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_block",
          "args": [
            "Sh",
            "0",
            "-1",
            "-1"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "print_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "593-617",
          "snippet": "void print_block(struct buffer_head *bh, ...)\n{\n\tva_list args;\n\tint mode, first, last;\n\n\tif (!bh) {\n\t\tprintk(\"print_block: buffer is NULL\\n\");\n\t\treturn;\n\t}\n\n\tva_start(args, bh);\n\n\tmode = va_arg(args, int);\n\tfirst = va_arg(args, int);\n\tlast = va_arg(args, int);\n\tif (print_leaf(bh, mode, first, last))\n\t\tif (print_internal(bh, first, last))\n\t\t\tif (print_super_block(bh))\n\t\t\t\tif (print_desc_block(bh))\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"Block %llu contains unformatted data\\n\",\n\t\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid print_block(struct buffer_head *bh, ...)\n{\n\tva_list args;\n\tint mode, first, last;\n\n\tif (!bh) {\n\t\tprintk(\"print_block: buffer is NULL\\n\");\n\t\treturn;\n\t}\n\n\tva_start(args, bh);\n\n\tmode = va_arg(args, int);\n\tfirst = va_arg(args, int);\n\tlast = va_arg(args, int);\n\tif (print_leaf(bh, mode, first, last))\n\t\tif (print_internal(bh, first, last))\n\t\t\tif (print_super_block(bh))\n\t\t\t\tif (print_desc_block(bh))\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"Block %llu contains unformatted data\\n\",\n\t\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "item_head(Sh, 0)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "Sh",
            "0"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "item_head(Sh, 0)"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "Sh"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "Sh"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_is_left_mergeable",
          "args": [
            "key",
            "Sh->b_size"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "Sh"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_is_left_mergeable",
          "args": [
            "key",
            "Sh->b_size"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "tb->CFR[0]",
            "tb->rkey[0]"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "op_create_vi",
          "args": [
            "vn",
            "vi",
            "0/*not pasted or cut */",
            "tb->insert_size[0]"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "vn->vn_ins_ih == NULL",
            "\"vs-8040: item header of inserted item is not specified\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"vs-8030\"",
            "\"virtual node space consumed\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_create_vi",
          "args": [
            "vn",
            "vi",
            "is_affected",
            "tb->insert_size[0]"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_body",
          "args": [
            "Sh",
            "ih + j"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "ih_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2213-2217",
          "snippet": "static inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih + j"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_item_num",
          "args": [
            "new_num",
            "vn->vn_affected_item_num",
            "vn->vn_mode"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "old_item_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "31-49",
          "snippet": "static inline int old_item_num(int new_num, int affected_item_num, int mode)\n{\n\tif (mode == M_PASTE || mode == M_CUT || new_num < affected_item_num)\n\t\treturn new_num;\n\n\tif (mode == M_INSERT) {\n\n\t\tRFALSE(new_num == 0,\n\t\t       \"vs-8005: for INSERT mode and item number of inserted item\");\n\n\t\treturn new_num - 1;\n\t}\n\n\tRFALSE(mode != M_DELETE,\n\t       \"vs-8010: old_item_num: mode must be M_DELETE (mode = \\'%c\\'\",\n\t       mode);\n\t/* delete mode */\n\treturn new_num + 1;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic inline int old_item_num(int new_num, int affected_item_num, int mode)\n{\n\tif (mode == M_PASTE || mode == M_CUT || new_num < affected_item_num)\n\t\treturn new_num;\n\n\tif (mode == M_INSERT) {\n\n\t\tRFALSE(new_num == 0,\n\t\t       \"vs-8005: for INSERT mode and item number of inserted item\");\n\n\t\treturn new_num - 1;\n\t}\n\n\tRFALSE(mode != M_DELETE,\n\t       \"vs-8010: old_item_num: mode must be M_DELETE (mode = \\'%c\\'\",\n\t       mode);\n\t/* delete mode */\n\treturn new_num + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "op_is_left_mergeable",
          "args": [
            "&ih->ih_key",
            "Sh->b_size"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vn->vn_vi",
            "0",
            "vn->vn_nr_item * sizeof(struct virtual_item)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "Sh"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "Sh"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "Sh"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic void create_virtual_node(struct tree_balance *tb, int h)\n{\n\tstruct item_head *ih;\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint new_num;\n\tstruct buffer_head *Sh;\t/* this comes from tb->S[h] */\n\n\tSh = PATH_H_PBUFFER(tb->tb_path, h);\n\n\t/* size of changed node */\n\tvn->vn_size =\n\t    MAX_CHILD_SIZE(Sh) - B_FREE_SPACE(Sh) + tb->insert_size[h];\n\n\t/* for internal nodes array if virtual items is not created */\n\tif (h) {\n\t\tvn->vn_nr_item = (vn->vn_size - DC_SIZE) / (DC_SIZE + KEY_SIZE);\n\t\treturn;\n\t}\n\n\t/* number of items in virtual node  */\n\tvn->vn_nr_item =\n\t    B_NR_ITEMS(Sh) + ((vn->vn_mode == M_INSERT) ? 1 : 0) -\n\t    ((vn->vn_mode == M_DELETE) ? 1 : 0);\n\n\t/* first virtual item */\n\tvn->vn_vi = (struct virtual_item *)(tb->tb_vn + 1);\n\tmemset(vn->vn_vi, 0, vn->vn_nr_item * sizeof(struct virtual_item));\n\tvn->vn_free_ptr += vn->vn_nr_item * sizeof(struct virtual_item);\n\n\t/* first item in the node */\n\tih = item_head(Sh, 0);\n\n\t/* define the mergeability for 0-th item (if it is not being deleted) */\n\tif (op_is_left_mergeable(&ih->ih_key, Sh->b_size)\n\t    && (vn->vn_mode != M_DELETE || vn->vn_affected_item_num))\n\t\tvn->vn_vi[0].vi_type |= VI_TYPE_LEFT_MERGEABLE;\n\n\t/*\n\t * go through all items that remain in the virtual\n\t * node (except for the new (inserted) one)\n\t */\n\tfor (new_num = 0; new_num < vn->vn_nr_item; new_num++) {\n\t\tint j;\n\t\tstruct virtual_item *vi = vn->vn_vi + new_num;\n\t\tint is_affected =\n\t\t    ((new_num != vn->vn_affected_item_num) ? 0 : 1);\n\n\t\tif (is_affected && vn->vn_mode == M_INSERT)\n\t\t\tcontinue;\n\n\t\t/* get item number in source node */\n\t\tj = old_item_num(new_num, vn->vn_affected_item_num,\n\t\t\t\t vn->vn_mode);\n\n\t\tvi->vi_item_len += ih_item_len(ih + j) + IH_SIZE;\n\t\tvi->vi_ih = ih + j;\n\t\tvi->vi_item = ih_item_body(Sh, ih + j);\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\t/*\n\t\t * FIXME: there is no check that item operation did not\n\t\t * consume too much memory\n\t\t */\n\t\tvn->vn_free_ptr +=\n\t\t    op_create_vi(vn, vi, is_affected, tb->insert_size[0]);\n\t\tif (tb->vn_buf + tb->vn_buf_size < vn->vn_free_ptr)\n\t\t\treiserfs_panic(tb->tb_sb, \"vs-8030\",\n\t\t\t\t       \"virtual node space consumed\");\n\n\t\tif (!is_affected)\n\t\t\t/* this is not being changed */\n\t\t\tcontinue;\n\n\t\tif (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT) {\n\t\t\tvn->vn_vi[new_num].vi_item_len += tb->insert_size[0];\n\t\t\t/* pointer to data which is going to be pasted */\n\t\t\tvi->vi_new_data = vn->vn_data;\n\t\t}\n\t}\n\n\t/* virtual inserted item is not defined yet */\n\tif (vn->vn_mode == M_INSERT) {\n\t\tstruct virtual_item *vi = vn->vn_vi + vn->vn_affected_item_num;\n\n\t\tRFALSE(vn->vn_ins_ih == NULL,\n\t\t       \"vs-8040: item header of inserted item is not specified\");\n\t\tvi->vi_item_len = tb->insert_size[0];\n\t\tvi->vi_ih = vn->vn_ins_ih;\n\t\tvi->vi_item = vn->vn_data;\n\t\tvi->vi_uarea = vn->vn_free_ptr;\n\n\t\top_create_vi(vn, vi, 0 /*not pasted or cut */ ,\n\t\t\t     tb->insert_size[0]);\n\t}\n\n\t/*\n\t * set right merge flag we take right delimiting key and\n\t * check whether it is a mergeable item\n\t */\n\tif (tb->CFR[0]) {\n\t\tstruct reiserfs_key *key;\n\n\t\tkey = internal_key(tb->CFR[0], tb->rkey[0]);\n\t\tif (op_is_left_mergeable(key, Sh->b_size)\n\t\t    && (vn->vn_mode != M_DELETE\n\t\t\t|| vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1))\n\t\t\tvn->vn_vi[vn->vn_nr_item - 1].vi_type |=\n\t\t\t    VI_TYPE_RIGHT_MERGEABLE;\n\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (op_is_left_mergeable(key, Sh->b_size) &&\n\t\t    !(vn->vn_mode != M_DELETE\n\t\t      || vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1)) {\n\t\t\t/*\n\t\t\t * we delete last item and it could be merged\n\t\t\t * with right neighbor's first item\n\t\t\t */\n\t\t\tif (!\n\t\t\t    (B_NR_ITEMS(Sh) == 1\n\t\t\t     && is_direntry_le_ih(item_head(Sh, 0))\n\t\t\t     && ih_entry_count(item_head(Sh, 0)) == 1)) {\n\t\t\t\t/*\n\t\t\t\t * node contains more than 1 item, or item\n\t\t\t\t * is not directory item, or this item\n\t\t\t\t * contains more than 1 entry\n\t\t\t\t */\n\t\t\t\tprint_block(Sh, 0, -1, -1);\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-8045\",\n\t\t\t\t\t       \"rdkey %k, affected item==%d \"\n\t\t\t\t\t       \"(mode==%c) Must be %c\",\n\t\t\t\t\t       key, vn->vn_affected_item_num,\n\t\t\t\t\t       vn->vn_mode, M_DELETE);\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n}"
  },
  {
    "function_name": "old_item_num",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
    "lines": "31-49",
    "snippet": "static inline int old_item_num(int new_num, int affected_item_num, int mode)\n{\n\tif (mode == M_PASTE || mode == M_CUT || new_num < affected_item_num)\n\t\treturn new_num;\n\n\tif (mode == M_INSERT) {\n\n\t\tRFALSE(new_num == 0,\n\t\t       \"vs-8005: for INSERT mode and item number of inserted item\");\n\n\t\treturn new_num - 1;\n\t}\n\n\tRFALSE(mode != M_DELETE,\n\t       \"vs-8010: old_item_num: mode must be M_DELETE (mode = \\'%c\\'\",\n\t       mode);\n\t/* delete mode */\n\treturn new_num + 1;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "mode != M_DELETE",
            "\"vs-8010: old_item_num: mode must be M_DELETE (mode = \\'%c\\'\"",
            "mode"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "new_num == 0",
            "\"vs-8005: for INSERT mode and item number of inserted item\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic inline int old_item_num(int new_num, int affected_item_num, int mode)\n{\n\tif (mode == M_PASTE || mode == M_CUT || new_num < affected_item_num)\n\t\treturn new_num;\n\n\tif (mode == M_INSERT) {\n\n\t\tRFALSE(new_num == 0,\n\t\t       \"vs-8005: for INSERT mode and item number of inserted item\");\n\n\t\treturn new_num - 1;\n\t}\n\n\tRFALSE(mode != M_DELETE,\n\t       \"vs-8010: old_item_num: mode must be M_DELETE (mode = \\'%c\\'\",\n\t       mode);\n\t/* delete mode */\n\treturn new_num + 1;\n}"
  }
]