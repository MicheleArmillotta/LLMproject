[
  {
    "function_name": "ramfs_nommu_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/file-nommu.c",
    "lines": "265-273",
    "snippet": "static int ramfs_nommu_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn -ENOSYS;\n\n\tfile_accessed(file);\n\tvma->vm_ops = &generic_file_vm_ops;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ramfs_nommu_mmap(struct file *file, struct vm_area_struct *vma);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/pagevec.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ramfs_nommu_mmap(struct file *file, struct vm_area_struct *vma);\n\nstatic int ramfs_nommu_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn -ENOSYS;\n\n\tfile_accessed(file);\n\tvma->vm_ops = &generic_file_vm_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "ramfs_nommu_get_unmapped_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/file-nommu.c",
    "lines": "206-259",
    "snippet": "static unsigned long ramfs_nommu_get_unmapped_area(struct file *file,\n\t\t\t\t\t    unsigned long addr, unsigned long len,\n\t\t\t\t\t    unsigned long pgoff, unsigned long flags)\n{\n\tunsigned long maxpages, lpages, nr, loop, ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct page **pages = NULL, **ptr, *page;\n\tloff_t isize;\n\n\tif (!(flags & MAP_SHARED))\n\t\treturn addr;\n\n\t/* the mapping mustn't extend beyond the EOF */\n\tlpages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tisize = i_size_read(inode);\n\n\tret = -EINVAL;\n\tmaxpages = (isize + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (pgoff >= maxpages)\n\t\tgoto out;\n\n\tif (maxpages - pgoff < lpages)\n\t\tgoto out;\n\n\t/* gang-find the pages */\n\tret = -ENOMEM;\n\tpages = kcalloc(lpages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\tgoto out_free;\n\n\tnr = find_get_pages(inode->i_mapping, pgoff, lpages, pages);\n\tif (nr != lpages)\n\t\tgoto out_free_pages; /* leave if some pages were missing */\n\n\t/* check the pages for physical adjacency */\n\tptr = pages;\n\tpage = *ptr++;\n\tpage++;\n\tfor (loop = lpages; loop > 1; loop--)\n\t\tif (*ptr++ != page++)\n\t\t\tgoto out_free_pages;\n\n\t/* okay - all conditions fulfilled */\n\tret = (unsigned long) page_address(pages[0]);\n\nout_free_pages:\n\tptr = pages;\n\tfor (loop = nr; loop > 0; loop--)\n\t\tput_page(*ptr++);\nout_free:\n\tkfree(pages);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ramfs_nommu_get_unmapped_area(struct file *file,\n\t\t\t\t\t\t   unsigned long addr,\n\t\t\t\t\t\t   unsigned long len,\n\t\t\t\t\t\t   unsigned long pgoff,\n\t\t\t\t\t\t   unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "*ptr++"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pages[0]"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages",
          "args": [
            "inode->i_mapping",
            "pgoff",
            "lpages",
            "pages"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "lpages",
            "sizeof(struct page *)",
            "GFP_KERNEL"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/pagevec.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic unsigned long ramfs_nommu_get_unmapped_area(struct file *file,\n\t\t\t\t\t\t   unsigned long addr,\n\t\t\t\t\t\t   unsigned long len,\n\t\t\t\t\t\t   unsigned long pgoff,\n\t\t\t\t\t\t   unsigned long flags);\n\nstatic unsigned long ramfs_nommu_get_unmapped_area(struct file *file,\n\t\t\t\t\t    unsigned long addr, unsigned long len,\n\t\t\t\t\t    unsigned long pgoff, unsigned long flags)\n{\n\tunsigned long maxpages, lpages, nr, loop, ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct page **pages = NULL, **ptr, *page;\n\tloff_t isize;\n\n\tif (!(flags & MAP_SHARED))\n\t\treturn addr;\n\n\t/* the mapping mustn't extend beyond the EOF */\n\tlpages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tisize = i_size_read(inode);\n\n\tret = -EINVAL;\n\tmaxpages = (isize + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (pgoff >= maxpages)\n\t\tgoto out;\n\n\tif (maxpages - pgoff < lpages)\n\t\tgoto out;\n\n\t/* gang-find the pages */\n\tret = -ENOMEM;\n\tpages = kcalloc(lpages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\tgoto out_free;\n\n\tnr = find_get_pages(inode->i_mapping, pgoff, lpages, pages);\n\tif (nr != lpages)\n\t\tgoto out_free_pages; /* leave if some pages were missing */\n\n\t/* check the pages for physical adjacency */\n\tptr = pages;\n\tpage = *ptr++;\n\tpage++;\n\tfor (loop = lpages; loop > 1; loop--)\n\t\tif (*ptr++ != page++)\n\t\t\tgoto out_free_pages;\n\n\t/* okay - all conditions fulfilled */\n\tret = (unsigned long) page_address(pages[0]);\n\nout_free_pages:\n\tptr = pages;\n\tfor (loop = nr; loop > 0; loop--)\n\t\tput_page(*ptr++);\nout_free:\n\tkfree(pages);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ramfs_nommu_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/file-nommu.c",
    "lines": "166-197",
    "snippet": "static int ramfs_nommu_setattr(struct dentry *dentry, struct iattr *ia)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int old_ia_valid = ia->ia_valid;\n\tint ret = 0;\n\n\t/* POSIX UID/GID verification for setting inode attributes */\n\tret = inode_change_ok(inode, ia);\n\tif (ret)\n\t\treturn ret;\n\n\t/* pick out size-changing events */\n\tif (ia->ia_valid & ATTR_SIZE) {\n\t\tloff_t size = inode->i_size;\n\n\t\tif (ia->ia_size != size) {\n\t\t\tret = ramfs_nommu_resize(inode, ia->ia_size, size);\n\t\t\tif (ret < 0 || ia->ia_valid == ATTR_SIZE)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* we skipped the truncate but must still update\n\t\t\t * timestamps\n\t\t\t */\n\t\t\tia->ia_valid |= ATTR_MTIME|ATTR_CTIME;\n\t\t}\n\t}\n\n\tsetattr_copy(inode, ia);\n out:\n\tia->ia_valid = old_ia_valid;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ramfs_nommu_setattr(struct dentry *, struct iattr *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "ia"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ramfs_nommu_resize",
          "args": [
            "inode",
            "ia->ia_size",
            "size"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ramfs_nommu_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/file-nommu.c",
          "lines": "137-159",
          "snippet": "static int ramfs_nommu_resize(struct inode *inode, loff_t newsize, loff_t size)\n{\n\tint ret;\n\n\t/* assume a truncate from zero size is going to be for the purposes of\n\t * shared mmap */\n\tif (size == 0) {\n\t\tif (unlikely(newsize >> 32))\n\t\t\treturn -EFBIG;\n\n\t\treturn ramfs_nommu_expand_for_mapping(inode, newsize);\n\t}\n\n\t/* check that a decrease in size doesn't cut off any shared mappings */\n\tif (newsize < size) {\n\t\tret = nommu_shrink_inode_mappings(inode, size, newsize);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttruncate_setsize(inode, newsize);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/pagevec.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ramfs_nommu_resize(struct inode *inode, loff_t newsize, loff_t size)\n{\n\tint ret;\n\n\t/* assume a truncate from zero size is going to be for the purposes of\n\t * shared mmap */\n\tif (size == 0) {\n\t\tif (unlikely(newsize >> 32))\n\t\t\treturn -EFBIG;\n\n\t\treturn ramfs_nommu_expand_for_mapping(inode, newsize);\n\t}\n\n\t/* check that a decrease in size doesn't cut off any shared mappings */\n\tif (newsize < size) {\n\t\tret = nommu_shrink_inode_mappings(inode, size, newsize);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttruncate_setsize(inode, newsize);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "ia"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/pagevec.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ramfs_nommu_setattr(struct dentry *, struct iattr *);\n\nstatic int ramfs_nommu_setattr(struct dentry *dentry, struct iattr *ia)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int old_ia_valid = ia->ia_valid;\n\tint ret = 0;\n\n\t/* POSIX UID/GID verification for setting inode attributes */\n\tret = inode_change_ok(inode, ia);\n\tif (ret)\n\t\treturn ret;\n\n\t/* pick out size-changing events */\n\tif (ia->ia_valid & ATTR_SIZE) {\n\t\tloff_t size = inode->i_size;\n\n\t\tif (ia->ia_size != size) {\n\t\t\tret = ramfs_nommu_resize(inode, ia->ia_size, size);\n\t\t\tif (ret < 0 || ia->ia_valid == ATTR_SIZE)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* we skipped the truncate but must still update\n\t\t\t * timestamps\n\t\t\t */\n\t\t\tia->ia_valid |= ATTR_MTIME|ATTR_CTIME;\n\t\t}\n\t}\n\n\tsetattr_copy(inode, ia);\n out:\n\tia->ia_valid = old_ia_valid;\n\treturn ret;\n}"
  },
  {
    "function_name": "ramfs_nommu_resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/file-nommu.c",
    "lines": "137-159",
    "snippet": "static int ramfs_nommu_resize(struct inode *inode, loff_t newsize, loff_t size)\n{\n\tint ret;\n\n\t/* assume a truncate from zero size is going to be for the purposes of\n\t * shared mmap */\n\tif (size == 0) {\n\t\tif (unlikely(newsize >> 32))\n\t\t\treturn -EFBIG;\n\n\t\treturn ramfs_nommu_expand_for_mapping(inode, newsize);\n\t}\n\n\t/* check that a decrease in size doesn't cut off any shared mappings */\n\tif (newsize < size) {\n\t\tret = nommu_shrink_inode_mappings(inode, size, newsize);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttruncate_setsize(inode, newsize);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nommu_shrink_inode_mappings",
          "args": [
            "inode",
            "size",
            "newsize"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ramfs_nommu_expand_for_mapping",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ramfs_nommu_expand_for_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/file-nommu.c",
          "lines": "68-131",
          "snippet": "int ramfs_nommu_expand_for_mapping(struct inode *inode, size_t newsize)\n{\n\tunsigned long npages, xpages, loop;\n\tstruct page *pages;\n\tunsigned order;\n\tvoid *data;\n\tint ret;\n\n\t/* make various checks */\n\torder = get_order(newsize);\n\tif (unlikely(order >= MAX_ORDER))\n\t\treturn -EFBIG;\n\n\tret = inode_newsize_ok(inode, newsize);\n\tif (ret)\n\t\treturn ret;\n\n\ti_size_write(inode, newsize);\n\n\t/* allocate enough contiguous pages to be able to satisfy the\n\t * request */\n\tpages = alloc_pages(mapping_gfp_mask(inode->i_mapping), order);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\t/* split the high-order page into an array of single pages */\n\txpages = 1UL << order;\n\tnpages = (newsize + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\tsplit_page(pages, order);\n\n\t/* trim off any pages we don't actually require */\n\tfor (loop = npages; loop < xpages; loop++)\n\t\t__free_page(pages + loop);\n\n\t/* clear the memory we allocated */\n\tnewsize = PAGE_SIZE * npages;\n\tdata = page_address(pages);\n\tmemset(data, 0, newsize);\n\n\t/* attach all the pages to the inode's address space */\n\tfor (loop = 0; loop < npages; loop++) {\n\t\tstruct page *page = pages + loop;\n\n\t\tret = add_to_page_cache_lru(page, inode->i_mapping, loop,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto add_error;\n\n\t\t/* prevent the page from being discarded on memory pressure */\n\t\tSetPageDirty(page);\n\t\tSetPageUptodate(page);\n\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\n\treturn 0;\n\nadd_error:\n\twhile (loop < npages)\n\t\t__free_page(pages + loop++);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/pagevec.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint ramfs_nommu_expand_for_mapping(struct inode *inode, size_t newsize)\n{\n\tunsigned long npages, xpages, loop;\n\tstruct page *pages;\n\tunsigned order;\n\tvoid *data;\n\tint ret;\n\n\t/* make various checks */\n\torder = get_order(newsize);\n\tif (unlikely(order >= MAX_ORDER))\n\t\treturn -EFBIG;\n\n\tret = inode_newsize_ok(inode, newsize);\n\tif (ret)\n\t\treturn ret;\n\n\ti_size_write(inode, newsize);\n\n\t/* allocate enough contiguous pages to be able to satisfy the\n\t * request */\n\tpages = alloc_pages(mapping_gfp_mask(inode->i_mapping), order);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\t/* split the high-order page into an array of single pages */\n\txpages = 1UL << order;\n\tnpages = (newsize + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\tsplit_page(pages, order);\n\n\t/* trim off any pages we don't actually require */\n\tfor (loop = npages; loop < xpages; loop++)\n\t\t__free_page(pages + loop);\n\n\t/* clear the memory we allocated */\n\tnewsize = PAGE_SIZE * npages;\n\tdata = page_address(pages);\n\tmemset(data, 0, newsize);\n\n\t/* attach all the pages to the inode's address space */\n\tfor (loop = 0; loop < npages; loop++) {\n\t\tstruct page *page = pages + loop;\n\n\t\tret = add_to_page_cache_lru(page, inode->i_mapping, loop,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto add_error;\n\n\t\t/* prevent the page from being discarded on memory pressure */\n\t\tSetPageDirty(page);\n\t\tSetPageUptodate(page);\n\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\n\treturn 0;\n\nadd_error:\n\twhile (loop < npages)\n\t\t__free_page(pages + loop++);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "newsize >> 32"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/pagevec.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ramfs_nommu_resize(struct inode *inode, loff_t newsize, loff_t size)\n{\n\tint ret;\n\n\t/* assume a truncate from zero size is going to be for the purposes of\n\t * shared mmap */\n\tif (size == 0) {\n\t\tif (unlikely(newsize >> 32))\n\t\t\treturn -EFBIG;\n\n\t\treturn ramfs_nommu_expand_for_mapping(inode, newsize);\n\t}\n\n\t/* check that a decrease in size doesn't cut off any shared mappings */\n\tif (newsize < size) {\n\t\tret = nommu_shrink_inode_mappings(inode, size, newsize);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttruncate_setsize(inode, newsize);\n\treturn 0;\n}"
  },
  {
    "function_name": "ramfs_nommu_expand_for_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/file-nommu.c",
    "lines": "68-131",
    "snippet": "int ramfs_nommu_expand_for_mapping(struct inode *inode, size_t newsize)\n{\n\tunsigned long npages, xpages, loop;\n\tstruct page *pages;\n\tunsigned order;\n\tvoid *data;\n\tint ret;\n\n\t/* make various checks */\n\torder = get_order(newsize);\n\tif (unlikely(order >= MAX_ORDER))\n\t\treturn -EFBIG;\n\n\tret = inode_newsize_ok(inode, newsize);\n\tif (ret)\n\t\treturn ret;\n\n\ti_size_write(inode, newsize);\n\n\t/* allocate enough contiguous pages to be able to satisfy the\n\t * request */\n\tpages = alloc_pages(mapping_gfp_mask(inode->i_mapping), order);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\t/* split the high-order page into an array of single pages */\n\txpages = 1UL << order;\n\tnpages = (newsize + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\tsplit_page(pages, order);\n\n\t/* trim off any pages we don't actually require */\n\tfor (loop = npages; loop < xpages; loop++)\n\t\t__free_page(pages + loop);\n\n\t/* clear the memory we allocated */\n\tnewsize = PAGE_SIZE * npages;\n\tdata = page_address(pages);\n\tmemset(data, 0, newsize);\n\n\t/* attach all the pages to the inode's address space */\n\tfor (loop = 0; loop < npages; loop++) {\n\t\tstruct page *page = pages + loop;\n\n\t\tret = add_to_page_cache_lru(page, inode->i_mapping, loop,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto add_error;\n\n\t\t/* prevent the page from being discarded on memory pressure */\n\t\tSetPageDirty(page);\n\t\tSetPageUptodate(page);\n\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\n\treturn 0;\n\nadd_error:\n\twhile (loop < npages)\n\t\t__free_page(pages + loop++);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "pages + loop++"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "page"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "inode->i_mapping",
            "loop",
            "GFP_KERNEL"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "newsize"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pages"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "pages + loop"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_page",
          "args": [
            "pages",
            "order"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "mapping_gfp_mask(inode->i_mapping)",
            "order"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "7735-7756",
          "snippet": "static struct page **nfs4_alloc_pages(size_t size, gfp_t gfp_flags)\n{\n\tstruct page **pages;\n\tint i;\n\n\tpages = kcalloc(size, sizeof(struct page *), gfp_flags);\n\tif (!pages) {\n\t\tdprintk(\"%s: can't alloc array of %zu pages\\n\", __func__, size);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i]) {\n\t\t\tdprintk(\"%s: failed to allocate page\\n\", __func__);\n\t\t\tnfs4_free_pages(pages, size);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic struct page **nfs4_alloc_pages(size_t size, gfp_t gfp_flags)\n{\n\tstruct page **pages;\n\tint i;\n\n\tpages = kcalloc(size, sizeof(struct page *), gfp_flags);\n\tif (!pages) {\n\t\tdprintk(\"%s: can't alloc array of %zu pages\\n\", __func__, size);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i]) {\n\t\t\tdprintk(\"%s: failed to allocate page\\n\", __func__);\n\t\t\tnfs4_free_pages(pages, size);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "inode->i_mapping"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "99-124",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "order >= MAX_ORDER"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "newsize"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/pagevec.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint ramfs_nommu_expand_for_mapping(struct inode *inode, size_t newsize)\n{\n\tunsigned long npages, xpages, loop;\n\tstruct page *pages;\n\tunsigned order;\n\tvoid *data;\n\tint ret;\n\n\t/* make various checks */\n\torder = get_order(newsize);\n\tif (unlikely(order >= MAX_ORDER))\n\t\treturn -EFBIG;\n\n\tret = inode_newsize_ok(inode, newsize);\n\tif (ret)\n\t\treturn ret;\n\n\ti_size_write(inode, newsize);\n\n\t/* allocate enough contiguous pages to be able to satisfy the\n\t * request */\n\tpages = alloc_pages(mapping_gfp_mask(inode->i_mapping), order);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\t/* split the high-order page into an array of single pages */\n\txpages = 1UL << order;\n\tnpages = (newsize + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\tsplit_page(pages, order);\n\n\t/* trim off any pages we don't actually require */\n\tfor (loop = npages; loop < xpages; loop++)\n\t\t__free_page(pages + loop);\n\n\t/* clear the memory we allocated */\n\tnewsize = PAGE_SIZE * npages;\n\tdata = page_address(pages);\n\tmemset(data, 0, newsize);\n\n\t/* attach all the pages to the inode's address space */\n\tfor (loop = 0; loop < npages; loop++) {\n\t\tstruct page *page = pages + loop;\n\n\t\tret = add_to_page_cache_lru(page, inode->i_mapping, loop,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto add_error;\n\n\t\t/* prevent the page from being discarded on memory pressure */\n\t\tSetPageDirty(page);\n\t\tSetPageUptodate(page);\n\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\n\treturn 0;\n\nadd_error:\n\twhile (loop < npages)\n\t\t__free_page(pages + loop++);\n\treturn ret;\n}"
  },
  {
    "function_name": "ramfs_mmap_capabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ramfs/file-nommu.c",
    "lines": "37-41",
    "snippet": "static unsigned ramfs_mmap_capabilities(struct file *file)\n{\n\treturn NOMMU_MAP_DIRECT | NOMMU_MAP_COPY | NOMMU_MAP_READ |\n\t\tNOMMU_MAP_WRITE | NOMMU_MAP_EXEC;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/pagevec.h>\n#include <linux/ramfs.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic unsigned ramfs_mmap_capabilities(struct file *file)\n{\n\treturn NOMMU_MAP_DIRECT | NOMMU_MAP_COPY | NOMMU_MAP_READ |\n\t\tNOMMU_MAP_WRITE | NOMMU_MAP_EXEC;\n}"
  }
]