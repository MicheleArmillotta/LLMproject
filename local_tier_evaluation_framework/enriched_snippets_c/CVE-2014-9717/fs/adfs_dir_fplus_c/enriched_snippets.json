[
  {
    "function_name": "adfs_fplus_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_fplus.c",
    "lines": "239-256",
    "snippet": "static void\nadfs_fplus_free(struct adfs_dir *dir)\n{\n\tint i;\n\n\tif (dir->bh_fplus) {\n\t\tfor (i = 0; i < dir->nr_buffers; i++)\n\t\t\tbrelse(dir->bh_fplus[i]);\n\n\t\tif (&dir->bh[0] != dir->bh_fplus)\n\t\t\tkfree(dir->bh_fplus);\n\n\t\tdir->bh_fplus = NULL;\n\t}\n\n\tdir->nr_buffers = 0;\n\tdir->sb = NULL;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"adfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dir->bh_fplus"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dir->bh_fplus[i]"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"adfs.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void\nadfs_fplus_free(struct adfs_dir *dir)\n{\n\tint i;\n\n\tif (dir->bh_fplus) {\n\t\tfor (i = 0; i < dir->nr_buffers; i++)\n\t\t\tbrelse(dir->bh_fplus[i]);\n\n\t\tif (&dir->bh[0] != dir->bh_fplus)\n\t\t\tkfree(dir->bh_fplus);\n\n\t\tdir->bh_fplus = NULL;\n\t}\n\n\tdir->nr_buffers = 0;\n\tdir->sb = NULL;\n}"
  },
  {
    "function_name": "adfs_fplus_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_fplus.c",
    "lines": "223-237",
    "snippet": "static int\nadfs_fplus_sync(struct adfs_dir *dir)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = dir->nr_buffers - 1; i >= 0; i--) {\n\t\tstruct buffer_head *bh = dir->bh_fplus[i];\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"adfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_req",
          "args": [
            "bh"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"adfs.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int\nadfs_fplus_sync(struct adfs_dir *dir)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = dir->nr_buffers - 1; i >= 0; i--) {\n\t\tstruct buffer_head *bh = dir->bh_fplus[i];\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "adfs_fplus_getnext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_fplus.c",
    "lines": "164-221",
    "snippet": "static int\nadfs_fplus_getnext(struct adfs_dir *dir, struct object_info *obj)\n{\n\tstruct adfs_bigdirheader *h =\n\t\t(struct adfs_bigdirheader *) dir->bh_fplus[0]->b_data;\n\tstruct adfs_bigdirentry bde;\n\tunsigned int offset;\n\tint i, ret = -ENOENT;\n\n\tif (dir->pos >= le32_to_cpu(h->bigdirentries))\n\t\tgoto out;\n\n\toffset = offsetof(struct adfs_bigdirheader, bigdirname);\n\toffset += ((le32_to_cpu(h->bigdirnamelen) + 4) & ~3);\n\toffset += dir->pos * sizeof(struct adfs_bigdirentry);\n\n\tdir_memcpy(dir, offset, &bde, sizeof(struct adfs_bigdirentry));\n\n\tobj->loadaddr = le32_to_cpu(bde.bigdirload);\n\tobj->execaddr = le32_to_cpu(bde.bigdirexec);\n\tobj->size     = le32_to_cpu(bde.bigdirlen);\n\tobj->file_id  = le32_to_cpu(bde.bigdirindaddr);\n\tobj->attr     = le32_to_cpu(bde.bigdirattr);\n\tobj->name_len = le32_to_cpu(bde.bigdirobnamelen);\n\n\toffset = offsetof(struct adfs_bigdirheader, bigdirname);\n\toffset += ((le32_to_cpu(h->bigdirnamelen) + 4) & ~3);\n\toffset += le32_to_cpu(h->bigdirentries) * sizeof(struct adfs_bigdirentry);\n\toffset += le32_to_cpu(bde.bigdirobnameptr);\n\n\tdir_memcpy(dir, offset, obj->name, obj->name_len);\n\tfor (i = 0; i < obj->name_len; i++)\n\t\tif (obj->name[i] == '/')\n\t\t\tobj->name[i] = '.';\n\n\tobj->filetype = -1;\n\n\t/*\n\t * object is a file and is filetyped and timestamped?\n\t * RISC OS 12-bit filetype is stored in load_address[19:8]\n\t */\n\tif ((0 == (obj->attr & ADFS_NDA_DIRECTORY)) &&\n\t\t(0xfff00000 == (0xfff00000 & obj->loadaddr))) {\n\t\tobj->filetype = (__u16) ((0x000fff00 & obj->loadaddr) >> 8);\n\n\t\t/* optionally append the ,xyz hex filetype suffix */\n\t\tif (ADFS_SB(dir->sb)->s_ftsuffix)\n\t\t\tobj->name_len +=\n\t\t\t\tappend_filetype_suffix(\n\t\t\t\t\t&obj->name[obj->name_len],\n\t\t\t\t\tobj->filetype);\n\t}\n\n\tdir->pos += 1;\n\tret = 0;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"adfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "append_filetype_suffix",
          "args": [
            "&obj->name[obj->name_len]",
            "obj->filetype"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "append_filetype_suffix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "116-126",
          "snippet": "static inline int append_filetype_suffix(char *buf, __u16 filetype)\n{\n\tif (filetype == 0xffff)\t/* no explicit 12-bit file type was set */\n\t\treturn 0;\n\n\t*buf++ = ',';\n\t*buf++ = hex_asc_lo(filetype >> 8);\n\t*buf++ = hex_asc_lo(filetype >> 4);\n\t*buf++ = hex_asc_lo(filetype >> 0);\n\treturn 4;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline int append_filetype_suffix(char *buf, __u16 filetype)\n{\n\tif (filetype == 0xffff)\t/* no explicit 12-bit file type was set */\n\t\treturn 0;\n\n\t*buf++ = ',';\n\t*buf++ = hex_asc_lo(filetype >> 8);\n\t*buf++ = hex_asc_lo(filetype >> 4);\n\t*buf++ = hex_asc_lo(filetype >> 0);\n\treturn 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "dir->sb"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(0x000fff00 & obj->loadaddr) >> 8"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_memcpy",
          "args": [
            "dir",
            "offset",
            "obj->name",
            "obj->name_len"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "dir_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_fplus.c",
          "lines": "136-162",
          "snippet": "static void\ndir_memcpy(struct adfs_dir *dir, unsigned int offset, void *to, int len)\n{\n\tstruct super_block *sb = dir->sb;\n\tunsigned int buffer, partial, remainder;\n\n\tbuffer = offset >> sb->s_blocksize_bits;\n\toffset &= sb->s_blocksize - 1;\n\n\tpartial = sb->s_blocksize - offset;\n\n\tif (partial >= len)\n\t\tmemcpy(to, dir->bh_fplus[buffer]->b_data + offset, len);\n\telse {\n\t\tchar *c = (char *)to;\n\n\t\tremainder = len - partial;\n\n\t\tmemcpy(c,\n\t\t\tdir->bh_fplus[buffer]->b_data + offset,\n\t\t\tpartial);\n\n\t\tmemcpy(c + partial,\n\t\t\tdir->bh_fplus[buffer + 1]->b_data,\n\t\t\tremainder);\n\t}\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"adfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"adfs.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void\ndir_memcpy(struct adfs_dir *dir, unsigned int offset, void *to, int len)\n{\n\tstruct super_block *sb = dir->sb;\n\tunsigned int buffer, partial, remainder;\n\n\tbuffer = offset >> sb->s_blocksize_bits;\n\toffset &= sb->s_blocksize - 1;\n\n\tpartial = sb->s_blocksize - offset;\n\n\tif (partial >= len)\n\t\tmemcpy(to, dir->bh_fplus[buffer]->b_data + offset, len);\n\telse {\n\t\tchar *c = (char *)to;\n\n\t\tremainder = len - partial;\n\n\t\tmemcpy(c,\n\t\t\tdir->bh_fplus[buffer]->b_data + offset,\n\t\t\tpartial);\n\n\t\tmemcpy(c + partial,\n\t\t\tdir->bh_fplus[buffer + 1]->b_data,\n\t\t\tremainder);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bde.bigdirobnameptr"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"adfs.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int\nadfs_fplus_getnext(struct adfs_dir *dir, struct object_info *obj)\n{\n\tstruct adfs_bigdirheader *h =\n\t\t(struct adfs_bigdirheader *) dir->bh_fplus[0]->b_data;\n\tstruct adfs_bigdirentry bde;\n\tunsigned int offset;\n\tint i, ret = -ENOENT;\n\n\tif (dir->pos >= le32_to_cpu(h->bigdirentries))\n\t\tgoto out;\n\n\toffset = offsetof(struct adfs_bigdirheader, bigdirname);\n\toffset += ((le32_to_cpu(h->bigdirnamelen) + 4) & ~3);\n\toffset += dir->pos * sizeof(struct adfs_bigdirentry);\n\n\tdir_memcpy(dir, offset, &bde, sizeof(struct adfs_bigdirentry));\n\n\tobj->loadaddr = le32_to_cpu(bde.bigdirload);\n\tobj->execaddr = le32_to_cpu(bde.bigdirexec);\n\tobj->size     = le32_to_cpu(bde.bigdirlen);\n\tobj->file_id  = le32_to_cpu(bde.bigdirindaddr);\n\tobj->attr     = le32_to_cpu(bde.bigdirattr);\n\tobj->name_len = le32_to_cpu(bde.bigdirobnamelen);\n\n\toffset = offsetof(struct adfs_bigdirheader, bigdirname);\n\toffset += ((le32_to_cpu(h->bigdirnamelen) + 4) & ~3);\n\toffset += le32_to_cpu(h->bigdirentries) * sizeof(struct adfs_bigdirentry);\n\toffset += le32_to_cpu(bde.bigdirobnameptr);\n\n\tdir_memcpy(dir, offset, obj->name, obj->name_len);\n\tfor (i = 0; i < obj->name_len; i++)\n\t\tif (obj->name[i] == '/')\n\t\t\tobj->name[i] = '.';\n\n\tobj->filetype = -1;\n\n\t/*\n\t * object is a file and is filetyped and timestamped?\n\t * RISC OS 12-bit filetype is stored in load_address[19:8]\n\t */\n\tif ((0 == (obj->attr & ADFS_NDA_DIRECTORY)) &&\n\t\t(0xfff00000 == (0xfff00000 & obj->loadaddr))) {\n\t\tobj->filetype = (__u16) ((0x000fff00 & obj->loadaddr) >> 8);\n\n\t\t/* optionally append the ,xyz hex filetype suffix */\n\t\tif (ADFS_SB(dir->sb)->s_ftsuffix)\n\t\t\tobj->name_len +=\n\t\t\t\tappend_filetype_suffix(\n\t\t\t\t\t&obj->name[obj->name_len],\n\t\t\t\t\tobj->filetype);\n\t}\n\n\tdir->pos += 1;\n\tret = 0;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "dir_memcpy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_fplus.c",
    "lines": "136-162",
    "snippet": "static void\ndir_memcpy(struct adfs_dir *dir, unsigned int offset, void *to, int len)\n{\n\tstruct super_block *sb = dir->sb;\n\tunsigned int buffer, partial, remainder;\n\n\tbuffer = offset >> sb->s_blocksize_bits;\n\toffset &= sb->s_blocksize - 1;\n\n\tpartial = sb->s_blocksize - offset;\n\n\tif (partial >= len)\n\t\tmemcpy(to, dir->bh_fplus[buffer]->b_data + offset, len);\n\telse {\n\t\tchar *c = (char *)to;\n\n\t\tremainder = len - partial;\n\n\t\tmemcpy(c,\n\t\t\tdir->bh_fplus[buffer]->b_data + offset,\n\t\t\tpartial);\n\n\t\tmemcpy(c + partial,\n\t\t\tdir->bh_fplus[buffer + 1]->b_data,\n\t\t\tremainder);\n\t}\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"adfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "c + partial",
            "dir->bh_fplus[buffer + 1]->b_data",
            "remainder"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "c",
            "dir->bh_fplus[buffer]->b_data + offset",
            "partial"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to",
            "dir->bh_fplus[buffer]->b_data + offset",
            "len"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"adfs.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic void\ndir_memcpy(struct adfs_dir *dir, unsigned int offset, void *to, int len)\n{\n\tstruct super_block *sb = dir->sb;\n\tunsigned int buffer, partial, remainder;\n\n\tbuffer = offset >> sb->s_blocksize_bits;\n\toffset &= sb->s_blocksize - 1;\n\n\tpartial = sb->s_blocksize - offset;\n\n\tif (partial >= len)\n\t\tmemcpy(to, dir->bh_fplus[buffer]->b_data + offset, len);\n\telse {\n\t\tchar *c = (char *)to;\n\n\t\tremainder = len - partial;\n\n\t\tmemcpy(c,\n\t\t\tdir->bh_fplus[buffer]->b_data + offset,\n\t\t\tpartial);\n\n\t\tmemcpy(c + partial,\n\t\t\tdir->bh_fplus[buffer + 1]->b_data,\n\t\t\tremainder);\n\t}\n}"
  },
  {
    "function_name": "adfs_fplus_setpos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_fplus.c",
    "lines": "121-134",
    "snippet": "static int\nadfs_fplus_setpos(struct adfs_dir *dir, unsigned int fpos)\n{\n\tstruct adfs_bigdirheader *h =\n\t\t(struct adfs_bigdirheader *) dir->bh_fplus[0]->b_data;\n\tint ret = -ENOENT;\n\n\tif (fpos <= le32_to_cpu(h->bigdirentries)) {\n\t\tdir->pos = fpos;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"adfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "h->bigdirentries"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"adfs.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int\nadfs_fplus_setpos(struct adfs_dir *dir, unsigned int fpos)\n{\n\tstruct adfs_bigdirheader *h =\n\t\t(struct adfs_bigdirheader *) dir->bh_fplus[0]->b_data;\n\tint ret = -ENOENT;\n\n\tif (fpos <= le32_to_cpu(h->bigdirentries)) {\n\t\tdir->pos = fpos;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "adfs_fplus_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_fplus.c",
    "lines": "15-119",
    "snippet": "static int\nadfs_fplus_read(struct super_block *sb, unsigned int id, unsigned int sz, struct adfs_dir *dir)\n{\n\tstruct adfs_bigdirheader *h;\n\tstruct adfs_bigdirtail *t;\n\tunsigned long block;\n\tunsigned int blk, size;\n\tint i, ret = -EIO;\n\n\tdir->nr_buffers = 0;\n\n\t/* start off using fixed bh set - only alloc for big dirs */\n\tdir->bh_fplus = &dir->bh[0];\n\n\tblock = __adfs_block_map(sb, id, 0);\n\tif (!block) {\n\t\tadfs_error(sb, \"dir object %X has a hole at offset 0\", id);\n\t\tgoto out;\n\t}\n\n\tdir->bh_fplus[0] = sb_bread(sb, block);\n\tif (!dir->bh_fplus[0])\n\t\tgoto out;\n\tdir->nr_buffers += 1;\n\n\th = (struct adfs_bigdirheader *)dir->bh_fplus[0]->b_data;\n\tsize = le32_to_cpu(h->bigdirsize);\n\tif (size != sz) {\n\t\tprintk(KERN_WARNING \"adfs: adfs_fplus_read:\"\n\t\t\t\t\t\" directory header size %X\\n\"\n\t\t\t\t\t\" does not match directory size %X\\n\",\n\t\t\t\t\tsize, sz);\n\t}\n\n\tif (h->bigdirversion[0] != 0 || h->bigdirversion[1] != 0 ||\n\t    h->bigdirversion[2] != 0 || size & 2047 ||\n\t    h->bigdirstartname != cpu_to_le32(BIGDIRSTARTNAME)) {\n\t\tprintk(KERN_WARNING \"adfs: dir object %X has\"\n\t\t\t\t\t\" malformed dir header\\n\", id);\n\t\tgoto out;\n\t}\n\n\tsize >>= sb->s_blocksize_bits;\n\tif (size > ARRAY_SIZE(dir->bh)) {\n\t\t/* this directory is too big for fixed bh set, must allocate */\n\t\tstruct buffer_head **bh_fplus =\n\t\t\tkcalloc(size, sizeof(struct buffer_head *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!bh_fplus) {\n\t\t\tadfs_error(sb, \"not enough memory for\"\n\t\t\t\t\t\" dir object %X (%d blocks)\", id, size);\n\t\t\tgoto out;\n\t\t}\n\t\tdir->bh_fplus = bh_fplus;\n\t\t/* copy over the pointer to the block that we've already read */\n\t\tdir->bh_fplus[0] = dir->bh[0];\n\t}\n\n\tfor (blk = 1; blk < size; blk++) {\n\t\tblock = __adfs_block_map(sb, id, blk);\n\t\tif (!block) {\n\t\t\tadfs_error(sb, \"dir object %X has a hole at offset %d\", id, blk);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdir->bh_fplus[blk] = sb_bread(sb, block);\n\t\tif (!dir->bh_fplus[blk]) {\n\t\t\tadfs_error(sb,\t\"dir object %x failed read for offset %d, mapped block %lX\",\n\t\t\t\t   id, blk, block);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdir->nr_buffers += 1;\n\t}\n\n\tt = (struct adfs_bigdirtail *)\n\t\t(dir->bh_fplus[size - 1]->b_data + (sb->s_blocksize - 8));\n\n\tif (t->bigdirendname != cpu_to_le32(BIGDIRENDNAME) ||\n\t    t->bigdirendmasseq != h->startmasseq ||\n\t    t->reserved[0] != 0 || t->reserved[1] != 0) {\n\t\tprintk(KERN_WARNING \"adfs: dir object %X has \"\n\t\t\t\t\t\"malformed dir end\\n\", id);\n\t\tgoto out;\n\t}\n\n\tdir->parent_id = le32_to_cpu(h->bigdirparent);\n\tdir->sb = sb;\n\treturn 0;\n\nout:\n\tif (dir->bh_fplus) {\n\t\tfor (i = 0; i < dir->nr_buffers; i++)\n\t\t\tbrelse(dir->bh_fplus[i]);\n\n\t\tif (&dir->bh[0] != dir->bh_fplus)\n\t\t\tkfree(dir->bh_fplus);\n\n\t\tdir->bh_fplus = NULL;\n\t}\n\n\tdir->nr_buffers = 0;\n\tdir->sb = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"adfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dir->bh_fplus"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dir->bh_fplus[i]"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "h->bigdirparent"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"adfs: dir object %X has \"\n\t\t\t\t\t\"malformed dir end\\n\"",
            "id"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "BIGDIRENDNAME"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "sb",
            "\"dir object %x failed read for offset %d, mapped block %lX\"",
            "id",
            "blk",
            "block"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "__adfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "26-38",
          "snippet": "void __adfs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tchar error_buf[128];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\tprintk(KERN_CRIT \"ADFS-fs error (device %s)%s%s: %s\\n\",\n\t\tsb->s_id, function ? \": \" : \"\",\n\t\tfunction ? function : \"\", error_buf);\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid __adfs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tchar error_buf[128];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\tprintk(KERN_CRIT \"ADFS-fs error (device %s)%s%s: %s\\n\",\n\t\tsb->s_id, function ? \": \" : \"\",\n\t\tfunction ? function : \"\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__adfs_block_map",
          "args": [
            "sb",
            "id",
            "blk"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "__adfs_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "196-208",
          "snippet": "static inline int\n__adfs_block_map(struct super_block *sb, unsigned int object_id,\n\t\t unsigned int block)\n{\n\tif (object_id & 255) {\n\t\tunsigned int off;\n\n\t\toff = (object_id & 255) - 1;\n\t\tblock += off << ADFS_SB(sb)->s_log2sharesize;\n\t}\n\n\treturn adfs_map_lookup(sb, object_id >> 8, block);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline int\n__adfs_block_map(struct super_block *sb, unsigned int object_id,\n\t\t unsigned int block)\n{\n\tif (object_id & 255) {\n\t\tunsigned int off;\n\n\t\toff = (object_id & 255) - 1;\n\t\tblock += off << ADFS_SB(sb)->s_log2sharesize;\n\t}\n\n\treturn adfs_map_lookup(sb, object_id >> 8, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "size",
            "sizeof(struct buffer_head *)",
            "GFP_KERNEL"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "dir->bh"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "BIGDIRSTARTNAME"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"adfs.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int\nadfs_fplus_read(struct super_block *sb, unsigned int id, unsigned int sz, struct adfs_dir *dir)\n{\n\tstruct adfs_bigdirheader *h;\n\tstruct adfs_bigdirtail *t;\n\tunsigned long block;\n\tunsigned int blk, size;\n\tint i, ret = -EIO;\n\n\tdir->nr_buffers = 0;\n\n\t/* start off using fixed bh set - only alloc for big dirs */\n\tdir->bh_fplus = &dir->bh[0];\n\n\tblock = __adfs_block_map(sb, id, 0);\n\tif (!block) {\n\t\tadfs_error(sb, \"dir object %X has a hole at offset 0\", id);\n\t\tgoto out;\n\t}\n\n\tdir->bh_fplus[0] = sb_bread(sb, block);\n\tif (!dir->bh_fplus[0])\n\t\tgoto out;\n\tdir->nr_buffers += 1;\n\n\th = (struct adfs_bigdirheader *)dir->bh_fplus[0]->b_data;\n\tsize = le32_to_cpu(h->bigdirsize);\n\tif (size != sz) {\n\t\tprintk(KERN_WARNING \"adfs: adfs_fplus_read:\"\n\t\t\t\t\t\" directory header size %X\\n\"\n\t\t\t\t\t\" does not match directory size %X\\n\",\n\t\t\t\t\tsize, sz);\n\t}\n\n\tif (h->bigdirversion[0] != 0 || h->bigdirversion[1] != 0 ||\n\t    h->bigdirversion[2] != 0 || size & 2047 ||\n\t    h->bigdirstartname != cpu_to_le32(BIGDIRSTARTNAME)) {\n\t\tprintk(KERN_WARNING \"adfs: dir object %X has\"\n\t\t\t\t\t\" malformed dir header\\n\", id);\n\t\tgoto out;\n\t}\n\n\tsize >>= sb->s_blocksize_bits;\n\tif (size > ARRAY_SIZE(dir->bh)) {\n\t\t/* this directory is too big for fixed bh set, must allocate */\n\t\tstruct buffer_head **bh_fplus =\n\t\t\tkcalloc(size, sizeof(struct buffer_head *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!bh_fplus) {\n\t\t\tadfs_error(sb, \"not enough memory for\"\n\t\t\t\t\t\" dir object %X (%d blocks)\", id, size);\n\t\t\tgoto out;\n\t\t}\n\t\tdir->bh_fplus = bh_fplus;\n\t\t/* copy over the pointer to the block that we've already read */\n\t\tdir->bh_fplus[0] = dir->bh[0];\n\t}\n\n\tfor (blk = 1; blk < size; blk++) {\n\t\tblock = __adfs_block_map(sb, id, blk);\n\t\tif (!block) {\n\t\t\tadfs_error(sb, \"dir object %X has a hole at offset %d\", id, blk);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdir->bh_fplus[blk] = sb_bread(sb, block);\n\t\tif (!dir->bh_fplus[blk]) {\n\t\t\tadfs_error(sb,\t\"dir object %x failed read for offset %d, mapped block %lX\",\n\t\t\t\t   id, blk, block);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdir->nr_buffers += 1;\n\t}\n\n\tt = (struct adfs_bigdirtail *)\n\t\t(dir->bh_fplus[size - 1]->b_data + (sb->s_blocksize - 8));\n\n\tif (t->bigdirendname != cpu_to_le32(BIGDIRENDNAME) ||\n\t    t->bigdirendmasseq != h->startmasseq ||\n\t    t->reserved[0] != 0 || t->reserved[1] != 0) {\n\t\tprintk(KERN_WARNING \"adfs: dir object %X has \"\n\t\t\t\t\t\"malformed dir end\\n\", id);\n\t\tgoto out;\n\t}\n\n\tdir->parent_id = le32_to_cpu(h->bigdirparent);\n\tdir->sb = sb;\n\treturn 0;\n\nout:\n\tif (dir->bh_fplus) {\n\t\tfor (i = 0; i < dir->nr_buffers; i++)\n\t\t\tbrelse(dir->bh_fplus[i]);\n\n\t\tif (&dir->bh[0] != dir->bh_fplus)\n\t\t\tkfree(dir->bh_fplus);\n\n\t\tdir->bh_fplus = NULL;\n\t}\n\n\tdir->nr_buffers = 0;\n\tdir->sb = NULL;\n\treturn ret;\n}"
  }
]