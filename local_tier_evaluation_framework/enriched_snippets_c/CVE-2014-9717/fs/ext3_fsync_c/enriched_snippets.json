[
  {
    "function_name": "ext3_sync_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/fsync.c",
    "lines": "41-109",
    "snippet": "int ext3_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tjournal_t *journal = EXT3_SB(inode->i_sb)->s_journal;\n\tint ret, needs_barrier = 0;\n\ttid_t commit_tid;\n\n\ttrace_ext3_sync_file_enter(file, datasync);\n\n\tif (inode->i_sb->s_flags & MS_RDONLY) {\n\t\t/* Make sure that we read updated state */\n\t\tsmp_rmb();\n\t\tif (EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS)\n\t\t\treturn -EROFS;\n\t\treturn 0;\n\t}\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (ret)\n\t\tgoto out;\n\n\tJ_ASSERT(ext3_journal_current_handle() == NULL);\n\n\t/*\n\t * data=writeback,ordered:\n\t *  The caller's filemap_fdatawrite()/wait will sync the data.\n\t *  Metadata is in the journal, we wait for a proper transaction\n\t *  to commit here.\n\t *\n\t * data=journal:\n\t *  filemap_fdatawrite won't do anything (the buffers are clean).\n\t *  ext3_force_commit will write the file data into the journal and\n\t *  will wait on that.\n\t *  filemap_fdatawait() will encounter a ton of newly-dirtied pages\n\t *  (they were dirtied by commit).  But that's OK - the blocks are\n\t *  safe in-journal, which is all fsync() needs to ensure.\n\t */\n\tif (ext3_should_journal_data(inode)) {\n\t\tret = ext3_force_commit(inode->i_sb);\n\t\tgoto out;\n\t}\n\n\tif (datasync)\n\t\tcommit_tid = atomic_read(&ei->i_datasync_tid);\n\telse\n\t\tcommit_tid = atomic_read(&ei->i_sync_tid);\n\n\tif (test_opt(inode->i_sb, BARRIER) &&\n\t    !journal_trans_will_send_data_barrier(journal, commit_tid))\n\t\tneeds_barrier = 1;\n\tlog_start_commit(journal, commit_tid);\n\tret = log_wait_commit(journal, commit_tid);\n\n\t/*\n\t * In case we didn't commit a transaction, we have to flush\n\t * disk caches manually so that data really is on persistent\n\t * storage\n\t */\n\tif (needs_barrier) {\n\t\tint err;\n\n\t\terr = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\nout:\n\ttrace_ext3_sync_file_exit(inode, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext3_sync_file_exit",
          "args": [
            "inode",
            "ret"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "inode->i_sb->s_bdev",
            "GFP_KERNEL",
            "NULL"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_wait_commit",
          "args": [
            "journal",
            "commit_tid"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "569-610",
          "snippet": "int log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_start_commit",
          "args": [
            "journal",
            "commit_tid"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "490-498",
          "snippet": "int log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\tspin_lock(&journal->j_state_lock);\n\tret = __log_start_commit(journal, tid);\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\tspin_lock(&journal->j_state_lock);\n\tret = __log_start_commit(journal, tid);\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_trans_will_send_data_barrier",
          "args": [
            "journal",
            "commit_tid"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "journal_trans_will_send_data_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "618-641",
          "snippet": "int journal_trans_will_send_data_barrier(journal_t *journal, tid_t tid)\n{\n\tint ret = 0;\n\ttransaction_t *commit_trans;\n\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\treturn 0;\n\tspin_lock(&journal->j_state_lock);\n\t/* Transaction already committed? */\n\tif (tid_geq(journal->j_commit_sequence, tid))\n\t\tgoto out;\n\t/*\n\t * Transaction is being committed and we already proceeded to\n\t * writing commit record?\n\t */\n\tcommit_trans = journal->j_committing_transaction;\n\tif (commit_trans && commit_trans->t_tid == tid &&\n\t    commit_trans->t_state >= T_COMMIT_RECORD)\n\t\tgoto out;\n\tret = 1;\nout:\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_trans_will_send_data_barrier(journal_t *journal, tid_t tid)\n{\n\tint ret = 0;\n\ttransaction_t *commit_trans;\n\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\treturn 0;\n\tspin_lock(&journal->j_state_lock);\n\t/* Transaction already committed? */\n\tif (tid_geq(journal->j_commit_sequence, tid))\n\t\tgoto out;\n\t/*\n\t * Transaction is being committed and we already proceeded to\n\t * writing commit record?\n\t */\n\tcommit_trans = journal->j_committing_transaction;\n\tif (commit_trans && commit_trans->t_tid == tid &&\n\t    commit_trans->t_state >= T_COMMIT_RECORD)\n\t\tgoto out;\n\tret = 1;\nout:\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "BARRIER"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ei->i_sync_tid"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ei->i_datasync_tid"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_force_commit",
          "args": [
            "inode->i_sb"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_force_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "2563-2574",
          "snippet": "int ext3_force_commit(struct super_block *sb)\n{\n\tjournal_t *journal;\n\tint ret;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\tret = ext3_journal_force_commit(journal);\n\treturn ret;\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nint ext3_force_commit(struct super_block *sb)\n{\n\tjournal_t *journal;\n\tint ret;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\tret = ext3_journal_force_commit(journal);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1299-1308",
          "snippet": "static inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */",
            "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
          ],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "ext3_journal_current_handle() == NULL"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_current_handle",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_sync_file_enter",
          "args": [
            "file",
            "datasync"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n\nint ext3_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tjournal_t *journal = EXT3_SB(inode->i_sb)->s_journal;\n\tint ret, needs_barrier = 0;\n\ttid_t commit_tid;\n\n\ttrace_ext3_sync_file_enter(file, datasync);\n\n\tif (inode->i_sb->s_flags & MS_RDONLY) {\n\t\t/* Make sure that we read updated state */\n\t\tsmp_rmb();\n\t\tif (EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ERROR_FS)\n\t\t\treturn -EROFS;\n\t\treturn 0;\n\t}\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (ret)\n\t\tgoto out;\n\n\tJ_ASSERT(ext3_journal_current_handle() == NULL);\n\n\t/*\n\t * data=writeback,ordered:\n\t *  The caller's filemap_fdatawrite()/wait will sync the data.\n\t *  Metadata is in the journal, we wait for a proper transaction\n\t *  to commit here.\n\t *\n\t * data=journal:\n\t *  filemap_fdatawrite won't do anything (the buffers are clean).\n\t *  ext3_force_commit will write the file data into the journal and\n\t *  will wait on that.\n\t *  filemap_fdatawait() will encounter a ton of newly-dirtied pages\n\t *  (they were dirtied by commit).  But that's OK - the blocks are\n\t *  safe in-journal, which is all fsync() needs to ensure.\n\t */\n\tif (ext3_should_journal_data(inode)) {\n\t\tret = ext3_force_commit(inode->i_sb);\n\t\tgoto out;\n\t}\n\n\tif (datasync)\n\t\tcommit_tid = atomic_read(&ei->i_datasync_tid);\n\telse\n\t\tcommit_tid = atomic_read(&ei->i_sync_tid);\n\n\tif (test_opt(inode->i_sb, BARRIER) &&\n\t    !journal_trans_will_send_data_barrier(journal, commit_tid))\n\t\tneeds_barrier = 1;\n\tlog_start_commit(journal, commit_tid);\n\tret = log_wait_commit(journal, commit_tid);\n\n\t/*\n\t * In case we didn't commit a transaction, we have to flush\n\t * disk caches manually so that data really is on persistent\n\t * storage\n\t */\n\tif (needs_barrier) {\n\t\tint err;\n\n\t\terr = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\nout:\n\ttrace_ext3_sync_file_exit(inode, ret);\n\treturn ret;\n}"
  }
]