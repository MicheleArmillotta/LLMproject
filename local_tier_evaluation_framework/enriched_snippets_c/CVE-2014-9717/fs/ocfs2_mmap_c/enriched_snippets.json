[
  {
    "function_name": "ocfs2_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/mmap.c",
    "lines": "178-192",
    "snippet": "int ocfs2_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint ret = 0, lock_level = 0;\n\n\tret = ocfs2_inode_lock_atime(file_inode(file),\n\t\t\t\t    file->f_path.mnt, &lock_level);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_inode_unlock(file_inode(file), lock_level);\nout:\n\tvma->vm_ops = &ocfs2_file_vm_ops;\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"mmap.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct ocfs2_file_vm_ops = {\n\t.fault\t\t= ocfs2_fault,\n\t.page_mkwrite\t= ocfs2_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "file_inode(file)",
            "lock_level"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_atime",
          "args": [
            "file_inode(file)",
            "file->f_path.mnt",
            "&lock_level"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"mmap.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/signal.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic const struct vm_operations_struct ocfs2_file_vm_ops = {\n\t.fault\t\t= ocfs2_fault,\n\t.page_mkwrite\t= ocfs2_page_mkwrite,\n};\n\nint ocfs2_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint ret = 0, lock_level = 0;\n\n\tret = ocfs2_inode_lock_atime(file_inode(file),\n\t\t\t\t    file->f_path.mnt, &lock_level);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_inode_unlock(file_inode(file), lock_level);\nout:\n\tvma->vm_ops = &ocfs2_file_vm_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/mmap.c",
    "lines": "131-171",
    "snippet": "static int ocfs2_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct buffer_head *di_bh = NULL;\n\tsigset_t oldset;\n\tint ret;\n\n\tsb_start_pagefault(inode->i_sb);\n\tocfs2_block_signals(&oldset);\n\n\t/*\n\t * The cluster locks taken will block a truncate from another\n\t * node. Taking the data lock will also ensure that we don't\n\t * attempt page truncation as part of a downconvert.\n\t */\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The alloc sem should be enough to serialize with\n\t * ocfs2_truncate_file() changing i_size as well as any thread\n\t * modifying the inode btree.\n\t */\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tret = __ocfs2_page_mkwrite(vma->vm_file, di_bh, page);\n\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\n\nout:\n\tocfs2_unblock_signals(&oldset);\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"mmap.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_pagefault",
          "args": [
            "inode->i_sb"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_unblock_signals",
          "args": [
            "&oldset"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unblock_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2632-2636",
          "snippet": "void ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_page_mkwrite",
          "args": [
            "vma->vm_file",
            "di_bh",
            "page"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_page_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/mmap.c",
          "lines": "61-129",
          "snippet": "static int __ocfs2_page_mkwrite(struct file *file, struct buffer_head *di_bh,\n\t\t\t\tstruct page *page)\n{\n\tint ret = VM_FAULT_NOPAGE;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t pos = page_offset(page);\n\tunsigned int len = PAGE_CACHE_SIZE;\n\tpgoff_t last_index;\n\tstruct page *locked_page = NULL;\n\tvoid *fsdata;\n\tloff_t size = i_size_read(inode);\n\n\tlast_index = (size - 1) >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * There are cases that lead to the page no longer bebongs to the\n\t * mapping.\n\t * 1) pagecache truncates locally due to memory pressure.\n\t * 2) pagecache truncates when another is taking EX lock against \n\t * inode lock. see ocfs2_data_convert_worker.\n\t * \n\t * The i_size check doesn't catch the case where nodes truncated and\n\t * then re-extended the file. We'll re-check the page mapping after\n\t * taking the page lock inside of ocfs2_write_begin_nolock().\n\t *\n\t * Let VM retry with these cases.\n\t */\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (!PageUptodate(page)) ||\n\t    (page_offset(page) >= size))\n\t\tgoto out;\n\n\t/*\n\t * Call ocfs2_write_begin() and ocfs2_write_end() to take\n\t * advantage of the allocation code there. We pass a write\n\t * length of the whole page (chopped to i_size) to make sure\n\t * the whole thing is allocated.\n\t *\n\t * Since we know the page is up to date, we don't have to\n\t * worry about ocfs2_write_begin() skipping some buffer reads\n\t * because the \"write\" would invalidate their data.\n\t */\n\tif (page->index == last_index)\n\t\tlen = ((size - 1) & ~PAGE_CACHE_MASK) + 1;\n\n\tret = ocfs2_write_begin_nolock(file, mapping, pos, len, 0, &locked_page,\n\t\t\t\t       &fsdata, di_bh, page);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tif (ret == -ENOMEM)\n\t\t\tret = VM_FAULT_OOM;\n\t\telse\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\n\tif (!locked_page) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\tret = ocfs2_write_end_nolock(mapping, pos, len, len, locked_page,\n\t\t\t\t     fsdata);\n\tBUG_ON(ret != len);\n\tret = VM_FAULT_LOCKED;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"mmap.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"mmap.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/signal.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int __ocfs2_page_mkwrite(struct file *file, struct buffer_head *di_bh,\n\t\t\t\tstruct page *page)\n{\n\tint ret = VM_FAULT_NOPAGE;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t pos = page_offset(page);\n\tunsigned int len = PAGE_CACHE_SIZE;\n\tpgoff_t last_index;\n\tstruct page *locked_page = NULL;\n\tvoid *fsdata;\n\tloff_t size = i_size_read(inode);\n\n\tlast_index = (size - 1) >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * There are cases that lead to the page no longer bebongs to the\n\t * mapping.\n\t * 1) pagecache truncates locally due to memory pressure.\n\t * 2) pagecache truncates when another is taking EX lock against \n\t * inode lock. see ocfs2_data_convert_worker.\n\t * \n\t * The i_size check doesn't catch the case where nodes truncated and\n\t * then re-extended the file. We'll re-check the page mapping after\n\t * taking the page lock inside of ocfs2_write_begin_nolock().\n\t *\n\t * Let VM retry with these cases.\n\t */\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (!PageUptodate(page)) ||\n\t    (page_offset(page) >= size))\n\t\tgoto out;\n\n\t/*\n\t * Call ocfs2_write_begin() and ocfs2_write_end() to take\n\t * advantage of the allocation code there. We pass a write\n\t * length of the whole page (chopped to i_size) to make sure\n\t * the whole thing is allocated.\n\t *\n\t * Since we know the page is up to date, we don't have to\n\t * worry about ocfs2_write_begin() skipping some buffer reads\n\t * because the \"write\" would invalidate their data.\n\t */\n\tif (page->index == last_index)\n\t\tlen = ((size - 1) & ~PAGE_CACHE_MASK) + 1;\n\n\tret = ocfs2_write_begin_nolock(file, mapping, pos, len, 0, &locked_page,\n\t\t\t\t       &fsdata, di_bh, page);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tif (ret == -ENOMEM)\n\t\t\tret = VM_FAULT_OOM;\n\t\telse\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\n\tif (!locked_page) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\tret = ocfs2_write_end_nolock(mapping, pos, len, len, locked_page,\n\t\t\t\t     fsdata);\n\tBUG_ON(ret != len);\n\tret = VM_FAULT_LOCKED;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "1"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_signals",
          "args": [
            "&oldset"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2622-2630",
          "snippet": "void ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_pagefault",
          "args": [
            "inode->i_sb"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"mmap.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/signal.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct buffer_head *di_bh = NULL;\n\tsigset_t oldset;\n\tint ret;\n\n\tsb_start_pagefault(inode->i_sb);\n\tocfs2_block_signals(&oldset);\n\n\t/*\n\t * The cluster locks taken will block a truncate from another\n\t * node. Taking the data lock will also ensure that we don't\n\t * attempt page truncation as part of a downconvert.\n\t */\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The alloc sem should be enough to serialize with\n\t * ocfs2_truncate_file() changing i_size as well as any thread\n\t * modifying the inode btree.\n\t */\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tret = __ocfs2_page_mkwrite(vma->vm_file, di_bh, page);\n\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\n\nout:\n\tocfs2_unblock_signals(&oldset);\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/mmap.c",
    "lines": "61-129",
    "snippet": "static int __ocfs2_page_mkwrite(struct file *file, struct buffer_head *di_bh,\n\t\t\t\tstruct page *page)\n{\n\tint ret = VM_FAULT_NOPAGE;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t pos = page_offset(page);\n\tunsigned int len = PAGE_CACHE_SIZE;\n\tpgoff_t last_index;\n\tstruct page *locked_page = NULL;\n\tvoid *fsdata;\n\tloff_t size = i_size_read(inode);\n\n\tlast_index = (size - 1) >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * There are cases that lead to the page no longer bebongs to the\n\t * mapping.\n\t * 1) pagecache truncates locally due to memory pressure.\n\t * 2) pagecache truncates when another is taking EX lock against \n\t * inode lock. see ocfs2_data_convert_worker.\n\t * \n\t * The i_size check doesn't catch the case where nodes truncated and\n\t * then re-extended the file. We'll re-check the page mapping after\n\t * taking the page lock inside of ocfs2_write_begin_nolock().\n\t *\n\t * Let VM retry with these cases.\n\t */\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (!PageUptodate(page)) ||\n\t    (page_offset(page) >= size))\n\t\tgoto out;\n\n\t/*\n\t * Call ocfs2_write_begin() and ocfs2_write_end() to take\n\t * advantage of the allocation code there. We pass a write\n\t * length of the whole page (chopped to i_size) to make sure\n\t * the whole thing is allocated.\n\t *\n\t * Since we know the page is up to date, we don't have to\n\t * worry about ocfs2_write_begin() skipping some buffer reads\n\t * because the \"write\" would invalidate their data.\n\t */\n\tif (page->index == last_index)\n\t\tlen = ((size - 1) & ~PAGE_CACHE_MASK) + 1;\n\n\tret = ocfs2_write_begin_nolock(file, mapping, pos, len, 0, &locked_page,\n\t\t\t\t       &fsdata, di_bh, page);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tif (ret == -ENOMEM)\n\t\t\tret = VM_FAULT_OOM;\n\t\telse\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\n\tif (!locked_page) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\tret = ocfs2_write_end_nolock(mapping, pos, len, len, locked_page,\n\t\t\t\t     fsdata);\n\tBUG_ON(ret != len);\n\tret = VM_FAULT_LOCKED;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"mmap.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret != len"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_write_end_nolock",
          "args": [
            "mapping",
            "pos",
            "len",
            "len",
            "locked_page",
            "fsdata"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_end_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "2211-2294",
          "snippet": "int ocfs2_write_end_nolock(struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied,\n\t\t\t   struct page *page, void *fsdata)\n{\n\tint i;\n\tunsigned from, to, start = pos & (PAGE_CACHE_SIZE - 1);\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_write_ctxt *wc = fsdata;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\thandle_t *handle = wc->w_handle;\n\tstruct page *tmppage;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tocfs2_write_end_inline(inode, pos, len, &copied, di, wc);\n\t\tgoto out_write_size;\n\t}\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(wc->w_target_page))\n\t\t\tcopied = 0;\n\n\t\tocfs2_zero_new_buffers(wc->w_target_page, start+copied,\n\t\t\t\t       start+len);\n\t}\n\tflush_dcache_page(wc->w_target_page);\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\ttmppage = wc->w_pages[i];\n\n\t\tif (tmppage == wc->w_target_page) {\n\t\t\tfrom = wc->w_target_from;\n\t\t\tto = wc->w_target_to;\n\n\t\t\tBUG_ON(from > PAGE_CACHE_SIZE ||\n\t\t\t       to > PAGE_CACHE_SIZE ||\n\t\t\t       to < from);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Pages adjacent to the target (if any) imply\n\t\t\t * a hole-filling write in which case we want\n\t\t\t * to flush their entire range.\n\t\t\t */\n\t\t\tfrom = 0;\n\t\t\tto = PAGE_CACHE_SIZE;\n\t\t}\n\n\t\tif (page_has_buffers(tmppage)) {\n\t\t\tif (ocfs2_should_order_data(inode))\n\t\t\t\tocfs2_jbd2_file_inode(wc->w_handle, inode);\n\t\t\tblock_commit_write(tmppage, from, to);\n\t\t}\n\t}\n\nout_write_size:\n\tpos += copied;\n\tif (pos > i_size_read(inode)) {\n\t\ti_size_write(inode, pos);\n\t\tmark_inode_dirty(inode);\n\t}\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tdi->i_size = cpu_to_le64((u64)i_size_read(inode));\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tdi->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tdi->i_mtime_nsec = di->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, wc->w_di_bh);\n\n\t/* unlock pages before dealloc since it needs acquiring j_trans_barrier\n\t * lock, or it will cause a deadlock since journal commit threads holds\n\t * this lock and will ask for the page lock when flushing the data.\n\t * put it here to preserve the unlock order.\n\t */\n\tocfs2_unlock_pages(wc);\n\n\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_run_deallocs(osb, &wc->w_dealloc);\n\n\tbrelse(wc->w_di_bh);\n\tkfree(wc);\n\n\treturn copied;\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_write_end_nolock(struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied,\n\t\t\t   struct page *page, void *fsdata)\n{\n\tint i;\n\tunsigned from, to, start = pos & (PAGE_CACHE_SIZE - 1);\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_write_ctxt *wc = fsdata;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\thandle_t *handle = wc->w_handle;\n\tstruct page *tmppage;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tocfs2_write_end_inline(inode, pos, len, &copied, di, wc);\n\t\tgoto out_write_size;\n\t}\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(wc->w_target_page))\n\t\t\tcopied = 0;\n\n\t\tocfs2_zero_new_buffers(wc->w_target_page, start+copied,\n\t\t\t\t       start+len);\n\t}\n\tflush_dcache_page(wc->w_target_page);\n\n\tfor(i = 0; i < wc->w_num_pages; i++) {\n\t\ttmppage = wc->w_pages[i];\n\n\t\tif (tmppage == wc->w_target_page) {\n\t\t\tfrom = wc->w_target_from;\n\t\t\tto = wc->w_target_to;\n\n\t\t\tBUG_ON(from > PAGE_CACHE_SIZE ||\n\t\t\t       to > PAGE_CACHE_SIZE ||\n\t\t\t       to < from);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Pages adjacent to the target (if any) imply\n\t\t\t * a hole-filling write in which case we want\n\t\t\t * to flush their entire range.\n\t\t\t */\n\t\t\tfrom = 0;\n\t\t\tto = PAGE_CACHE_SIZE;\n\t\t}\n\n\t\tif (page_has_buffers(tmppage)) {\n\t\t\tif (ocfs2_should_order_data(inode))\n\t\t\t\tocfs2_jbd2_file_inode(wc->w_handle, inode);\n\t\t\tblock_commit_write(tmppage, from, to);\n\t\t}\n\t}\n\nout_write_size:\n\tpos += copied;\n\tif (pos > i_size_read(inode)) {\n\t\ti_size_write(inode, pos);\n\t\tmark_inode_dirty(inode);\n\t}\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tdi->i_size = cpu_to_le64((u64)i_size_read(inode));\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tdi->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tdi->i_mtime_nsec = di->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, wc->w_di_bh);\n\n\t/* unlock pages before dealloc since it needs acquiring j_trans_barrier\n\t * lock, or it will cause a deadlock since journal commit threads holds\n\t * this lock and will ask for the page lock when flushing the data.\n\t * put it here to preserve the unlock order.\n\t */\n\tocfs2_unlock_pages(wc);\n\n\tocfs2_commit_trans(osb, handle);\n\n\tocfs2_run_deallocs(osb, &wc->w_dealloc);\n\n\tbrelse(wc->w_di_bh);\n\tkfree(wc);\n\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_write_begin_nolock",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "0",
            "&locked_page",
            "&fsdata",
            "di_bh",
            "page"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_begin_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1917-2141",
          "snippet": "int ocfs2_write_begin_nolock(struct file *filp,\n\t\t\t     struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, unsigned flags,\n\t\t\t     struct page **pagep, void **fsdata,\n\t\t\t     struct buffer_head *di_bh, struct page *mmap_page)\n{\n\tint ret, cluster_of_pages, credits = OCFS2_INODE_UPDATE_CREDITS;\n\tunsigned int clusters_to_alloc, extents_to_split, clusters_need = 0;\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle;\n\tstruct ocfs2_extent_tree et;\n\tint try_free = 1, ret1;\n\ntry_again:\n\tret = ocfs2_alloc_write_ctxt(&wc, osb, pos, len, di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tif (ocfs2_supports_inline_data(osb)) {\n\t\tret = ocfs2_try_to_write_inline_data(mapping, inode, pos, len,\n\t\t\t\t\t\t     mmap_page, wc);\n\t\tif (ret == 1) {\n\t\t\tret = 0;\n\t\t\tgoto success;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ocfs2_sparse_alloc(osb))\n\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\telse\n\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos, len,\n\t\t\t\t\t\t   wc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_check_range_for_refcount(inode, pos, len);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else if (ret == 1) {\n\t\tclusters_need = wc->w_clen;\n\t\tret = ocfs2_refcount_cow(inode, di_bh,\n\t\t\t\t\t wc->w_cpos, wc->w_clen, UINT_MAX);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_populate_write_desc(inode, wc, &clusters_to_alloc,\n\t\t\t\t\t&extents_to_split);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tclusters_need += clusters_to_alloc;\n\n\tdi = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\n\ttrace_ocfs2_write_begin_nolock(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(long long)i_size_read(inode),\n\t\t\tle32_to_cpu(di->i_clusters),\n\t\t\tpos, len, flags, mmap_page,\n\t\t\tclusters_to_alloc, extents_to_split);\n\n\t/*\n\t * We set w_target_from, w_target_to here so that\n\t * ocfs2_write_end() knows which range in the target page to\n\t * write out. An allocation requires that we write the entire\n\t * cluster range.\n\t */\n\tif (clusters_to_alloc || extents_to_split) {\n\t\t/*\n\t\t * XXX: We are stretching the limits of\n\t\t * ocfs2_lock_allocators(). It greatly over-estimates\n\t\t * the work to be done.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode),\n\t\t\t\t\t      wc->w_di_bh);\n\t\tret = ocfs2_lock_allocators(inode, &et,\n\t\t\t\t\t    clusters_to_alloc, extents_to_split,\n\t\t\t\t\t    &data_ac, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (data_ac)\n\t\t\tdata_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t    &di->id2.i_list);\n\n\t}\n\n\t/*\n\t * We have to zero sparse allocated clusters, unwritten extent clusters,\n\t * and non-sparse clusters we just extended.  For non-sparse writes,\n\t * we know zeros will only be needed in the first and/or last cluster.\n\t */\n\tif (clusters_to_alloc || extents_to_split ||\n\t    (wc->w_clen && (wc->w_desc[0].c_needs_zero ||\n\t\t\t    wc->w_desc[wc->w_clen - 1].c_needs_zero)))\n\t\tcluster_of_pages = 1;\n\telse\n\t\tcluster_of_pages = 0;\n\n\tocfs2_set_target_boundaries(osb, wc, pos, len, cluster_of_pages);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twc->w_handle = handle;\n\n\tif (clusters_to_alloc) {\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_alloc));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t}\n\t/*\n\t * We don't want this to fail in ocfs2_write_end(), so do it\n\t * here.\n\t */\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), wc->w_di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\t/*\n\t * Fill our page array first. That way we've grabbed enough so\n\t * that we can zero and flush if we error after adding the\n\t * extent.\n\t */\n\tret = ocfs2_grab_pages_for_write(mapping, wc, wc->w_cpos, pos, len,\n\t\t\t\t\t cluster_of_pages, mmap_page);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\t/*\n\t * ocfs2_grab_pages_for_write() returns -EAGAIN if it could not lock\n\t * the target page. In this case, we exit with no error and no target\n\t * page. This will trigger the caller, page_mkwrite(), to re-try\n\t * the operation.\n\t */\n\tif (ret == -EAGAIN) {\n\t\tBUG_ON(wc->w_target_page);\n\t\tret = 0;\n\t\tgoto out_quota;\n\t}\n\n\tret = ocfs2_write_cluster_by_desc(mapping, data_ac, meta_ac, wc, pos,\n\t\t\t\t\t  len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\nsuccess:\n\t*pagep = wc->w_target_page;\n\t*fsdata = wc;\n\treturn 0;\nout_quota:\n\tif (clusters_to_alloc)\n\t\tdquot_free_space(inode,\n\t\t\t  ocfs2_clusters_to_bytes(osb->sb, clusters_to_alloc));\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tocfs2_free_write_ctxt(wc);\n\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\n\tif (ret == -ENOSPC && try_free) {\n\t\t/*\n\t\t * Try to free some truncate log so that we can have enough\n\t\t * clusters to allocate.\n\t\t */\n\t\ttry_free = 0;\n\n\t\tret1 = ocfs2_try_to_free_truncate_log(osb, clusters_need);\n\t\tif (ret1 == 1)\n\t\t\tgoto try_again;\n\n\t\tif (ret1 < 0)\n\t\t\tmlog_errno(ret1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_write_begin_nolock(struct file *filp,\n\t\t\t     struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, unsigned flags,\n\t\t\t     struct page **pagep, void **fsdata,\n\t\t\t     struct buffer_head *di_bh, struct page *mmap_page)\n{\n\tint ret, cluster_of_pages, credits = OCFS2_INODE_UPDATE_CREDITS;\n\tunsigned int clusters_to_alloc, extents_to_split, clusters_need = 0;\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct inode *inode = mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\thandle_t *handle;\n\tstruct ocfs2_extent_tree et;\n\tint try_free = 1, ret1;\n\ntry_again:\n\tret = ocfs2_alloc_write_ctxt(&wc, osb, pos, len, di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tif (ocfs2_supports_inline_data(osb)) {\n\t\tret = ocfs2_try_to_write_inline_data(mapping, inode, pos, len,\n\t\t\t\t\t\t     mmap_page, wc);\n\t\tif (ret == 1) {\n\t\t\tret = 0;\n\t\t\tgoto success;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ocfs2_sparse_alloc(osb))\n\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\telse\n\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos, len,\n\t\t\t\t\t\t   wc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_check_range_for_refcount(inode, pos, len);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else if (ret == 1) {\n\t\tclusters_need = wc->w_clen;\n\t\tret = ocfs2_refcount_cow(inode, di_bh,\n\t\t\t\t\t wc->w_cpos, wc->w_clen, UINT_MAX);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_populate_write_desc(inode, wc, &clusters_to_alloc,\n\t\t\t\t\t&extents_to_split);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tclusters_need += clusters_to_alloc;\n\n\tdi = (struct ocfs2_dinode *)wc->w_di_bh->b_data;\n\n\ttrace_ocfs2_write_begin_nolock(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(long long)i_size_read(inode),\n\t\t\tle32_to_cpu(di->i_clusters),\n\t\t\tpos, len, flags, mmap_page,\n\t\t\tclusters_to_alloc, extents_to_split);\n\n\t/*\n\t * We set w_target_from, w_target_to here so that\n\t * ocfs2_write_end() knows which range in the target page to\n\t * write out. An allocation requires that we write the entire\n\t * cluster range.\n\t */\n\tif (clusters_to_alloc || extents_to_split) {\n\t\t/*\n\t\t * XXX: We are stretching the limits of\n\t\t * ocfs2_lock_allocators(). It greatly over-estimates\n\t\t * the work to be done.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode),\n\t\t\t\t\t      wc->w_di_bh);\n\t\tret = ocfs2_lock_allocators(inode, &et,\n\t\t\t\t\t    clusters_to_alloc, extents_to_split,\n\t\t\t\t\t    &data_ac, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (data_ac)\n\t\t\tdata_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\n\t\tcredits = ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t    &di->id2.i_list);\n\n\t}\n\n\t/*\n\t * We have to zero sparse allocated clusters, unwritten extent clusters,\n\t * and non-sparse clusters we just extended.  For non-sparse writes,\n\t * we know zeros will only be needed in the first and/or last cluster.\n\t */\n\tif (clusters_to_alloc || extents_to_split ||\n\t    (wc->w_clen && (wc->w_desc[0].c_needs_zero ||\n\t\t\t    wc->w_desc[wc->w_clen - 1].c_needs_zero)))\n\t\tcluster_of_pages = 1;\n\telse\n\t\tcluster_of_pages = 0;\n\n\tocfs2_set_target_boundaries(osb, wc, pos, len, cluster_of_pages);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twc->w_handle = handle;\n\n\tif (clusters_to_alloc) {\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_alloc));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t}\n\t/*\n\t * We don't want this to fail in ocfs2_write_end(), so do it\n\t * here.\n\t */\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), wc->w_di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\t/*\n\t * Fill our page array first. That way we've grabbed enough so\n\t * that we can zero and flush if we error after adding the\n\t * extent.\n\t */\n\tret = ocfs2_grab_pages_for_write(mapping, wc, wc->w_cpos, pos, len,\n\t\t\t\t\t cluster_of_pages, mmap_page);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\t/*\n\t * ocfs2_grab_pages_for_write() returns -EAGAIN if it could not lock\n\t * the target page. In this case, we exit with no error and no target\n\t * page. This will trigger the caller, page_mkwrite(), to re-try\n\t * the operation.\n\t */\n\tif (ret == -EAGAIN) {\n\t\tBUG_ON(wc->w_target_page);\n\t\tret = 0;\n\t\tgoto out_quota;\n\t}\n\n\tret = ocfs2_write_cluster_by_desc(mapping, data_ac, meta_ac, wc, pos,\n\t\t\t\t\t  len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_quota;\n\t}\n\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\nsuccess:\n\t*pagep = wc->w_target_page;\n\t*fsdata = wc;\n\treturn 0;\nout_quota:\n\tif (clusters_to_alloc)\n\t\tdquot_free_space(inode,\n\t\t\t  ocfs2_clusters_to_bytes(osb->sb, clusters_to_alloc));\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tocfs2_free_write_ctxt(wc);\n\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\n\tif (ret == -ENOSPC && try_free) {\n\t\t/*\n\t\t * Try to free some truncate log so that we can have enough\n\t\t * clusters to allocate.\n\t\t */\n\t\ttry_free = 0;\n\n\t\tret1 = ocfs2_try_to_free_truncate_log(osb, clusters_need);\n\t\tif (ret1 == 1)\n\t\t\tgoto try_again;\n\n\t\tif (ret1 < 0)\n\t\t\tmlog_errno(ret1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"mmap.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/signal.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int __ocfs2_page_mkwrite(struct file *file, struct buffer_head *di_bh,\n\t\t\t\tstruct page *page)\n{\n\tint ret = VM_FAULT_NOPAGE;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t pos = page_offset(page);\n\tunsigned int len = PAGE_CACHE_SIZE;\n\tpgoff_t last_index;\n\tstruct page *locked_page = NULL;\n\tvoid *fsdata;\n\tloff_t size = i_size_read(inode);\n\n\tlast_index = (size - 1) >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * There are cases that lead to the page no longer bebongs to the\n\t * mapping.\n\t * 1) pagecache truncates locally due to memory pressure.\n\t * 2) pagecache truncates when another is taking EX lock against \n\t * inode lock. see ocfs2_data_convert_worker.\n\t * \n\t * The i_size check doesn't catch the case where nodes truncated and\n\t * then re-extended the file. We'll re-check the page mapping after\n\t * taking the page lock inside of ocfs2_write_begin_nolock().\n\t *\n\t * Let VM retry with these cases.\n\t */\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (!PageUptodate(page)) ||\n\t    (page_offset(page) >= size))\n\t\tgoto out;\n\n\t/*\n\t * Call ocfs2_write_begin() and ocfs2_write_end() to take\n\t * advantage of the allocation code there. We pass a write\n\t * length of the whole page (chopped to i_size) to make sure\n\t * the whole thing is allocated.\n\t *\n\t * Since we know the page is up to date, we don't have to\n\t * worry about ocfs2_write_begin() skipping some buffer reads\n\t * because the \"write\" would invalidate their data.\n\t */\n\tif (page->index == last_index)\n\t\tlen = ((size - 1) & ~PAGE_CACHE_MASK) + 1;\n\n\tret = ocfs2_write_begin_nolock(file, mapping, pos, len, 0, &locked_page,\n\t\t\t\t       &fsdata, di_bh, page);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tif (ret == -ENOMEM)\n\t\t\tret = VM_FAULT_OOM;\n\t\telse\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\n\tif (!locked_page) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\tret = ocfs2_write_end_nolock(mapping, pos, len, len, locked_page,\n\t\t\t\t     fsdata);\n\tBUG_ON(ret != len);\n\tret = VM_FAULT_LOCKED;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/mmap.c",
    "lines": "47-59",
    "snippet": "static int ocfs2_fault(struct vm_area_struct *area, struct vm_fault *vmf)\n{\n\tsigset_t oldset;\n\tint ret;\n\n\tocfs2_block_signals(&oldset);\n\tret = filemap_fault(area, vmf);\n\tocfs2_unblock_signals(&oldset);\n\n\ttrace_ocfs2_fault(OCFS2_I(area->vm_file->f_mapping->host)->ip_blkno,\n\t\t\t  area, vmf->page, vmf->pgoff);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"mmap.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_fault",
          "args": [
            "OCFS2_I(area->vm_file->f_mapping->host)->ip_blkno",
            "area",
            "vmf->page",
            "vmf->pgoff"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "area->vm_file->f_mapping->host"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unblock_signals",
          "args": [
            "&oldset"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unblock_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2632-2636",
          "snippet": "void ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fault",
          "args": [
            "area",
            "vmf"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_filemap_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "1226-1304",
          "snippet": "static int ceph_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_file_info *fi = vma->vm_file->private_data;\n\tstruct page *pinned_page = NULL;\n\tloff_t off = vmf->pgoff << PAGE_CACHE_SHIFT;\n\tint want, got, ret;\n\n\tdout(\"filemap_fault %p %llx.%llx %llu~%zd trying to get caps\\n\",\n\t     inode, ceph_vinop(inode), off, (size_t)PAGE_CACHE_SIZE);\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_CACHE;\n\twhile (1) {\n\t\tgot = 0;\n\t\tret = ceph_get_caps(ci, CEPH_CAP_FILE_RD, want,\n\t\t\t\t    -1, &got, &pinned_page);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret != -ERESTARTSYS) {\n\t\t\tWARN_ON(1);\n\t\t\treturn VM_FAULT_SIGBUS;\n\t\t}\n\t}\n\tdout(\"filemap_fault %p %llu~%zd got cap refs on %s\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ceph_cap_string(got));\n\n\tif ((got & (CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO)) ||\n\t    ci->i_inline_version == CEPH_INLINE_NONE)\n\t\tret = filemap_fault(vma, vmf);\n\telse\n\t\tret = -EAGAIN;\n\n\tdout(\"filemap_fault %p %llu~%zd dropping cap refs on %s ret %d\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ceph_cap_string(got), ret);\n\tif (pinned_page)\n\t\tpage_cache_release(pinned_page);\n\tceph_put_cap_refs(ci, got);\n\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\n\t/* read inline data */\n\tif (off >= PAGE_CACHE_SIZE) {\n\t\t/* does not support inline data > PAGE_SIZE */\n\t\tret = VM_FAULT_SIGBUS;\n\t} else {\n\t\tint ret1;\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page = find_or_create_page(mapping, 0,\n\t\t\t\t\t\tmapping_gfp_mask(mapping) &\n\t\t\t\t\t\t~__GFP_FS);\n\t\tif (!page) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out;\n\t\t}\n\t\tret1 = __ceph_do_getattr(inode, page,\n\t\t\t\t\t CEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret1 < 0 || off >= i_size_read(inode)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret1 < PAGE_CACHE_SIZE)\n\t\t\tzero_user_segment(page, ret1, PAGE_CACHE_SIZE);\n\t\telse\n\t\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tvmf->page = page;\n\t\tret = VM_FAULT_MAJOR | VM_FAULT_LOCKED;\n\t}\nout:\n\tdout(\"filemap_fault %p %llu~%zd read inline data ret %d\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ret);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_file_info *fi = vma->vm_file->private_data;\n\tstruct page *pinned_page = NULL;\n\tloff_t off = vmf->pgoff << PAGE_CACHE_SHIFT;\n\tint want, got, ret;\n\n\tdout(\"filemap_fault %p %llx.%llx %llu~%zd trying to get caps\\n\",\n\t     inode, ceph_vinop(inode), off, (size_t)PAGE_CACHE_SIZE);\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_CACHE;\n\twhile (1) {\n\t\tgot = 0;\n\t\tret = ceph_get_caps(ci, CEPH_CAP_FILE_RD, want,\n\t\t\t\t    -1, &got, &pinned_page);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret != -ERESTARTSYS) {\n\t\t\tWARN_ON(1);\n\t\t\treturn VM_FAULT_SIGBUS;\n\t\t}\n\t}\n\tdout(\"filemap_fault %p %llu~%zd got cap refs on %s\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ceph_cap_string(got));\n\n\tif ((got & (CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO)) ||\n\t    ci->i_inline_version == CEPH_INLINE_NONE)\n\t\tret = filemap_fault(vma, vmf);\n\telse\n\t\tret = -EAGAIN;\n\n\tdout(\"filemap_fault %p %llu~%zd dropping cap refs on %s ret %d\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ceph_cap_string(got), ret);\n\tif (pinned_page)\n\t\tpage_cache_release(pinned_page);\n\tceph_put_cap_refs(ci, got);\n\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\n\t/* read inline data */\n\tif (off >= PAGE_CACHE_SIZE) {\n\t\t/* does not support inline data > PAGE_SIZE */\n\t\tret = VM_FAULT_SIGBUS;\n\t} else {\n\t\tint ret1;\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page = find_or_create_page(mapping, 0,\n\t\t\t\t\t\tmapping_gfp_mask(mapping) &\n\t\t\t\t\t\t~__GFP_FS);\n\t\tif (!page) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out;\n\t\t}\n\t\tret1 = __ceph_do_getattr(inode, page,\n\t\t\t\t\t CEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret1 < 0 || off >= i_size_read(inode)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret1 < PAGE_CACHE_SIZE)\n\t\t\tzero_user_segment(page, ret1, PAGE_CACHE_SIZE);\n\t\telse\n\t\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tvmf->page = page;\n\t\tret = VM_FAULT_MAJOR | VM_FAULT_LOCKED;\n\t}\nout:\n\tdout(\"filemap_fault %p %llu~%zd read inline data ret %d\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_signals",
          "args": [
            "&oldset"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2622-2630",
          "snippet": "void ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"mmap.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/signal.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_fault(struct vm_area_struct *area, struct vm_fault *vmf)\n{\n\tsigset_t oldset;\n\tint ret;\n\n\tocfs2_block_signals(&oldset);\n\tret = filemap_fault(area, vmf);\n\tocfs2_unblock_signals(&oldset);\n\n\ttrace_ocfs2_fault(OCFS2_I(area->vm_file->f_mapping->host)->ip_blkno,\n\t\t\t  area, vmf->page, vmf->pgoff);\n\treturn ret;\n}"
  }
]