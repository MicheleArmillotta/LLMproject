[
  {
    "function_name": "fscache_withdraw_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
    "lines": "365-420",
    "snippet": "void fscache_withdraw_cache(struct fscache_cache *cache)\n{\n\tLIST_HEAD(dying_objects);\n\n\t_enter(\"\");\n\n\tpr_notice(\"Withdrawing cache \\\"%s\\\"\\n\",\n\t\t  cache->tag->name);\n\n\t/* make the cache unavailable for cookie acquisition */\n\tif (test_and_set_bit(FSCACHE_CACHE_WITHDRAWN, &cache->flags))\n\t\tBUG();\n\n\tdown_write(&fscache_addremove_sem);\n\tlist_del_init(&cache->link);\n\tcache->tag->cache = NULL;\n\tup_write(&fscache_addremove_sem);\n\n\t/* make sure all pages pinned by operations on behalf of the netfs are\n\t * written to disk */\n\tfscache_stat(&fscache_n_cop_sync_cache);\n\tcache->ops->sync_cache(cache);\n\tfscache_stat_d(&fscache_n_cop_sync_cache);\n\n\t/* dissociate all the netfs pages backed by this cache from the block\n\t * mappings in the cache */\n\tfscache_stat(&fscache_n_cop_dissociate_pages);\n\tcache->ops->dissociate_pages(cache);\n\tfscache_stat_d(&fscache_n_cop_dissociate_pages);\n\n\t/* we now have to destroy all the active objects pertaining to this\n\t * cache - which we do by passing them off to thread pool to be\n\t * disposed of */\n\t_debug(\"destroy\");\n\n\tfscache_withdraw_all_objects(cache, &dying_objects);\n\n\t/* wait for all extant objects to finish their outstanding operations\n\t * and go away */\n\t_debug(\"wait for finish\");\n\twait_event(fscache_cache_cleared_wq,\n\t\t   atomic_read(&cache->object_count) == 0);\n\t_debug(\"wait for clearance\");\n\twait_event(fscache_cache_cleared_wq,\n\t\t   list_empty(&cache->object_list));\n\t_debug(\"cleared\");\n\tASSERT(list_empty(&dying_objects));\n\n\tkobject_put(cache->kobj);\n\n\tclear_bit(FSCACHE_TAG_RESERVED, &cache->tag->flags);\n\tfscache_release_cache_tag(cache->tag);\n\tcache->tag = NULL;\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_release_cache_tag",
          "args": [
            "cache->tag"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_release_cache_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
          "lines": "73-87",
          "snippet": "void __fscache_release_cache_tag(struct fscache_cache_tag *tag)\n{\n\tif (tag != ERR_PTR(-ENOMEM)) {\n\t\tdown_write(&fscache_addremove_sem);\n\n\t\tif (atomic_dec_and_test(&tag->usage))\n\t\t\tlist_del_init(&tag->link);\n\t\telse\n\t\t\ttag = NULL;\n\n\t\tup_write(&fscache_addremove_sem);\n\n\t\tkfree(tag);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid __fscache_release_cache_tag(struct fscache_cache_tag *tag)\n{\n\tif (tag != ERR_PTR(-ENOMEM)) {\n\t\tdown_write(&fscache_addremove_sem);\n\n\t\tif (atomic_dec_and_test(&tag->usage))\n\t\t\tlist_del_init(&tag->link);\n\t\telse\n\t\t\ttag = NULL;\n\n\t\tup_write(&fscache_addremove_sem);\n\n\t\tkfree(tag);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "FSCACHE_TAG_RESERVED",
            "&cache->tag->flags"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "cache->kobj"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&dying_objects)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dying_objects"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"cleared\""
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fscache_cache_cleared_wq",
            "list_empty(&cache->object_list)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fscache_cache_cleared_wq",
            "atomic_read(&cache->object_count) == 0"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cache->object_count"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_withdraw_all_objects",
          "args": [
            "cache",
            "&dying_objects"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_withdraw_all_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
          "lines": "329-353",
          "snippet": "static void fscache_withdraw_all_objects(struct fscache_cache *cache,\n\t\t\t\t\t struct list_head *dying_objects)\n{\n\tstruct fscache_object *object;\n\n\twhile (!list_empty(&cache->object_list)) {\n\t\tspin_lock(&cache->object_list_lock);\n\n\t\tif (!list_empty(&cache->object_list)) {\n\t\t\tobject = list_entry(cache->object_list.next,\n\t\t\t\t\t    struct fscache_object, cache_link);\n\t\t\tlist_move_tail(&object->cache_link, dying_objects);\n\n\t\t\t_debug(\"withdraw %p\", object->cookie);\n\n\t\t\t/* This must be done under object_list_lock to prevent\n\t\t\t * a race with fscache_drop_object().\n\t\t\t */\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_KILL);\n\t\t}\n\n\t\tspin_unlock(&cache->object_list_lock);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void fscache_withdraw_all_objects(struct fscache_cache *cache,\n\t\t\t\t\t struct list_head *dying_objects)\n{\n\tstruct fscache_object *object;\n\n\twhile (!list_empty(&cache->object_list)) {\n\t\tspin_lock(&cache->object_list_lock);\n\n\t\tif (!list_empty(&cache->object_list)) {\n\t\t\tobject = list_entry(cache->object_list.next,\n\t\t\t\t\t    struct fscache_object, cache_link);\n\t\t\tlist_move_tail(&object->cache_link, dying_objects);\n\n\t\t\t_debug(\"withdraw %p\", object->cookie);\n\n\t\t\t/* This must be done under object_list_lock to prevent\n\t\t\t * a race with fscache_drop_object().\n\t\t\t */\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_KILL);\n\t\t}\n\n\t\tspin_unlock(&cache->object_list_lock);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat_d",
          "args": [
            "&fscache_n_cop_dissociate_pages"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache->ops->dissociate_pages",
          "args": [
            "cache"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache->ops->sync_cache",
          "args": [
            "cache"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cache->link"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "FSCACHE_CACHE_WITHDRAWN",
            "&cache->flags"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Withdrawing cache \\\"%s\\\"\\n\"",
            "cache->tag->name"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dying_objects"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid fscache_withdraw_cache(struct fscache_cache *cache)\n{\n\tLIST_HEAD(dying_objects);\n\n\t_enter(\"\");\n\n\tpr_notice(\"Withdrawing cache \\\"%s\\\"\\n\",\n\t\t  cache->tag->name);\n\n\t/* make the cache unavailable for cookie acquisition */\n\tif (test_and_set_bit(FSCACHE_CACHE_WITHDRAWN, &cache->flags))\n\t\tBUG();\n\n\tdown_write(&fscache_addremove_sem);\n\tlist_del_init(&cache->link);\n\tcache->tag->cache = NULL;\n\tup_write(&fscache_addremove_sem);\n\n\t/* make sure all pages pinned by operations on behalf of the netfs are\n\t * written to disk */\n\tfscache_stat(&fscache_n_cop_sync_cache);\n\tcache->ops->sync_cache(cache);\n\tfscache_stat_d(&fscache_n_cop_sync_cache);\n\n\t/* dissociate all the netfs pages backed by this cache from the block\n\t * mappings in the cache */\n\tfscache_stat(&fscache_n_cop_dissociate_pages);\n\tcache->ops->dissociate_pages(cache);\n\tfscache_stat_d(&fscache_n_cop_dissociate_pages);\n\n\t/* we now have to destroy all the active objects pertaining to this\n\t * cache - which we do by passing them off to thread pool to be\n\t * disposed of */\n\t_debug(\"destroy\");\n\n\tfscache_withdraw_all_objects(cache, &dying_objects);\n\n\t/* wait for all extant objects to finish their outstanding operations\n\t * and go away */\n\t_debug(\"wait for finish\");\n\twait_event(fscache_cache_cleared_wq,\n\t\t   atomic_read(&cache->object_count) == 0);\n\t_debug(\"wait for clearance\");\n\twait_event(fscache_cache_cleared_wq,\n\t\t   list_empty(&cache->object_list));\n\t_debug(\"cleared\");\n\tASSERT(list_empty(&dying_objects));\n\n\tkobject_put(cache->kobj);\n\n\tclear_bit(FSCACHE_TAG_RESERVED, &cache->tag->flags);\n\tfscache_release_cache_tag(cache->tag);\n\tcache->tag = NULL;\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_withdraw_all_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
    "lines": "329-353",
    "snippet": "static void fscache_withdraw_all_objects(struct fscache_cache *cache,\n\t\t\t\t\t struct list_head *dying_objects)\n{\n\tstruct fscache_object *object;\n\n\twhile (!list_empty(&cache->object_list)) {\n\t\tspin_lock(&cache->object_list_lock);\n\n\t\tif (!list_empty(&cache->object_list)) {\n\t\t\tobject = list_entry(cache->object_list.next,\n\t\t\t\t\t    struct fscache_object, cache_link);\n\t\t\tlist_move_tail(&object->cache_link, dying_objects);\n\n\t\t\t_debug(\"withdraw %p\", object->cookie);\n\n\t\t\t/* This must be done under object_list_lock to prevent\n\t\t\t * a race with fscache_drop_object().\n\t\t\t */\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_KILL);\n\t\t}\n\n\t\tspin_unlock(&cache->object_list_lock);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cache->object_list_lock"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_raise_event",
          "args": [
            "object",
            "FSCACHE_OBJECT_EV_KILL"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_raise_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "299-310",
          "snippet": "static inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fscache_enqueue_object(struct fscache_object *);",
            "extern void fscache_cancel_all_ops(struct fscache_object *);",
            "extern void fscache_abort_object(struct fscache_object *);",
            "extern void fscache_start_operations(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern void fscache_enqueue_object(struct fscache_object *);\nextern void fscache_cancel_all_ops(struct fscache_object *);\nextern void fscache_abort_object(struct fscache_object *);\nextern void fscache_start_operations(struct fscache_object *);\n\nstatic inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"withdraw %p\"",
            "object->cookie"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&object->cache_link",
            "dying_objects"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cache->object_list.next",
            "structfscache_object",
            "cache_link"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cache->object_list"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cache->object_list_lock"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void fscache_withdraw_all_objects(struct fscache_cache *cache,\n\t\t\t\t\t struct list_head *dying_objects)\n{\n\tstruct fscache_object *object;\n\n\twhile (!list_empty(&cache->object_list)) {\n\t\tspin_lock(&cache->object_list_lock);\n\n\t\tif (!list_empty(&cache->object_list)) {\n\t\t\tobject = list_entry(cache->object_list.next,\n\t\t\t\t\t    struct fscache_object, cache_link);\n\t\t\tlist_move_tail(&object->cache_link, dying_objects);\n\n\t\t\t_debug(\"withdraw %p\", object->cookie);\n\n\t\t\t/* This must be done under object_list_lock to prevent\n\t\t\t * a race with fscache_drop_object().\n\t\t\t */\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_KILL);\n\t\t}\n\n\t\tspin_unlock(&cache->object_list_lock);\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "fscache_io_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
    "lines": "317-322",
    "snippet": "void fscache_io_error(struct fscache_cache *cache)\n{\n\tif (!test_and_set_bit(FSCACHE_IOERROR, &cache->flags))\n\t\tpr_err(\"Cache '%s' stopped due to I/O error\\n\",\n\t\t       cache->ops->name);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cache '%s' stopped due to I/O error\\n\"",
            "cache->ops->name"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "FSCACHE_IOERROR",
            "&cache->flags"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid fscache_io_error(struct fscache_cache *cache)\n{\n\tif (!test_and_set_bit(FSCACHE_IOERROR, &cache->flags))\n\t\tpr_err(\"Cache '%s' stopped due to I/O error\\n\",\n\t\t       cache->ops->name);\n}"
  },
  {
    "function_name": "fscache_add_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
    "lines": "217-304",
    "snippet": "int fscache_add_cache(struct fscache_cache *cache,\n\t\t      struct fscache_object *ifsdef,\n\t\t      const char *tagname)\n{\n\tstruct fscache_cache_tag *tag;\n\n\tBUG_ON(!cache->ops);\n\tBUG_ON(!ifsdef);\n\n\tcache->flags = 0;\n\tifsdef->event_mask =\n\t\t((1 << NR_FSCACHE_OBJECT_EVENTS) - 1) &\n\t\t~(1 << FSCACHE_OBJECT_EV_CLEARED);\n\t__set_bit(FSCACHE_OBJECT_IS_AVAILABLE, &ifsdef->flags);\n\n\tif (!tagname)\n\t\ttagname = cache->identifier;\n\n\tBUG_ON(!tagname[0]);\n\n\t_enter(\"{%s.%s},,%s\", cache->ops->name, cache->identifier, tagname);\n\n\t/* we use the cache tag to uniquely identify caches */\n\ttag = __fscache_lookup_cache_tag(tagname);\n\tif (IS_ERR(tag))\n\t\tgoto nomem;\n\n\tif (test_and_set_bit(FSCACHE_TAG_RESERVED, &tag->flags))\n\t\tgoto tag_in_use;\n\n\tcache->kobj = kobject_create_and_add(tagname, fscache_root);\n\tif (!cache->kobj)\n\t\tgoto error;\n\n\tifsdef->cookie = &fscache_fsdef_index;\n\tifsdef->cache = cache;\n\tcache->fsdef = ifsdef;\n\n\tdown_write(&fscache_addremove_sem);\n\n\ttag->cache = cache;\n\tcache->tag = tag;\n\n\t/* add the cache to the list */\n\tlist_add(&cache->link, &fscache_cache_list);\n\n\t/* add the cache's netfs definition index object to the cache's\n\t * list */\n\tspin_lock(&cache->object_list_lock);\n\tlist_add_tail(&ifsdef->cache_link, &cache->object_list);\n\tspin_unlock(&cache->object_list_lock);\n\tfscache_objlist_add(ifsdef);\n\n\t/* add the cache's netfs definition index object to the top level index\n\t * cookie as a known backing object */\n\tspin_lock(&fscache_fsdef_index.lock);\n\n\thlist_add_head(&ifsdef->cookie_link,\n\t\t       &fscache_fsdef_index.backing_objects);\n\n\tatomic_inc(&fscache_fsdef_index.usage);\n\n\t/* done */\n\tspin_unlock(&fscache_fsdef_index.lock);\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Cache \\\"%s\\\" added (type %s)\\n\",\n\t\t  cache->tag->name, cache->ops->name);\n\tkobject_uevent(cache->kobj, KOBJ_ADD);\n\n\t_leave(\" = 0 [%s]\", cache->identifier);\n\treturn 0;\n\ntag_in_use:\n\tpr_err(\"Cache tag '%s' already in use\\n\", tagname);\n\t__fscache_release_cache_tag(tag);\n\t_leave(\" = -EXIST\");\n\treturn -EEXIST;\n\nerror:\n\t__fscache_release_cache_tag(tag);\n\t_leave(\" = -EINVAL\");\n\treturn -EINVAL;\n\nnomem:\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOMEM\""
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_release_cache_tag",
          "args": [
            "tag"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_release_cache_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
          "lines": "73-87",
          "snippet": "void __fscache_release_cache_tag(struct fscache_cache_tag *tag)\n{\n\tif (tag != ERR_PTR(-ENOMEM)) {\n\t\tdown_write(&fscache_addremove_sem);\n\n\t\tif (atomic_dec_and_test(&tag->usage))\n\t\t\tlist_del_init(&tag->link);\n\t\telse\n\t\t\ttag = NULL;\n\n\t\tup_write(&fscache_addremove_sem);\n\n\t\tkfree(tag);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid __fscache_release_cache_tag(struct fscache_cache_tag *tag)\n{\n\tif (tag != ERR_PTR(-ENOMEM)) {\n\t\tdown_write(&fscache_addremove_sem);\n\n\t\tif (atomic_dec_and_test(&tag->usage))\n\t\t\tlist_del_init(&tag->link);\n\t\telse\n\t\t\ttag = NULL;\n\n\t\tup_write(&fscache_addremove_sem);\n\n\t\tkfree(tag);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cache tag '%s' already in use\\n\"",
            "tagname"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [%s]\"",
            "cache->identifier"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "cache->kobj",
            "KOBJ_ADD"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kobject_uevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "113-124",
          "snippet": "static void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Cache \\\"%s\\\" added (type %s)\\n\"",
            "cache->tag->name",
            "cache->ops->name"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fscache_fsdef_index.lock"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fscache_fsdef_index.usage"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&ifsdef->cookie_link",
            "&fscache_fsdef_index.backing_objects"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fscache_fsdef_index.lock"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_objlist_add",
          "args": [
            "ifsdef"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_objlist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object-list.c",
          "lines": "48-73",
          "snippet": "void fscache_objlist_add(struct fscache_object *obj)\n{\n\tstruct fscache_object *xobj;\n\tstruct rb_node **p = &fscache_object_list.rb_node, *parent = NULL;\n\n\tASSERT(RB_EMPTY_NODE(&obj->objlist_link));\n\n\twrite_lock(&fscache_object_list_lock);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\txobj = rb_entry(parent, struct fscache_object, objlist_link);\n\n\t\tif (obj < xobj)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (obj > xobj)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&obj->objlist_link, parent, p);\n\trb_insert_color(&obj->objlist_link, &fscache_object_list);\n\n\twrite_unlock(&fscache_object_list_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root fscache_object_list;",
            "static DEFINE_RWLOCK(fscache_object_list_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nstatic struct rb_root fscache_object_list;\nstatic DEFINE_RWLOCK(fscache_object_list_lock);\n\nvoid fscache_objlist_add(struct fscache_object *obj)\n{\n\tstruct fscache_object *xobj;\n\tstruct rb_node **p = &fscache_object_list.rb_node, *parent = NULL;\n\n\tASSERT(RB_EMPTY_NODE(&obj->objlist_link));\n\n\twrite_lock(&fscache_object_list_lock);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\txobj = rb_entry(parent, struct fscache_object, objlist_link);\n\n\t\tif (obj < xobj)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (obj > xobj)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&obj->objlist_link, parent, p);\n\trb_insert_color(&obj->objlist_link, &fscache_object_list);\n\n\twrite_unlock(&fscache_object_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ifsdef->cache_link",
            "&cache->object_list"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cache->link",
            "&fscache_cache_list"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "tagname",
            "fscache_root"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "FSCACHE_TAG_RESERVED",
            "&tag->flags"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tag"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_lookup_cache_tag",
          "args": [
            "tagname"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_lookup_cache_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
          "lines": "27-68",
          "snippet": "struct fscache_cache_tag *__fscache_lookup_cache_tag(const char *name)\n{\n\tstruct fscache_cache_tag *tag, *xtag;\n\n\t/* firstly check for the existence of the tag under read lock */\n\tdown_read(&fscache_addremove_sem);\n\n\tlist_for_each_entry(tag, &fscache_cache_tag_list, link) {\n\t\tif (strcmp(tag->name, name) == 0) {\n\t\t\tatomic_inc(&tag->usage);\n\t\t\tup_read(&fscache_addremove_sem);\n\t\t\treturn tag;\n\t\t}\n\t}\n\n\tup_read(&fscache_addremove_sem);\n\n\t/* the tag does not exist - create a candidate */\n\txtag = kzalloc(sizeof(*xtag) + strlen(name) + 1, GFP_KERNEL);\n\tif (!xtag)\n\t\t/* return a dummy tag if out of memory */\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&xtag->usage, 1);\n\tstrcpy(xtag->name, name);\n\n\t/* write lock, search again and add if still not present */\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_for_each_entry(tag, &fscache_cache_tag_list, link) {\n\t\tif (strcmp(tag->name, name) == 0) {\n\t\t\tatomic_inc(&tag->usage);\n\t\t\tup_write(&fscache_addremove_sem);\n\t\t\tkfree(xtag);\n\t\t\treturn tag;\n\t\t}\n\t}\n\n\tlist_add_tail(&xtag->link, &fscache_cache_tag_list);\n\tup_write(&fscache_addremove_sem);\n\treturn xtag;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fscache_cache_tag_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(fscache_cache_tag_list);\n\nstruct fscache_cache_tag *__fscache_lookup_cache_tag(const char *name)\n{\n\tstruct fscache_cache_tag *tag, *xtag;\n\n\t/* firstly check for the existence of the tag under read lock */\n\tdown_read(&fscache_addremove_sem);\n\n\tlist_for_each_entry(tag, &fscache_cache_tag_list, link) {\n\t\tif (strcmp(tag->name, name) == 0) {\n\t\t\tatomic_inc(&tag->usage);\n\t\t\tup_read(&fscache_addremove_sem);\n\t\t\treturn tag;\n\t\t}\n\t}\n\n\tup_read(&fscache_addremove_sem);\n\n\t/* the tag does not exist - create a candidate */\n\txtag = kzalloc(sizeof(*xtag) + strlen(name) + 1, GFP_KERNEL);\n\tif (!xtag)\n\t\t/* return a dummy tag if out of memory */\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&xtag->usage, 1);\n\tstrcpy(xtag->name, name);\n\n\t/* write lock, search again and add if still not present */\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_for_each_entry(tag, &fscache_cache_tag_list, link) {\n\t\tif (strcmp(tag->name, name) == 0) {\n\t\t\tatomic_inc(&tag->usage);\n\t\t\tup_write(&fscache_addremove_sem);\n\t\t\tkfree(xtag);\n\t\t\treturn tag;\n\t\t}\n\t}\n\n\tlist_add_tail(&xtag->link, &fscache_cache_tag_list);\n\tup_write(&fscache_addremove_sem);\n\treturn xtag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s.%s},,%s\"",
            "cache->ops->name",
            "cache->identifier",
            "tagname"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tagname[0]"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "FSCACHE_OBJECT_IS_AVAILABLE",
            "&ifsdef->flags"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ifsdef"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cache->ops"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fscache_add_cache(struct fscache_cache *cache,\n\t\t      struct fscache_object *ifsdef,\n\t\t      const char *tagname)\n{\n\tstruct fscache_cache_tag *tag;\n\n\tBUG_ON(!cache->ops);\n\tBUG_ON(!ifsdef);\n\n\tcache->flags = 0;\n\tifsdef->event_mask =\n\t\t((1 << NR_FSCACHE_OBJECT_EVENTS) - 1) &\n\t\t~(1 << FSCACHE_OBJECT_EV_CLEARED);\n\t__set_bit(FSCACHE_OBJECT_IS_AVAILABLE, &ifsdef->flags);\n\n\tif (!tagname)\n\t\ttagname = cache->identifier;\n\n\tBUG_ON(!tagname[0]);\n\n\t_enter(\"{%s.%s},,%s\", cache->ops->name, cache->identifier, tagname);\n\n\t/* we use the cache tag to uniquely identify caches */\n\ttag = __fscache_lookup_cache_tag(tagname);\n\tif (IS_ERR(tag))\n\t\tgoto nomem;\n\n\tif (test_and_set_bit(FSCACHE_TAG_RESERVED, &tag->flags))\n\t\tgoto tag_in_use;\n\n\tcache->kobj = kobject_create_and_add(tagname, fscache_root);\n\tif (!cache->kobj)\n\t\tgoto error;\n\n\tifsdef->cookie = &fscache_fsdef_index;\n\tifsdef->cache = cache;\n\tcache->fsdef = ifsdef;\n\n\tdown_write(&fscache_addremove_sem);\n\n\ttag->cache = cache;\n\tcache->tag = tag;\n\n\t/* add the cache to the list */\n\tlist_add(&cache->link, &fscache_cache_list);\n\n\t/* add the cache's netfs definition index object to the cache's\n\t * list */\n\tspin_lock(&cache->object_list_lock);\n\tlist_add_tail(&ifsdef->cache_link, &cache->object_list);\n\tspin_unlock(&cache->object_list_lock);\n\tfscache_objlist_add(ifsdef);\n\n\t/* add the cache's netfs definition index object to the top level index\n\t * cookie as a known backing object */\n\tspin_lock(&fscache_fsdef_index.lock);\n\n\thlist_add_head(&ifsdef->cookie_link,\n\t\t       &fscache_fsdef_index.backing_objects);\n\n\tatomic_inc(&fscache_fsdef_index.usage);\n\n\t/* done */\n\tspin_unlock(&fscache_fsdef_index.lock);\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Cache \\\"%s\\\" added (type %s)\\n\",\n\t\t  cache->tag->name, cache->ops->name);\n\tkobject_uevent(cache->kobj, KOBJ_ADD);\n\n\t_leave(\" = 0 [%s]\", cache->identifier);\n\treturn 0;\n\ntag_in_use:\n\tpr_err(\"Cache tag '%s' already in use\\n\", tagname);\n\t__fscache_release_cache_tag(tag);\n\t_leave(\" = -EXIST\");\n\treturn -EEXIST;\n\nerror:\n\t__fscache_release_cache_tag(tag);\n\t_leave(\" = -EINVAL\");\n\treturn -EINVAL;\n\nnomem:\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "fscache_init_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
    "lines": "182-203",
    "snippet": "void fscache_init_cache(struct fscache_cache *cache,\n\t\t\tconst struct fscache_cache_ops *ops,\n\t\t\tconst char *idfmt,\n\t\t\t...)\n{\n\tva_list va;\n\n\tmemset(cache, 0, sizeof(*cache));\n\n\tcache->ops = ops;\n\n\tva_start(va, idfmt);\n\tvsnprintf(cache->identifier, sizeof(cache->identifier), idfmt, va);\n\tva_end(va);\n\n\tINIT_WORK(&cache->op_gc, fscache_operation_gc);\n\tINIT_LIST_HEAD(&cache->link);\n\tINIT_LIST_HEAD(&cache->object_list);\n\tINIT_LIST_HEAD(&cache->op_gc_list);\n\tspin_lock_init(&cache->object_list_lock);\n\tspin_lock_init(&cache->op_gc_list_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cache->op_gc_list_lock"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cache->object_list_lock"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cache->op_gc_list"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cache->object_list"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cache->link"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&cache->op_gc",
            "fscache_operation_gc"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "va"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "cache->identifier",
            "sizeof(cache->identifier)",
            "idfmt",
            "va"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "va",
            "idfmt"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cache",
            "0",
            "sizeof(*cache)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid fscache_init_cache(struct fscache_cache *cache,\n\t\t\tconst struct fscache_cache_ops *ops,\n\t\t\tconst char *idfmt,\n\t\t\t...)\n{\n\tva_list va;\n\n\tmemset(cache, 0, sizeof(*cache));\n\n\tcache->ops = ops;\n\n\tva_start(va, idfmt);\n\tvsnprintf(cache->identifier, sizeof(cache->identifier), idfmt, va);\n\tva_end(va);\n\n\tINIT_WORK(&cache->op_gc, fscache_operation_gc);\n\tINIT_LIST_HEAD(&cache->link);\n\tINIT_LIST_HEAD(&cache->object_list);\n\tINIT_LIST_HEAD(&cache->op_gc_list);\n\tspin_lock_init(&cache->object_list_lock);\n\tspin_lock_init(&cache->op_gc_list_lock);\n}"
  },
  {
    "function_name": "fscache_select_cache_for_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
    "lines": "94-168",
    "snippet": "struct fscache_cache *fscache_select_cache_for_object(\n\tstruct fscache_cookie *cookie)\n{\n\tstruct fscache_cache_tag *tag;\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"\");\n\n\tif (list_empty(&fscache_cache_list)) {\n\t\t_leave(\" = NULL [no cache]\");\n\t\treturn NULL;\n\t}\n\n\t/* we check the parent to determine the cache to use */\n\tspin_lock(&cookie->lock);\n\n\t/* the first in the parent's backing list should be the preferred\n\t * cache */\n\tif (!hlist_empty(&cookie->backing_objects)) {\n\t\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t\t     struct fscache_object, cookie_link);\n\n\t\tcache = object->cache;\n\t\tif (fscache_object_is_dying(object) ||\n\t\t    test_bit(FSCACHE_IOERROR, &cache->flags))\n\t\t\tcache = NULL;\n\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" = %p [parent]\", cache);\n\t\treturn cache;\n\t}\n\n\t/* the parent is unbacked */\n\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t/* cookie not an index and is unbacked */\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" = NULL [cookie ub,ni]\");\n\t\treturn NULL;\n\t}\n\n\tspin_unlock(&cookie->lock);\n\n\tif (!cookie->def->select_cache)\n\t\tgoto no_preference;\n\n\t/* ask the netfs for its preference */\n\ttag = cookie->def->select_cache(cookie->parent->netfs_data,\n\t\t\t\t\tcookie->netfs_data);\n\tif (!tag)\n\t\tgoto no_preference;\n\n\tif (tag == ERR_PTR(-ENOMEM)) {\n\t\t_leave(\" = NULL [nomem tag]\");\n\t\treturn NULL;\n\t}\n\n\tif (!tag->cache) {\n\t\t_leave(\" = NULL [unbacked tag]\");\n\t\treturn NULL;\n\t}\n\n\tif (test_bit(FSCACHE_IOERROR, &tag->cache->flags))\n\t\treturn NULL;\n\n\t_leave(\" = %p [specific]\", tag->cache);\n\treturn tag->cache;\n\nno_preference:\n\t/* netfs has no preference - just select first cache */\n\tcache = list_entry(fscache_cache_list.next,\n\t\t\t   struct fscache_cache, link);\n\t_leave(\" = %p [first]\", cache);\n\treturn cache;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %p [first]\"",
            "cache"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "fscache_cache_list.next",
            "structfscache_cache",
            "link"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_IOERROR",
            "&tag->cache->flags"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = NULL [unbacked tag]\""
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie->def->select_cache",
          "args": [
            "cookie->parent->netfs_data",
            "cookie->netfs_data"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_object_is_dying",
          "args": [
            "object"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "cookie->backing_objects.first",
            "structfscache_object",
            "cookie_link"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fscache_cache_list"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct fscache_cache *fscache_select_cache_for_object(\n\tstruct fscache_cookie *cookie)\n{\n\tstruct fscache_cache_tag *tag;\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"\");\n\n\tif (list_empty(&fscache_cache_list)) {\n\t\t_leave(\" = NULL [no cache]\");\n\t\treturn NULL;\n\t}\n\n\t/* we check the parent to determine the cache to use */\n\tspin_lock(&cookie->lock);\n\n\t/* the first in the parent's backing list should be the preferred\n\t * cache */\n\tif (!hlist_empty(&cookie->backing_objects)) {\n\t\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t\t     struct fscache_object, cookie_link);\n\n\t\tcache = object->cache;\n\t\tif (fscache_object_is_dying(object) ||\n\t\t    test_bit(FSCACHE_IOERROR, &cache->flags))\n\t\t\tcache = NULL;\n\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" = %p [parent]\", cache);\n\t\treturn cache;\n\t}\n\n\t/* the parent is unbacked */\n\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t/* cookie not an index and is unbacked */\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" = NULL [cookie ub,ni]\");\n\t\treturn NULL;\n\t}\n\n\tspin_unlock(&cookie->lock);\n\n\tif (!cookie->def->select_cache)\n\t\tgoto no_preference;\n\n\t/* ask the netfs for its preference */\n\ttag = cookie->def->select_cache(cookie->parent->netfs_data,\n\t\t\t\t\tcookie->netfs_data);\n\tif (!tag)\n\t\tgoto no_preference;\n\n\tif (tag == ERR_PTR(-ENOMEM)) {\n\t\t_leave(\" = NULL [nomem tag]\");\n\t\treturn NULL;\n\t}\n\n\tif (!tag->cache) {\n\t\t_leave(\" = NULL [unbacked tag]\");\n\t\treturn NULL;\n\t}\n\n\tif (test_bit(FSCACHE_IOERROR, &tag->cache->flags))\n\t\treturn NULL;\n\n\t_leave(\" = %p [specific]\", tag->cache);\n\treturn tag->cache;\n\nno_preference:\n\t/* netfs has no preference - just select first cache */\n\tcache = list_entry(fscache_cache_list.next,\n\t\t\t   struct fscache_cache, link);\n\t_leave(\" = %p [first]\", cache);\n\treturn cache;\n}"
  },
  {
    "function_name": "__fscache_release_cache_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
    "lines": "73-87",
    "snippet": "void __fscache_release_cache_tag(struct fscache_cache_tag *tag)\n{\n\tif (tag != ERR_PTR(-ENOMEM)) {\n\t\tdown_write(&fscache_addremove_sem);\n\n\t\tif (atomic_dec_and_test(&tag->usage))\n\t\t\tlist_del_init(&tag->link);\n\t\telse\n\t\t\ttag = NULL;\n\n\t\tup_write(&fscache_addremove_sem);\n\n\t\tkfree(tag);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tag"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tag->link"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&tag->usage"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid __fscache_release_cache_tag(struct fscache_cache_tag *tag)\n{\n\tif (tag != ERR_PTR(-ENOMEM)) {\n\t\tdown_write(&fscache_addremove_sem);\n\n\t\tif (atomic_dec_and_test(&tag->usage))\n\t\t\tlist_del_init(&tag->link);\n\t\telse\n\t\t\ttag = NULL;\n\n\t\tup_write(&fscache_addremove_sem);\n\n\t\tkfree(tag);\n\t}\n}"
  },
  {
    "function_name": "__fscache_lookup_cache_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
    "lines": "27-68",
    "snippet": "struct fscache_cache_tag *__fscache_lookup_cache_tag(const char *name)\n{\n\tstruct fscache_cache_tag *tag, *xtag;\n\n\t/* firstly check for the existence of the tag under read lock */\n\tdown_read(&fscache_addremove_sem);\n\n\tlist_for_each_entry(tag, &fscache_cache_tag_list, link) {\n\t\tif (strcmp(tag->name, name) == 0) {\n\t\t\tatomic_inc(&tag->usage);\n\t\t\tup_read(&fscache_addremove_sem);\n\t\t\treturn tag;\n\t\t}\n\t}\n\n\tup_read(&fscache_addremove_sem);\n\n\t/* the tag does not exist - create a candidate */\n\txtag = kzalloc(sizeof(*xtag) + strlen(name) + 1, GFP_KERNEL);\n\tif (!xtag)\n\t\t/* return a dummy tag if out of memory */\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&xtag->usage, 1);\n\tstrcpy(xtag->name, name);\n\n\t/* write lock, search again and add if still not present */\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_for_each_entry(tag, &fscache_cache_tag_list, link) {\n\t\tif (strcmp(tag->name, name) == 0) {\n\t\t\tatomic_inc(&tag->usage);\n\t\t\tup_write(&fscache_addremove_sem);\n\t\t\tkfree(xtag);\n\t\t\treturn tag;\n\t\t}\n\t}\n\n\tlist_add_tail(&xtag->link, &fscache_cache_tag_list);\n\tup_write(&fscache_addremove_sem);\n\treturn xtag;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(fscache_cache_tag_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&xtag->link",
            "&fscache_cache_tag_list"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xtag"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&tag->usage"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tag->name",
            "name"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tag",
            "&fscache_cache_tag_list",
            "link"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xtag->name",
            "name"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&xtag->usage",
            "1"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*xtag) + strlen(name) + 1",
            "GFP_KERNEL"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&tag->usage"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tag",
            "&fscache_cache_tag_list",
            "link"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(fscache_cache_tag_list);\n\nstruct fscache_cache_tag *__fscache_lookup_cache_tag(const char *name)\n{\n\tstruct fscache_cache_tag *tag, *xtag;\n\n\t/* firstly check for the existence of the tag under read lock */\n\tdown_read(&fscache_addremove_sem);\n\n\tlist_for_each_entry(tag, &fscache_cache_tag_list, link) {\n\t\tif (strcmp(tag->name, name) == 0) {\n\t\t\tatomic_inc(&tag->usage);\n\t\t\tup_read(&fscache_addremove_sem);\n\t\t\treturn tag;\n\t\t}\n\t}\n\n\tup_read(&fscache_addremove_sem);\n\n\t/* the tag does not exist - create a candidate */\n\txtag = kzalloc(sizeof(*xtag) + strlen(name) + 1, GFP_KERNEL);\n\tif (!xtag)\n\t\t/* return a dummy tag if out of memory */\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&xtag->usage, 1);\n\tstrcpy(xtag->name, name);\n\n\t/* write lock, search again and add if still not present */\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_for_each_entry(tag, &fscache_cache_tag_list, link) {\n\t\tif (strcmp(tag->name, name) == 0) {\n\t\t\tatomic_inc(&tag->usage);\n\t\t\tup_write(&fscache_addremove_sem);\n\t\t\tkfree(xtag);\n\t\t\treturn tag;\n\t\t}\n\t}\n\n\tlist_add_tail(&xtag->link, &fscache_cache_tag_list);\n\tup_write(&fscache_addremove_sem);\n\treturn xtag;\n}"
  }
]