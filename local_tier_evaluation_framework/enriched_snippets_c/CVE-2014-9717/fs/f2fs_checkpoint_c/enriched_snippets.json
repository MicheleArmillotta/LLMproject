[
  {
    "function_name": "destroy_checkpoint_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "1131-1135",
    "snippet": "void destroy_checkpoint_caches(void)\n{\n\tkmem_cache_destroy(ino_entry_slab);\n\tkmem_cache_destroy(inode_entry_slab);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ino_entry_slab;",
      "struct kmem_cache *inode_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "inode_entry_slab"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ino_entry_slab"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\nstruct kmem_cache *inode_entry_slab;\n\nvoid destroy_checkpoint_caches(void)\n{\n\tkmem_cache_destroy(ino_entry_slab);\n\tkmem_cache_destroy(inode_entry_slab);\n}"
  },
  {
    "function_name": "create_checkpoint_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "1116-1129",
    "snippet": "int __init create_checkpoint_caches(void)\n{\n\tino_entry_slab = f2fs_kmem_cache_create(\"f2fs_ino_entry\",\n\t\t\tsizeof(struct ino_entry));\n\tif (!ino_entry_slab)\n\t\treturn -ENOMEM;\n\tinode_entry_slab = f2fs_kmem_cache_create(\"f2fs_inode_entry\",\n\t\t\tsizeof(struct inode_entry));\n\tif (!inode_entry_slab) {\n\t\tkmem_cache_destroy(ino_entry_slab);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ino_entry_slab;",
      "struct kmem_cache *inode_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ino_entry_slab"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_create",
          "args": [
            "\"f2fs_inode_entry\"",
            "sizeof(struct inode_entry)"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1058-1062",
          "snippet": "static inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,\n\t\t\t\t\tsize_t size)\n{\n\treturn kmem_cache_create(name, size, 0, SLAB_RECLAIM_ACCOUNT, NULL);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,\n\t\t\t\t\tsize_t size)\n{\n\treturn kmem_cache_create(name, size, 0, SLAB_RECLAIM_ACCOUNT, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\nstruct kmem_cache *inode_entry_slab;\n\nint __init create_checkpoint_caches(void)\n{\n\tino_entry_slab = f2fs_kmem_cache_create(\"f2fs_ino_entry\",\n\t\t\tsizeof(struct ino_entry));\n\tif (!ino_entry_slab)\n\t\treturn -ENOMEM;\n\tinode_entry_slab = f2fs_kmem_cache_create(\"f2fs_inode_entry\",\n\t\t\tsizeof(struct inode_entry));\n\tif (!inode_entry_slab) {\n\t\tkmem_cache_destroy(ino_entry_slab);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "init_ino_entry_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "1093-1114",
    "snippet": "void init_ino_entry_info(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_INO_ENTRY; i++) {\n\t\tstruct inode_management *im = &sbi->im[i];\n\n\t\tINIT_RADIX_TREE(&im->ino_root, GFP_ATOMIC);\n\t\tspin_lock_init(&im->ino_lock);\n\t\tINIT_LIST_HEAD(&im->ino_list);\n\t\tim->ino_num = 0;\n\t}\n\n\t/*\n\t * considering 512 blocks in a segment 8 blocks are needed for cp\n\t * and log segment summaries. Remaining blocks are used to keep\n\t * orphan entries with the limitation one reserved segment\n\t * for cp pack we can have max 1020*504 orphan entries\n\t */\n\tsbi->max_orphans = (sbi->blocks_per_seg - F2FS_CP_PACKS -\n\t\t\tNR_CURSEG_TYPE) * F2FS_ORPHANS_PER_BLOCK;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&im->ino_list"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&im->ino_lock"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&im->ino_root",
            "GFP_ATOMIC"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid init_ino_entry_info(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_INO_ENTRY; i++) {\n\t\tstruct inode_management *im = &sbi->im[i];\n\n\t\tINIT_RADIX_TREE(&im->ino_root, GFP_ATOMIC);\n\t\tspin_lock_init(&im->ino_lock);\n\t\tINIT_LIST_HEAD(&im->ino_list);\n\t\tim->ino_num = 0;\n\t}\n\n\t/*\n\t * considering 512 blocks in a segment 8 blocks are needed for cp\n\t * and log segment summaries. Remaining blocks are used to keep\n\t * orphan entries with the limitation one reserved segment\n\t * for cp pack we can have max 1020*504 orphan entries\n\t */\n\tsbi->max_orphans = (sbi->blocks_per_seg - F2FS_CP_PACKS -\n\t\t\tNR_CURSEG_TYPE) * F2FS_ORPHANS_PER_BLOCK;\n}"
  },
  {
    "function_name": "write_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "1046-1091",
    "snippet": "void write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\tmutex_lock(&sbi->cp_mutex);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t\tcpc->reason != CP_DISCARD && cpc->reason != CP_UMOUNT)\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\tif (f2fs_readonly(sbi->sb))\n\t\tgoto out;\n\tif (block_operations(sbi))\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\n\t/*\n\t * update checkpoint pack index\n\t * Increase the version number so that\n\t * SIT entries and seg summaries are written at correct place\n\t */\n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t/* write cached NAT/SIT entries to NAT/SIT area */\n\tflush_nat_entries(sbi);\n\tflush_sit_entries(sbi, cpc);\n\n\t/* unlock all the fs_lock[] in do_checkpoint() */\n\tdo_checkpoint(sbi, cpc);\n\n\tunblock_operations(sbi);\n\tstat_inc_cp_count(sbi->stat_info);\nout:\n\tmutex_unlock(&sbi->cp_mutex);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_f2fs_write_checkpoint",
          "args": [
            "sbi->sb",
            "cpc->reason",
            "\"finish checkpoint\""
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->cp_mutex"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat_inc_cp_count",
          "args": [
            "sbi->stat_info"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unblock_operations",
          "args": [
            "sbi"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "unblock_operations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "853-857",
          "snippet": "static void unblock_operations(struct f2fs_sb_info *sbi)\n{\n\tup_write(&sbi->node_write);\n\tf2fs_unlock_all(sbi);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic void unblock_operations(struct f2fs_sb_info *sbi)\n{\n\tup_write(&sbi->node_write);\n\tf2fs_unlock_all(sbi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_checkpoint",
          "args": [
            "sbi",
            "cpc"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "do_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "874-1041",
          "snippet": "static void do_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_WARM_NODE);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned long orphan_num = sbi->im[ORPHAN_INO].ino_num;\n\tnid_t last_nid = nm_i->next_scan_nid;\n\tblock_t start_blk;\n\tstruct page *cp_page;\n\tunsigned int data_sum_blocks, orphan_blocks;\n\t__u32 crc32 = 0;\n\tvoid *kaddr;\n\tint i;\n\tint cp_payload_blks = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n\n\t/*\n\t * This avoids to conduct wrong roll-forward operations and uses\n\t * metapages, so should be called prior to sync_meta_pages below.\n\t */\n\tdiscard_next_dnode(sbi, NEXT_FREE_BLKADDR(sbi, curseg));\n\n\t/* Flush all the NAT/SIT pages */\n\twhile (get_pages(sbi, F2FS_DIRTY_META)) {\n\t\tsync_meta_pages(sbi, META, LONG_MAX);\n\t\tif (unlikely(f2fs_cp_error(sbi)))\n\t\t\treturn;\n\t}\n\n\tnext_free_nid(sbi, &last_nid);\n\n\t/*\n\t * modify checkpoint\n\t * version number is already updated\n\t */\n\tckpt->elapsed_time = cpu_to_le64(get_mtime(sbi));\n\tckpt->valid_block_count = cpu_to_le64(valid_user_blocks(sbi));\n\tckpt->free_segment_count = cpu_to_le32(free_segments(sbi));\n\tfor (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {\n\t\tckpt->cur_node_segno[i] =\n\t\t\tcpu_to_le32(curseg_segno(sbi, i + CURSEG_HOT_NODE));\n\t\tckpt->cur_node_blkoff[i] =\n\t\t\tcpu_to_le16(curseg_blkoff(sbi, i + CURSEG_HOT_NODE));\n\t\tckpt->alloc_type[i + CURSEG_HOT_NODE] =\n\t\t\t\tcurseg_alloc_type(sbi, i + CURSEG_HOT_NODE);\n\t}\n\tfor (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {\n\t\tckpt->cur_data_segno[i] =\n\t\t\tcpu_to_le32(curseg_segno(sbi, i + CURSEG_HOT_DATA));\n\t\tckpt->cur_data_blkoff[i] =\n\t\t\tcpu_to_le16(curseg_blkoff(sbi, i + CURSEG_HOT_DATA));\n\t\tckpt->alloc_type[i + CURSEG_HOT_DATA] =\n\t\t\t\tcurseg_alloc_type(sbi, i + CURSEG_HOT_DATA);\n\t}\n\n\tckpt->valid_node_count = cpu_to_le32(valid_node_count(sbi));\n\tckpt->valid_inode_count = cpu_to_le32(valid_inode_count(sbi));\n\tckpt->next_free_nid = cpu_to_le32(last_nid);\n\n\t/* 2 cp  + n data seg summary + orphan inode blocks */\n\tdata_sum_blocks = npages_for_summary_flush(sbi, false);\n\tif (data_sum_blocks < NR_CURSEG_DATA_TYPE)\n\t\tset_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);\n\n\torphan_blocks = GET_ORPHAN_BLOCKS(orphan_num);\n\tckpt->cp_pack_start_sum = cpu_to_le32(1 + cp_payload_blks +\n\t\t\torphan_blocks);\n\n\tif (__remain_node_summaries(cpc->reason))\n\t\tckpt->cp_pack_total_block_count = cpu_to_le32(F2FS_CP_PACKS+\n\t\t\t\tcp_payload_blks + data_sum_blocks +\n\t\t\t\torphan_blocks + NR_CURSEG_NODE_TYPE);\n\telse\n\t\tckpt->cp_pack_total_block_count = cpu_to_le32(F2FS_CP_PACKS +\n\t\t\t\tcp_payload_blks + data_sum_blocks +\n\t\t\t\torphan_blocks);\n\n\tif (cpc->reason == CP_UMOUNT)\n\t\tset_ckpt_flags(ckpt, CP_UMOUNT_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_UMOUNT_FLAG);\n\n\tif (cpc->reason == CP_FASTBOOT)\n\t\tset_ckpt_flags(ckpt, CP_FASTBOOT_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_FASTBOOT_FLAG);\n\n\tif (orphan_num)\n\t\tset_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);\n\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK))\n\t\tset_ckpt_flags(ckpt, CP_FSCK_FLAG);\n\n\t/* update SIT/NAT bitmap */\n\tget_sit_bitmap(sbi, __bitmap_ptr(sbi, SIT_BITMAP));\n\tget_nat_bitmap(sbi, __bitmap_ptr(sbi, NAT_BITMAP));\n\n\tcrc32 = f2fs_crc32(ckpt, le32_to_cpu(ckpt->checksum_offset));\n\t*((__le32 *)((unsigned char *)ckpt +\n\t\t\t\tle32_to_cpu(ckpt->checksum_offset)))\n\t\t\t\t= cpu_to_le32(crc32);\n\n\tstart_blk = __start_cp_addr(sbi);\n\n\t/* write out checkpoint buffer at block 0 */\n\tcp_page = grab_meta_page(sbi, start_blk++);\n\tkaddr = page_address(cp_page);\n\tmemcpy(kaddr, ckpt, F2FS_BLKSIZE);\n\tset_page_dirty(cp_page);\n\tf2fs_put_page(cp_page, 1);\n\n\tfor (i = 1; i < 1 + cp_payload_blks; i++) {\n\t\tcp_page = grab_meta_page(sbi, start_blk++);\n\t\tkaddr = page_address(cp_page);\n\t\tmemcpy(kaddr, (char *)ckpt + i * F2FS_BLKSIZE, F2FS_BLKSIZE);\n\t\tset_page_dirty(cp_page);\n\t\tf2fs_put_page(cp_page, 1);\n\t}\n\n\tif (orphan_num) {\n\t\twrite_orphan_inodes(sbi, start_blk);\n\t\tstart_blk += orphan_blocks;\n\t}\n\n\twrite_data_summaries(sbi, start_blk);\n\tstart_blk += data_sum_blocks;\n\tif (__remain_node_summaries(cpc->reason)) {\n\t\twrite_node_summaries(sbi, start_blk);\n\t\tstart_blk += NR_CURSEG_NODE_TYPE;\n\t}\n\n\t/* writeout checkpoint block */\n\tcp_page = grab_meta_page(sbi, start_blk);\n\tkaddr = page_address(cp_page);\n\tmemcpy(kaddr, ckpt, F2FS_BLKSIZE);\n\tset_page_dirty(cp_page);\n\tf2fs_put_page(cp_page, 1);\n\n\t/* wait for previous submitted node/meta pages writeback */\n\twait_on_all_pages_writeback(sbi);\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tfilemap_fdatawait_range(NODE_MAPPING(sbi), 0, LONG_MAX);\n\tfilemap_fdatawait_range(META_MAPPING(sbi), 0, LONG_MAX);\n\n\t/* update user_block_counts */\n\tsbi->last_valid_block_count = sbi->total_valid_block_count;\n\tsbi->alloc_valid_block_count = 0;\n\n\t/* Here, we only have one bio having CP pack */\n\tsync_meta_pages(sbi, META_FLUSH, LONG_MAX);\n\n\t/* wait for previous submitted meta pages writeback */\n\twait_on_all_pages_writeback(sbi);\n\n\trelease_dirty_inode(sbi);\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tclear_prefree_segments(sbi);\n\tclear_sbi_flag(sbi, SBI_IS_DIRTY);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic void do_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_WARM_NODE);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned long orphan_num = sbi->im[ORPHAN_INO].ino_num;\n\tnid_t last_nid = nm_i->next_scan_nid;\n\tblock_t start_blk;\n\tstruct page *cp_page;\n\tunsigned int data_sum_blocks, orphan_blocks;\n\t__u32 crc32 = 0;\n\tvoid *kaddr;\n\tint i;\n\tint cp_payload_blks = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n\n\t/*\n\t * This avoids to conduct wrong roll-forward operations and uses\n\t * metapages, so should be called prior to sync_meta_pages below.\n\t */\n\tdiscard_next_dnode(sbi, NEXT_FREE_BLKADDR(sbi, curseg));\n\n\t/* Flush all the NAT/SIT pages */\n\twhile (get_pages(sbi, F2FS_DIRTY_META)) {\n\t\tsync_meta_pages(sbi, META, LONG_MAX);\n\t\tif (unlikely(f2fs_cp_error(sbi)))\n\t\t\treturn;\n\t}\n\n\tnext_free_nid(sbi, &last_nid);\n\n\t/*\n\t * modify checkpoint\n\t * version number is already updated\n\t */\n\tckpt->elapsed_time = cpu_to_le64(get_mtime(sbi));\n\tckpt->valid_block_count = cpu_to_le64(valid_user_blocks(sbi));\n\tckpt->free_segment_count = cpu_to_le32(free_segments(sbi));\n\tfor (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {\n\t\tckpt->cur_node_segno[i] =\n\t\t\tcpu_to_le32(curseg_segno(sbi, i + CURSEG_HOT_NODE));\n\t\tckpt->cur_node_blkoff[i] =\n\t\t\tcpu_to_le16(curseg_blkoff(sbi, i + CURSEG_HOT_NODE));\n\t\tckpt->alloc_type[i + CURSEG_HOT_NODE] =\n\t\t\t\tcurseg_alloc_type(sbi, i + CURSEG_HOT_NODE);\n\t}\n\tfor (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {\n\t\tckpt->cur_data_segno[i] =\n\t\t\tcpu_to_le32(curseg_segno(sbi, i + CURSEG_HOT_DATA));\n\t\tckpt->cur_data_blkoff[i] =\n\t\t\tcpu_to_le16(curseg_blkoff(sbi, i + CURSEG_HOT_DATA));\n\t\tckpt->alloc_type[i + CURSEG_HOT_DATA] =\n\t\t\t\tcurseg_alloc_type(sbi, i + CURSEG_HOT_DATA);\n\t}\n\n\tckpt->valid_node_count = cpu_to_le32(valid_node_count(sbi));\n\tckpt->valid_inode_count = cpu_to_le32(valid_inode_count(sbi));\n\tckpt->next_free_nid = cpu_to_le32(last_nid);\n\n\t/* 2 cp  + n data seg summary + orphan inode blocks */\n\tdata_sum_blocks = npages_for_summary_flush(sbi, false);\n\tif (data_sum_blocks < NR_CURSEG_DATA_TYPE)\n\t\tset_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);\n\n\torphan_blocks = GET_ORPHAN_BLOCKS(orphan_num);\n\tckpt->cp_pack_start_sum = cpu_to_le32(1 + cp_payload_blks +\n\t\t\torphan_blocks);\n\n\tif (__remain_node_summaries(cpc->reason))\n\t\tckpt->cp_pack_total_block_count = cpu_to_le32(F2FS_CP_PACKS+\n\t\t\t\tcp_payload_blks + data_sum_blocks +\n\t\t\t\torphan_blocks + NR_CURSEG_NODE_TYPE);\n\telse\n\t\tckpt->cp_pack_total_block_count = cpu_to_le32(F2FS_CP_PACKS +\n\t\t\t\tcp_payload_blks + data_sum_blocks +\n\t\t\t\torphan_blocks);\n\n\tif (cpc->reason == CP_UMOUNT)\n\t\tset_ckpt_flags(ckpt, CP_UMOUNT_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_UMOUNT_FLAG);\n\n\tif (cpc->reason == CP_FASTBOOT)\n\t\tset_ckpt_flags(ckpt, CP_FASTBOOT_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_FASTBOOT_FLAG);\n\n\tif (orphan_num)\n\t\tset_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);\n\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK))\n\t\tset_ckpt_flags(ckpt, CP_FSCK_FLAG);\n\n\t/* update SIT/NAT bitmap */\n\tget_sit_bitmap(sbi, __bitmap_ptr(sbi, SIT_BITMAP));\n\tget_nat_bitmap(sbi, __bitmap_ptr(sbi, NAT_BITMAP));\n\n\tcrc32 = f2fs_crc32(ckpt, le32_to_cpu(ckpt->checksum_offset));\n\t*((__le32 *)((unsigned char *)ckpt +\n\t\t\t\tle32_to_cpu(ckpt->checksum_offset)))\n\t\t\t\t= cpu_to_le32(crc32);\n\n\tstart_blk = __start_cp_addr(sbi);\n\n\t/* write out checkpoint buffer at block 0 */\n\tcp_page = grab_meta_page(sbi, start_blk++);\n\tkaddr = page_address(cp_page);\n\tmemcpy(kaddr, ckpt, F2FS_BLKSIZE);\n\tset_page_dirty(cp_page);\n\tf2fs_put_page(cp_page, 1);\n\n\tfor (i = 1; i < 1 + cp_payload_blks; i++) {\n\t\tcp_page = grab_meta_page(sbi, start_blk++);\n\t\tkaddr = page_address(cp_page);\n\t\tmemcpy(kaddr, (char *)ckpt + i * F2FS_BLKSIZE, F2FS_BLKSIZE);\n\t\tset_page_dirty(cp_page);\n\t\tf2fs_put_page(cp_page, 1);\n\t}\n\n\tif (orphan_num) {\n\t\twrite_orphan_inodes(sbi, start_blk);\n\t\tstart_blk += orphan_blocks;\n\t}\n\n\twrite_data_summaries(sbi, start_blk);\n\tstart_blk += data_sum_blocks;\n\tif (__remain_node_summaries(cpc->reason)) {\n\t\twrite_node_summaries(sbi, start_blk);\n\t\tstart_blk += NR_CURSEG_NODE_TYPE;\n\t}\n\n\t/* writeout checkpoint block */\n\tcp_page = grab_meta_page(sbi, start_blk);\n\tkaddr = page_address(cp_page);\n\tmemcpy(kaddr, ckpt, F2FS_BLKSIZE);\n\tset_page_dirty(cp_page);\n\tf2fs_put_page(cp_page, 1);\n\n\t/* wait for previous submitted node/meta pages writeback */\n\twait_on_all_pages_writeback(sbi);\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tfilemap_fdatawait_range(NODE_MAPPING(sbi), 0, LONG_MAX);\n\tfilemap_fdatawait_range(META_MAPPING(sbi), 0, LONG_MAX);\n\n\t/* update user_block_counts */\n\tsbi->last_valid_block_count = sbi->total_valid_block_count;\n\tsbi->alloc_valid_block_count = 0;\n\n\t/* Here, we only have one bio having CP pack */\n\tsync_meta_pages(sbi, META_FLUSH, LONG_MAX);\n\n\t/* wait for previous submitted meta pages writeback */\n\twait_on_all_pages_writeback(sbi);\n\n\trelease_dirty_inode(sbi);\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tclear_prefree_segments(sbi);\n\tclear_sbi_flag(sbi, SBI_IS_DIRTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_sit_entries",
          "args": [
            "sbi",
            "cpc"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "flush_sit_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1719-1821",
          "snippet": "void flush_sit_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned long *bitmap = sit_i->dirty_sentries_bitmap;\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tstruct sit_entry_set *ses, *tmp;\n\tstruct list_head *head = &SM_I(sbi)->sit_entry_set;\n\tbool to_journal = true;\n\tstruct seg_entry *se;\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tmutex_lock(&sit_i->sentry_lock);\n\n\t/*\n\t * add and account sit entries of dirty bitmap in sit entry\n\t * set temporarily\n\t */\n\tadd_sits_in_set(sbi);\n\n\t/*\n\t * if there are no enough space in journal to store dirty sit\n\t * entries, remove all entries from journal and add and account\n\t * them in sit entry set.\n\t */\n\tif (!__has_cursum_space(sum, sit_i->dirty_sentries, SIT_JOURNAL))\n\t\tremove_sits_in_journal(sbi);\n\n\tif (!sit_i->dirty_sentries)\n\t\tgoto out;\n\n\t/*\n\t * there are two steps to flush sit entries:\n\t * #1, flush sit entries to journal in current cold data summary block.\n\t * #2, flush sit entries to sit page.\n\t */\n\tlist_for_each_entry_safe(ses, tmp, head, set_list) {\n\t\tstruct page *page = NULL;\n\t\tstruct f2fs_sit_block *raw_sit = NULL;\n\t\tunsigned int start_segno = ses->start_segno;\n\t\tunsigned int end = min(start_segno + SIT_ENTRY_PER_BLOCK,\n\t\t\t\t\t\t(unsigned long)MAIN_SEGS(sbi));\n\t\tunsigned int segno = start_segno;\n\n\t\tif (to_journal &&\n\t\t\t!__has_cursum_space(sum, ses->entry_cnt, SIT_JOURNAL))\n\t\t\tto_journal = false;\n\n\t\tif (!to_journal) {\n\t\t\tpage = get_next_sit_page(sbi, start_segno);\n\t\t\traw_sit = page_address(page);\n\t\t}\n\n\t\t/* flush dirty sit entries in region of current sit set */\n\t\tfor_each_set_bit_from(segno, bitmap, end) {\n\t\t\tint offset, sit_offset;\n\n\t\t\tse = get_seg_entry(sbi, segno);\n\n\t\t\t/* add discard candidates */\n\t\t\tif (cpc->reason != CP_DISCARD) {\n\t\t\t\tcpc->trim_start = segno;\n\t\t\t\tadd_discard_addrs(sbi, cpc);\n\t\t\t}\n\n\t\t\tif (to_journal) {\n\t\t\t\toffset = lookup_journal_in_cursum(sum,\n\t\t\t\t\t\t\tSIT_JOURNAL, segno, 1);\n\t\t\t\tf2fs_bug_on(sbi, offset < 0);\n\t\t\t\tsegno_in_journal(sum, offset) =\n\t\t\t\t\t\t\tcpu_to_le32(segno);\n\t\t\t\tseg_info_to_raw_sit(se,\n\t\t\t\t\t\t&sit_in_journal(sum, offset));\n\t\t\t} else {\n\t\t\t\tsit_offset = SIT_ENTRY_OFFSET(sit_i, segno);\n\t\t\t\tseg_info_to_raw_sit(se,\n\t\t\t\t\t\t&raw_sit->entries[sit_offset]);\n\t\t\t}\n\n\t\t\t__clear_bit(segno, bitmap);\n\t\t\tsit_i->dirty_sentries--;\n\t\t\tses->entry_cnt--;\n\t\t}\n\n\t\tif (!to_journal)\n\t\t\tf2fs_put_page(page, 1);\n\n\t\tf2fs_bug_on(sbi, ses->entry_cnt);\n\t\trelease_sit_entry_set(ses);\n\t}\n\n\tf2fs_bug_on(sbi, !list_empty(head));\n\tf2fs_bug_on(sbi, sit_i->dirty_sentries);\nout:\n\tif (cpc->reason == CP_DISCARD) {\n\t\tfor (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++)\n\t\t\tadd_discard_addrs(sbi, cpc);\n\t}\n\tmutex_unlock(&sit_i->sentry_lock);\n\tmutex_unlock(&curseg->curseg_mutex);\n\n\tset_prefree_as_free_segments(sbi);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid flush_sit_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned long *bitmap = sit_i->dirty_sentries_bitmap;\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tstruct sit_entry_set *ses, *tmp;\n\tstruct list_head *head = &SM_I(sbi)->sit_entry_set;\n\tbool to_journal = true;\n\tstruct seg_entry *se;\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tmutex_lock(&sit_i->sentry_lock);\n\n\t/*\n\t * add and account sit entries of dirty bitmap in sit entry\n\t * set temporarily\n\t */\n\tadd_sits_in_set(sbi);\n\n\t/*\n\t * if there are no enough space in journal to store dirty sit\n\t * entries, remove all entries from journal and add and account\n\t * them in sit entry set.\n\t */\n\tif (!__has_cursum_space(sum, sit_i->dirty_sentries, SIT_JOURNAL))\n\t\tremove_sits_in_journal(sbi);\n\n\tif (!sit_i->dirty_sentries)\n\t\tgoto out;\n\n\t/*\n\t * there are two steps to flush sit entries:\n\t * #1, flush sit entries to journal in current cold data summary block.\n\t * #2, flush sit entries to sit page.\n\t */\n\tlist_for_each_entry_safe(ses, tmp, head, set_list) {\n\t\tstruct page *page = NULL;\n\t\tstruct f2fs_sit_block *raw_sit = NULL;\n\t\tunsigned int start_segno = ses->start_segno;\n\t\tunsigned int end = min(start_segno + SIT_ENTRY_PER_BLOCK,\n\t\t\t\t\t\t(unsigned long)MAIN_SEGS(sbi));\n\t\tunsigned int segno = start_segno;\n\n\t\tif (to_journal &&\n\t\t\t!__has_cursum_space(sum, ses->entry_cnt, SIT_JOURNAL))\n\t\t\tto_journal = false;\n\n\t\tif (!to_journal) {\n\t\t\tpage = get_next_sit_page(sbi, start_segno);\n\t\t\traw_sit = page_address(page);\n\t\t}\n\n\t\t/* flush dirty sit entries in region of current sit set */\n\t\tfor_each_set_bit_from(segno, bitmap, end) {\n\t\t\tint offset, sit_offset;\n\n\t\t\tse = get_seg_entry(sbi, segno);\n\n\t\t\t/* add discard candidates */\n\t\t\tif (cpc->reason != CP_DISCARD) {\n\t\t\t\tcpc->trim_start = segno;\n\t\t\t\tadd_discard_addrs(sbi, cpc);\n\t\t\t}\n\n\t\t\tif (to_journal) {\n\t\t\t\toffset = lookup_journal_in_cursum(sum,\n\t\t\t\t\t\t\tSIT_JOURNAL, segno, 1);\n\t\t\t\tf2fs_bug_on(sbi, offset < 0);\n\t\t\t\tsegno_in_journal(sum, offset) =\n\t\t\t\t\t\t\tcpu_to_le32(segno);\n\t\t\t\tseg_info_to_raw_sit(se,\n\t\t\t\t\t\t&sit_in_journal(sum, offset));\n\t\t\t} else {\n\t\t\t\tsit_offset = SIT_ENTRY_OFFSET(sit_i, segno);\n\t\t\t\tseg_info_to_raw_sit(se,\n\t\t\t\t\t\t&raw_sit->entries[sit_offset]);\n\t\t\t}\n\n\t\t\t__clear_bit(segno, bitmap);\n\t\t\tsit_i->dirty_sentries--;\n\t\t\tses->entry_cnt--;\n\t\t}\n\n\t\tif (!to_journal)\n\t\t\tf2fs_put_page(page, 1);\n\n\t\tf2fs_bug_on(sbi, ses->entry_cnt);\n\t\trelease_sit_entry_set(ses);\n\t}\n\n\tf2fs_bug_on(sbi, !list_empty(head));\n\tf2fs_bug_on(sbi, sit_i->dirty_sentries);\nout:\n\tif (cpc->reason == CP_DISCARD) {\n\t\tfor (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++)\n\t\t\tadd_discard_addrs(sbi, cpc);\n\t}\n\tmutex_unlock(&sit_i->sentry_lock);\n\tmutex_unlock(&curseg->curseg_mutex);\n\n\tset_prefree_as_free_segments(sbi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_nat_entries",
          "args": [
            "sbi"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "flush_nat_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1884-1919",
          "snippet": "void flush_nat_entries(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tstruct nat_entry_set *set, *tmp;\n\tunsigned int found;\n\tnid_t set_idx = 0;\n\tLIST_HEAD(sets);\n\n\tif (!nm_i->dirty_nat_cnt)\n\t\treturn;\n\t/*\n\t * if there are no enough space in journal to store dirty nat\n\t * entries, remove all entries from journal and merge them\n\t * into nat entry set.\n\t */\n\tif (!__has_cursum_space(sum, nm_i->dirty_nat_cnt, NAT_JOURNAL))\n\t\tremove_nats_in_journal(sbi);\n\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tset_idx, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\t\tset_idx = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__adjust_nat_entry_set(setvec[idx], &sets,\n\t\t\t\t\t\t\tMAX_NAT_JENTRIES(sum));\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(set, tmp, &sets, set_list)\n\t\t__flush_nat_entry_set(sbi, set);\n\n\tf2fs_bug_on(sbi, nm_i->dirty_nat_cnt);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid flush_nat_entries(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tstruct nat_entry_set *set, *tmp;\n\tunsigned int found;\n\tnid_t set_idx = 0;\n\tLIST_HEAD(sets);\n\n\tif (!nm_i->dirty_nat_cnt)\n\t\treturn;\n\t/*\n\t * if there are no enough space in journal to store dirty nat\n\t * entries, remove all entries from journal and merge them\n\t * into nat entry set.\n\t */\n\tif (!__has_cursum_space(sum, nm_i->dirty_nat_cnt, NAT_JOURNAL))\n\t\tremove_nats_in_journal(sbi);\n\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tset_idx, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\t\tset_idx = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__adjust_nat_entry_set(setvec[idx], &sets,\n\t\t\t\t\t\t\tMAX_NAT_JENTRIES(sum));\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(set, tmp, &sets, set_list)\n\t\t__flush_nat_entry_set(sbi, set);\n\n\tf2fs_bug_on(sbi, nm_i->dirty_nat_cnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "++ckpt_ver"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_cp_version",
          "args": [
            "ckpt"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "cur_cp_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "730-733",
          "snippet": "static inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_submit_merged_bio",
          "args": [
            "sbi",
            "META",
            "WRITE"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "107-127",
          "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_write_checkpoint",
          "args": [
            "sbi->sb",
            "cpc->reason",
            "\"finish block_ops\""
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_readonly",
          "args": [
            "sbi->sb"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1305-1308",
          "snippet": "static inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_readonly(struct super_block *sb)\n{\n\treturn sb->s_flags & MS_RDONLY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_cp_error",
          "args": [
            "sbi"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_cp_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1310-1313",
          "snippet": "static inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sbi_flag_set",
          "args": [
            "sbi",
            "SBI_IS_DIRTY"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "is_sbi_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "715-718",
          "snippet": "static inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn sbi->s_flag & (0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn sbi->s_flag & (0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->cp_mutex"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_write_checkpoint",
          "args": [
            "sbi->sb",
            "cpc->reason",
            "\"start block_ops\""
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\tmutex_lock(&sbi->cp_mutex);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t\tcpc->reason != CP_DISCARD && cpc->reason != CP_UMOUNT)\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\tif (f2fs_readonly(sbi->sb))\n\t\tgoto out;\n\tif (block_operations(sbi))\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\n\t/*\n\t * update checkpoint pack index\n\t * Increase the version number so that\n\t * SIT entries and seg summaries are written at correct place\n\t */\n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t/* write cached NAT/SIT entries to NAT/SIT area */\n\tflush_nat_entries(sbi);\n\tflush_sit_entries(sbi, cpc);\n\n\t/* unlock all the fs_lock[] in do_checkpoint() */\n\tdo_checkpoint(sbi, cpc);\n\n\tunblock_operations(sbi);\n\tstat_inc_cp_count(sbi->stat_info);\nout:\n\tmutex_unlock(&sbi->cp_mutex);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\n}"
  },
  {
    "function_name": "do_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "874-1041",
    "snippet": "static void do_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_WARM_NODE);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned long orphan_num = sbi->im[ORPHAN_INO].ino_num;\n\tnid_t last_nid = nm_i->next_scan_nid;\n\tblock_t start_blk;\n\tstruct page *cp_page;\n\tunsigned int data_sum_blocks, orphan_blocks;\n\t__u32 crc32 = 0;\n\tvoid *kaddr;\n\tint i;\n\tint cp_payload_blks = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n\n\t/*\n\t * This avoids to conduct wrong roll-forward operations and uses\n\t * metapages, so should be called prior to sync_meta_pages below.\n\t */\n\tdiscard_next_dnode(sbi, NEXT_FREE_BLKADDR(sbi, curseg));\n\n\t/* Flush all the NAT/SIT pages */\n\twhile (get_pages(sbi, F2FS_DIRTY_META)) {\n\t\tsync_meta_pages(sbi, META, LONG_MAX);\n\t\tif (unlikely(f2fs_cp_error(sbi)))\n\t\t\treturn;\n\t}\n\n\tnext_free_nid(sbi, &last_nid);\n\n\t/*\n\t * modify checkpoint\n\t * version number is already updated\n\t */\n\tckpt->elapsed_time = cpu_to_le64(get_mtime(sbi));\n\tckpt->valid_block_count = cpu_to_le64(valid_user_blocks(sbi));\n\tckpt->free_segment_count = cpu_to_le32(free_segments(sbi));\n\tfor (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {\n\t\tckpt->cur_node_segno[i] =\n\t\t\tcpu_to_le32(curseg_segno(sbi, i + CURSEG_HOT_NODE));\n\t\tckpt->cur_node_blkoff[i] =\n\t\t\tcpu_to_le16(curseg_blkoff(sbi, i + CURSEG_HOT_NODE));\n\t\tckpt->alloc_type[i + CURSEG_HOT_NODE] =\n\t\t\t\tcurseg_alloc_type(sbi, i + CURSEG_HOT_NODE);\n\t}\n\tfor (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {\n\t\tckpt->cur_data_segno[i] =\n\t\t\tcpu_to_le32(curseg_segno(sbi, i + CURSEG_HOT_DATA));\n\t\tckpt->cur_data_blkoff[i] =\n\t\t\tcpu_to_le16(curseg_blkoff(sbi, i + CURSEG_HOT_DATA));\n\t\tckpt->alloc_type[i + CURSEG_HOT_DATA] =\n\t\t\t\tcurseg_alloc_type(sbi, i + CURSEG_HOT_DATA);\n\t}\n\n\tckpt->valid_node_count = cpu_to_le32(valid_node_count(sbi));\n\tckpt->valid_inode_count = cpu_to_le32(valid_inode_count(sbi));\n\tckpt->next_free_nid = cpu_to_le32(last_nid);\n\n\t/* 2 cp  + n data seg summary + orphan inode blocks */\n\tdata_sum_blocks = npages_for_summary_flush(sbi, false);\n\tif (data_sum_blocks < NR_CURSEG_DATA_TYPE)\n\t\tset_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);\n\n\torphan_blocks = GET_ORPHAN_BLOCKS(orphan_num);\n\tckpt->cp_pack_start_sum = cpu_to_le32(1 + cp_payload_blks +\n\t\t\torphan_blocks);\n\n\tif (__remain_node_summaries(cpc->reason))\n\t\tckpt->cp_pack_total_block_count = cpu_to_le32(F2FS_CP_PACKS+\n\t\t\t\tcp_payload_blks + data_sum_blocks +\n\t\t\t\torphan_blocks + NR_CURSEG_NODE_TYPE);\n\telse\n\t\tckpt->cp_pack_total_block_count = cpu_to_le32(F2FS_CP_PACKS +\n\t\t\t\tcp_payload_blks + data_sum_blocks +\n\t\t\t\torphan_blocks);\n\n\tif (cpc->reason == CP_UMOUNT)\n\t\tset_ckpt_flags(ckpt, CP_UMOUNT_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_UMOUNT_FLAG);\n\n\tif (cpc->reason == CP_FASTBOOT)\n\t\tset_ckpt_flags(ckpt, CP_FASTBOOT_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_FASTBOOT_FLAG);\n\n\tif (orphan_num)\n\t\tset_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);\n\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK))\n\t\tset_ckpt_flags(ckpt, CP_FSCK_FLAG);\n\n\t/* update SIT/NAT bitmap */\n\tget_sit_bitmap(sbi, __bitmap_ptr(sbi, SIT_BITMAP));\n\tget_nat_bitmap(sbi, __bitmap_ptr(sbi, NAT_BITMAP));\n\n\tcrc32 = f2fs_crc32(ckpt, le32_to_cpu(ckpt->checksum_offset));\n\t*((__le32 *)((unsigned char *)ckpt +\n\t\t\t\tle32_to_cpu(ckpt->checksum_offset)))\n\t\t\t\t= cpu_to_le32(crc32);\n\n\tstart_blk = __start_cp_addr(sbi);\n\n\t/* write out checkpoint buffer at block 0 */\n\tcp_page = grab_meta_page(sbi, start_blk++);\n\tkaddr = page_address(cp_page);\n\tmemcpy(kaddr, ckpt, F2FS_BLKSIZE);\n\tset_page_dirty(cp_page);\n\tf2fs_put_page(cp_page, 1);\n\n\tfor (i = 1; i < 1 + cp_payload_blks; i++) {\n\t\tcp_page = grab_meta_page(sbi, start_blk++);\n\t\tkaddr = page_address(cp_page);\n\t\tmemcpy(kaddr, (char *)ckpt + i * F2FS_BLKSIZE, F2FS_BLKSIZE);\n\t\tset_page_dirty(cp_page);\n\t\tf2fs_put_page(cp_page, 1);\n\t}\n\n\tif (orphan_num) {\n\t\twrite_orphan_inodes(sbi, start_blk);\n\t\tstart_blk += orphan_blocks;\n\t}\n\n\twrite_data_summaries(sbi, start_blk);\n\tstart_blk += data_sum_blocks;\n\tif (__remain_node_summaries(cpc->reason)) {\n\t\twrite_node_summaries(sbi, start_blk);\n\t\tstart_blk += NR_CURSEG_NODE_TYPE;\n\t}\n\n\t/* writeout checkpoint block */\n\tcp_page = grab_meta_page(sbi, start_blk);\n\tkaddr = page_address(cp_page);\n\tmemcpy(kaddr, ckpt, F2FS_BLKSIZE);\n\tset_page_dirty(cp_page);\n\tf2fs_put_page(cp_page, 1);\n\n\t/* wait for previous submitted node/meta pages writeback */\n\twait_on_all_pages_writeback(sbi);\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tfilemap_fdatawait_range(NODE_MAPPING(sbi), 0, LONG_MAX);\n\tfilemap_fdatawait_range(META_MAPPING(sbi), 0, LONG_MAX);\n\n\t/* update user_block_counts */\n\tsbi->last_valid_block_count = sbi->total_valid_block_count;\n\tsbi->alloc_valid_block_count = 0;\n\n\t/* Here, we only have one bio having CP pack */\n\tsync_meta_pages(sbi, META_FLUSH, LONG_MAX);\n\n\t/* wait for previous submitted meta pages writeback */\n\twait_on_all_pages_writeback(sbi);\n\n\trelease_dirty_inode(sbi);\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tclear_prefree_segments(sbi);\n\tclear_sbi_flag(sbi, SBI_IS_DIRTY);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_sbi_flag",
          "args": [
            "sbi",
            "SBI_IS_DIRTY"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sbi_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "725-728",
          "snippet": "static inline void clear_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag &= ~(0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag &= ~(0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_prefree_segments",
          "args": [
            "sbi"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "clear_prefree_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "585-623",
          "snippet": "void clear_prefree_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->discard_list);\n\tstruct discard_entry *entry, *this;\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned long *prefree_map = dirty_i->dirty_segmap[PRE];\n\tunsigned int start = 0, end = -1;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\twhile (1) {\n\t\tint i;\n\t\tstart = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + 1);\n\t\tif (start >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\tend = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi),\n\t\t\t\t\t\t\t\tstart + 1);\n\n\t\tfor (i = start; i < end; i++)\n\t\t\tclear_bit(i, prefree_map);\n\n\t\tdirty_i->nr_dirty[PRE] -= end - start;\n\n\t\tif (!test_opt(sbi, DISCARD))\n\t\t\tcontinue;\n\n\t\tf2fs_issue_discard(sbi, START_BLOCK(sbi, start),\n\t\t\t\t(end - start) << sbi->log_blocks_per_seg);\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t/* send small discards */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tf2fs_issue_discard(sbi, entry->blkaddr, entry->len);\n\t\tlist_del(&entry->list);\n\t\tSM_I(sbi)->nr_discards -= entry->len;\n\t\tkmem_cache_free(discard_entry_slab, entry);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *discard_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\n\nvoid clear_prefree_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->discard_list);\n\tstruct discard_entry *entry, *this;\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned long *prefree_map = dirty_i->dirty_segmap[PRE];\n\tunsigned int start = 0, end = -1;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\twhile (1) {\n\t\tint i;\n\t\tstart = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + 1);\n\t\tif (start >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\tend = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi),\n\t\t\t\t\t\t\t\tstart + 1);\n\n\t\tfor (i = start; i < end; i++)\n\t\t\tclear_bit(i, prefree_map);\n\n\t\tdirty_i->nr_dirty[PRE] -= end - start;\n\n\t\tif (!test_opt(sbi, DISCARD))\n\t\t\tcontinue;\n\n\t\tf2fs_issue_discard(sbi, START_BLOCK(sbi, start),\n\t\t\t\t(end - start) << sbi->log_blocks_per_seg);\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t/* send small discards */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tf2fs_issue_discard(sbi, entry->blkaddr, entry->len);\n\t\tlist_del(&entry->list);\n\t\tSM_I(sbi)->nr_discards -= entry->len;\n\t\tkmem_cache_free(discard_entry_slab, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_cp_error",
          "args": [
            "sbi"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_cp_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1310-1313",
          "snippet": "static inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_dirty_inode",
          "args": [
            "sbi"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "release_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "399-416",
          "snippet": "void release_dirty_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct ino_entry *e, *tmp;\n\tint i;\n\n\tfor (i = APPEND_INO; i <= UPDATE_INO; i++) {\n\t\tstruct inode_management *im = &sbi->im[i];\n\n\t\tspin_lock(&im->ino_lock);\n\t\tlist_for_each_entry_safe(e, tmp, &im->ino_list, list) {\n\t\t\tlist_del(&e->list);\n\t\t\tradix_tree_delete(&im->ino_root, e->ino);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tim->ino_num--;\n\t\t}\n\t\tspin_unlock(&im->ino_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ino_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\n\nvoid release_dirty_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct ino_entry *e, *tmp;\n\tint i;\n\n\tfor (i = APPEND_INO; i <= UPDATE_INO; i++) {\n\t\tstruct inode_management *im = &sbi->im[i];\n\n\t\tspin_lock(&im->ino_lock);\n\t\tlist_for_each_entry_safe(e, tmp, &im->ino_list, list) {\n\t\t\tlist_del(&e->list);\n\t\t\tradix_tree_delete(&im->ino_root, e->ino);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tim->ino_num--;\n\t\t}\n\t\tspin_unlock(&im->ino_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_all_pages_writeback",
          "args": [
            "sbi"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_all_pages_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "859-872",
          "snippet": "static void wait_on_all_pages_writeback(struct f2fs_sb_info *sbi)\n{\n\tDEFINE_WAIT(wait);\n\n\tfor (;;) {\n\t\tprepare_to_wait(&sbi->cp_wait, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\tif (!get_pages(sbi, F2FS_WRITEBACK))\n\t\t\tbreak;\n\n\t\tio_schedule();\n\t}\n\tfinish_wait(&sbi->cp_wait, &wait);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic void wait_on_all_pages_writeback(struct f2fs_sb_info *sbi)\n{\n\tDEFINE_WAIT(wait);\n\n\tfor (;;) {\n\t\tprepare_to_wait(&sbi->cp_wait, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\tif (!get_pages(sbi, F2FS_WRITEBACK))\n\t\t\tbreak;\n\n\t\tio_schedule();\n\t}\n\tfinish_wait(&sbi->cp_wait, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_meta_pages",
          "args": [
            "sbi",
            "META_FLUSH",
            "LONG_MAX"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "sync_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "240-295",
          "snippet": "long sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,\n\t\t\t\t\t\tlong nr_to_write)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tpgoff_t index = 0, end = LONG_MAX;\n\tstruct pagevec pvec;\n\tlong nwritten = 0;\n\tstruct writeback_control wbc = {\n\t\t.for_reclaim = 0,\n\t};\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (unlikely(nr_pages == 0))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (f2fs_write_meta_page(page, &wbc)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnwritten++;\n\t\t\tif (unlikely(nwritten >= nr_to_write))\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (nwritten)\n\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\n\treturn nwritten;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nlong sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,\n\t\t\t\t\t\tlong nr_to_write)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tpgoff_t index = 0, end = LONG_MAX;\n\tstruct pagevec pvec;\n\tlong nwritten = 0;\n\tstruct writeback_control wbc = {\n\t\t.for_reclaim = 0,\n\t};\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (unlikely(nr_pages == 0))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (f2fs_write_meta_page(page, &wbc)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnwritten++;\n\t\t\tif (unlikely(nwritten >= nr_to_write))\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (nwritten)\n\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\n\treturn nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait_range",
          "args": [
            "META_MAPPING(sbi)",
            "0",
            "LONG_MAX"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "META_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "META_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "705-708",
          "snippet": "static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait_range",
          "args": [
            "NODE_MAPPING(sbi)",
            "0",
            "LONG_MAX"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "cp_page",
            "1"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "cp_page"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "ckpt",
            "F2FS_BLKSIZE"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "cp_page"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_meta_page",
          "args": [
            "sbi",
            "start_blk"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "grab_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "32-45",
          "snippet": "struct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_node_summaries",
          "args": [
            "sbi",
            "start_blk"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "write_node_summaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1573-1576",
          "snippet": "void write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\twrite_normal_summaries(sbi, start_blk, CURSEG_HOT_NODE);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\twrite_normal_summaries(sbi, start_blk, CURSEG_HOT_NODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remain_node_summaries",
          "args": [
            "cpc->reason"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "__remain_node_summaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "786-789",
          "snippet": "static inline bool __remain_node_summaries(int reason)\n{\n\treturn (reason == CP_UMOUNT || reason == CP_FASTBOOT);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool __remain_node_summaries(int reason)\n{\n\treturn (reason == CP_UMOUNT || reason == CP_FASTBOOT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_data_summaries",
          "args": [
            "sbi",
            "start_blk"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "write_data_summaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1565-1571",
          "snippet": "void write_data_summaries(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\tif (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG))\n\t\twrite_compacted_summaries(sbi, start_blk);\n\telse\n\t\twrite_normal_summaries(sbi, start_blk, CURSEG_HOT_DATA);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid write_data_summaries(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\tif (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG))\n\t\twrite_compacted_summaries(sbi, start_blk);\n\telse\n\t\twrite_normal_summaries(sbi, start_blk, CURSEG_HOT_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_orphan_inodes",
          "args": [
            "sbi",
            "start_blk"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "write_orphan_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "497-556",
          "snippet": "static void write_orphan_inodes(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\tstruct list_head *head;\n\tstruct f2fs_orphan_block *orphan_blk = NULL;\n\tunsigned int nentries = 0;\n\tunsigned short index;\n\tunsigned short orphan_blocks;\n\tstruct page *page = NULL;\n\tstruct ino_entry *orphan = NULL;\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\torphan_blocks = GET_ORPHAN_BLOCKS(im->ino_num);\n\n\tfor (index = 0; index < orphan_blocks; index++)\n\t\tgrab_meta_page(sbi, start_blk + index);\n\n\tindex = 1;\n\tspin_lock(&im->ino_lock);\n\thead = &im->ino_list;\n\n\t/* loop for each orphan inode entry and write them in Jornal block */\n\tlist_for_each_entry(orphan, head, list) {\n\t\tif (!page) {\n\t\t\tpage = find_get_page(META_MAPPING(sbi), start_blk++);\n\t\t\tf2fs_bug_on(sbi, !page);\n\t\t\torphan_blk =\n\t\t\t\t(struct f2fs_orphan_block *)page_address(page);\n\t\t\tmemset(orphan_blk, 0, sizeof(*orphan_blk));\n\t\t\tf2fs_put_page(page, 0);\n\t\t}\n\n\t\torphan_blk->ino[nentries++] = cpu_to_le32(orphan->ino);\n\n\t\tif (nentries == F2FS_ORPHANS_PER_BLOCK) {\n\t\t\t/*\n\t\t\t * an orphan block is full of 1020 entries,\n\t\t\t * then we need to flush current orphan blocks\n\t\t\t * and bring another one in memory\n\t\t\t */\n\t\t\torphan_blk->blk_addr = cpu_to_le16(index);\n\t\t\torphan_blk->blk_count = cpu_to_le16(orphan_blocks);\n\t\t\torphan_blk->entry_count = cpu_to_le32(nentries);\n\t\t\tset_page_dirty(page);\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tindex++;\n\t\t\tnentries = 0;\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\torphan_blk->blk_addr = cpu_to_le16(index);\n\t\torphan_blk->blk_count = cpu_to_le16(orphan_blocks);\n\t\torphan_blk->entry_count = cpu_to_le32(nentries);\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\tspin_unlock(&im->ino_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic void write_orphan_inodes(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\tstruct list_head *head;\n\tstruct f2fs_orphan_block *orphan_blk = NULL;\n\tunsigned int nentries = 0;\n\tunsigned short index;\n\tunsigned short orphan_blocks;\n\tstruct page *page = NULL;\n\tstruct ino_entry *orphan = NULL;\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\torphan_blocks = GET_ORPHAN_BLOCKS(im->ino_num);\n\n\tfor (index = 0; index < orphan_blocks; index++)\n\t\tgrab_meta_page(sbi, start_blk + index);\n\n\tindex = 1;\n\tspin_lock(&im->ino_lock);\n\thead = &im->ino_list;\n\n\t/* loop for each orphan inode entry and write them in Jornal block */\n\tlist_for_each_entry(orphan, head, list) {\n\t\tif (!page) {\n\t\t\tpage = find_get_page(META_MAPPING(sbi), start_blk++);\n\t\t\tf2fs_bug_on(sbi, !page);\n\t\t\torphan_blk =\n\t\t\t\t(struct f2fs_orphan_block *)page_address(page);\n\t\t\tmemset(orphan_blk, 0, sizeof(*orphan_blk));\n\t\t\tf2fs_put_page(page, 0);\n\t\t}\n\n\t\torphan_blk->ino[nentries++] = cpu_to_le32(orphan->ino);\n\n\t\tif (nentries == F2FS_ORPHANS_PER_BLOCK) {\n\t\t\t/*\n\t\t\t * an orphan block is full of 1020 entries,\n\t\t\t * then we need to flush current orphan blocks\n\t\t\t * and bring another one in memory\n\t\t\t */\n\t\t\torphan_blk->blk_addr = cpu_to_le16(index);\n\t\t\torphan_blk->blk_count = cpu_to_le16(orphan_blocks);\n\t\t\torphan_blk->entry_count = cpu_to_le32(nentries);\n\t\t\tset_page_dirty(page);\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tindex++;\n\t\t\tnentries = 0;\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\torphan_blk->blk_addr = cpu_to_le16(index);\n\t\torphan_blk->blk_count = cpu_to_le16(orphan_blocks);\n\t\torphan_blk->entry_count = cpu_to_le32(nentries);\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\tspin_unlock(&im->ino_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "(char *)ckpt + i * F2FS_BLKSIZE",
            "F2FS_BLKSIZE"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "cp_page"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "ckpt",
            "F2FS_BLKSIZE"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "cp_page"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__start_cp_addr",
          "args": [
            "sbi"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "__start_cp_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "940-956",
          "snippet": "static inline block_t __start_cp_addr(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_addr;\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_version = cur_cp_version(ckpt);\n\n\tstart_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_blkaddr);\n\n\t/*\n\t * odd numbered checkpoint should at cp segment 0\n\t * and even segment must be at cp segment 1\n\t */\n\tif (!(ckpt_version & 1))\n\t\tstart_addr += sbi->blocks_per_seg;\n\n\treturn start_addr;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline block_t __start_cp_addr(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_addr;\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_version = cur_cp_version(ckpt);\n\n\tstart_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_blkaddr);\n\n\t/*\n\t * odd numbered checkpoint should at cp segment 0\n\t * and even segment must be at cp segment 1\n\t */\n\tif (!(ckpt_version & 1))\n\t\tstart_addr += sbi->blocks_per_seg;\n\n\treturn start_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "crc32"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ckpt->checksum_offset"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_crc32",
          "args": [
            "ckpt",
            "le32_to_cpu(ckpt->checksum_offset)"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "74-86",
          "snippet": "static inline __u32 f2fs_crc32(void *buf, size_t len)\n{\n\tunsigned char *p = (unsigned char *)buf;\n\t__u32 crc = F2FS_SUPER_MAGIC;\n\tint i;\n\n\twhile (len--) {\n\t\tcrc ^= *p++;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tcrc = (crc >> 1) ^ ((crc & 1) ? CRCPOLY_LE : 0);\n\t}\n\treturn crc;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define CRCPOLY_LE 0xedb88320"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\n#define CRCPOLY_LE 0xedb88320\n\nstatic inline __u32 f2fs_crc32(void *buf, size_t len)\n{\n\tunsigned char *p = (unsigned char *)buf;\n\t__u32 crc = F2FS_SUPER_MAGIC;\n\tint i;\n\n\twhile (len--) {\n\t\tcrc ^= *p++;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tcrc = (crc >> 1) ^ ((crc & 1) ? CRCPOLY_LE : 0);\n\t}\n\treturn crc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nat_bitmap",
          "args": [
            "sbi",
            "__bitmap_ptr(sbi, NAT_BITMAP)"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "get_nat_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "165-169",
          "snippet": "static inline void get_nat_bitmap(struct f2fs_sb_info *sbi, void *addr)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tmemcpy(addr, nm_i->nat_bitmap, nm_i->bitmap_size);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void get_nat_bitmap(struct f2fs_sb_info *sbi, void *addr)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tmemcpy(addr, nm_i->nat_bitmap, nm_i->bitmap_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bitmap_ptr",
          "args": [
            "sbi",
            "NAT_BITMAP"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "__bitmap_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "923-938",
          "snippet": "static inline void *__bitmap_ptr(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tint offset;\n\n\tif (le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload) > 0) {\n\t\tif (flag == NAT_BITMAP)\n\t\t\treturn &ckpt->sit_nat_version_bitmap;\n\t\telse\n\t\t\treturn (unsigned char *)ckpt + F2FS_BLKSIZE;\n\t} else {\n\t\toffset = (flag == NAT_BITMAP) ?\n\t\t\tle32_to_cpu(ckpt->sit_ver_bitmap_bytesize) : 0;\n\t\treturn &ckpt->sit_nat_version_bitmap + offset;\n\t}\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *__bitmap_ptr(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tint offset;\n\n\tif (le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload) > 0) {\n\t\tif (flag == NAT_BITMAP)\n\t\t\treturn &ckpt->sit_nat_version_bitmap;\n\t\telse\n\t\t\treturn (unsigned char *)ckpt + F2FS_BLKSIZE;\n\t} else {\n\t\toffset = (flag == NAT_BITMAP) ?\n\t\t\tle32_to_cpu(ckpt->sit_ver_bitmap_bytesize) : 0;\n\t\treturn &ckpt->sit_nat_version_bitmap + offset;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_sit_bitmap",
          "args": [
            "sbi",
            "__bitmap_ptr(sbi, SIT_BITMAP)"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "get_sit_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "394-399",
          "snippet": "static inline void get_sit_bitmap(struct f2fs_sb_info *sbi,\n\t\tvoid *dst_addr)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tmemcpy(dst_addr, sit_i->sit_bitmap, sit_i->bitmap_size);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void get_sit_bitmap(struct f2fs_sb_info *sbi,\n\t\tvoid *dst_addr)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tmemcpy(dst_addr, sit_i->sit_bitmap, sit_i->bitmap_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ckpt_flags",
          "args": [
            "ckpt",
            "CP_FSCK_FLAG"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "set_ckpt_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "741-746",
          "snippet": "static inline void set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\tckpt_flags |= f;\n\tcp->ckpt_flags = cpu_to_le32(ckpt_flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\tckpt_flags |= f;\n\tcp->ckpt_flags = cpu_to_le32(ckpt_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sbi_flag_set",
          "args": [
            "sbi",
            "SBI_NEED_FSCK"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "is_sbi_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "715-718",
          "snippet": "static inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn sbi->s_flag & (0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn sbi->s_flag & (0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_ckpt_flags",
          "args": [
            "ckpt",
            "CP_ORPHAN_PRESENT_FLAG"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "clear_ckpt_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "748-753",
          "snippet": "static inline void clear_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\tckpt_flags &= (~f);\n\tcp->ckpt_flags = cpu_to_le32(ckpt_flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\tckpt_flags &= (~f);\n\tcp->ckpt_flags = cpu_to_le32(ckpt_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "F2FS_CP_PACKS +\n\t\t\t\tcp_payload_blks + data_sum_blocks +\n\t\t\t\torphan_blocks"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "F2FS_CP_PACKS+\n\t\t\t\tcp_payload_blks + data_sum_blocks +\n\t\t\t\torphan_blocks + NR_CURSEG_NODE_TYPE"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1 + cp_payload_blks +\n\t\t\torphan_blocks"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_ORPHAN_BLOCKS",
          "args": [
            "orphan_num"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "npages_for_summary_flush",
          "args": [
            "sbi",
            "false"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "npages_for_summary_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "730-755",
          "snippet": "int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra)\n{\n\tint valid_sum_count = 0;\n\tint i, sum_in_page;\n\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tif (sbi->ckpt->alloc_type[i] == SSR)\n\t\t\tvalid_sum_count += sbi->blocks_per_seg;\n\t\telse {\n\t\t\tif (for_ra)\n\t\t\t\tvalid_sum_count += le16_to_cpu(\n\t\t\t\t\tF2FS_CKPT(sbi)->cur_data_blkoff[i]);\n\t\t\telse\n\t\t\t\tvalid_sum_count += curseg_blkoff(sbi, i);\n\t\t}\n\t}\n\n\tsum_in_page = (PAGE_CACHE_SIZE - 2 * SUM_JOURNAL_SIZE -\n\t\t\tSUM_FOOTER_SIZE) / SUMMARY_SIZE;\n\tif (valid_sum_count <= sum_in_page)\n\t\treturn 1;\n\telse if ((valid_sum_count - sum_in_page) <=\n\t\t(PAGE_CACHE_SIZE - SUM_FOOTER_SIZE) / SUMMARY_SIZE)\n\t\treturn 2;\n\treturn 3;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra)\n{\n\tint valid_sum_count = 0;\n\tint i, sum_in_page;\n\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tif (sbi->ckpt->alloc_type[i] == SSR)\n\t\t\tvalid_sum_count += sbi->blocks_per_seg;\n\t\telse {\n\t\t\tif (for_ra)\n\t\t\t\tvalid_sum_count += le16_to_cpu(\n\t\t\t\t\tF2FS_CKPT(sbi)->cur_data_blkoff[i]);\n\t\t\telse\n\t\t\t\tvalid_sum_count += curseg_blkoff(sbi, i);\n\t\t}\n\t}\n\n\tsum_in_page = (PAGE_CACHE_SIZE - 2 * SUM_JOURNAL_SIZE -\n\t\t\tSUM_FOOTER_SIZE) / SUMMARY_SIZE;\n\tif (valid_sum_count <= sum_in_page)\n\t\treturn 1;\n\telse if ((valid_sum_count - sum_in_page) <=\n\t\t(PAGE_CACHE_SIZE - SUM_FOOTER_SIZE) / SUMMARY_SIZE)\n\t\treturn 2;\n\treturn 3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "last_nid"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "valid_inode_count(sbi)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_inode_count",
          "args": [
            "sbi"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "valid_inode_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1031-1034",
          "snippet": "static inline unsigned int valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_inode_count;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned int valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_inode_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "valid_node_count(sbi)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_node_count",
          "args": [
            "sbi"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "valid_node_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1010-1013",
          "snippet": "static inline unsigned int valid_node_count(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_node_count;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned int valid_node_count(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_node_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "curseg_alloc_type",
          "args": [
            "sbi",
            "i + CURSEG_HOT_DATA"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "curseg_alloc_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "542-547",
          "snippet": "static inline unsigned char curseg_alloc_type(struct f2fs_sb_info *sbi,\n\t\tint type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\treturn curseg->alloc_type;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned char curseg_alloc_type(struct f2fs_sb_info *sbi,\n\t\tint type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\treturn curseg->alloc_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "curseg_blkoff(sbi, i + CURSEG_HOT_DATA)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curseg_blkoff",
          "args": [
            "sbi",
            "i + CURSEG_HOT_DATA"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "curseg_blkoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "549-553",
          "snippet": "static inline unsigned short curseg_blkoff(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\treturn curseg->next_blkoff;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned short curseg_blkoff(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\treturn curseg->next_blkoff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "curseg_segno(sbi, i + CURSEG_HOT_DATA)"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curseg_segno",
          "args": [
            "sbi",
            "i + CURSEG_HOT_DATA"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "curseg_segno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "535-540",
          "snippet": "static inline unsigned int curseg_segno(struct f2fs_sb_info *sbi,\n\t\tint type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\treturn curseg->segno;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int curseg_segno(struct f2fs_sb_info *sbi,\n\t\tint type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\treturn curseg->segno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "curseg_blkoff(sbi, i + CURSEG_HOT_NODE)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "curseg_segno(sbi, i + CURSEG_HOT_NODE)"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "free_segments(sbi)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "valid_user_blocks(sbi)"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_user_blocks",
          "args": [
            "sbi"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "valid_user_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "905-908",
          "snippet": "static inline block_t valid_user_blocks(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_block_count;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline block_t valid_user_blocks(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_block_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "get_mtime(sbi)"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mtime",
          "args": [
            "sbi"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "get_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "664-669",
          "snippet": "static inline unsigned long long get_mtime(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn sit_i->elapsed_time + CURRENT_TIME_SEC.tv_sec -\n\t\t\t\t\t\tsit_i->mounted_time;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned long long get_mtime(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn sit_i->elapsed_time + CURRENT_TIME_SEC.tv_sec -\n\t\t\t\t\t\tsit_i->mounted_time;\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_free_nid",
          "args": [
            "sbi",
            "&last_nid"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "next_free_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "147-160",
          "snippet": "static inline void next_free_nid(struct f2fs_sb_info *sbi, nid_t *nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *fnid;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tif (nm_i->fcnt <= 0) {\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\treturn;\n\t}\n\tfnid = list_entry(nm_i->free_nid_list.next, struct free_nid, list);\n\t*nid = fnid->nid;\n\tspin_unlock(&nm_i->free_nid_list_lock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void next_free_nid(struct f2fs_sb_info *sbi, nid_t *nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *fnid;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tif (nm_i->fcnt <= 0) {\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\treturn;\n\t}\n\tfnid = list_entry(nm_i->free_nid_list.next, struct free_nid, list);\n\t*nid = fnid->nid;\n\tspin_unlock(&nm_i->free_nid_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pages",
          "args": [
            "sbi",
            "F2FS_DIRTY_META"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "887-890",
          "snippet": "static inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "discard_next_dnode",
          "args": [
            "sbi",
            "NEXT_FREE_BLKADDR(sbi, curseg)"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "discard_next_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "466-474",
          "snippet": "void discard_next_dnode(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tif (f2fs_issue_discard(sbi, blkaddr, 1)) {\n\t\tstruct page *page = grab_meta_page(sbi, blkaddr);\n\t\t/* zero-filled page */\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid discard_next_dnode(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tif (f2fs_issue_discard(sbi, blkaddr, 1)) {\n\t\tstruct page *page = grab_meta_page(sbi, blkaddr);\n\t\t/* zero-filled page */\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_FREE_BLKADDR",
          "args": [
            "sbi",
            "curseg"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_RAW_SUPER",
          "args": [
            "sbi"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_RAW_SUPER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "660-663",
          "snippet": "static inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "CURSEG_WARM_NODE"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic void do_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_WARM_NODE);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned long orphan_num = sbi->im[ORPHAN_INO].ino_num;\n\tnid_t last_nid = nm_i->next_scan_nid;\n\tblock_t start_blk;\n\tstruct page *cp_page;\n\tunsigned int data_sum_blocks, orphan_blocks;\n\t__u32 crc32 = 0;\n\tvoid *kaddr;\n\tint i;\n\tint cp_payload_blks = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n\n\t/*\n\t * This avoids to conduct wrong roll-forward operations and uses\n\t * metapages, so should be called prior to sync_meta_pages below.\n\t */\n\tdiscard_next_dnode(sbi, NEXT_FREE_BLKADDR(sbi, curseg));\n\n\t/* Flush all the NAT/SIT pages */\n\twhile (get_pages(sbi, F2FS_DIRTY_META)) {\n\t\tsync_meta_pages(sbi, META, LONG_MAX);\n\t\tif (unlikely(f2fs_cp_error(sbi)))\n\t\t\treturn;\n\t}\n\n\tnext_free_nid(sbi, &last_nid);\n\n\t/*\n\t * modify checkpoint\n\t * version number is already updated\n\t */\n\tckpt->elapsed_time = cpu_to_le64(get_mtime(sbi));\n\tckpt->valid_block_count = cpu_to_le64(valid_user_blocks(sbi));\n\tckpt->free_segment_count = cpu_to_le32(free_segments(sbi));\n\tfor (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {\n\t\tckpt->cur_node_segno[i] =\n\t\t\tcpu_to_le32(curseg_segno(sbi, i + CURSEG_HOT_NODE));\n\t\tckpt->cur_node_blkoff[i] =\n\t\t\tcpu_to_le16(curseg_blkoff(sbi, i + CURSEG_HOT_NODE));\n\t\tckpt->alloc_type[i + CURSEG_HOT_NODE] =\n\t\t\t\tcurseg_alloc_type(sbi, i + CURSEG_HOT_NODE);\n\t}\n\tfor (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {\n\t\tckpt->cur_data_segno[i] =\n\t\t\tcpu_to_le32(curseg_segno(sbi, i + CURSEG_HOT_DATA));\n\t\tckpt->cur_data_blkoff[i] =\n\t\t\tcpu_to_le16(curseg_blkoff(sbi, i + CURSEG_HOT_DATA));\n\t\tckpt->alloc_type[i + CURSEG_HOT_DATA] =\n\t\t\t\tcurseg_alloc_type(sbi, i + CURSEG_HOT_DATA);\n\t}\n\n\tckpt->valid_node_count = cpu_to_le32(valid_node_count(sbi));\n\tckpt->valid_inode_count = cpu_to_le32(valid_inode_count(sbi));\n\tckpt->next_free_nid = cpu_to_le32(last_nid);\n\n\t/* 2 cp  + n data seg summary + orphan inode blocks */\n\tdata_sum_blocks = npages_for_summary_flush(sbi, false);\n\tif (data_sum_blocks < NR_CURSEG_DATA_TYPE)\n\t\tset_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);\n\n\torphan_blocks = GET_ORPHAN_BLOCKS(orphan_num);\n\tckpt->cp_pack_start_sum = cpu_to_le32(1 + cp_payload_blks +\n\t\t\torphan_blocks);\n\n\tif (__remain_node_summaries(cpc->reason))\n\t\tckpt->cp_pack_total_block_count = cpu_to_le32(F2FS_CP_PACKS+\n\t\t\t\tcp_payload_blks + data_sum_blocks +\n\t\t\t\torphan_blocks + NR_CURSEG_NODE_TYPE);\n\telse\n\t\tckpt->cp_pack_total_block_count = cpu_to_le32(F2FS_CP_PACKS +\n\t\t\t\tcp_payload_blks + data_sum_blocks +\n\t\t\t\torphan_blocks);\n\n\tif (cpc->reason == CP_UMOUNT)\n\t\tset_ckpt_flags(ckpt, CP_UMOUNT_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_UMOUNT_FLAG);\n\n\tif (cpc->reason == CP_FASTBOOT)\n\t\tset_ckpt_flags(ckpt, CP_FASTBOOT_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_FASTBOOT_FLAG);\n\n\tif (orphan_num)\n\t\tset_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);\n\telse\n\t\tclear_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);\n\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK))\n\t\tset_ckpt_flags(ckpt, CP_FSCK_FLAG);\n\n\t/* update SIT/NAT bitmap */\n\tget_sit_bitmap(sbi, __bitmap_ptr(sbi, SIT_BITMAP));\n\tget_nat_bitmap(sbi, __bitmap_ptr(sbi, NAT_BITMAP));\n\n\tcrc32 = f2fs_crc32(ckpt, le32_to_cpu(ckpt->checksum_offset));\n\t*((__le32 *)((unsigned char *)ckpt +\n\t\t\t\tle32_to_cpu(ckpt->checksum_offset)))\n\t\t\t\t= cpu_to_le32(crc32);\n\n\tstart_blk = __start_cp_addr(sbi);\n\n\t/* write out checkpoint buffer at block 0 */\n\tcp_page = grab_meta_page(sbi, start_blk++);\n\tkaddr = page_address(cp_page);\n\tmemcpy(kaddr, ckpt, F2FS_BLKSIZE);\n\tset_page_dirty(cp_page);\n\tf2fs_put_page(cp_page, 1);\n\n\tfor (i = 1; i < 1 + cp_payload_blks; i++) {\n\t\tcp_page = grab_meta_page(sbi, start_blk++);\n\t\tkaddr = page_address(cp_page);\n\t\tmemcpy(kaddr, (char *)ckpt + i * F2FS_BLKSIZE, F2FS_BLKSIZE);\n\t\tset_page_dirty(cp_page);\n\t\tf2fs_put_page(cp_page, 1);\n\t}\n\n\tif (orphan_num) {\n\t\twrite_orphan_inodes(sbi, start_blk);\n\t\tstart_blk += orphan_blocks;\n\t}\n\n\twrite_data_summaries(sbi, start_blk);\n\tstart_blk += data_sum_blocks;\n\tif (__remain_node_summaries(cpc->reason)) {\n\t\twrite_node_summaries(sbi, start_blk);\n\t\tstart_blk += NR_CURSEG_NODE_TYPE;\n\t}\n\n\t/* writeout checkpoint block */\n\tcp_page = grab_meta_page(sbi, start_blk);\n\tkaddr = page_address(cp_page);\n\tmemcpy(kaddr, ckpt, F2FS_BLKSIZE);\n\tset_page_dirty(cp_page);\n\tf2fs_put_page(cp_page, 1);\n\n\t/* wait for previous submitted node/meta pages writeback */\n\twait_on_all_pages_writeback(sbi);\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tfilemap_fdatawait_range(NODE_MAPPING(sbi), 0, LONG_MAX);\n\tfilemap_fdatawait_range(META_MAPPING(sbi), 0, LONG_MAX);\n\n\t/* update user_block_counts */\n\tsbi->last_valid_block_count = sbi->total_valid_block_count;\n\tsbi->alloc_valid_block_count = 0;\n\n\t/* Here, we only have one bio having CP pack */\n\tsync_meta_pages(sbi, META_FLUSH, LONG_MAX);\n\n\t/* wait for previous submitted meta pages writeback */\n\twait_on_all_pages_writeback(sbi);\n\n\trelease_dirty_inode(sbi);\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tclear_prefree_segments(sbi);\n\tclear_sbi_flag(sbi, SBI_IS_DIRTY);\n}"
  },
  {
    "function_name": "wait_on_all_pages_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "859-872",
    "snippet": "static void wait_on_all_pages_writeback(struct f2fs_sb_info *sbi)\n{\n\tDEFINE_WAIT(wait);\n\n\tfor (;;) {\n\t\tprepare_to_wait(&sbi->cp_wait, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\tif (!get_pages(sbi, F2FS_WRITEBACK))\n\t\t\tbreak;\n\n\t\tio_schedule();\n\t}\n\tfinish_wait(&sbi->cp_wait, &wait);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&sbi->cp_wait",
            "&wait"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pages",
          "args": [
            "sbi",
            "F2FS_WRITEBACK"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "887-890",
          "snippet": "static inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&sbi->cp_wait",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic void wait_on_all_pages_writeback(struct f2fs_sb_info *sbi)\n{\n\tDEFINE_WAIT(wait);\n\n\tfor (;;) {\n\t\tprepare_to_wait(&sbi->cp_wait, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\tif (!get_pages(sbi, F2FS_WRITEBACK))\n\t\t\tbreak;\n\n\t\tio_schedule();\n\t}\n\tfinish_wait(&sbi->cp_wait, &wait);\n}"
  },
  {
    "function_name": "unblock_operations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "853-857",
    "snippet": "static void unblock_operations(struct f2fs_sb_info *sbi)\n{\n\tup_write(&sbi->node_write);\n\tf2fs_unlock_all(sbi);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_unlock_all",
          "args": [
            "sbi"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "770-773",
          "snippet": "static inline void f2fs_unlock_all(struct f2fs_sb_info *sbi)\n{\n\tup_write(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_all(struct f2fs_sb_info *sbi)\n{\n\tup_write(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sbi->node_write"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic void unblock_operations(struct f2fs_sb_info *sbi)\n{\n\tup_write(&sbi->node_write);\n\tf2fs_unlock_all(sbi);\n}"
  },
  {
    "function_name": "block_operations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "806-851",
    "snippet": "static int block_operations(struct f2fs_sb_info *sbi)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.for_reclaim = 0,\n\t};\n\tstruct blk_plug plug;\n\tint err = 0;\n\n\tblk_start_plug(&plug);\n\nretry_flush_dents:\n\tf2fs_lock_all(sbi);\n\t/* write all the dirty dentry pages */\n\tif (get_pages(sbi, F2FS_DIRTY_DENTS)) {\n\t\tf2fs_unlock_all(sbi);\n\t\tsync_dirty_dir_inodes(sbi);\n\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto retry_flush_dents;\n\t}\n\n\t/*\n\t * POR: we should ensure that there are no dirty node pages\n\t * until finishing nat/sit flush.\n\t */\nretry_flush_nodes:\n\tdown_write(&sbi->node_write);\n\n\tif (get_pages(sbi, F2FS_DIRTY_NODES)) {\n\t\tup_write(&sbi->node_write);\n\t\tsync_node_pages(sbi, 0, &wbc);\n\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\tf2fs_unlock_all(sbi);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto retry_flush_nodes;\n\t}\nout:\n\tblk_finish_plug(&plug);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_all",
          "args": [
            "sbi"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "770-773",
          "snippet": "static inline void f2fs_unlock_all(struct f2fs_sb_info *sbi)\n{\n\tup_write(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_all(struct f2fs_sb_info *sbi)\n{\n\tup_write(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_cp_error",
          "args": [
            "sbi"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_cp_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1310-1313",
          "snippet": "static inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_node_pages",
          "args": [
            "sbi",
            "0",
            "&wbc"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "sync_node_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1131-1237",
          "snippet": "int sync_node_pages(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint step = ino ? 2 : 0;\n\tint nwritten = 0, wrote = 0;\n\n\tpagevec_init(&pvec, 0);\n\nnext_step:\n\tindex = 0;\n\tend = LONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * flushing sequence with step:\n\t\t\t * 0. indirect nodes\n\t\t\t * 1. dentry dnodes\n\t\t\t * 2. file dnodes\n\t\t\t */\n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If an fsync mode,\n\t\t\t * we should not skip writing node pages.\n\t\t\t */\n\t\t\tif (ino && ino_of_node(page) == ino)\n\t\t\t\tlock_page(page);\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino && ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\t/* called by fsync() */\n\t\t\tif (ino && IS_DNODE(page)) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (!is_checkpointed_node(sbi, ino) &&\n\t\t\t\t\t\t!has_fsynced_inode(sbi, ino))\n\t\t\t\t\t\tset_dentry_mark(page, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t\t}\n\t\t\t\tnwritten++;\n\t\t\t} else {\n\t\t\t\tset_fsync_mark(page, 0);\n\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t}\n\n\t\t\tif (NODE_MAPPING(sbi)->a_ops->writepage(page, wbc))\n\t\t\t\tunlock_page(page);\n\t\t\telse\n\t\t\t\twrote++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tstep++;\n\t\tgoto next_step;\n\t}\n\n\tif (wrote)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\treturn nwritten;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint sync_node_pages(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint step = ino ? 2 : 0;\n\tint nwritten = 0, wrote = 0;\n\n\tpagevec_init(&pvec, 0);\n\nnext_step:\n\tindex = 0;\n\tend = LONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * flushing sequence with step:\n\t\t\t * 0. indirect nodes\n\t\t\t * 1. dentry dnodes\n\t\t\t * 2. file dnodes\n\t\t\t */\n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If an fsync mode,\n\t\t\t * we should not skip writing node pages.\n\t\t\t */\n\t\t\tif (ino && ino_of_node(page) == ino)\n\t\t\t\tlock_page(page);\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino && ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\t/* called by fsync() */\n\t\t\tif (ino && IS_DNODE(page)) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (!is_checkpointed_node(sbi, ino) &&\n\t\t\t\t\t\t!has_fsynced_inode(sbi, ino))\n\t\t\t\t\t\tset_dentry_mark(page, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t\t}\n\t\t\t\tnwritten++;\n\t\t\t} else {\n\t\t\t\tset_fsync_mark(page, 0);\n\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t}\n\n\t\t\tif (NODE_MAPPING(sbi)->a_ops->writepage(page, wbc))\n\t\t\t\tunlock_page(page);\n\t\t\telse\n\t\t\t\twrote++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tstep++;\n\t\tgoto next_step;\n\t}\n\n\tif (wrote)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\treturn nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sbi->node_write"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pages",
          "args": [
            "sbi",
            "F2FS_DIRTY_NODES"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "887-890",
          "snippet": "static inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sbi->node_write"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_dir_inodes",
          "args": [
            "sbi"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_dir_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "771-801",
          "snippet": "void sync_dirty_dir_inodes(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head;\n\tstruct inode_entry *entry;\n\tstruct inode *inode;\nretry:\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tspin_lock(&sbi->dir_inode_lock);\n\n\thead = &sbi->dir_inode_list;\n\tif (list_empty(head)) {\n\t\tspin_unlock(&sbi->dir_inode_lock);\n\t\treturn;\n\t}\n\tentry = list_entry(head->next, struct inode_entry, list);\n\tinode = igrab(entry->inode);\n\tspin_unlock(&sbi->dir_inode_lock);\n\tif (inode) {\n\t\tfilemap_fdatawrite(inode->i_mapping);\n\t\tiput(inode);\n\t} else {\n\t\t/*\n\t\t * We should submit bio, since it exists several\n\t\t * wribacking dentry pages in the freeing inode.\n\t\t */\n\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n\tgoto retry;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid sync_dirty_dir_inodes(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head;\n\tstruct inode_entry *entry;\n\tstruct inode *inode;\nretry:\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tspin_lock(&sbi->dir_inode_lock);\n\n\thead = &sbi->dir_inode_list;\n\tif (list_empty(head)) {\n\t\tspin_unlock(&sbi->dir_inode_lock);\n\t\treturn;\n\t}\n\tentry = list_entry(head->next, struct inode_entry, list);\n\tinode = igrab(entry->inode);\n\tspin_unlock(&sbi->dir_inode_lock);\n\tif (inode) {\n\t\tfilemap_fdatawrite(inode->i_mapping);\n\t\tiput(inode);\n\t} else {\n\t\t/*\n\t\t * We should submit bio, since it exists several\n\t\t * wribacking dentry pages in the freeing inode.\n\t\t */\n\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n\tgoto retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_all",
          "args": [
            "sbi"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "765-768",
          "snippet": "static inline void f2fs_lock_all(struct f2fs_sb_info *sbi)\n{\n\tf2fs_down_write(&sbi->cp_rwsem, &sbi->cp_mutex);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_all(struct f2fs_sb_info *sbi)\n{\n\tf2fs_down_write(&sbi->cp_rwsem, &sbi->cp_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic int block_operations(struct f2fs_sb_info *sbi)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.for_reclaim = 0,\n\t};\n\tstruct blk_plug plug;\n\tint err = 0;\n\n\tblk_start_plug(&plug);\n\nretry_flush_dents:\n\tf2fs_lock_all(sbi);\n\t/* write all the dirty dentry pages */\n\tif (get_pages(sbi, F2FS_DIRTY_DENTS)) {\n\t\tf2fs_unlock_all(sbi);\n\t\tsync_dirty_dir_inodes(sbi);\n\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto retry_flush_dents;\n\t}\n\n\t/*\n\t * POR: we should ensure that there are no dirty node pages\n\t * until finishing nat/sit flush.\n\t */\nretry_flush_nodes:\n\tdown_write(&sbi->node_write);\n\n\tif (get_pages(sbi, F2FS_DIRTY_NODES)) {\n\t\tup_write(&sbi->node_write);\n\t\tsync_node_pages(sbi, 0, &wbc);\n\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\tf2fs_unlock_all(sbi);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto retry_flush_nodes;\n\t}\nout:\n\tblk_finish_plug(&plug);\n\treturn err;\n}"
  },
  {
    "function_name": "sync_dirty_dir_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "771-801",
    "snippet": "void sync_dirty_dir_inodes(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head;\n\tstruct inode_entry *entry;\n\tstruct inode *inode;\nretry:\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tspin_lock(&sbi->dir_inode_lock);\n\n\thead = &sbi->dir_inode_list;\n\tif (list_empty(head)) {\n\t\tspin_unlock(&sbi->dir_inode_lock);\n\t\treturn;\n\t}\n\tentry = list_entry(head->next, struct inode_entry, list);\n\tinode = igrab(entry->inode);\n\tspin_unlock(&sbi->dir_inode_lock);\n\tif (inode) {\n\t\tfilemap_fdatawrite(inode->i_mapping);\n\t\tiput(inode);\n\t} else {\n\t\t/*\n\t\t * We should submit bio, since it exists several\n\t\t * wribacking dentry pages in the freeing inode.\n\t\t */\n\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n\tgoto retry;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_submit_merged_bio",
          "args": [
            "sbi",
            "DATA",
            "WRITE"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "107-127",
          "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "inode->i_mapping"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->dir_inode_lock"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "entry->inode"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->next",
            "structinode_entry",
            "list"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->dir_inode_lock"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_cp_error",
          "args": [
            "sbi"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_cp_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1310-1313",
          "snippet": "static inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid sync_dirty_dir_inodes(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head;\n\tstruct inode_entry *entry;\n\tstruct inode *inode;\nretry:\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tspin_lock(&sbi->dir_inode_lock);\n\n\thead = &sbi->dir_inode_list;\n\tif (list_empty(head)) {\n\t\tspin_unlock(&sbi->dir_inode_lock);\n\t\treturn;\n\t}\n\tentry = list_entry(head->next, struct inode_entry, list);\n\tinode = igrab(entry->inode);\n\tspin_unlock(&sbi->dir_inode_lock);\n\tif (inode) {\n\t\tfilemap_fdatawrite(inode->i_mapping);\n\t\tiput(inode);\n\t} else {\n\t\t/*\n\t\t * We should submit bio, since it exists several\n\t\t * wribacking dentry pages in the freeing inode.\n\t\t */\n\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n\tgoto retry;\n}"
  },
  {
    "function_name": "remove_dirty_dir_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "741-769",
    "snippet": "void remove_dirty_dir_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *entry;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tif (get_dirty_pages(inode) ||\n\t\t\t!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR)) {\n\t\tspin_unlock(&sbi->dir_inode_lock);\n\t\treturn;\n\t}\n\n\tentry = F2FS_I(inode)->dirty_dir;\n\tlist_del(&entry->list);\n\tF2FS_I(inode)->dirty_dir = NULL;\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tstat_dec_dirty_dir(sbi);\n\tspin_unlock(&sbi->dir_inode_lock);\n\tkmem_cache_free(inode_entry_slab, entry);\n\n\t/* Only from the recovery routine */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DELAY_IPUT)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_DELAY_IPUT);\n\t\tiput(inode);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *inode_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_DELAY_IPUT"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "F2FS_I(inode)",
            "FI_DELAY_IPUT"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inode_entry_slab",
            "entry"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->dir_inode_lock"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_dec_dirty_dir",
          "args": [
            "sbi"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dirty_pages",
          "args": [
            "inode"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "get_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "892-895",
          "snippet": "static inline int get_dirty_pages(struct inode *inode)\n{\n\treturn atomic_read(&F2FS_I(inode)->dirty_pages);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_dirty_pages(struct inode *inode)\n{\n\treturn atomic_read(&F2FS_I(inode)->dirty_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->dir_inode_lock"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *inode_entry_slab;\n\nvoid remove_dirty_dir_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *entry;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tif (get_dirty_pages(inode) ||\n\t\t\t!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR)) {\n\t\tspin_unlock(&sbi->dir_inode_lock);\n\t\treturn;\n\t}\n\n\tentry = F2FS_I(inode)->dirty_dir;\n\tlist_del(&entry->list);\n\tF2FS_I(inode)->dirty_dir = NULL;\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tstat_dec_dirty_dir(sbi);\n\tspin_unlock(&sbi->dir_inode_lock);\n\tkmem_cache_free(inode_entry_slab, entry);\n\n\t/* Only from the recovery routine */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DELAY_IPUT)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_DELAY_IPUT);\n\t\tiput(inode);\n\t}\n}"
  },
  {
    "function_name": "add_dirty_dir_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "723-739",
    "snippet": "void add_dirty_dir_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *new =\n\t\t\tf2fs_kmem_cache_alloc(inode_entry_slab, GFP_NOFS);\n\tint ret = 0;\n\n\tnew->inode = inode;\n\tINIT_LIST_HEAD(&new->list);\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tret = __add_dirty_inode(inode, new);\n\tspin_unlock(&sbi->dir_inode_lock);\n\n\tif (ret)\n\t\tkmem_cache_free(inode_entry_slab, new);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *inode_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inode_entry_slab",
            "new"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->dir_inode_lock"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_dirty_inode",
          "args": [
            "inode",
            "new"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "__add_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "679-691",
          "snippet": "static int __add_dirty_inode(struct inode *inode, struct inode_entry *new)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR))\n\t\treturn -EEXIST;\n\n\tset_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tF2FS_I(inode)->dirty_dir = new;\n\tlist_add_tail(&new->list, &sbi->dir_inode_list);\n\tstat_inc_dirty_dir(sbi);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic int __add_dirty_inode(struct inode *inode, struct inode_entry *new)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR))\n\t\treturn -EEXIST;\n\n\tset_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tF2FS_I(inode)->dirty_dir = new;\n\tlist_add_tail(&new->list, &sbi->dir_inode_list);\n\tstat_inc_dirty_dir(sbi);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->dir_inode_lock"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->list"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_alloc",
          "args": [
            "inode_entry_slab",
            "GFP_NOFS"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *inode_entry_slab;\n\nvoid add_dirty_dir_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *new =\n\t\t\tf2fs_kmem_cache_alloc(inode_entry_slab, GFP_NOFS);\n\tint ret = 0;\n\n\tnew->inode = inode;\n\tINIT_LIST_HEAD(&new->list);\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tret = __add_dirty_inode(inode, new);\n\tspin_unlock(&sbi->dir_inode_lock);\n\n\tif (ret)\n\t\tkmem_cache_free(inode_entry_slab, new);\n}"
  },
  {
    "function_name": "update_dirty_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "693-721",
    "snippet": "void update_dirty_page(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *new;\n\tint ret = 0;\n\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tinode_inc_dirty_pages(inode);\n\t\tgoto out;\n\t}\n\n\tnew = f2fs_kmem_cache_alloc(inode_entry_slab, GFP_NOFS);\n\tnew->inode = inode;\n\tINIT_LIST_HEAD(&new->list);\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tret = __add_dirty_inode(inode, new);\n\tinode_inc_dirty_pages(inode);\n\tspin_unlock(&sbi->dir_inode_lock);\n\n\tif (ret)\n\t\tkmem_cache_free(inode_entry_slab, new);\nout:\n\tSetPagePrivate(page);\n\tf2fs_trace_pid(page);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *inode_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_trace_pid",
          "args": [
            "page"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_trace_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/trace.c",
          "lines": "55-81",
          "snippet": "void f2fs_trace_pid(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tpid_t pid = task_pid_nr(current);\n\tvoid *p;\n\n\tpage->private = pid;\n\n\tif (radix_tree_preload(GFP_NOFS))\n\t\treturn;\n\n\tspin_lock(&pids_lock);\n\tp = radix_tree_lookup(&pids, pid);\n\tif (p == current)\n\t\tgoto out;\n\tif (p)\n\t\tradix_tree_delete(&pids, pid);\n\n\tf2fs_radix_tree_insert(&pids, pid, current);\n\n\ttrace_printk(\"%3x:%3x %4x %-16s\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tpid, current->comm);\nout:\n\tspin_unlock(&pids_lock);\n\tradix_tree_preload_end();\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/radix-tree.h>",
            "#include <linux/sched.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t pids_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"f2fs.h\"\n#include <linux/radix-tree.h>\n#include <linux/sched.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic spinlock_t pids_lock;\n\nvoid f2fs_trace_pid(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tpid_t pid = task_pid_nr(current);\n\tvoid *p;\n\n\tpage->private = pid;\n\n\tif (radix_tree_preload(GFP_NOFS))\n\t\treturn;\n\n\tspin_lock(&pids_lock);\n\tp = radix_tree_lookup(&pids, pid);\n\tif (p == current)\n\t\tgoto out;\n\tif (p)\n\t\tradix_tree_delete(&pids, pid);\n\n\tf2fs_radix_tree_insert(&pids, pid, current);\n\n\ttrace_printk(\"%3x:%3x %4x %-16s\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tpid, current->comm);\nout:\n\tspin_unlock(&pids_lock);\n\tradix_tree_preload_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inode_entry_slab",
            "new"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->dir_inode_lock"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_dirty_pages",
          "args": [
            "inode"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "inode_inc_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "864-869",
          "snippet": "static inline void inode_inc_dirty_pages(struct inode *inode)\n{\n\tatomic_inc(&F2FS_I(inode)->dirty_pages);\n\tif (S_ISDIR(inode->i_mode))\n\t\tinc_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inode_inc_dirty_pages(struct inode *inode)\n{\n\tatomic_inc(&F2FS_I(inode)->dirty_pages);\n\tif (S_ISDIR(inode->i_mode))\n\t\tinc_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_dirty_inode",
          "args": [
            "inode",
            "new"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "__add_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "679-691",
          "snippet": "static int __add_dirty_inode(struct inode *inode, struct inode_entry *new)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR))\n\t\treturn -EEXIST;\n\n\tset_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tF2FS_I(inode)->dirty_dir = new;\n\tlist_add_tail(&new->list, &sbi->dir_inode_list);\n\tstat_inc_dirty_dir(sbi);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic int __add_dirty_inode(struct inode *inode, struct inode_entry *new)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR))\n\t\treturn -EEXIST;\n\n\tset_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tF2FS_I(inode)->dirty_dir = new;\n\tlist_add_tail(&new->list, &sbi->dir_inode_list);\n\tstat_inc_dirty_dir(sbi);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->dir_inode_lock"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->list"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_alloc",
          "args": [
            "inode_entry_slab",
            "GFP_NOFS"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *inode_entry_slab;\n\nvoid update_dirty_page(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *new;\n\tint ret = 0;\n\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tinode_inc_dirty_pages(inode);\n\t\tgoto out;\n\t}\n\n\tnew = f2fs_kmem_cache_alloc(inode_entry_slab, GFP_NOFS);\n\tnew->inode = inode;\n\tINIT_LIST_HEAD(&new->list);\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tret = __add_dirty_inode(inode, new);\n\tinode_inc_dirty_pages(inode);\n\tspin_unlock(&sbi->dir_inode_lock);\n\n\tif (ret)\n\t\tkmem_cache_free(inode_entry_slab, new);\nout:\n\tSetPagePrivate(page);\n\tf2fs_trace_pid(page);\n}"
  },
  {
    "function_name": "__add_dirty_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "679-691",
    "snippet": "static int __add_dirty_inode(struct inode *inode, struct inode_entry *new)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR))\n\t\treturn -EEXIST;\n\n\tset_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tF2FS_I(inode)->dirty_dir = new;\n\tlist_add_tail(&new->list, &sbi->dir_inode_list);\n\tstat_inc_dirty_dir(sbi);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat_inc_dirty_dir",
          "args": [
            "sbi"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new->list",
            "&sbi->dir_inode_list"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_DIRTY_DIR"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "F2FS_I(inode)",
            "FI_DIRTY_DIR"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic int __add_dirty_inode(struct inode *inode, struct inode_entry *new)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR))\n\t\treturn -EEXIST;\n\n\tset_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tF2FS_I(inode)->dirty_dir = new;\n\tlist_add_tail(&new->list, &sbi->dir_inode_list);\n\tstat_inc_dirty_dir(sbi);\n\treturn 0;\n}"
  },
  {
    "function_name": "get_valid_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "610-677",
    "snippet": "int get_valid_checkpoint(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *cp_block;\n\tstruct f2fs_super_block *fsb = sbi->raw_super;\n\tstruct page *cp1, *cp2, *cur_page;\n\tunsigned long blk_size = sbi->blocksize;\n\tunsigned long long cp1_version = 0, cp2_version = 0;\n\tunsigned long long cp_start_blk_no;\n\tunsigned int cp_blks = 1 + le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n\tblock_t cp_blk_no;\n\tint i;\n\n\tsbi->ckpt = kzalloc(cp_blks * blk_size, GFP_KERNEL);\n\tif (!sbi->ckpt)\n\t\treturn -ENOMEM;\n\t/*\n\t * Finding out valid cp block involves read both\n\t * sets( cp pack1 and cp pack 2)\n\t */\n\tcp_start_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tcp1 = validate_checkpoint(sbi, cp_start_blk_no, &cp1_version);\n\n\t/* The second checkpoint pack should start at the next segment */\n\tcp_start_blk_no += ((unsigned long long)1) <<\n\t\t\t\tle32_to_cpu(fsb->log_blocks_per_seg);\n\tcp2 = validate_checkpoint(sbi, cp_start_blk_no, &cp2_version);\n\n\tif (cp1 && cp2) {\n\t\tif (ver_after(cp2_version, cp1_version))\n\t\t\tcur_page = cp2;\n\t\telse\n\t\t\tcur_page = cp1;\n\t} else if (cp1) {\n\t\tcur_page = cp1;\n\t} else if (cp2) {\n\t\tcur_page = cp2;\n\t} else {\n\t\tgoto fail_no_cp;\n\t}\n\n\tcp_block = (struct f2fs_checkpoint *)page_address(cur_page);\n\tmemcpy(sbi->ckpt, cp_block, blk_size);\n\n\tif (cp_blks <= 1)\n\t\tgoto done;\n\n\tcp_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tif (cur_page == cp2)\n\t\tcp_blk_no += 1 << le32_to_cpu(fsb->log_blocks_per_seg);\n\n\tfor (i = 1; i < cp_blks; i++) {\n\t\tvoid *sit_bitmap_ptr;\n\t\tunsigned char *ckpt = (unsigned char *)sbi->ckpt;\n\n\t\tcur_page = get_meta_page(sbi, cp_blk_no + i);\n\t\tsit_bitmap_ptr = page_address(cur_page);\n\t\tmemcpy(ckpt + i * blk_size, sit_bitmap_ptr, blk_size);\n\t\tf2fs_put_page(cur_page, 1);\n\t}\ndone:\n\tf2fs_put_page(cp1, 1);\n\tf2fs_put_page(cp2, 1);\n\treturn 0;\n\nfail_no_cp:\n\tkfree(sbi->ckpt);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->ckpt"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "cp2",
            "1"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ckpt + i * blk_size",
            "sit_bitmap_ptr",
            "blk_size"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "cur_page"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "cp_blk_no + i"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fsb->log_blocks_per_seg"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sbi->ckpt",
            "cp_block",
            "blk_size"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "cur_page"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ver_after",
          "args": [
            "cp2_version",
            "cp1_version"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_checkpoint",
          "args": [
            "sbi",
            "cp_start_blk_no",
            "&cp2_version"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "validate_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "558-608",
          "snippet": "static struct page *validate_checkpoint(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t cp_addr, unsigned long long *version)\n{\n\tstruct page *cp_page_1, *cp_page_2 = NULL;\n\tunsigned long blk_size = sbi->blocksize;\n\tstruct f2fs_checkpoint *cp_block;\n\tunsigned long long cur_version = 0, pre_version = 0;\n\tsize_t crc_offset;\n\t__u32 crc = 0;\n\n\t/* Read the 1st cp block in this CP pack */\n\tcp_page_1 = get_meta_page(sbi, cp_addr);\n\n\t/* get the version number */\n\tcp_block = (struct f2fs_checkpoint *)page_address(cp_page_1);\n\tcrc_offset = le32_to_cpu(cp_block->checksum_offset);\n\tif (crc_offset >= blk_size)\n\t\tgoto invalid_cp1;\n\n\tcrc = le32_to_cpu(*((__le32 *)((unsigned char *)cp_block + crc_offset)));\n\tif (!f2fs_crc_valid(crc, cp_block, crc_offset))\n\t\tgoto invalid_cp1;\n\n\tpre_version = cur_cp_version(cp_block);\n\n\t/* Read the 2nd cp block in this CP pack */\n\tcp_addr += le32_to_cpu(cp_block->cp_pack_total_block_count) - 1;\n\tcp_page_2 = get_meta_page(sbi, cp_addr);\n\n\tcp_block = (struct f2fs_checkpoint *)page_address(cp_page_2);\n\tcrc_offset = le32_to_cpu(cp_block->checksum_offset);\n\tif (crc_offset >= blk_size)\n\t\tgoto invalid_cp2;\n\n\tcrc = le32_to_cpu(*((__le32 *)((unsigned char *)cp_block + crc_offset)));\n\tif (!f2fs_crc_valid(crc, cp_block, crc_offset))\n\t\tgoto invalid_cp2;\n\n\tcur_version = cur_cp_version(cp_block);\n\n\tif (cur_version == pre_version) {\n\t\t*version = cur_version;\n\t\tf2fs_put_page(cp_page_2, 1);\n\t\treturn cp_page_1;\n\t}\ninvalid_cp2:\n\tf2fs_put_page(cp_page_2, 1);\ninvalid_cp1:\n\tf2fs_put_page(cp_page_1, 1);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct page *validate_checkpoint(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t cp_addr, unsigned long long *version)\n{\n\tstruct page *cp_page_1, *cp_page_2 = NULL;\n\tunsigned long blk_size = sbi->blocksize;\n\tstruct f2fs_checkpoint *cp_block;\n\tunsigned long long cur_version = 0, pre_version = 0;\n\tsize_t crc_offset;\n\t__u32 crc = 0;\n\n\t/* Read the 1st cp block in this CP pack */\n\tcp_page_1 = get_meta_page(sbi, cp_addr);\n\n\t/* get the version number */\n\tcp_block = (struct f2fs_checkpoint *)page_address(cp_page_1);\n\tcrc_offset = le32_to_cpu(cp_block->checksum_offset);\n\tif (crc_offset >= blk_size)\n\t\tgoto invalid_cp1;\n\n\tcrc = le32_to_cpu(*((__le32 *)((unsigned char *)cp_block + crc_offset)));\n\tif (!f2fs_crc_valid(crc, cp_block, crc_offset))\n\t\tgoto invalid_cp1;\n\n\tpre_version = cur_cp_version(cp_block);\n\n\t/* Read the 2nd cp block in this CP pack */\n\tcp_addr += le32_to_cpu(cp_block->cp_pack_total_block_count) - 1;\n\tcp_page_2 = get_meta_page(sbi, cp_addr);\n\n\tcp_block = (struct f2fs_checkpoint *)page_address(cp_page_2);\n\tcrc_offset = le32_to_cpu(cp_block->checksum_offset);\n\tif (crc_offset >= blk_size)\n\t\tgoto invalid_cp2;\n\n\tcrc = le32_to_cpu(*((__le32 *)((unsigned char *)cp_block + crc_offset)));\n\tif (!f2fs_crc_valid(crc, cp_block, crc_offset))\n\t\tgoto invalid_cp2;\n\n\tcur_version = cur_cp_version(cp_block);\n\n\tif (cur_version == pre_version) {\n\t\t*version = cur_version;\n\t\tf2fs_put_page(cp_page_2, 1);\n\t\treturn cp_page_1;\n\t}\ninvalid_cp2:\n\tf2fs_put_page(cp_page_2, 1);\ninvalid_cp1:\n\tf2fs_put_page(cp_page_1, 1);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "cp_blks * blk_size",
            "GFP_KERNEL"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_RAW_SUPER",
          "args": [
            "sbi"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_RAW_SUPER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "660-663",
          "snippet": "static inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint get_valid_checkpoint(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *cp_block;\n\tstruct f2fs_super_block *fsb = sbi->raw_super;\n\tstruct page *cp1, *cp2, *cur_page;\n\tunsigned long blk_size = sbi->blocksize;\n\tunsigned long long cp1_version = 0, cp2_version = 0;\n\tunsigned long long cp_start_blk_no;\n\tunsigned int cp_blks = 1 + le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n\tblock_t cp_blk_no;\n\tint i;\n\n\tsbi->ckpt = kzalloc(cp_blks * blk_size, GFP_KERNEL);\n\tif (!sbi->ckpt)\n\t\treturn -ENOMEM;\n\t/*\n\t * Finding out valid cp block involves read both\n\t * sets( cp pack1 and cp pack 2)\n\t */\n\tcp_start_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tcp1 = validate_checkpoint(sbi, cp_start_blk_no, &cp1_version);\n\n\t/* The second checkpoint pack should start at the next segment */\n\tcp_start_blk_no += ((unsigned long long)1) <<\n\t\t\t\tle32_to_cpu(fsb->log_blocks_per_seg);\n\tcp2 = validate_checkpoint(sbi, cp_start_blk_no, &cp2_version);\n\n\tif (cp1 && cp2) {\n\t\tif (ver_after(cp2_version, cp1_version))\n\t\t\tcur_page = cp2;\n\t\telse\n\t\t\tcur_page = cp1;\n\t} else if (cp1) {\n\t\tcur_page = cp1;\n\t} else if (cp2) {\n\t\tcur_page = cp2;\n\t} else {\n\t\tgoto fail_no_cp;\n\t}\n\n\tcp_block = (struct f2fs_checkpoint *)page_address(cur_page);\n\tmemcpy(sbi->ckpt, cp_block, blk_size);\n\n\tif (cp_blks <= 1)\n\t\tgoto done;\n\n\tcp_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tif (cur_page == cp2)\n\t\tcp_blk_no += 1 << le32_to_cpu(fsb->log_blocks_per_seg);\n\n\tfor (i = 1; i < cp_blks; i++) {\n\t\tvoid *sit_bitmap_ptr;\n\t\tunsigned char *ckpt = (unsigned char *)sbi->ckpt;\n\n\t\tcur_page = get_meta_page(sbi, cp_blk_no + i);\n\t\tsit_bitmap_ptr = page_address(cur_page);\n\t\tmemcpy(ckpt + i * blk_size, sit_bitmap_ptr, blk_size);\n\t\tf2fs_put_page(cur_page, 1);\n\t}\ndone:\n\tf2fs_put_page(cp1, 1);\n\tf2fs_put_page(cp2, 1);\n\treturn 0;\n\nfail_no_cp:\n\tkfree(sbi->ckpt);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "validate_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "558-608",
    "snippet": "static struct page *validate_checkpoint(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t cp_addr, unsigned long long *version)\n{\n\tstruct page *cp_page_1, *cp_page_2 = NULL;\n\tunsigned long blk_size = sbi->blocksize;\n\tstruct f2fs_checkpoint *cp_block;\n\tunsigned long long cur_version = 0, pre_version = 0;\n\tsize_t crc_offset;\n\t__u32 crc = 0;\n\n\t/* Read the 1st cp block in this CP pack */\n\tcp_page_1 = get_meta_page(sbi, cp_addr);\n\n\t/* get the version number */\n\tcp_block = (struct f2fs_checkpoint *)page_address(cp_page_1);\n\tcrc_offset = le32_to_cpu(cp_block->checksum_offset);\n\tif (crc_offset >= blk_size)\n\t\tgoto invalid_cp1;\n\n\tcrc = le32_to_cpu(*((__le32 *)((unsigned char *)cp_block + crc_offset)));\n\tif (!f2fs_crc_valid(crc, cp_block, crc_offset))\n\t\tgoto invalid_cp1;\n\n\tpre_version = cur_cp_version(cp_block);\n\n\t/* Read the 2nd cp block in this CP pack */\n\tcp_addr += le32_to_cpu(cp_block->cp_pack_total_block_count) - 1;\n\tcp_page_2 = get_meta_page(sbi, cp_addr);\n\n\tcp_block = (struct f2fs_checkpoint *)page_address(cp_page_2);\n\tcrc_offset = le32_to_cpu(cp_block->checksum_offset);\n\tif (crc_offset >= blk_size)\n\t\tgoto invalid_cp2;\n\n\tcrc = le32_to_cpu(*((__le32 *)((unsigned char *)cp_block + crc_offset)));\n\tif (!f2fs_crc_valid(crc, cp_block, crc_offset))\n\t\tgoto invalid_cp2;\n\n\tcur_version = cur_cp_version(cp_block);\n\n\tif (cur_version == pre_version) {\n\t\t*version = cur_version;\n\t\tf2fs_put_page(cp_page_2, 1);\n\t\treturn cp_page_1;\n\t}\ninvalid_cp2:\n\tf2fs_put_page(cp_page_2, 1);\ninvalid_cp1:\n\tf2fs_put_page(cp_page_1, 1);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "cp_page_1",
            "1"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_cp_version",
          "args": [
            "cp_block"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "cur_cp_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "730-733",
          "snippet": "static inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_crc_valid",
          "args": [
            "crc",
            "cp_block",
            "crc_offset"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_crc_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "88-91",
          "snippet": "static inline bool f2fs_crc_valid(__u32 blk_crc, void *buf, size_t buf_size)\n{\n\treturn f2fs_crc32(buf, buf_size) == blk_crc;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_crc_valid(__u32 blk_crc, void *buf, size_t buf_size)\n{\n\treturn f2fs_crc32(buf, buf_size) == blk_crc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*((__le32 *)((unsigned char *)cp_block + crc_offset))"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "cp_page_2"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "cp_addr"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "cp_page_1"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct page *validate_checkpoint(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t cp_addr, unsigned long long *version)\n{\n\tstruct page *cp_page_1, *cp_page_2 = NULL;\n\tunsigned long blk_size = sbi->blocksize;\n\tstruct f2fs_checkpoint *cp_block;\n\tunsigned long long cur_version = 0, pre_version = 0;\n\tsize_t crc_offset;\n\t__u32 crc = 0;\n\n\t/* Read the 1st cp block in this CP pack */\n\tcp_page_1 = get_meta_page(sbi, cp_addr);\n\n\t/* get the version number */\n\tcp_block = (struct f2fs_checkpoint *)page_address(cp_page_1);\n\tcrc_offset = le32_to_cpu(cp_block->checksum_offset);\n\tif (crc_offset >= blk_size)\n\t\tgoto invalid_cp1;\n\n\tcrc = le32_to_cpu(*((__le32 *)((unsigned char *)cp_block + crc_offset)));\n\tif (!f2fs_crc_valid(crc, cp_block, crc_offset))\n\t\tgoto invalid_cp1;\n\n\tpre_version = cur_cp_version(cp_block);\n\n\t/* Read the 2nd cp block in this CP pack */\n\tcp_addr += le32_to_cpu(cp_block->cp_pack_total_block_count) - 1;\n\tcp_page_2 = get_meta_page(sbi, cp_addr);\n\n\tcp_block = (struct f2fs_checkpoint *)page_address(cp_page_2);\n\tcrc_offset = le32_to_cpu(cp_block->checksum_offset);\n\tif (crc_offset >= blk_size)\n\t\tgoto invalid_cp2;\n\n\tcrc = le32_to_cpu(*((__le32 *)((unsigned char *)cp_block + crc_offset)));\n\tif (!f2fs_crc_valid(crc, cp_block, crc_offset))\n\t\tgoto invalid_cp2;\n\n\tcur_version = cur_cp_version(cp_block);\n\n\tif (cur_version == pre_version) {\n\t\t*version = cur_version;\n\t\tf2fs_put_page(cp_page_2, 1);\n\t\treturn cp_page_1;\n\t}\ninvalid_cp2:\n\tf2fs_put_page(cp_page_2, 1);\ninvalid_cp1:\n\tf2fs_put_page(cp_page_1, 1);\n\treturn NULL;\n}"
  },
  {
    "function_name": "write_orphan_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "497-556",
    "snippet": "static void write_orphan_inodes(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\tstruct list_head *head;\n\tstruct f2fs_orphan_block *orphan_blk = NULL;\n\tunsigned int nentries = 0;\n\tunsigned short index;\n\tunsigned short orphan_blocks;\n\tstruct page *page = NULL;\n\tstruct ino_entry *orphan = NULL;\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\torphan_blocks = GET_ORPHAN_BLOCKS(im->ino_num);\n\n\tfor (index = 0; index < orphan_blocks; index++)\n\t\tgrab_meta_page(sbi, start_blk + index);\n\n\tindex = 1;\n\tspin_lock(&im->ino_lock);\n\thead = &im->ino_list;\n\n\t/* loop for each orphan inode entry and write them in Jornal block */\n\tlist_for_each_entry(orphan, head, list) {\n\t\tif (!page) {\n\t\t\tpage = find_get_page(META_MAPPING(sbi), start_blk++);\n\t\t\tf2fs_bug_on(sbi, !page);\n\t\t\torphan_blk =\n\t\t\t\t(struct f2fs_orphan_block *)page_address(page);\n\t\t\tmemset(orphan_blk, 0, sizeof(*orphan_blk));\n\t\t\tf2fs_put_page(page, 0);\n\t\t}\n\n\t\torphan_blk->ino[nentries++] = cpu_to_le32(orphan->ino);\n\n\t\tif (nentries == F2FS_ORPHANS_PER_BLOCK) {\n\t\t\t/*\n\t\t\t * an orphan block is full of 1020 entries,\n\t\t\t * then we need to flush current orphan blocks\n\t\t\t * and bring another one in memory\n\t\t\t */\n\t\t\torphan_blk->blk_addr = cpu_to_le16(index);\n\t\t\torphan_blk->blk_count = cpu_to_le16(orphan_blocks);\n\t\t\torphan_blk->entry_count = cpu_to_le32(nentries);\n\t\t\tset_page_dirty(page);\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tindex++;\n\t\t\tnentries = 0;\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\torphan_blk->blk_addr = cpu_to_le16(index);\n\t\torphan_blk->blk_count = cpu_to_le16(orphan_blocks);\n\t\torphan_blk->entry_count = cpu_to_le32(nentries);\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\tspin_unlock(&im->ino_lock);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "nentries"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "orphan_blocks"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "index"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "nentries"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "orphan_blocks"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "index"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "orphan->ino"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "orphan_blk",
            "0",
            "sizeof(*orphan_blk)"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "!page"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "META_MAPPING(sbi)",
            "start_blk++"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "META_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "META_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "705-708",
          "snippet": "static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "orphan",
            "head",
            "list"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_meta_page",
          "args": [
            "sbi",
            "start_blk + index"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "grab_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "32-45",
          "snippet": "struct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_ORPHAN_BLOCKS",
          "args": [
            "im->ino_num"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic void write_orphan_inodes(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\tstruct list_head *head;\n\tstruct f2fs_orphan_block *orphan_blk = NULL;\n\tunsigned int nentries = 0;\n\tunsigned short index;\n\tunsigned short orphan_blocks;\n\tstruct page *page = NULL;\n\tstruct ino_entry *orphan = NULL;\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\torphan_blocks = GET_ORPHAN_BLOCKS(im->ino_num);\n\n\tfor (index = 0; index < orphan_blocks; index++)\n\t\tgrab_meta_page(sbi, start_blk + index);\n\n\tindex = 1;\n\tspin_lock(&im->ino_lock);\n\thead = &im->ino_list;\n\n\t/* loop for each orphan inode entry and write them in Jornal block */\n\tlist_for_each_entry(orphan, head, list) {\n\t\tif (!page) {\n\t\t\tpage = find_get_page(META_MAPPING(sbi), start_blk++);\n\t\t\tf2fs_bug_on(sbi, !page);\n\t\t\torphan_blk =\n\t\t\t\t(struct f2fs_orphan_block *)page_address(page);\n\t\t\tmemset(orphan_blk, 0, sizeof(*orphan_blk));\n\t\t\tf2fs_put_page(page, 0);\n\t\t}\n\n\t\torphan_blk->ino[nentries++] = cpu_to_le32(orphan->ino);\n\n\t\tif (nentries == F2FS_ORPHANS_PER_BLOCK) {\n\t\t\t/*\n\t\t\t * an orphan block is full of 1020 entries,\n\t\t\t * then we need to flush current orphan blocks\n\t\t\t * and bring another one in memory\n\t\t\t */\n\t\t\torphan_blk->blk_addr = cpu_to_le16(index);\n\t\t\torphan_blk->blk_count = cpu_to_le16(orphan_blocks);\n\t\t\torphan_blk->entry_count = cpu_to_le32(nentries);\n\t\t\tset_page_dirty(page);\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tindex++;\n\t\t\tnentries = 0;\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\torphan_blk->blk_addr = cpu_to_le16(index);\n\t\torphan_blk->blk_count = cpu_to_le16(orphan_blocks);\n\t\torphan_blk->entry_count = cpu_to_le32(nentries);\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\tspin_unlock(&im->ino_lock);\n}"
  },
  {
    "function_name": "recover_orphan_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "465-495",
    "snippet": "void recover_orphan_inodes(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_blk, orphan_blkaddr, i, j;\n\n\tif (!is_set_ckpt_flags(F2FS_CKPT(sbi), CP_ORPHAN_PRESENT_FLAG))\n\t\treturn;\n\n\tset_sbi_flag(sbi, SBI_POR_DOING);\n\n\tstart_blk = __start_cp_addr(sbi) + 1 +\n\t\tle32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n\torphan_blkaddr = __start_sum_addr(sbi) - 1;\n\n\tra_meta_pages(sbi, start_blk, orphan_blkaddr, META_CP);\n\n\tfor (i = 0; i < orphan_blkaddr; i++) {\n\t\tstruct page *page = get_meta_page(sbi, start_blk + i);\n\t\tstruct f2fs_orphan_block *orphan_blk;\n\n\t\torphan_blk = (struct f2fs_orphan_block *)page_address(page);\n\t\tfor (j = 0; j < le32_to_cpu(orphan_blk->entry_count); j++) {\n\t\t\tnid_t ino = le32_to_cpu(orphan_blk->ino[j]);\n\t\t\trecover_orphan_inode(sbi, ino);\n\t\t}\n\t\tf2fs_put_page(page, 1);\n\t}\n\t/* clear Orphan Flag */\n\tclear_ckpt_flags(F2FS_CKPT(sbi), CP_ORPHAN_PRESENT_FLAG);\n\tclear_sbi_flag(sbi, SBI_POR_DOING);\n\treturn;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_sbi_flag",
          "args": [
            "sbi",
            "SBI_POR_DOING"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sbi_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "725-728",
          "snippet": "static inline void clear_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag &= ~(0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag &= ~(0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_ckpt_flags",
          "args": [
            "F2FS_CKPT(sbi)",
            "CP_ORPHAN_PRESENT_FLAG"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "clear_ckpt_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "748-753",
          "snippet": "static inline void clear_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\tckpt_flags &= (~f);\n\tcp->ckpt_flags = cpu_to_le32(ckpt_flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\tckpt_flags &= (~f);\n\tcp->ckpt_flags = cpu_to_le32(ckpt_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_orphan_inode",
          "args": [
            "sbi",
            "ino"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "recover_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "455-463",
          "snippet": "static void recover_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct inode *inode = f2fs_iget(sbi->sb, ino);\n\tf2fs_bug_on(sbi, IS_ERR(inode));\n\tclear_nlink(inode);\n\n\t/* truncate all the data during iput */\n\tiput(inode);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic void recover_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct inode *inode = f2fs_iget(sbi->sb, ino);\n\tf2fs_bug_on(sbi, IS_ERR(inode));\n\tclear_nlink(inode);\n\n\t/* truncate all the data during iput */\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "orphan_blk->ino[j]"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "start_blk + i"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ra_meta_pages",
          "args": [
            "sbi",
            "start_blk",
            "orphan_blkaddr",
            "META_CP"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "ra_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "115-170",
          "snippet": "int ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__start_sum_addr",
          "args": [
            "sbi"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "__start_sum_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "958-961",
          "snippet": "static inline block_t __start_sum_addr(struct f2fs_sb_info *sbi)\n{\n\treturn le32_to_cpu(F2FS_CKPT(sbi)->cp_pack_start_sum);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline block_t __start_sum_addr(struct f2fs_sb_info *sbi)\n{\n\treturn le32_to_cpu(F2FS_CKPT(sbi)->cp_pack_start_sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_RAW_SUPER",
          "args": [
            "sbi"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_RAW_SUPER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "660-663",
          "snippet": "static inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__start_cp_addr",
          "args": [
            "sbi"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "__start_cp_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "940-956",
          "snippet": "static inline block_t __start_cp_addr(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_addr;\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_version = cur_cp_version(ckpt);\n\n\tstart_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_blkaddr);\n\n\t/*\n\t * odd numbered checkpoint should at cp segment 0\n\t * and even segment must be at cp segment 1\n\t */\n\tif (!(ckpt_version & 1))\n\t\tstart_addr += sbi->blocks_per_seg;\n\n\treturn start_addr;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline block_t __start_cp_addr(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_addr;\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_version = cur_cp_version(ckpt);\n\n\tstart_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_blkaddr);\n\n\t/*\n\t * odd numbered checkpoint should at cp segment 0\n\t * and even segment must be at cp segment 1\n\t */\n\tif (!(ckpt_version & 1))\n\t\tstart_addr += sbi->blocks_per_seg;\n\n\treturn start_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sbi_flag",
          "args": [
            "sbi",
            "SBI_POR_DOING"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "set_sbi_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "720-723",
          "snippet": "static inline void set_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag |= (0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag |= (0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_set_ckpt_flags",
          "args": [
            "F2FS_CKPT(sbi)",
            "CP_ORPHAN_PRESENT_FLAG"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "is_set_ckpt_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "735-739",
          "snippet": "static inline bool is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\treturn ckpt_flags & f;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\treturn ckpt_flags & f;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid recover_orphan_inodes(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_blk, orphan_blkaddr, i, j;\n\n\tif (!is_set_ckpt_flags(F2FS_CKPT(sbi), CP_ORPHAN_PRESENT_FLAG))\n\t\treturn;\n\n\tset_sbi_flag(sbi, SBI_POR_DOING);\n\n\tstart_blk = __start_cp_addr(sbi) + 1 +\n\t\tle32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n\torphan_blkaddr = __start_sum_addr(sbi) - 1;\n\n\tra_meta_pages(sbi, start_blk, orphan_blkaddr, META_CP);\n\n\tfor (i = 0; i < orphan_blkaddr; i++) {\n\t\tstruct page *page = get_meta_page(sbi, start_blk + i);\n\t\tstruct f2fs_orphan_block *orphan_blk;\n\n\t\torphan_blk = (struct f2fs_orphan_block *)page_address(page);\n\t\tfor (j = 0; j < le32_to_cpu(orphan_blk->entry_count); j++) {\n\t\t\tnid_t ino = le32_to_cpu(orphan_blk->ino[j]);\n\t\t\trecover_orphan_inode(sbi, ino);\n\t\t}\n\t\tf2fs_put_page(page, 1);\n\t}\n\t/* clear Orphan Flag */\n\tclear_ckpt_flags(F2FS_CKPT(sbi), CP_ORPHAN_PRESENT_FLAG);\n\tclear_sbi_flag(sbi, SBI_POR_DOING);\n\treturn;\n}"
  },
  {
    "function_name": "recover_orphan_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "455-463",
    "snippet": "static void recover_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct inode *inode = f2fs_iget(sbi->sb, ino);\n\tf2fs_bug_on(sbi, IS_ERR(inode));\n\tclear_nlink(inode);\n\n\t/* truncate all the data during iput */\n\tiput(inode);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "IS_ERR(inode)"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_iget",
          "args": [
            "sbi->sb",
            "ino"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "151-206",
          "snippet": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic void recover_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct inode *inode = f2fs_iget(sbi->sb, ino);\n\tf2fs_bug_on(sbi, IS_ERR(inode));\n\tclear_nlink(inode);\n\n\t/* truncate all the data during iput */\n\tiput(inode);\n}"
  },
  {
    "function_name": "remove_orphan_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "449-453",
    "snippet": "void remove_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* remove orphan entry from orphan list */\n\t__remove_ino_entry(sbi, ino, ORPHAN_INO);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__remove_ino_entry",
          "args": [
            "sbi",
            "ino",
            "ORPHAN_INO"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_ino_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "357-373",
          "snippet": "static void __remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (e) {\n\t\tlist_del(&e->list);\n\t\tradix_tree_delete(&im->ino_root, ino);\n\t\tim->ino_num--;\n\t\tspin_unlock(&im->ino_lock);\n\t\tkmem_cache_free(ino_entry_slab, e);\n\t\treturn;\n\t}\n\tspin_unlock(&im->ino_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ino_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\n\nstatic void __remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (e) {\n\t\tlist_del(&e->list);\n\t\tradix_tree_delete(&im->ino_root, ino);\n\t\tim->ino_num--;\n\t\tspin_unlock(&im->ino_lock);\n\t\tkmem_cache_free(ino_entry_slab, e);\n\t\treturn;\n\t}\n\tspin_unlock(&im->ino_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid remove_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* remove orphan entry from orphan list */\n\t__remove_ino_entry(sbi, ino, ORPHAN_INO);\n}"
  },
  {
    "function_name": "add_orphan_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "443-447",
    "snippet": "void add_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* add new orphan ino entry into list */\n\t__add_ino_entry(sbi, ino, ORPHAN_INO);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_ino_entry",
          "args": [
            "sbi",
            "ino",
            "ORPHAN_INO"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "__add_ino_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "320-355",
          "snippet": "static void __add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\nretry:\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\tspin_lock(&im->ino_lock);\n\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (!e) {\n\t\te = kmem_cache_alloc(ino_entry_slab, GFP_ATOMIC);\n\t\tif (!e) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (radix_tree_insert(&im->ino_root, ino, e)) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\tmemset(e, 0, sizeof(struct ino_entry));\n\t\te->ino = ino;\n\n\t\tlist_add_tail(&e->list, &im->ino_list);\n\t\tif (type != ORPHAN_INO)\n\t\t\tim->ino_num++;\n\t}\n\tspin_unlock(&im->ino_lock);\n\tradix_tree_preload_end();\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ino_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\n\nstatic void __add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\nretry:\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\tspin_lock(&im->ino_lock);\n\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (!e) {\n\t\te = kmem_cache_alloc(ino_entry_slab, GFP_ATOMIC);\n\t\tif (!e) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (radix_tree_insert(&im->ino_root, ino, e)) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\tmemset(e, 0, sizeof(struct ino_entry));\n\t\te->ino = ino;\n\n\t\tlist_add_tail(&e->list, &im->ino_list);\n\t\tif (type != ORPHAN_INO)\n\t\t\tim->ino_num++;\n\t}\n\tspin_unlock(&im->ino_lock);\n\tradix_tree_preload_end();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid add_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* add new orphan ino entry into list */\n\t__add_ino_entry(sbi, ino, ORPHAN_INO);\n}"
  },
  {
    "function_name": "release_orphan_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "433-441",
    "snippet": "void release_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\tspin_lock(&im->ino_lock);\n\tf2fs_bug_on(sbi, im->ino_num == 0);\n\tim->ino_num--;\n\tspin_unlock(&im->ino_lock);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "im->ino_num == 0"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid release_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\tspin_lock(&im->ino_lock);\n\tf2fs_bug_on(sbi, im->ino_num == 0);\n\tim->ino_num--;\n\tspin_unlock(&im->ino_lock);\n}"
  },
  {
    "function_name": "acquire_orphan_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "418-431",
    "snippet": "int acquire_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\tint err = 0;\n\n\tspin_lock(&im->ino_lock);\n\tif (unlikely(im->ino_num >= sbi->max_orphans))\n\t\terr = -ENOSPC;\n\telse\n\t\tim->ino_num++;\n\tspin_unlock(&im->ino_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "im->ino_num >= sbi->max_orphans"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint acquire_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\tint err = 0;\n\n\tspin_lock(&im->ino_lock);\n\tif (unlikely(im->ino_num >= sbi->max_orphans))\n\t\terr = -ENOSPC;\n\telse\n\t\tim->ino_num++;\n\tspin_unlock(&im->ino_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "release_dirty_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "399-416",
    "snippet": "void release_dirty_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct ino_entry *e, *tmp;\n\tint i;\n\n\tfor (i = APPEND_INO; i <= UPDATE_INO; i++) {\n\t\tstruct inode_management *im = &sbi->im[i];\n\n\t\tspin_lock(&im->ino_lock);\n\t\tlist_for_each_entry_safe(e, tmp, &im->ino_list, list) {\n\t\t\tlist_del(&e->list);\n\t\t\tradix_tree_delete(&im->ino_root, e->ino);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tim->ino_num--;\n\t\t}\n\t\tspin_unlock(&im->ino_lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ino_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ino_entry_slab",
            "e"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&im->ino_root",
            "e->ino"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&e->list"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "e",
            "tmp",
            "&im->ino_list",
            "list"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\n\nvoid release_dirty_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct ino_entry *e, *tmp;\n\tint i;\n\n\tfor (i = APPEND_INO; i <= UPDATE_INO; i++) {\n\t\tstruct inode_management *im = &sbi->im[i];\n\n\t\tspin_lock(&im->ino_lock);\n\t\tlist_for_each_entry_safe(e, tmp, &im->ino_list, list) {\n\t\t\tlist_del(&e->list);\n\t\t\tradix_tree_delete(&im->ino_root, e->ino);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tim->ino_num--;\n\t\t}\n\t\tspin_unlock(&im->ino_lock);\n\t}\n}"
  },
  {
    "function_name": "exist_written_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "388-397",
    "snippet": "bool exist_written_data(struct f2fs_sb_info *sbi, nid_t ino, int mode)\n{\n\tstruct inode_management *im = &sbi->im[mode];\n\tstruct ino_entry *e;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tspin_unlock(&im->ino_lock);\n\treturn e ? true : false;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&im->ino_root",
            "ino"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nbool exist_written_data(struct f2fs_sb_info *sbi, nid_t ino, int mode)\n{\n\tstruct inode_management *im = &sbi->im[mode];\n\tstruct ino_entry *e;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tspin_unlock(&im->ino_lock);\n\treturn e ? true : false;\n}"
  },
  {
    "function_name": "remove_dirty_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "381-385",
    "snippet": "void remove_dirty_inode(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\t/* remove dirty ino entry from list */\n\t__remove_ino_entry(sbi, ino, type);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__remove_ino_entry",
          "args": [
            "sbi",
            "ino",
            "type"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_ino_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "357-373",
          "snippet": "static void __remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (e) {\n\t\tlist_del(&e->list);\n\t\tradix_tree_delete(&im->ino_root, ino);\n\t\tim->ino_num--;\n\t\tspin_unlock(&im->ino_lock);\n\t\tkmem_cache_free(ino_entry_slab, e);\n\t\treturn;\n\t}\n\tspin_unlock(&im->ino_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ino_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\n\nstatic void __remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (e) {\n\t\tlist_del(&e->list);\n\t\tradix_tree_delete(&im->ino_root, ino);\n\t\tim->ino_num--;\n\t\tspin_unlock(&im->ino_lock);\n\t\tkmem_cache_free(ino_entry_slab, e);\n\t\treturn;\n\t}\n\tspin_unlock(&im->ino_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid remove_dirty_inode(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\t/* remove dirty ino entry from list */\n\t__remove_ino_entry(sbi, ino, type);\n}"
  },
  {
    "function_name": "add_dirty_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "375-379",
    "snippet": "void add_dirty_inode(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\t/* add new dirty ino entry into list */\n\t__add_ino_entry(sbi, ino, type);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_ino_entry",
          "args": [
            "sbi",
            "ino",
            "type"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "__add_ino_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "320-355",
          "snippet": "static void __add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\nretry:\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\tspin_lock(&im->ino_lock);\n\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (!e) {\n\t\te = kmem_cache_alloc(ino_entry_slab, GFP_ATOMIC);\n\t\tif (!e) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (radix_tree_insert(&im->ino_root, ino, e)) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\tmemset(e, 0, sizeof(struct ino_entry));\n\t\te->ino = ino;\n\n\t\tlist_add_tail(&e->list, &im->ino_list);\n\t\tif (type != ORPHAN_INO)\n\t\t\tim->ino_num++;\n\t}\n\tspin_unlock(&im->ino_lock);\n\tradix_tree_preload_end();\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ino_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\n\nstatic void __add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\nretry:\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\tspin_lock(&im->ino_lock);\n\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (!e) {\n\t\te = kmem_cache_alloc(ino_entry_slab, GFP_ATOMIC);\n\t\tif (!e) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (radix_tree_insert(&im->ino_root, ino, e)) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\tmemset(e, 0, sizeof(struct ino_entry));\n\t\te->ino = ino;\n\n\t\tlist_add_tail(&e->list, &im->ino_list);\n\t\tif (type != ORPHAN_INO)\n\t\t\tim->ino_num++;\n\t}\n\tspin_unlock(&im->ino_lock);\n\tradix_tree_preload_end();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid add_dirty_inode(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\t/* add new dirty ino entry into list */\n\t__add_ino_entry(sbi, ino, type);\n}"
  },
  {
    "function_name": "__remove_ino_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "357-373",
    "snippet": "static void __remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (e) {\n\t\tlist_del(&e->list);\n\t\tradix_tree_delete(&im->ino_root, ino);\n\t\tim->ino_num--;\n\t\tspin_unlock(&im->ino_lock);\n\t\tkmem_cache_free(ino_entry_slab, e);\n\t\treturn;\n\t}\n\tspin_unlock(&im->ino_lock);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ino_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ino_entry_slab",
            "e"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&im->ino_root",
            "ino"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&e->list"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&im->ino_root",
            "ino"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\n\nstatic void __remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (e) {\n\t\tlist_del(&e->list);\n\t\tradix_tree_delete(&im->ino_root, ino);\n\t\tim->ino_num--;\n\t\tspin_unlock(&im->ino_lock);\n\t\tkmem_cache_free(ino_entry_slab, e);\n\t\treturn;\n\t}\n\tspin_unlock(&im->ino_lock);\n}"
  },
  {
    "function_name": "__add_ino_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "320-355",
    "snippet": "static void __add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\nretry:\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\tspin_lock(&im->ino_lock);\n\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (!e) {\n\t\te = kmem_cache_alloc(ino_entry_slab, GFP_ATOMIC);\n\t\tif (!e) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (radix_tree_insert(&im->ino_root, ino, e)) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\tmemset(e, 0, sizeof(struct ino_entry));\n\t\te->ino = ino;\n\n\t\tlist_add_tail(&e->list, &im->ino_list);\n\t\tif (type != ORPHAN_INO)\n\t\t\tim->ino_num++;\n\t}\n\tspin_unlock(&im->ino_lock);\n\tradix_tree_preload_end();\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ino_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&e->list",
            "&im->ino_list"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "e",
            "0",
            "sizeof(struct ino_entry)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ino_entry_slab",
            "e"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&im->ino_root",
            "ino",
            "e"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ino_entry_slab",
            "GFP_ATOMIC"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&im->ino_root",
            "ino"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&im->ino_lock"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload",
          "args": [
            "GFP_NOFS"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ino_entry_slab;\n\nstatic void __add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\nretry:\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\tspin_lock(&im->ino_lock);\n\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (!e) {\n\t\te = kmem_cache_alloc(ino_entry_slab, GFP_ATOMIC);\n\t\tif (!e) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (radix_tree_insert(&im->ino_root, ino, e)) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\tmemset(e, 0, sizeof(struct ino_entry));\n\t\te->ino = ino;\n\n\t\tlist_add_tail(&e->list, &im->ino_list);\n\t\tif (type != ORPHAN_INO)\n\t\t\tim->ino_num++;\n\t}\n\tspin_unlock(&im->ino_lock);\n\tradix_tree_preload_end();\n}"
  },
  {
    "function_name": "f2fs_set_meta_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "297-310",
    "snippet": "static int f2fs_set_meta_page_dirty(struct page *page)\n{\n\ttrace_f2fs_set_page_dirty(page, META);\n\n\tSetPageUptodate(page);\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tinc_page_count(F2FS_P_SB(page), F2FS_DIRTY_META);\n\t\tSetPagePrivate(page);\n\t\tf2fs_trace_pid(page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_trace_pid",
          "args": [
            "page"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_trace_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/trace.c",
          "lines": "55-81",
          "snippet": "void f2fs_trace_pid(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tpid_t pid = task_pid_nr(current);\n\tvoid *p;\n\n\tpage->private = pid;\n\n\tif (radix_tree_preload(GFP_NOFS))\n\t\treturn;\n\n\tspin_lock(&pids_lock);\n\tp = radix_tree_lookup(&pids, pid);\n\tif (p == current)\n\t\tgoto out;\n\tif (p)\n\t\tradix_tree_delete(&pids, pid);\n\n\tf2fs_radix_tree_insert(&pids, pid, current);\n\n\ttrace_printk(\"%3x:%3x %4x %-16s\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tpid, current->comm);\nout:\n\tspin_unlock(&pids_lock);\n\tradix_tree_preload_end();\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/radix-tree.h>",
            "#include <linux/sched.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t pids_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"f2fs.h\"\n#include <linux/radix-tree.h>\n#include <linux/sched.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic spinlock_t pids_lock;\n\nvoid f2fs_trace_pid(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tpid_t pid = task_pid_nr(current);\n\tvoid *p;\n\n\tpage->private = pid;\n\n\tif (radix_tree_preload(GFP_NOFS))\n\t\treturn;\n\n\tspin_lock(&pids_lock);\n\tp = radix_tree_lookup(&pids, pid);\n\tif (p == current)\n\t\tgoto out;\n\tif (p)\n\t\tradix_tree_delete(&pids, pid);\n\n\tf2fs_radix_tree_insert(&pids, pid, current);\n\n\ttrace_printk(\"%3x:%3x %4x %-16s\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tpid, current->comm);\nout:\n\tspin_unlock(&pids_lock);\n\tradix_tree_preload_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_page_count",
          "args": [
            "F2FS_P_SB(page)",
            "F2FS_DIRTY_META"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "inc_page_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "858-862",
          "snippet": "static inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_inc(&sbi->nr_pages[count_type]);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_inc(&sbi->nr_pages[count_type]);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_P_SB",
          "args": [
            "page"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_P_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "655-658",
          "snippet": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_set_page_dirty",
          "args": [
            "page",
            "META"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic int f2fs_set_meta_page_dirty(struct page *page)\n{\n\ttrace_f2fs_set_page_dirty(page, META);\n\n\tSetPageUptodate(page);\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tinc_page_count(F2FS_P_SB(page), F2FS_DIRTY_META);\n\t\tSetPagePrivate(page);\n\t\tf2fs_trace_pid(page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sync_meta_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "240-295",
    "snippet": "long sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,\n\t\t\t\t\t\tlong nr_to_write)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tpgoff_t index = 0, end = LONG_MAX;\n\tstruct pagevec pvec;\n\tlong nwritten = 0;\n\tstruct writeback_control wbc = {\n\t\t.for_reclaim = 0,\n\t};\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (unlikely(nr_pages == 0))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (f2fs_write_meta_page(page, &wbc)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnwritten++;\n\t\t\tif (unlikely(nwritten >= nr_to_write))\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (nwritten)\n\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\n\treturn nwritten;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_submit_merged_bio",
          "args": [
            "sbi",
            "type",
            "WRITE"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "107-127",
          "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nwritten >= nr_to_write"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_write_meta_page",
          "args": [
            "page",
            "&wbc"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_write_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "214-238",
          "snippet": "static int f2fs_write_meta_pages(struct address_space *mapping,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_M_SB(mapping);\n\tlong diff, written;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, META);\n\n\t/* collect a number of dirty meta pages and write together */\n\tif (wbc->for_kupdate ||\n\t\tget_pages(sbi, F2FS_DIRTY_META) < nr_pages_to_skip(sbi, META))\n\t\tgoto skip_write;\n\n\t/* if mounting is failed, skip writing node pages */\n\tmutex_lock(&sbi->cp_mutex);\n\tdiff = nr_pages_to_write(sbi, META, wbc);\n\twritten = sync_meta_pages(sbi, META, wbc->nr_to_write);\n\tmutex_unlock(&sbi->cp_mutex);\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - written - diff);\n\treturn 0;\n\nskip_write:\n\twbc->pages_skipped += get_pages(sbi, F2FS_DIRTY_META);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic int f2fs_write_meta_pages(struct address_space *mapping,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_M_SB(mapping);\n\tlong diff, written;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, META);\n\n\t/* collect a number of dirty meta pages and write together */\n\tif (wbc->for_kupdate ||\n\t\tget_pages(sbi, F2FS_DIRTY_META) < nr_pages_to_skip(sbi, META))\n\t\tgoto skip_write;\n\n\t/* if mounting is failed, skip writing node pages */\n\tmutex_lock(&sbi->cp_mutex);\n\tdiff = nr_pages_to_write(sbi, META, wbc);\n\twritten = sync_meta_pages(sbi, META, wbc->nr_to_write);\n\tmutex_unlock(&sbi->cp_mutex);\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - written - diff);\n\treturn 0;\n\nskip_write:\n\twbc->pages_skipped += get_pages(sbi, F2FS_DIRTY_META);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr_pages == 0"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "mapping",
            "&index",
            "PAGECACHE_TAG_DIRTY",
            "min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end - index",
            "(pgoff_t)PAGEVEC_SIZE-1"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "META_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "META_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "705-708",
          "snippet": "static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nlong sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,\n\t\t\t\t\t\tlong nr_to_write)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tpgoff_t index = 0, end = LONG_MAX;\n\tstruct pagevec pvec;\n\tlong nwritten = 0;\n\tstruct writeback_control wbc = {\n\t\t.for_reclaim = 0,\n\t};\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (unlikely(nr_pages == 0))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (f2fs_write_meta_page(page, &wbc)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnwritten++;\n\t\t\tif (unlikely(nwritten >= nr_to_write))\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (nwritten)\n\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\n\treturn nwritten;\n}"
  },
  {
    "function_name": "f2fs_write_meta_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "214-238",
    "snippet": "static int f2fs_write_meta_pages(struct address_space *mapping,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_M_SB(mapping);\n\tlong diff, written;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, META);\n\n\t/* collect a number of dirty meta pages and write together */\n\tif (wbc->for_kupdate ||\n\t\tget_pages(sbi, F2FS_DIRTY_META) < nr_pages_to_skip(sbi, META))\n\t\tgoto skip_write;\n\n\t/* if mounting is failed, skip writing node pages */\n\tmutex_lock(&sbi->cp_mutex);\n\tdiff = nr_pages_to_write(sbi, META, wbc);\n\twritten = sync_meta_pages(sbi, META, wbc->nr_to_write);\n\tmutex_unlock(&sbi->cp_mutex);\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - written - diff);\n\treturn 0;\n\nskip_write:\n\twbc->pages_skipped += get_pages(sbi, F2FS_DIRTY_META);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pages",
          "args": [
            "sbi",
            "F2FS_DIRTY_META"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "887-890",
          "snippet": "static inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(long)0",
            "wbc->nr_to_write - written - diff"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "get_max_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "168-180",
          "snippet": "static unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t/* SSR allocates in a segment unit */\n\tif (p->alloc_mode == SSR)\n\t\treturn 1 << sbi->log_blocks_per_seg;\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn (1 << sbi->log_blocks_per_seg) * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse /* No other gc_mode */\n\t\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t/* SSR allocates in a segment unit */\n\tif (p->alloc_mode == SSR)\n\t\treturn 1 << sbi->log_blocks_per_seg;\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn (1 << sbi->log_blocks_per_seg) * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse /* No other gc_mode */\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->cp_mutex"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_meta_pages",
          "args": [
            "sbi",
            "META",
            "wbc->nr_to_write"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "sync_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "240-295",
          "snippet": "long sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,\n\t\t\t\t\t\tlong nr_to_write)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tpgoff_t index = 0, end = LONG_MAX;\n\tstruct pagevec pvec;\n\tlong nwritten = 0;\n\tstruct writeback_control wbc = {\n\t\t.for_reclaim = 0,\n\t};\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (unlikely(nr_pages == 0))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (f2fs_write_meta_page(page, &wbc)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnwritten++;\n\t\t\tif (unlikely(nwritten >= nr_to_write))\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (nwritten)\n\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\n\treturn nwritten;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nlong sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,\n\t\t\t\t\t\tlong nr_to_write)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tpgoff_t index = 0, end = LONG_MAX;\n\tstruct pagevec pvec;\n\tlong nwritten = 0;\n\tstruct writeback_control wbc = {\n\t\t.for_reclaim = 0,\n\t};\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (unlikely(nr_pages == 0))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (f2fs_write_meta_page(page, &wbc)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnwritten++;\n\t\t\tif (unlikely(nwritten >= nr_to_write))\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (nwritten)\n\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\n\treturn nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_pages_to_write",
          "args": [
            "sbi",
            "META",
            "wbc"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "nr_pages_to_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "731-750",
          "snippet": "static inline long nr_pages_to_write(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tlong nr_to_write, desired;\n\n\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\treturn 0;\n\n\tnr_to_write = wbc->nr_to_write;\n\n\tif (type == DATA)\n\t\tdesired = 4096;\n\telse if (type == NODE)\n\t\tdesired = 3 * max_hw_blocks(sbi);\n\telse\n\t\tdesired = MAX_BIO_BLOCKS(sbi);\n\n\twbc->nr_to_write = desired;\n\treturn desired - nr_to_write;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline long nr_pages_to_write(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tlong nr_to_write, desired;\n\n\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\treturn 0;\n\n\tnr_to_write = wbc->nr_to_write;\n\n\tif (type == DATA)\n\t\tdesired = 4096;\n\telse if (type == NODE)\n\t\tdesired = 3 * max_hw_blocks(sbi);\n\telse\n\t\tdesired = MAX_BIO_BLOCKS(sbi);\n\n\twbc->nr_to_write = desired;\n\treturn desired - nr_to_write;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->cp_mutex"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_pages_to_skip",
          "args": [
            "sbi",
            "META"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "nr_pages_to_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "713-726",
          "snippet": "static inline int nr_pages_to_skip(struct f2fs_sb_info *sbi, int type)\n{\n\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\treturn 0;\n\n\tif (type == DATA)\n\t\treturn sbi->blocks_per_seg;\n\telse if (type == NODE)\n\t\treturn 3 * sbi->blocks_per_seg;\n\telse if (type == META)\n\t\treturn MAX_BIO_BLOCKS(sbi);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline int nr_pages_to_skip(struct f2fs_sb_info *sbi, int type)\n{\n\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\treturn 0;\n\n\tif (type == DATA)\n\t\treturn sbi->blocks_per_seg;\n\telse if (type == NODE)\n\t\treturn 3 * sbi->blocks_per_seg;\n\telse if (type == META)\n\t\treturn MAX_BIO_BLOCKS(sbi);\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_writepages",
          "args": [
            "mapping->host",
            "wbc",
            "META"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_M_SB",
          "args": [
            "mapping"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_M_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "650-653",
          "snippet": "static inline struct f2fs_sb_info *F2FS_M_SB(struct address_space *mapping)\n{\n\treturn F2FS_I_SB(mapping->host);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_M_SB(struct address_space *mapping)\n{\n\treturn F2FS_I_SB(mapping->host);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic int f2fs_write_meta_pages(struct address_space *mapping,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_M_SB(mapping);\n\tlong diff, written;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, META);\n\n\t/* collect a number of dirty meta pages and write together */\n\tif (wbc->for_kupdate ||\n\t\tget_pages(sbi, F2FS_DIRTY_META) < nr_pages_to_skip(sbi, META))\n\t\tgoto skip_write;\n\n\t/* if mounting is failed, skip writing node pages */\n\tmutex_lock(&sbi->cp_mutex);\n\tdiff = nr_pages_to_write(sbi, META, wbc);\n\twritten = sync_meta_pages(sbi, META, wbc->nr_to_write);\n\tmutex_unlock(&sbi->cp_mutex);\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - written - diff);\n\treturn 0;\n\nskip_write:\n\twbc->pages_skipped += get_pages(sbi, F2FS_DIRTY_META);\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_write_meta_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "186-212",
    "snippet": "static int f2fs_write_meta_page(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\ttrace_f2fs_writepage(page, META);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\tgoto redirty_out;\n\tif (wbc->for_reclaim && page->index < GET_SUM_BLOCK(sbi, 0))\n\t\tgoto redirty_out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto redirty_out;\n\n\tf2fs_wait_on_page_writeback(page, META);\n\twrite_meta_page(sbi, page);\n\tdec_page_count(sbi, F2FS_DIRTY_META);\n\tunlock_page(page);\n\n\tif (wbc->for_reclaim)\n\t\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\treturn 0;\n\nredirty_out:\n\tredirty_page_for_writepage(wbc, page);\n\treturn AOP_WRITEPAGE_ACTIVATE;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_submit_merged_bio",
          "args": [
            "sbi",
            "META",
            "WRITE"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "107-127",
          "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_page_count",
          "args": [
            "sbi",
            "F2FS_DIRTY_META"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "dec_page_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "871-874",
          "snippet": "static inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_meta_page",
          "args": [
            "sbi",
            "page"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_write_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "214-238",
          "snippet": "static int f2fs_write_meta_pages(struct address_space *mapping,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_M_SB(mapping);\n\tlong diff, written;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, META);\n\n\t/* collect a number of dirty meta pages and write together */\n\tif (wbc->for_kupdate ||\n\t\tget_pages(sbi, F2FS_DIRTY_META) < nr_pages_to_skip(sbi, META))\n\t\tgoto skip_write;\n\n\t/* if mounting is failed, skip writing node pages */\n\tmutex_lock(&sbi->cp_mutex);\n\tdiff = nr_pages_to_write(sbi, META, wbc);\n\twritten = sync_meta_pages(sbi, META, wbc->nr_to_write);\n\tmutex_unlock(&sbi->cp_mutex);\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - written - diff);\n\treturn 0;\n\nskip_write:\n\twbc->pages_skipped += get_pages(sbi, F2FS_DIRTY_META);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic int f2fs_write_meta_pages(struct address_space *mapping,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_M_SB(mapping);\n\tlong diff, written;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, META);\n\n\t/* collect a number of dirty meta pages and write together */\n\tif (wbc->for_kupdate ||\n\t\tget_pages(sbi, F2FS_DIRTY_META) < nr_pages_to_skip(sbi, META))\n\t\tgoto skip_write;\n\n\t/* if mounting is failed, skip writing node pages */\n\tmutex_lock(&sbi->cp_mutex);\n\tdiff = nr_pages_to_write(sbi, META, wbc);\n\twritten = sync_meta_pages(sbi, META, wbc->nr_to_write);\n\tmutex_unlock(&sbi->cp_mutex);\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - written - diff);\n\treturn 0;\n\nskip_write:\n\twbc->pages_skipped += get_pages(sbi, F2FS_DIRTY_META);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "META"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_cp_error",
          "args": [
            "sbi"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_cp_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1310-1313",
          "snippet": "static inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SUM_BLOCK",
          "args": [
            "sbi",
            "0"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_sbi_flag_set(sbi, SBI_POR_DOING)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sbi_flag_set",
          "args": [
            "sbi",
            "SBI_POR_DOING"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "is_sbi_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "715-718",
          "snippet": "static inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn sbi->s_flag & (0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn sbi->s_flag & (0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_writepage",
          "args": [
            "page",
            "META"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_P_SB",
          "args": [
            "page"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_P_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "655-658",
          "snippet": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic int f2fs_write_meta_page(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\ttrace_f2fs_writepage(page, META);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\tgoto redirty_out;\n\tif (wbc->for_reclaim && page->index < GET_SUM_BLOCK(sbi, 0))\n\t\tgoto redirty_out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto redirty_out;\n\n\tf2fs_wait_on_page_writeback(page, META);\n\twrite_meta_page(sbi, page);\n\tdec_page_count(sbi, F2FS_DIRTY_META);\n\tunlock_page(page);\n\n\tif (wbc->for_reclaim)\n\t\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\treturn 0;\n\nredirty_out:\n\tredirty_page_for_writepage(wbc, page);\n\treturn AOP_WRITEPAGE_ACTIVATE;\n}"
  },
  {
    "function_name": "ra_meta_pages_cond",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "172-184",
    "snippet": "void ra_meta_pages_cond(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct page *page;\n\tbool readahead = false;\n\n\tpage = find_get_page(META_MAPPING(sbi), index);\n\tif (!page || (page && !PageUptodate(page)))\n\t\treadahead = true;\n\tf2fs_put_page(page, 0);\n\n\tif (readahead)\n\t\tra_meta_pages(sbi, index, MAX_BIO_BLOCKS(sbi), META_POR);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ra_meta_pages",
          "args": [
            "sbi",
            "index",
            "MAX_BIO_BLOCKS(sbi)",
            "META_POR"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "ra_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "115-170",
          "snippet": "int ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_BIO_BLOCKS",
          "args": [
            "sbi"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "0"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "META_MAPPING(sbi)",
            "index"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "META_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "META_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "705-708",
          "snippet": "static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid ra_meta_pages_cond(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct page *page;\n\tbool readahead = false;\n\n\tpage = find_get_page(META_MAPPING(sbi), index);\n\tif (!page || (page && !PageUptodate(page)))\n\t\treadahead = true;\n\tf2fs_put_page(page, 0);\n\n\tif (readahead)\n\t\tra_meta_pages(sbi, index, MAX_BIO_BLOCKS(sbi), META_POR);\n}"
  },
  {
    "function_name": "ra_meta_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "115-170",
    "snippet": "int ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_submit_merged_bio",
          "args": [
            "sbi",
            "META",
            "READ"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "107-127",
          "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "0"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_submit_page_mbio",
          "args": [
            "sbi",
            "page",
            "&fio"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_page_mbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "154-192",
          "snippet": "void f2fs_submit_page_mbio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(fio->type);\n\tstruct f2fs_bio_info *io;\n\tbool is_read = is_read_io(fio->rw);\n\n\tio = is_read ? &sbi->read_io : &sbi->write_io[btype];\n\n\tverify_block_addr(sbi, fio->blk_addr);\n\n\tdown_write(&io->io_rwsem);\n\n\tif (!is_read)\n\t\tinc_page_count(sbi, F2FS_WRITEBACK);\n\n\tif (io->bio && (io->last_block_in_bio != fio->blk_addr - 1 ||\n\t\t\t\t\t\tio->fio.rw != fio->rw))\n\t\t__submit_merged_bio(io);\nalloc_new:\n\tif (io->bio == NULL) {\n\t\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\n\t\tio->bio = __bio_alloc(sbi, fio->blk_addr, bio_blocks, is_read);\n\t\tio->fio = *fio;\n\t}\n\n\tif (bio_add_page(io->bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE) {\n\t\t__submit_merged_bio(io);\n\t\tgoto alloc_new;\n\t}\n\n\tio->last_block_in_bio = fio->blk_addr;\n\tf2fs_trace_ios(page, fio, 0);\n\n\tup_write(&io->io_rwsem);\n\ttrace_f2fs_submit_page_mbio(page, fio);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_page_mbio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(fio->type);\n\tstruct f2fs_bio_info *io;\n\tbool is_read = is_read_io(fio->rw);\n\n\tio = is_read ? &sbi->read_io : &sbi->write_io[btype];\n\n\tverify_block_addr(sbi, fio->blk_addr);\n\n\tdown_write(&io->io_rwsem);\n\n\tif (!is_read)\n\t\tinc_page_count(sbi, F2FS_WRITEBACK);\n\n\tif (io->bio && (io->last_block_in_bio != fio->blk_addr - 1 ||\n\t\t\t\t\t\tio->fio.rw != fio->rw))\n\t\t__submit_merged_bio(io);\nalloc_new:\n\tif (io->bio == NULL) {\n\t\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\n\t\tio->bio = __bio_alloc(sbi, fio->blk_addr, bio_blocks, is_read);\n\t\tio->fio = *fio;\n\t}\n\n\tif (bio_add_page(io->bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE) {\n\t\t__submit_merged_bio(io);\n\t\tgoto alloc_new;\n\t}\n\n\tio->last_block_in_bio = fio->blk_addr;\n\tf2fs_trace_ios(page, fio, 0);\n\n\tup_write(&io->io_rwsem);\n\ttrace_f2fs_submit_page_mbio(page, fio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "META_MAPPING(sbi)",
            "fio.blk_addr"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "META_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "META_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "705-708",
          "snippet": "static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_sit_addr",
          "args": [
            "sbi",
            "blkno * SIT_ENTRY_PER_BLOCK"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "current_sit_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "628-642",
          "snippet": "static inline pgoff_t current_sit_addr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int offset = SIT_BLOCK_OFFSET(start);\n\tblock_t blk_addr = sit_i->sit_base_addr + offset;\n\n\tcheck_seg_range(sbi, start);\n\n\t/* calculate sit block address */\n\tif (f2fs_test_bit(offset, sit_i->sit_bitmap))\n\t\tblk_addr += sit_i->sit_blocks;\n\n\treturn blk_addr;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline pgoff_t current_sit_addr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int offset = SIT_BLOCK_OFFSET(start);\n\tblock_t blk_addr = sit_i->sit_base_addr + offset;\n\n\tcheck_seg_range(sbi, start);\n\n\t/* calculate sit block address */\n\tif (f2fs_test_bit(offset, sit_i->sit_bitmap))\n\t\tblk_addr += sit_i->sit_blocks;\n\n\treturn blk_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_nat_addr",
          "args": [
            "sbi",
            "blkno * NAT_ENTRY_PER_BLOCK"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "current_nat_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "171-189",
          "snippet": "static inline pgoff_t current_nat_addr(struct f2fs_sb_info *sbi, nid_t start)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tpgoff_t block_off;\n\tpgoff_t block_addr;\n\tint seg_off;\n\n\tblock_off = NAT_BLOCK_OFFSET(start);\n\tseg_off = block_off >> sbi->log_blocks_per_seg;\n\n\tblock_addr = (pgoff_t)(nm_i->nat_blkaddr +\n\t\t(seg_off << sbi->log_blocks_per_seg << 1) +\n\t\t(block_off & ((1 << sbi->log_blocks_per_seg) - 1)));\n\n\tif (f2fs_test_bit(block_off, nm_i->nat_bitmap))\n\t\tblock_addr += sbi->blocks_per_seg;\n\n\treturn block_addr;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline pgoff_t current_nat_addr(struct f2fs_sb_info *sbi, nid_t start)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tpgoff_t block_off;\n\tpgoff_t block_addr;\n\tint seg_off;\n\n\tblock_off = NAT_BLOCK_OFFSET(start);\n\tseg_off = block_off >> sbi->log_blocks_per_seg;\n\n\tblock_addr = (pgoff_t)(nm_i->nat_blkaddr +\n\t\t(seg_off << sbi->log_blocks_per_seg << 1) +\n\t\t(block_off & ((1 << sbi->log_blocks_per_seg) - 1)));\n\n\tif (f2fs_test_bit(block_off, nm_i->nat_bitmap))\n\t\tblock_addr += sbi->blocks_per_seg;\n\n\treturn block_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NAT_BLOCK_OFFSET",
          "args": [
            "NM_I(sbi)->max_nid"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_valid_blkaddr",
          "args": [
            "sbi",
            "blkno",
            "type"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "is_valid_blkaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "80-110",
          "snippet": "static inline bool is_valid_blkaddr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tswitch (type) {\n\tcase META_NAT:\n\t\tbreak;\n\tcase META_SIT:\n\t\tif (unlikely(blkaddr >= SIT_BLK_CNT(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_SSA:\n\t\tif (unlikely(blkaddr >= MAIN_BLKADDR(sbi) ||\n\t\t\tblkaddr < SM_I(sbi)->ssa_blkaddr))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_CP:\n\t\tif (unlikely(blkaddr >= SIT_I(sbi)->sit_base_addr ||\n\t\t\tblkaddr < __start_cp_addr(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_POR:\n\t\tif (unlikely(blkaddr >= MAX_BLKADDR(sbi) ||\n\t\t\tblkaddr < MAIN_BLKADDR(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic inline bool is_valid_blkaddr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tswitch (type) {\n\tcase META_NAT:\n\t\tbreak;\n\tcase META_SIT:\n\t\tif (unlikely(blkaddr >= SIT_BLK_CNT(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_SSA:\n\t\tif (unlikely(blkaddr >= MAIN_BLKADDR(sbi) ||\n\t\t\tblkaddr < SM_I(sbi)->ssa_blkaddr))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_CP:\n\t\tif (unlikely(blkaddr >= SIT_I(sbi)->sit_base_addr ||\n\t\t\tblkaddr < __start_cp_addr(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_POR:\n\t\tif (unlikely(blkaddr >= MAX_BLKADDR(sbi) ||\n\t\t\tblkaddr < MAIN_BLKADDR(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}"
  },
  {
    "function_name": "is_valid_blkaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "80-110",
    "snippet": "static inline bool is_valid_blkaddr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tswitch (type) {\n\tcase META_NAT:\n\t\tbreak;\n\tcase META_SIT:\n\t\tif (unlikely(blkaddr >= SIT_BLK_CNT(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_SSA:\n\t\tif (unlikely(blkaddr >= MAIN_BLKADDR(sbi) ||\n\t\t\tblkaddr < SM_I(sbi)->ssa_blkaddr))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_CP:\n\t\tif (unlikely(blkaddr >= SIT_I(sbi)->sit_base_addr ||\n\t\t\tblkaddr < __start_cp_addr(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_POR:\n\t\tif (unlikely(blkaddr >= MAX_BLKADDR(sbi) ||\n\t\t\tblkaddr < MAIN_BLKADDR(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "blkaddr >= MAX_BLKADDR(sbi) ||\n\t\t\tblkaddr < MAIN_BLKADDR(sbi)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "blkaddr >= SIT_I(sbi)->sit_base_addr ||\n\t\t\tblkaddr < __start_cp_addr(sbi)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__start_cp_addr",
          "args": [
            "sbi"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "__start_cp_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "940-956",
          "snippet": "static inline block_t __start_cp_addr(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_addr;\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_version = cur_cp_version(ckpt);\n\n\tstart_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_blkaddr);\n\n\t/*\n\t * odd numbered checkpoint should at cp segment 0\n\t * and even segment must be at cp segment 1\n\t */\n\tif (!(ckpt_version & 1))\n\t\tstart_addr += sbi->blocks_per_seg;\n\n\treturn start_addr;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline block_t __start_cp_addr(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_addr;\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_version = cur_cp_version(ckpt);\n\n\tstart_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_blkaddr);\n\n\t/*\n\t * odd numbered checkpoint should at cp segment 0\n\t * and even segment must be at cp segment 1\n\t */\n\tif (!(ckpt_version & 1))\n\t\tstart_addr += sbi->blocks_per_seg;\n\n\treturn start_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "blkaddr >= MAIN_BLKADDR(sbi) ||\n\t\t\tblkaddr < SM_I(sbi)->ssa_blkaddr"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SM_I",
          "args": [
            "sbi"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "SM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "685-688",
          "snippet": "static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "blkaddr >= SIT_BLK_CNT(sbi)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_BLK_CNT",
          "args": [
            "sbi"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstatic inline bool is_valid_blkaddr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tswitch (type) {\n\tcase META_NAT:\n\t\tbreak;\n\tcase META_SIT:\n\t\tif (unlikely(blkaddr >= SIT_BLK_CNT(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_SSA:\n\t\tif (unlikely(blkaddr >= MAIN_BLKADDR(sbi) ||\n\t\t\tblkaddr < SM_I(sbi)->ssa_blkaddr))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_CP:\n\t\tif (unlikely(blkaddr >= SIT_I(sbi)->sit_base_addr ||\n\t\t\tblkaddr < __start_cp_addr(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_POR:\n\t\tif (unlikely(blkaddr >= MAX_BLKADDR(sbi) ||\n\t\t\tblkaddr < MAIN_BLKADDR(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "get_meta_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "50-78",
    "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_submit_page_bio",
          "args": [
            "sbi",
            "page",
            "&fio"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_page_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "133-152",
          "snippet": "int f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "META_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "META_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "705-708",
          "snippet": "static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
  },
  {
    "function_name": "grab_meta_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
    "lines": "32-45",
    "snippet": "struct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "META"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "META_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "META_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "705-708",
          "snippet": "static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}"
  }
]