[
  {
    "function_name": "ceph_mdsmap_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mdsmap.c",
    "lines": "180-189",
    "snippet": "void ceph_mdsmap_destroy(struct ceph_mdsmap *m)\n{\n\tint i;\n\n\tfor (i = 0; i < m->m_max_mds; i++)\n\t\tkfree(m->m_info[i].export_targets);\n\tkfree(m->m_info);\n\tkfree(m->m_data_pg_pools);\n\tkfree(m);\n}",
    "includes": [
      "#include \"super.h\"",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/mdsmap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "m"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "m->m_data_pg_pools"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "m->m_info"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "m->m_info[i].export_targets"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"super.h\"\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsmap_destroy(struct ceph_mdsmap *m)\n{\n\tint i;\n\n\tfor (i = 0; i < m->m_max_mds; i++)\n\t\tkfree(m->m_info[i].export_targets);\n\tkfree(m->m_info);\n\tkfree(m->m_data_pg_pools);\n\tkfree(m);\n}"
  },
  {
    "function_name": "ceph_mdsmap_decode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mdsmap.c",
    "lines": "51-178",
    "snippet": "struct ceph_mdsmap *ceph_mdsmap_decode(void **p, void *end)\n{\n\tstruct ceph_mdsmap *m;\n\tconst void *start = *p;\n\tint i, j, n;\n\tint err = -EINVAL;\n\tu16 version;\n\n\tm = kzalloc(sizeof(*m), GFP_NOFS);\n\tif (m == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tceph_decode_16_safe(p, end, version, bad);\n\tif (version > 3) {\n\t\tpr_warn(\"got mdsmap version %d > 3, failing\", version);\n\t\tgoto bad;\n\t}\n\n\tceph_decode_need(p, end, 8*sizeof(u32) + sizeof(u64), bad);\n\tm->m_epoch = ceph_decode_32(p);\n\tm->m_client_epoch = ceph_decode_32(p);\n\tm->m_last_failure = ceph_decode_32(p);\n\tm->m_root = ceph_decode_32(p);\n\tm->m_session_timeout = ceph_decode_32(p);\n\tm->m_session_autoclose = ceph_decode_32(p);\n\tm->m_max_file_size = ceph_decode_64(p);\n\tm->m_max_mds = ceph_decode_32(p);\n\n\tm->m_info = kcalloc(m->m_max_mds, sizeof(*m->m_info), GFP_NOFS);\n\tif (m->m_info == NULL)\n\t\tgoto badmem;\n\n\t/* pick out active nodes from mds_info (state > 0) */\n\tn = ceph_decode_32(p);\n\tfor (i = 0; i < n; i++) {\n\t\tu64 global_id;\n\t\tu32 namelen;\n\t\ts32 mds, inc, state;\n\t\tu64 state_seq;\n\t\tu8 infoversion;\n\t\tstruct ceph_entity_addr addr;\n\t\tu32 num_export_targets;\n\t\tvoid *pexport_targets = NULL;\n\t\tstruct ceph_timespec laggy_since;\n\t\tstruct ceph_mds_info *info;\n\n\t\tceph_decode_need(p, end, sizeof(u64)*2 + 1 + sizeof(u32), bad);\n\t\tglobal_id = ceph_decode_64(p);\n\t\tinfoversion = ceph_decode_8(p);\n\t\t*p += sizeof(u64);\n\t\tnamelen = ceph_decode_32(p);  /* skip mds name */\n\t\t*p += namelen;\n\n\t\tceph_decode_need(p, end,\n\t\t\t\t 4*sizeof(u32) + sizeof(u64) +\n\t\t\t\t sizeof(addr) + sizeof(struct ceph_timespec),\n\t\t\t\t bad);\n\t\tmds = ceph_decode_32(p);\n\t\tinc = ceph_decode_32(p);\n\t\tstate = ceph_decode_32(p);\n\t\tstate_seq = ceph_decode_64(p);\n\t\tceph_decode_copy(p, &addr, sizeof(addr));\n\t\tceph_decode_addr(&addr);\n\t\tceph_decode_copy(p, &laggy_since, sizeof(laggy_since));\n\t\t*p += sizeof(u32);\n\t\tceph_decode_32_safe(p, end, namelen, bad);\n\t\t*p += namelen;\n\t\tif (infoversion >= 2) {\n\t\t\tceph_decode_32_safe(p, end, num_export_targets, bad);\n\t\t\tpexport_targets = *p;\n\t\t\t*p += num_export_targets * sizeof(u32);\n\t\t} else {\n\t\t\tnum_export_targets = 0;\n\t\t}\n\n\t\tdout(\"mdsmap_decode %d/%d %lld mds%d.%d %s %s\\n\",\n\t\t     i+1, n, global_id, mds, inc,\n\t\t     ceph_pr_addr(&addr.in_addr),\n\t\t     ceph_mds_state_name(state));\n\n\t\tif (mds < 0 || mds >= m->m_max_mds || state <= 0)\n\t\t\tcontinue;\n\n\t\tinfo = &m->m_info[mds];\n\t\tinfo->global_id = global_id;\n\t\tinfo->state = state;\n\t\tinfo->addr = addr;\n\t\tinfo->laggy = (laggy_since.tv_sec != 0 ||\n\t\t\t       laggy_since.tv_nsec != 0);\n\t\tinfo->num_export_targets = num_export_targets;\n\t\tif (num_export_targets) {\n\t\t\tinfo->export_targets = kcalloc(num_export_targets,\n\t\t\t\t\t\t       sizeof(u32), GFP_NOFS);\n\t\t\tif (info->export_targets == NULL)\n\t\t\t\tgoto badmem;\n\t\t\tfor (j = 0; j < num_export_targets; j++)\n\t\t\t\tinfo->export_targets[j] =\n\t\t\t\t       ceph_decode_32(&pexport_targets);\n\t\t} else {\n\t\t\tinfo->export_targets = NULL;\n\t\t}\n\t}\n\n\t/* pg_pools */\n\tceph_decode_32_safe(p, end, n, bad);\n\tm->m_num_data_pg_pools = n;\n\tm->m_data_pg_pools = kcalloc(n, sizeof(u64), GFP_NOFS);\n\tif (!m->m_data_pg_pools)\n\t\tgoto badmem;\n\tceph_decode_need(p, end, sizeof(u64)*(n+1), bad);\n\tfor (i = 0; i < n; i++)\n\t\tm->m_data_pg_pools[i] = ceph_decode_64(p);\n\tm->m_cas_pg_pool = ceph_decode_64(p);\n\n\t/* ok, we don't care about the rest. */\n\tdout(\"mdsmap_decode success epoch %u\\n\", m->m_epoch);\n\treturn m;\n\nbadmem:\n\terr = -ENOMEM;\nbad:\n\tpr_err(\"corrupt mdsmap\\n\");\n\tprint_hex_dump(KERN_DEBUG, \"mdsmap: \",\n\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       start, end - start, true);\n\tceph_mdsmap_destroy(m);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"super.h\"",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/mdsmap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_destroy",
          "args": [
            "m"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mdsmap.c",
          "lines": "180-189",
          "snippet": "void ceph_mdsmap_destroy(struct ceph_mdsmap *m)\n{\n\tint i;\n\n\tfor (i = 0; i < m->m_max_mds; i++)\n\t\tkfree(m->m_info[i].export_targets);\n\tkfree(m->m_info);\n\tkfree(m->m_data_pg_pools);\n\tkfree(m);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/err.h>",
            "#include <linux/bug.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsmap_destroy(struct ceph_mdsmap *m)\n{\n\tint i;\n\n\tfor (i = 0; i < m->m_max_mds; i++)\n\t\tkfree(m->m_info[i].export_targets);\n\tkfree(m->m_info);\n\tkfree(m->m_data_pg_pools);\n\tkfree(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_DEBUG",
            "\"mdsmap: \"",
            "DUMP_PREFIX_OFFSET",
            "16",
            "1",
            "start",
            "end - start",
            "true"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"corrupt mdsmap\\n\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mdsmap_decode success epoch %u\\n\"",
            "m->m_epoch"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_64",
          "args": [
            "p"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_64",
          "args": [
            "p"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "p",
            "end",
            "sizeof(u64)*(n+1)",
            "bad"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "n",
            "sizeof(u64)",
            "GFP_NOFS"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "p",
            "end",
            "n",
            "bad"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "&pexport_targets"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "num_export_targets",
            "sizeof(u32)",
            "GFP_NOFS"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mdsmap_decode %d/%d %lld mds%d.%d %s %s\\n\"",
            "i+1",
            "n",
            "global_id",
            "mds",
            "inc",
            "ceph_pr_addr(&addr.in_addr)",
            "ceph_mds_state_name(state)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mds_state_name",
          "args": [
            "state"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mds_state_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "8-31",
          "snippet": "const char *ceph_mds_state_name(int s)\n{\n\tswitch (s) {\n\t\t/* down and out */\n\tcase CEPH_MDS_STATE_DNE:        return \"down:dne\";\n\tcase CEPH_MDS_STATE_STOPPED:    return \"down:stopped\";\n\t\t/* up and out */\n\tcase CEPH_MDS_STATE_BOOT:       return \"up:boot\";\n\tcase CEPH_MDS_STATE_STANDBY:    return \"up:standby\";\n\tcase CEPH_MDS_STATE_STANDBY_REPLAY:    return \"up:standby-replay\";\n\tcase CEPH_MDS_STATE_REPLAYONCE: return \"up:oneshot-replay\";\n\tcase CEPH_MDS_STATE_CREATING:   return \"up:creating\";\n\tcase CEPH_MDS_STATE_STARTING:   return \"up:starting\";\n\t\t/* up and in */\n\tcase CEPH_MDS_STATE_REPLAY:     return \"up:replay\";\n\tcase CEPH_MDS_STATE_RESOLVE:    return \"up:resolve\";\n\tcase CEPH_MDS_STATE_RECONNECT:  return \"up:reconnect\";\n\tcase CEPH_MDS_STATE_REJOIN:     return \"up:rejoin\";\n\tcase CEPH_MDS_STATE_CLIENTREPLAY: return \"up:clientreplay\";\n\tcase CEPH_MDS_STATE_ACTIVE:     return \"up:active\";\n\tcase CEPH_MDS_STATE_STOPPING:   return \"up:stopping\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_mds_state_name(int s)\n{\n\tswitch (s) {\n\t\t/* down and out */\n\tcase CEPH_MDS_STATE_DNE:        return \"down:dne\";\n\tcase CEPH_MDS_STATE_STOPPED:    return \"down:stopped\";\n\t\t/* up and out */\n\tcase CEPH_MDS_STATE_BOOT:       return \"up:boot\";\n\tcase CEPH_MDS_STATE_STANDBY:    return \"up:standby\";\n\tcase CEPH_MDS_STATE_STANDBY_REPLAY:    return \"up:standby-replay\";\n\tcase CEPH_MDS_STATE_REPLAYONCE: return \"up:oneshot-replay\";\n\tcase CEPH_MDS_STATE_CREATING:   return \"up:creating\";\n\tcase CEPH_MDS_STATE_STARTING:   return \"up:starting\";\n\t\t/* up and in */\n\tcase CEPH_MDS_STATE_REPLAY:     return \"up:replay\";\n\tcase CEPH_MDS_STATE_RESOLVE:    return \"up:resolve\";\n\tcase CEPH_MDS_STATE_RECONNECT:  return \"up:reconnect\";\n\tcase CEPH_MDS_STATE_REJOIN:     return \"up:rejoin\";\n\tcase CEPH_MDS_STATE_CLIENTREPLAY: return \"up:clientreplay\";\n\tcase CEPH_MDS_STATE_ACTIVE:     return \"up:active\";\n\tcase CEPH_MDS_STATE_STOPPING:   return \"up:stopping\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_pr_addr",
          "args": [
            "&addr.in_addr"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "p",
            "end",
            "num_export_targets",
            "bad"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "p",
            "end",
            "namelen",
            "bad"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_copy",
          "args": [
            "p",
            "&laggy_since",
            "sizeof(laggy_since)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_addr",
          "args": [
            "&addr"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_copy",
          "args": [
            "p",
            "&addr",
            "sizeof(addr)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_64",
          "args": [
            "p"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "p",
            "end",
            "4*sizeof(u32) + sizeof(u64) +\n\t\t\t\t sizeof(addr) + sizeof(struct ceph_timespec)",
            "bad"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_8",
          "args": [
            "p"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_64",
          "args": [
            "p"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "p",
            "end",
            "sizeof(u64)*2 + 1 + sizeof(u32)",
            "bad"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "m->m_max_mds",
            "sizeof(*m->m_info)",
            "GFP_NOFS"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_64",
          "args": [
            "p"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "p",
            "end",
            "8*sizeof(u32) + sizeof(u64)",
            "bad"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"got mdsmap version %d > 3, failing\"",
            "version"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_16_safe",
          "args": [
            "p",
            "end",
            "version",
            "bad"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*m)",
            "GFP_NOFS"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"super.h\"\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mdsmap *ceph_mdsmap_decode(void **p, void *end)\n{\n\tstruct ceph_mdsmap *m;\n\tconst void *start = *p;\n\tint i, j, n;\n\tint err = -EINVAL;\n\tu16 version;\n\n\tm = kzalloc(sizeof(*m), GFP_NOFS);\n\tif (m == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tceph_decode_16_safe(p, end, version, bad);\n\tif (version > 3) {\n\t\tpr_warn(\"got mdsmap version %d > 3, failing\", version);\n\t\tgoto bad;\n\t}\n\n\tceph_decode_need(p, end, 8*sizeof(u32) + sizeof(u64), bad);\n\tm->m_epoch = ceph_decode_32(p);\n\tm->m_client_epoch = ceph_decode_32(p);\n\tm->m_last_failure = ceph_decode_32(p);\n\tm->m_root = ceph_decode_32(p);\n\tm->m_session_timeout = ceph_decode_32(p);\n\tm->m_session_autoclose = ceph_decode_32(p);\n\tm->m_max_file_size = ceph_decode_64(p);\n\tm->m_max_mds = ceph_decode_32(p);\n\n\tm->m_info = kcalloc(m->m_max_mds, sizeof(*m->m_info), GFP_NOFS);\n\tif (m->m_info == NULL)\n\t\tgoto badmem;\n\n\t/* pick out active nodes from mds_info (state > 0) */\n\tn = ceph_decode_32(p);\n\tfor (i = 0; i < n; i++) {\n\t\tu64 global_id;\n\t\tu32 namelen;\n\t\ts32 mds, inc, state;\n\t\tu64 state_seq;\n\t\tu8 infoversion;\n\t\tstruct ceph_entity_addr addr;\n\t\tu32 num_export_targets;\n\t\tvoid *pexport_targets = NULL;\n\t\tstruct ceph_timespec laggy_since;\n\t\tstruct ceph_mds_info *info;\n\n\t\tceph_decode_need(p, end, sizeof(u64)*2 + 1 + sizeof(u32), bad);\n\t\tglobal_id = ceph_decode_64(p);\n\t\tinfoversion = ceph_decode_8(p);\n\t\t*p += sizeof(u64);\n\t\tnamelen = ceph_decode_32(p);  /* skip mds name */\n\t\t*p += namelen;\n\n\t\tceph_decode_need(p, end,\n\t\t\t\t 4*sizeof(u32) + sizeof(u64) +\n\t\t\t\t sizeof(addr) + sizeof(struct ceph_timespec),\n\t\t\t\t bad);\n\t\tmds = ceph_decode_32(p);\n\t\tinc = ceph_decode_32(p);\n\t\tstate = ceph_decode_32(p);\n\t\tstate_seq = ceph_decode_64(p);\n\t\tceph_decode_copy(p, &addr, sizeof(addr));\n\t\tceph_decode_addr(&addr);\n\t\tceph_decode_copy(p, &laggy_since, sizeof(laggy_since));\n\t\t*p += sizeof(u32);\n\t\tceph_decode_32_safe(p, end, namelen, bad);\n\t\t*p += namelen;\n\t\tif (infoversion >= 2) {\n\t\t\tceph_decode_32_safe(p, end, num_export_targets, bad);\n\t\t\tpexport_targets = *p;\n\t\t\t*p += num_export_targets * sizeof(u32);\n\t\t} else {\n\t\t\tnum_export_targets = 0;\n\t\t}\n\n\t\tdout(\"mdsmap_decode %d/%d %lld mds%d.%d %s %s\\n\",\n\t\t     i+1, n, global_id, mds, inc,\n\t\t     ceph_pr_addr(&addr.in_addr),\n\t\t     ceph_mds_state_name(state));\n\n\t\tif (mds < 0 || mds >= m->m_max_mds || state <= 0)\n\t\t\tcontinue;\n\n\t\tinfo = &m->m_info[mds];\n\t\tinfo->global_id = global_id;\n\t\tinfo->state = state;\n\t\tinfo->addr = addr;\n\t\tinfo->laggy = (laggy_since.tv_sec != 0 ||\n\t\t\t       laggy_since.tv_nsec != 0);\n\t\tinfo->num_export_targets = num_export_targets;\n\t\tif (num_export_targets) {\n\t\t\tinfo->export_targets = kcalloc(num_export_targets,\n\t\t\t\t\t\t       sizeof(u32), GFP_NOFS);\n\t\t\tif (info->export_targets == NULL)\n\t\t\t\tgoto badmem;\n\t\t\tfor (j = 0; j < num_export_targets; j++)\n\t\t\t\tinfo->export_targets[j] =\n\t\t\t\t       ceph_decode_32(&pexport_targets);\n\t\t} else {\n\t\t\tinfo->export_targets = NULL;\n\t\t}\n\t}\n\n\t/* pg_pools */\n\tceph_decode_32_safe(p, end, n, bad);\n\tm->m_num_data_pg_pools = n;\n\tm->m_data_pg_pools = kcalloc(n, sizeof(u64), GFP_NOFS);\n\tif (!m->m_data_pg_pools)\n\t\tgoto badmem;\n\tceph_decode_need(p, end, sizeof(u64)*(n+1), bad);\n\tfor (i = 0; i < n; i++)\n\t\tm->m_data_pg_pools[i] = ceph_decode_64(p);\n\tm->m_cas_pg_pool = ceph_decode_64(p);\n\n\t/* ok, we don't care about the rest. */\n\tdout(\"mdsmap_decode success epoch %u\\n\", m->m_epoch);\n\treturn m;\n\nbadmem:\n\terr = -ENOMEM;\nbad:\n\tpr_err(\"corrupt mdsmap\\n\");\n\tprint_hex_dump(KERN_DEBUG, \"mdsmap: \",\n\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       start, end - start, true);\n\tceph_mdsmap_destroy(m);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "ceph_mdsmap_get_random_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mdsmap.c",
    "lines": "19-43",
    "snippet": "int ceph_mdsmap_get_random_mds(struct ceph_mdsmap *m)\n{\n\tint n = 0;\n\tint i;\n\n\t/* special case for one mds */\n\tif (1 == m->m_max_mds && m->m_info[0].state > 0)\n\t\treturn 0;\n\n\t/* count */\n\tfor (i = 0; i < m->m_max_mds; i++)\n\t\tif (m->m_info[i].state > 0)\n\t\t\tn++;\n\tif (n == 0)\n\t\treturn -1;\n\n\t/* pick */\n\tn = prandom_u32() % n;\n\ti = 0;\n\tfor (i = 0; n > 0; i++, n--)\n\t\twhile (m->m_info[i].state <= 0)\n\t\t\ti++;\n\n\treturn i;\n}",
    "includes": [
      "#include \"super.h\"",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/mdsmap.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"super.h\"\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_mdsmap_get_random_mds(struct ceph_mdsmap *m)\n{\n\tint n = 0;\n\tint i;\n\n\t/* special case for one mds */\n\tif (1 == m->m_max_mds && m->m_info[0].state > 0)\n\t\treturn 0;\n\n\t/* count */\n\tfor (i = 0; i < m->m_max_mds; i++)\n\t\tif (m->m_info[i].state > 0)\n\t\t\tn++;\n\tif (n == 0)\n\t\treturn -1;\n\n\t/* pick */\n\tn = prandom_u32() % n;\n\ti = 0;\n\tfor (i = 0; n > 0; i++, n--)\n\t\twhile (m->m_info[i].state <= 0)\n\t\t\ti++;\n\n\treturn i;\n}"
  }
]