[
  {
    "function_name": "ocfs2_xattr_user_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7398-7410",
    "snippet": "static int ocfs2_xattr_user_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\tif (osb->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ocfs2_xattr_set(dentry->d_inode, OCFS2_XATTR_INDEX_USER,\n\t\t\t       name, value, size, flags);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_set",
          "args": [
            "dentry->d_inode",
            "OCFS2_XATTR_INDEX_USER",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 7408
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3512-3661",
          "snippet": "int ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Only xbs will be used on indexed trees.  xis doesn't need a\n\t * bucket.\n\t */\n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t/*\n\t * Scan inode and external block to find the same name\n\t * extended attribute and collect search information.\n\t */\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Check whether the value is refcounted and do some preparation. */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tl_inode->i_mutex);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* we need to update inode's ctime field, so add credit for it. */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock(inode, 1);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nint ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Only xbs will be used on indexed trees.  xis doesn't need a\n\t * bucket.\n\t */\n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t/*\n\t * Scan inode and external block to find the same name\n\t * extended attribute and collect search information.\n\t */\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Check whether the value is refcounted and do some preparation. */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tl_inode->i_mutex);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* we need to update inode's ctime field, so add credit for it. */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock(inode, 1);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 7403
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 7401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_user_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\tif (osb->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ocfs2_xattr_set(dentry->d_inode, OCFS2_XATTR_INDEX_USER,\n\t\t\t       name, value, size, flags);\n}"
  },
  {
    "function_name": "ocfs2_xattr_user_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7385-7396",
    "snippet": "static int ocfs2_xattr_user_get(struct dentry *dentry, const char *name,\n\t\tvoid *buffer, size_t size, int type)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\tif (osb->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)\n\t\treturn -EOPNOTSUPP;\n\treturn ocfs2_xattr_get(dentry->d_inode, OCFS2_XATTR_INDEX_USER, name,\n\t\t\t       buffer, size);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_get",
          "args": [
            "dentry->d_inode",
            "OCFS2_XATTR_INDEX_USER",
            "name",
            "buffer",
            "size"
          ],
          "line": 7394
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1306-1330",
          "snippet": "static int ocfs2_xattr_get(struct inode *inode,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\tdown_read(&OCFS2_I(inode)->ip_xattr_sem);\n\tret = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t     name, buffer, buffer_size);\n\tup_read(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock(inode, 0);\n\n\tbrelse(di_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_get(struct inode *inode,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\tdown_read(&OCFS2_I(inode)->ip_xattr_sem);\n\tret = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t     name, buffer, buffer_size);\n\tup_read(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock(inode, 0);\n\n\tbrelse(di_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 7390
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 7388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_user_get(struct dentry *dentry, const char *name,\n\t\tvoid *buffer, size_t size, int type)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\tif (osb->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)\n\t\treturn -EOPNOTSUPP;\n\treturn ocfs2_xattr_get(dentry->d_inode, OCFS2_XATTR_INDEX_USER, name,\n\t\t\t       buffer, size);\n}"
  },
  {
    "function_name": "ocfs2_xattr_user_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7366-7383",
    "snippet": "static size_t ocfs2_xattr_user_list(struct dentry *dentry, char *list,\n\t\t\t\t    size_t list_size, const char *name,\n\t\t\t\t    size_t name_len, int type)\n{\n\tconst size_t prefix_len = XATTR_USER_PREFIX_LEN;\n\tconst size_t total_len = prefix_len + name_len + 1;\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)\n\t\treturn 0;\n\n\tif (list && total_len <= list_size) {\n\t\tmemcpy(list, XATTR_USER_PREFIX, prefix_len);\n\t\tmemcpy(list + prefix_len, name, name_len);\n\t\tlist[prefix_len + name_len] = '\\0';\n\t}\n\treturn total_len;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list + prefix_len",
            "name",
            "name_len"
          ],
          "line": 7379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list",
            "XATTR_USER_PREFIX",
            "prefix_len"
          ],
          "line": 7378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 7372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic size_t ocfs2_xattr_user_list(struct dentry *dentry, char *list,\n\t\t\t\t    size_t list_size, const char *name,\n\t\t\t\t    size_t name_len, int type)\n{\n\tconst size_t prefix_len = XATTR_USER_PREFIX_LEN;\n\tconst size_t total_len = prefix_len + name_len + 1;\n\tstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)\n\t\treturn 0;\n\n\tif (list && total_len <= list_size) {\n\t\tmemcpy(list, XATTR_USER_PREFIX, prefix_len);\n\t\tmemcpy(list + prefix_len, name, name_len);\n\t\tlist[prefix_len + name_len] = '\\0';\n\t}\n\treturn total_len;\n}"
  },
  {
    "function_name": "ocfs2_xattr_trusted_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7346-7354",
    "snippet": "static int ocfs2_xattr_trusted_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\n\treturn ocfs2_xattr_set(dentry->d_inode, OCFS2_XATTR_INDEX_TRUSTED,\n\t\t\t       name, value, size, flags);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_set",
          "args": [
            "dentry->d_inode",
            "OCFS2_XATTR_INDEX_TRUSTED",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 7352
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3512-3661",
          "snippet": "int ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Only xbs will be used on indexed trees.  xis doesn't need a\n\t * bucket.\n\t */\n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t/*\n\t * Scan inode and external block to find the same name\n\t * extended attribute and collect search information.\n\t */\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Check whether the value is refcounted and do some preparation. */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tl_inode->i_mutex);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* we need to update inode's ctime field, so add credit for it. */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock(inode, 1);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nint ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Only xbs will be used on indexed trees.  xis doesn't need a\n\t * bucket.\n\t */\n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t/*\n\t * Scan inode and external block to find the same name\n\t * extended attribute and collect search information.\n\t */\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Check whether the value is refcounted and do some preparation. */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tl_inode->i_mutex);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* we need to update inode's ctime field, so add credit for it. */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock(inode, 1);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 7349
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_trusted_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\n\treturn ocfs2_xattr_set(dentry->d_inode, OCFS2_XATTR_INDEX_TRUSTED,\n\t\t\t       name, value, size, flags);\n}"
  },
  {
    "function_name": "ocfs2_xattr_trusted_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7337-7344",
    "snippet": "static int ocfs2_xattr_trusted_get(struct dentry *dentry, const char *name,\n\t\tvoid *buffer, size_t size, int type)\n{\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\treturn ocfs2_xattr_get(dentry->d_inode, OCFS2_XATTR_INDEX_TRUSTED,\n\t\t\t       name, buffer, size);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_get",
          "args": [
            "dentry->d_inode",
            "OCFS2_XATTR_INDEX_TRUSTED",
            "name",
            "buffer",
            "size"
          ],
          "line": 7342
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1306-1330",
          "snippet": "static int ocfs2_xattr_get(struct inode *inode,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\tdown_read(&OCFS2_I(inode)->ip_xattr_sem);\n\tret = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t     name, buffer, buffer_size);\n\tup_read(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock(inode, 0);\n\n\tbrelse(di_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_get(struct inode *inode,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\tdown_read(&OCFS2_I(inode)->ip_xattr_sem);\n\tret = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t     name, buffer, buffer_size);\n\tup_read(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock(inode, 0);\n\n\tbrelse(di_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 7340
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_trusted_get(struct dentry *dentry, const char *name,\n\t\tvoid *buffer, size_t size, int type)\n{\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\treturn ocfs2_xattr_get(dentry->d_inode, OCFS2_XATTR_INDEX_TRUSTED,\n\t\t\t       name, buffer, size);\n}"
  },
  {
    "function_name": "ocfs2_xattr_trusted_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7322-7335",
    "snippet": "static size_t ocfs2_xattr_trusted_list(struct dentry *dentry, char *list,\n\t\t\t\t       size_t list_size, const char *name,\n\t\t\t\t       size_t name_len, int type)\n{\n\tconst size_t prefix_len = XATTR_TRUSTED_PREFIX_LEN;\n\tconst size_t total_len = prefix_len + name_len + 1;\n\n\tif (list && total_len <= list_size) {\n\t\tmemcpy(list, XATTR_TRUSTED_PREFIX, prefix_len);\n\t\tmemcpy(list + prefix_len, name, name_len);\n\t\tlist[prefix_len + name_len] = '\\0';\n\t}\n\treturn total_len;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list + prefix_len",
            "name",
            "name_len"
          ],
          "line": 7331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list",
            "XATTR_TRUSTED_PREFIX",
            "prefix_len"
          ],
          "line": 7330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic size_t ocfs2_xattr_trusted_list(struct dentry *dentry, char *list,\n\t\t\t\t       size_t list_size, const char *name,\n\t\t\t\t       size_t name_len, int type)\n{\n\tconst size_t prefix_len = XATTR_TRUSTED_PREFIX_LEN;\n\tconst size_t total_len = prefix_len + name_len + 1;\n\n\tif (list && total_len <= list_size) {\n\t\tmemcpy(list, XATTR_TRUSTED_PREFIX, prefix_len);\n\t\tmemcpy(list + prefix_len, name, name_len);\n\t\tlist[prefix_len + name_len] = '\\0';\n\t}\n\treturn total_len;\n}"
  },
  {
    "function_name": "ocfs2_init_security_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7299-7310",
    "snippet": "int ocfs2_init_security_set(handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *di_bh,\n\t\t\t    struct ocfs2_security_xattr_info *si,\n\t\t\t    struct ocfs2_alloc_context *xattr_ac,\n\t\t\t    struct ocfs2_alloc_context *data_ac)\n{\n\treturn ocfs2_xattr_set_handle(handle, inode, di_bh,\n\t\t\t\t     OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t\t     si->name, si->value, si->value_len, 0,\n\t\t\t\t     xattr_ac, data_ac);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_set_handle",
          "args": [
            "handle",
            "inode",
            "di_bh",
            "OCFS2_XATTR_INDEX_SECURITY",
            "si->name",
            "si->value",
            "si->value_len",
            "0",
            "xattr_ac",
            "data_ac"
          ],
          "line": 7306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_set_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3429-3503",
          "snippet": "int ocfs2_xattr_set_handle(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   const void *value,\n\t\t\t   size_t value_len,\n\t\t\t   int flags,\n\t\t\t   struct ocfs2_alloc_context *meta_ac,\n\t\t\t   struct ocfs2_alloc_context *data_ac)\n{\n\tstruct ocfs2_dinode *di;\n\tint ret;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_set_ctxt ctxt = {\n\t\t.handle = handle,\n\t\t.meta_ac = meta_ac,\n\t\t.data_ac = data_ac,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * In extreme situation, may need xattr bucket when\n\t * block size is too small. And we have already reserved\n\t * the credits for bucket in mknod.\n\t */\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE) {\n\t\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\t\tif (!xbs.bucket) {\n\t\t\tmlog_errno(-ENOMEM);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\ncleanup:\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nint ocfs2_xattr_set_handle(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   const void *value,\n\t\t\t   size_t value_len,\n\t\t\t   int flags,\n\t\t\t   struct ocfs2_alloc_context *meta_ac,\n\t\t\t   struct ocfs2_alloc_context *data_ac)\n{\n\tstruct ocfs2_dinode *di;\n\tint ret;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_set_ctxt ctxt = {\n\t\t.handle = handle,\n\t\t.meta_ac = meta_ac,\n\t\t.data_ac = data_ac,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * In extreme situation, may need xattr bucket when\n\t * block size is too small. And we have already reserved\n\t * the credits for bucket in mknod.\n\t */\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE) {\n\t\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\t\tif (!xbs.bucket) {\n\t\t\tmlog_errno(-ENOMEM);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\ncleanup:\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_init_security_set(handle_t *handle,\n\t\t\t    struct inode *inode,\n\t\t\t    struct buffer_head *di_bh,\n\t\t\t    struct ocfs2_security_xattr_info *si,\n\t\t\t    struct ocfs2_alloc_context *xattr_ac,\n\t\t\t    struct ocfs2_alloc_context *data_ac)\n{\n\treturn ocfs2_xattr_set_handle(handle, inode, di_bh,\n\t\t\t\t     OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t\t     si->name, si->value, si->value_len, 0,\n\t\t\t\t     xattr_ac, data_ac);\n}"
  },
  {
    "function_name": "ocfs2_init_security_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7282-7297",
    "snippet": "int ocfs2_init_security_get(struct inode *inode,\n\t\t\t    struct inode *dir,\n\t\t\t    const struct qstr *qstr,\n\t\t\t    struct ocfs2_security_xattr_info *si)\n{\n\t/* check whether ocfs2 support feature xattr */\n\tif (!ocfs2_supports_xattr(OCFS2_SB(dir->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\tif (si)\n\t\treturn security_old_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t\t\t&si->name, &si->value,\n\t\t\t\t\t\t\t&si->value_len);\n\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ocfs2_initxattrs, NULL);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_inode_init_security",
          "args": [
            "inode",
            "dir",
            "qstr",
            "&ocfs2_initxattrs",
            "NULL"
          ],
          "line": 7295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_old_inode_init_security",
          "args": [
            "inode",
            "dir",
            "qstr",
            "&si->name",
            "&si->value",
            "&si->value_len"
          ],
          "line": 7291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_xattr",
          "args": [
            "OCFS2_SB(dir->i_sb)"
          ],
          "line": 7288
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "518-523",
          "snippet": "static inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 7288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_init_security_get(struct inode *inode,\n\t\t\t    struct inode *dir,\n\t\t\t    const struct qstr *qstr,\n\t\t\t    struct ocfs2_security_xattr_info *si)\n{\n\t/* check whether ocfs2 support feature xattr */\n\tif (!ocfs2_supports_xattr(OCFS2_SB(dir->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\tif (si)\n\t\treturn security_old_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t\t\t&si->name, &si->value,\n\t\t\t\t\t\t\t&si->value_len);\n\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ocfs2_initxattrs, NULL);\n}"
  },
  {
    "function_name": "ocfs2_initxattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7266-7280",
    "snippet": "int ocfs2_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t     void *fs_info)\n{\n\tconst struct xattr *xattr;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terr = ocfs2_xattr_set(inode, OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t\t      xattr->name, xattr->value,\n\t\t\t\t      xattr->value_len, XATTR_CREATE);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_set",
          "args": [
            "inode",
            "OCFS2_XATTR_INDEX_SECURITY",
            "xattr->name",
            "xattr->value",
            "xattr->value_len",
            "XATTR_CREATE"
          ],
          "line": 7273
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3512-3661",
          "snippet": "int ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Only xbs will be used on indexed trees.  xis doesn't need a\n\t * bucket.\n\t */\n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t/*\n\t * Scan inode and external block to find the same name\n\t * extended attribute and collect search information.\n\t */\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Check whether the value is refcounted and do some preparation. */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tl_inode->i_mutex);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* we need to update inode's ctime field, so add credit for it. */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock(inode, 1);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nint ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Only xbs will be used on indexed trees.  xis doesn't need a\n\t * bucket.\n\t */\n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t/*\n\t * Scan inode and external block to find the same name\n\t * extended attribute and collect search information.\n\t */\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Check whether the value is refcounted and do some preparation. */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tl_inode->i_mutex);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* we need to update inode's ctime field, so add credit for it. */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock(inode, 1);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t     void *fs_info)\n{\n\tconst struct xattr *xattr;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terr = ocfs2_xattr_set(inode, OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t\t      xattr->name, xattr->value,\n\t\t\t\t      xattr->value_len, XATTR_CREATE);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ocfs2_xattr_security_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7256-7264",
    "snippet": "static int ocfs2_xattr_security_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\n\treturn ocfs2_xattr_set(dentry->d_inode, OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t       name, value, size, flags);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_set",
          "args": [
            "dentry->d_inode",
            "OCFS2_XATTR_INDEX_SECURITY",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 7262
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3512-3661",
          "snippet": "int ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Only xbs will be used on indexed trees.  xis doesn't need a\n\t * bucket.\n\t */\n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t/*\n\t * Scan inode and external block to find the same name\n\t * extended attribute and collect search information.\n\t */\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Check whether the value is refcounted and do some preparation. */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tl_inode->i_mutex);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* we need to update inode's ctime field, so add credit for it. */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock(inode, 1);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nint ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Only xbs will be used on indexed trees.  xis doesn't need a\n\t * bucket.\n\t */\n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t/*\n\t * Scan inode and external block to find the same name\n\t * extended attribute and collect search information.\n\t */\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Check whether the value is refcounted and do some preparation. */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tl_inode->i_mutex);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* we need to update inode's ctime field, so add credit for it. */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock(inode, 1);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 7259
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_security_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\n\treturn ocfs2_xattr_set(dentry->d_inode, OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t       name, value, size, flags);\n}"
  },
  {
    "function_name": "ocfs2_xattr_security_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7247-7254",
    "snippet": "static int ocfs2_xattr_security_get(struct dentry *dentry, const char *name,\n\t\t\t\t    void *buffer, size_t size, int type)\n{\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\treturn ocfs2_xattr_get(dentry->d_inode, OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t       name, buffer, size);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_get",
          "args": [
            "dentry->d_inode",
            "OCFS2_XATTR_INDEX_SECURITY",
            "name",
            "buffer",
            "size"
          ],
          "line": 7252
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1306-1330",
          "snippet": "static int ocfs2_xattr_get(struct inode *inode,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\tdown_read(&OCFS2_I(inode)->ip_xattr_sem);\n\tret = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t     name, buffer, buffer_size);\n\tup_read(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock(inode, 0);\n\n\tbrelse(di_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_get(struct inode *inode,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\tdown_read(&OCFS2_I(inode)->ip_xattr_sem);\n\tret = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t     name, buffer, buffer_size);\n\tup_read(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock(inode, 0);\n\n\tbrelse(di_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 7250
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_security_get(struct dentry *dentry, const char *name,\n\t\t\t\t    void *buffer, size_t size, int type)\n{\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\treturn ocfs2_xattr_get(dentry->d_inode, OCFS2_XATTR_INDEX_SECURITY,\n\t\t\t       name, buffer, size);\n}"
  },
  {
    "function_name": "ocfs2_xattr_security_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7232-7245",
    "snippet": "static size_t ocfs2_xattr_security_list(struct dentry *dentry, char *list,\n\t\t\t\t\tsize_t list_size, const char *name,\n\t\t\t\t\tsize_t name_len, int type)\n{\n\tconst size_t prefix_len = XATTR_SECURITY_PREFIX_LEN;\n\tconst size_t total_len = prefix_len + name_len + 1;\n\n\tif (list && total_len <= list_size) {\n\t\tmemcpy(list, XATTR_SECURITY_PREFIX, prefix_len);\n\t\tmemcpy(list + prefix_len, name, name_len);\n\t\tlist[prefix_len + name_len] = '\\0';\n\t}\n\treturn total_len;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list + prefix_len",
            "name",
            "name_len"
          ],
          "line": 7241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list",
            "XATTR_SECURITY_PREFIX",
            "prefix_len"
          ],
          "line": 7240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic size_t ocfs2_xattr_security_list(struct dentry *dentry, char *list,\n\t\t\t\t\tsize_t list_size, const char *name,\n\t\t\t\t\tsize_t name_len, int type)\n{\n\tconst size_t prefix_len = XATTR_SECURITY_PREFIX_LEN;\n\tconst size_t total_len = prefix_len + name_len + 1;\n\n\tif (list && total_len <= list_size) {\n\t\tmemcpy(list, XATTR_SECURITY_PREFIX, prefix_len);\n\t\tmemcpy(list + prefix_len, name, name_len);\n\t\tlist[prefix_len + name_len] = '\\0';\n\t}\n\treturn total_len;\n}"
  },
  {
    "function_name": "ocfs2_init_security_and_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7198-7228",
    "snippet": "int ocfs2_init_security_and_acl(struct inode *dir,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tconst struct qstr *qstr,\n\t\t\t\tstruct posix_acl *default_acl,\n\t\t\t\tstruct posix_acl *acl)\n{\n\tstruct buffer_head *dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_init_security_get(inode, dir, qstr, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tret = ocfs2_inode_lock(dir, &dir_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tif (!ret && default_acl)\n\t\tret = ocfs2_iop_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\tif (!ret && acl)\n\t\tret = ocfs2_iop_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\n\tocfs2_inode_unlock(dir, 0);\n\tbrelse(dir_bh);\nleave:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dir_bh"
          ],
          "line": 7225
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "dir",
            "0"
          ],
          "line": 7224
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_iop_set_acl",
          "args": [
            "inode",
            "acl",
            "ACL_TYPE_ACCESS"
          ],
          "line": 7222
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iop_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/acl.c",
          "lines": "285-288",
          "snippet": "int ocfs2_iop_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\treturn ocfs2_set_acl(NULL, inode, NULL, type, acl, NULL, NULL);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nint ocfs2_iop_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\treturn ocfs2_set_acl(NULL, inode, NULL, type, acl, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "dir",
            "&dir_bh",
            "0"
          ],
          "line": 7213
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_security_get",
          "args": [
            "inode",
            "dir",
            "qstr",
            "NULL"
          ],
          "line": 7207
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_security_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "7282-7297",
          "snippet": "int ocfs2_init_security_get(struct inode *inode,\n\t\t\t    struct inode *dir,\n\t\t\t    const struct qstr *qstr,\n\t\t\t    struct ocfs2_security_xattr_info *si)\n{\n\t/* check whether ocfs2 support feature xattr */\n\tif (!ocfs2_supports_xattr(OCFS2_SB(dir->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\tif (si)\n\t\treturn security_old_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t\t\t&si->name, &si->value,\n\t\t\t\t\t\t\t&si->value_len);\n\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ocfs2_initxattrs, NULL);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_init_security_get(struct inode *inode,\n\t\t\t    struct inode *dir,\n\t\t\t    const struct qstr *qstr,\n\t\t\t    struct ocfs2_security_xattr_info *si)\n{\n\t/* check whether ocfs2 support feature xattr */\n\tif (!ocfs2_supports_xattr(OCFS2_SB(dir->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\tif (si)\n\t\treturn security_old_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t\t\t&si->name, &si->value,\n\t\t\t\t\t\t\t&si->value_len);\n\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ocfs2_initxattrs, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_init_security_and_acl(struct inode *dir,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tconst struct qstr *qstr,\n\t\t\t\tstruct posix_acl *default_acl,\n\t\t\t\tstruct posix_acl *acl)\n{\n\tstruct buffer_head *dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_init_security_get(inode, dir, qstr, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tret = ocfs2_inode_lock(dir, &dir_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tif (!ret && default_acl)\n\t\tret = ocfs2_iop_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\tif (!ret && acl)\n\t\tret = ocfs2_iop_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\n\tocfs2_inode_unlock(dir, 0);\n\tbrelse(dir_bh);\nleave:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reflink_xattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7116-7189",
    "snippet": "int ocfs2_reflink_xattrs(struct inode *old_inode,\n\t\t\t struct buffer_head *old_bh,\n\t\t\t struct inode *new_inode,\n\t\t\t struct buffer_head *new_bh,\n\t\t\t bool preserve_security)\n{\n\tint ret;\n\tstruct ocfs2_xattr_reflink args;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(old_inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)old_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tstruct buffer_head *ref_root_bh = NULL;\n\n\tret = ocfs2_lock_refcount_tree(OCFS2_SB(old_inode->i_sb),\n\t\t\t\t       le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\targs.old_inode = old_inode;\n\targs.new_inode = new_inode;\n\targs.old_bh = old_bh;\n\targs.new_bh = new_bh;\n\targs.ref_ci = &ref_tree->rf_ci;\n\targs.ref_root_bh = ref_root_bh;\n\targs.dealloc = &dealloc;\n\tif (preserve_security)\n\t\targs.xattr_reflinked = NULL;\n\telse\n\t\targs.xattr_reflinked = ocfs2_reflink_xattr_no_security;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_reflink_xattr_inline(&args);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (!di->i_xattr_loc)\n\t\tgoto out_unlock;\n\n\tret = ocfs2_read_xattr_block(old_inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_reflink_xattr_in_block(&args, blk_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tbrelse(blk_bh);\n\nout_unlock:\n\tocfs2_unlock_refcount_tree(OCFS2_SB(old_inode->i_sb),\n\t\t\t\t   ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\tif (ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(OCFS2_SB(old_inode->i_sb), 1);\n\t\tocfs2_run_deallocs(OCFS2_SB(old_inode->i_sb), &dealloc);\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "OCFS2_SB(old_inode->i_sb)",
            "&dealloc"
          ],
          "line": 7184
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6472-6513",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "old_inode->i_sb"
          ],
          "line": 7184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "OCFS2_SB(old_inode->i_sb)",
            "1"
          ],
          "line": 7183
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "old_inode->i_sb"
          ],
          "line": 7183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dealloc_has_cluster",
          "args": [
            "&dealloc"
          ],
          "line": 7182
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dealloc_has_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "215-218",
          "snippet": "static inline int ocfs2_dealloc_has_cluster(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\treturn c->c_global_allocator != NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_dealloc_has_cluster(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\treturn c->c_global_allocator != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_root_bh"
          ],
          "line": 7180
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "OCFS2_SB(old_inode->i_sb)",
            "ref_tree",
            "1"
          ],
          "line": 7178
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "old_inode->i_sb"
          ],
          "line": 7178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_xattr_in_block",
          "args": [
            "&args",
            "blk_bh"
          ],
          "line": 7171
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_xattr_in_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "7076-7105",
          "snippet": "static int ocfs2_reflink_xattr_in_block(struct ocfs2_xattr_reflink *args,\n\t\t\t\t\tstruct buffer_head *blk_bh)\n{\n\tint ret, indexed = 0;\n\tstruct buffer_head *new_blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\n\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)\n\t\tindexed = 1;\n\n\tret = ocfs2_create_empty_xattr_block(args->new_inode, args->new_bh,\n\t\t\t\t\t     &new_blk_bh, indexed);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!indexed)\n\t\tret = ocfs2_reflink_xattr_block(args, blk_bh, new_blk_bh);\n\telse\n\t\tret = ocfs2_reflink_xattr_tree(args, blk_bh, new_blk_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(new_blk_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_reflink_xattr_in_block(struct ocfs2_xattr_reflink *args,\n\t\t\t\t\tstruct buffer_head *blk_bh)\n{\n\tint ret, indexed = 0;\n\tstruct buffer_head *new_blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\n\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)\n\t\tindexed = 1;\n\n\tret = ocfs2_create_empty_xattr_block(args->new_inode, args->new_bh,\n\t\t\t\t\t     &new_blk_bh, indexed);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!indexed)\n\t\tret = ocfs2_reflink_xattr_block(args, blk_bh, new_blk_bh);\n\telse\n\t\tret = ocfs2_reflink_xattr_tree(args, blk_bh, new_blk_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(new_blk_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_block",
          "args": [
            "old_inode",
            "le64_to_cpu(di->i_xattr_loc)",
            "&blk_bh"
          ],
          "line": 7164
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "531-545",
          "snippet": "static int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_xattr_loc"
          ],
          "line": 7164
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_xattr_inline",
          "args": [
            "&args"
          ],
          "line": 7154
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_xattr_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6450-6530",
          "snippet": "static int ocfs2_reflink_xattr_inline(struct ocfs2_xattr_reflink *args)\n{\n\tint ret = 0, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->old_inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)args->old_bh->b_data;\n\tint inline_size = le16_to_cpu(di->i_xattr_inline_size);\n\tint header_off = osb->sb->s_blocksize - inline_size;\n\tstruct ocfs2_xattr_header *xh = (struct ocfs2_xattr_header *)\n\t\t\t\t\t(args->old_bh->b_data + header_off);\n\tstruct ocfs2_xattr_header *new_xh = (struct ocfs2_xattr_header *)\n\t\t\t\t\t(args->new_bh->b_data + header_off);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_inode_info *new_oi;\n\tstruct ocfs2_dinode *new_di;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = args->new_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\tret = ocfs2_reflink_lock_xattr_allocators(osb, xh, args->ref_root_bh,\n\t\t\t\t\t\t  &credits, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(args->new_inode),\n\t\t\t\t      args->new_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(args->new_bh->b_data + header_off,\n\t       args->old_bh->b_data + header_off, inline_size);\n\n\tnew_di = (struct ocfs2_dinode *)args->new_bh->b_data;\n\tnew_di->i_xattr_inline_size = cpu_to_le16(inline_size);\n\n\tret = ocfs2_reflink_xattr_header(handle, args, args->old_bh, xh,\n\t\t\t\t\t args->new_bh, new_xh, &vb, meta_ac,\n\t\t\t\t\t ocfs2_get_xattr_value_root, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_oi = OCFS2_I(args->new_inode);\n\t/*\n\t * Adjust extent record count to reserve space for extended attribute.\n\t * Inline data count had been adjusted in ocfs2_duplicate_inline_data().\n\t */\n\tif (!(new_oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) &&\n\t    !(ocfs2_inode_is_fast_symlink(args->new_inode))) {\n\t\tstruct ocfs2_extent_list *el = &new_di->id2.i_list;\n\t\tle16_add_cpu(&el->l_count, -(inline_size /\n\t\t\t\t\tsizeof(struct ocfs2_extent_rec)));\n\t}\n\tspin_lock(&new_oi->ip_lock);\n\tnew_oi->ip_dyn_features |= OCFS2_HAS_XATTR_FL | OCFS2_INLINE_XATTR_FL;\n\tnew_di->i_dyn_features = cpu_to_le16(new_oi->ip_dyn_features);\n\tspin_unlock(&new_oi->ip_lock);\n\n\tocfs2_journal_dirty(handle, args->new_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_reflink_xattr_inline(struct ocfs2_xattr_reflink *args)\n{\n\tint ret = 0, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->old_inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)args->old_bh->b_data;\n\tint inline_size = le16_to_cpu(di->i_xattr_inline_size);\n\tint header_off = osb->sb->s_blocksize - inline_size;\n\tstruct ocfs2_xattr_header *xh = (struct ocfs2_xattr_header *)\n\t\t\t\t\t(args->old_bh->b_data + header_off);\n\tstruct ocfs2_xattr_header *new_xh = (struct ocfs2_xattr_header *)\n\t\t\t\t\t(args->new_bh->b_data + header_off);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_inode_info *new_oi;\n\tstruct ocfs2_dinode *new_di;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = args->new_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\tret = ocfs2_reflink_lock_xattr_allocators(osb, xh, args->ref_root_bh,\n\t\t\t\t\t\t  &credits, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(args->new_inode),\n\t\t\t\t      args->new_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(args->new_bh->b_data + header_off,\n\t       args->old_bh->b_data + header_off, inline_size);\n\n\tnew_di = (struct ocfs2_dinode *)args->new_bh->b_data;\n\tnew_di->i_xattr_inline_size = cpu_to_le16(inline_size);\n\n\tret = ocfs2_reflink_xattr_header(handle, args, args->old_bh, xh,\n\t\t\t\t\t args->new_bh, new_xh, &vb, meta_ac,\n\t\t\t\t\t ocfs2_get_xattr_value_root, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_oi = OCFS2_I(args->new_inode);\n\t/*\n\t * Adjust extent record count to reserve space for extended attribute.\n\t * Inline data count had been adjusted in ocfs2_duplicate_inline_data().\n\t */\n\tif (!(new_oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) &&\n\t    !(ocfs2_inode_is_fast_symlink(args->new_inode))) {\n\t\tstruct ocfs2_extent_list *el = &new_di->id2.i_list;\n\t\tle16_add_cpu(&el->l_count, -(inline_size /\n\t\t\t\t\tsizeof(struct ocfs2_extent_rec)));\n\t}\n\tspin_lock(&new_oi->ip_lock);\n\tnew_oi->ip_dyn_features |= OCFS2_HAS_XATTR_FL | OCFS2_INLINE_XATTR_FL;\n\tnew_di->i_dyn_features = cpu_to_le16(new_oi->ip_dyn_features);\n\tspin_unlock(&new_oi->ip_lock);\n\n\tocfs2_journal_dirty(handle, args->new_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&dealloc"
          ],
          "line": 7139
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "205-209",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "OCFS2_SB(old_inode->i_sb)",
            "le64_to_cpu(di->i_refcount_loc)",
            "1",
            "&ref_tree",
            "&ref_root_bh"
          ],
          "line": 7131
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "452-524",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "old_inode->i_sb"
          ],
          "line": 7131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "old_inode"
          ],
          "line": 7124
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_reflink_xattrs(struct inode *old_inode,\n\t\t\t struct buffer_head *old_bh,\n\t\t\t struct inode *new_inode,\n\t\t\t struct buffer_head *new_bh,\n\t\t\t bool preserve_security)\n{\n\tint ret;\n\tstruct ocfs2_xattr_reflink args;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(old_inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)old_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tstruct buffer_head *ref_root_bh = NULL;\n\n\tret = ocfs2_lock_refcount_tree(OCFS2_SB(old_inode->i_sb),\n\t\t\t\t       le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\targs.old_inode = old_inode;\n\targs.new_inode = new_inode;\n\targs.old_bh = old_bh;\n\targs.new_bh = new_bh;\n\targs.ref_ci = &ref_tree->rf_ci;\n\targs.ref_root_bh = ref_root_bh;\n\targs.dealloc = &dealloc;\n\tif (preserve_security)\n\t\targs.xattr_reflinked = NULL;\n\telse\n\t\targs.xattr_reflinked = ocfs2_reflink_xattr_no_security;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_reflink_xattr_inline(&args);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (!di->i_xattr_loc)\n\t\tgoto out_unlock;\n\n\tret = ocfs2_read_xattr_block(old_inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_reflink_xattr_in_block(&args, blk_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tbrelse(blk_bh);\n\nout_unlock:\n\tocfs2_unlock_refcount_tree(OCFS2_SB(old_inode->i_sb),\n\t\t\t\t   ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\tif (ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(OCFS2_SB(old_inode->i_sb), 1);\n\t\tocfs2_run_deallocs(OCFS2_SB(old_inode->i_sb), &dealloc);\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reflink_xattr_no_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7107-7114",
    "snippet": "static int ocfs2_reflink_xattr_no_security(struct ocfs2_xattr_entry *xe)\n{\n\tint type = ocfs2_xattr_get_type(xe);\n\n\treturn type != OCFS2_XATTR_INDEX_SECURITY &&\n\t       type != OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS &&\n\t       type != OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_type",
          "args": [
            "xe"
          ],
          "line": 7109
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1153-1156",
          "snippet": "static inline int ocfs2_xattr_get_type(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_TYPE_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_TYPE_MASK\t\t0x7F"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_TYPE_MASK\t\t0x7F\n\nstatic inline int ocfs2_xattr_get_type(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_TYPE_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_reflink_xattr_no_security(struct ocfs2_xattr_entry *xe)\n{\n\tint type = ocfs2_xattr_get_type(xe);\n\n\treturn type != OCFS2_XATTR_INDEX_SECURITY &&\n\t       type != OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS &&\n\t       type != OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n}"
  },
  {
    "function_name": "ocfs2_reflink_xattr_in_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7076-7105",
    "snippet": "static int ocfs2_reflink_xattr_in_block(struct ocfs2_xattr_reflink *args,\n\t\t\t\t\tstruct buffer_head *blk_bh)\n{\n\tint ret, indexed = 0;\n\tstruct buffer_head *new_blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\n\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)\n\t\tindexed = 1;\n\n\tret = ocfs2_create_empty_xattr_block(args->new_inode, args->new_bh,\n\t\t\t\t\t     &new_blk_bh, indexed);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!indexed)\n\t\tret = ocfs2_reflink_xattr_block(args, blk_bh, new_blk_bh);\n\telse\n\t\tret = ocfs2_reflink_xattr_tree(args, blk_bh, new_blk_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(new_blk_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_blk_bh"
          ],
          "line": 7103
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_xattr_tree",
          "args": [
            "args",
            "blk_bh",
            "new_blk_bh"
          ],
          "line": 7098
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_xattr_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "7039-7074",
          "snippet": "static int ocfs2_reflink_xattr_tree(struct ocfs2_xattr_reflink *args,\n\t\t\t\t    struct buffer_head *blk_bh,\n\t\t\t\t    struct buffer_head *new_blk_bh)\n{\n\tint ret;\n\tstruct ocfs2_reflink_xattr_tree_args para;\n\n\tmemset(&para, 0, sizeof(para));\n\tpara.reflink = args;\n\tpara.old_blk_bh = blk_bh;\n\tpara.new_blk_bh = new_blk_bh;\n\n\tpara.old_bucket = ocfs2_xattr_bucket_new(args->old_inode);\n\tif (!para.old_bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tpara.new_bucket = ocfs2_xattr_bucket_new(args->new_inode);\n\tif (!para.new_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_iterate_xattr_index_block(args->old_inode, blk_bh,\n\t\t\t\t\t      ocfs2_reflink_xattr_rec,\n\t\t\t\t\t      &para);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_xattr_bucket_free(para.old_bucket);\n\tocfs2_xattr_bucket_free(para.new_bucket);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_reflink_xattr_tree(struct ocfs2_xattr_reflink *args,\n\t\t\t\t    struct buffer_head *blk_bh,\n\t\t\t\t    struct buffer_head *new_blk_bh)\n{\n\tint ret;\n\tstruct ocfs2_reflink_xattr_tree_args para;\n\n\tmemset(&para, 0, sizeof(para));\n\tpara.reflink = args;\n\tpara.old_blk_bh = blk_bh;\n\tpara.new_blk_bh = new_blk_bh;\n\n\tpara.old_bucket = ocfs2_xattr_bucket_new(args->old_inode);\n\tif (!para.old_bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tpara.new_bucket = ocfs2_xattr_bucket_new(args->new_inode);\n\tif (!para.new_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_iterate_xattr_index_block(args->old_inode, blk_bh,\n\t\t\t\t\t      ocfs2_reflink_xattr_rec,\n\t\t\t\t\t      &para);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_xattr_bucket_free(para.old_bucket);\n\tocfs2_xattr_bucket_free(para.new_bucket);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_xattr_block",
          "args": [
            "args",
            "blk_bh",
            "new_blk_bh"
          ],
          "line": 7096
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6568-6652",
          "snippet": "static int ocfs2_reflink_xattr_block(struct ocfs2_xattr_reflink *args,\n\t\t\t\t     struct buffer_head *blk_bh,\n\t\t\t\t     struct buffer_head *new_blk_bh)\n{\n\tint ret = 0, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_inode_info *new_oi = OCFS2_I(args->new_inode);\n\tstruct ocfs2_dinode *new_di;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->new_inode->i_sb);\n\tint header_off = offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_xattr_header *xh = &xb->xb_attrs.xb_header;\n\tstruct ocfs2_xattr_block *new_xb =\n\t\t\t(struct ocfs2_xattr_block *)new_blk_bh->b_data;\n\tstruct ocfs2_xattr_header *new_xh = &new_xb->xb_attrs.xb_header;\n\tstruct ocfs2_alloc_context *meta_ac;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = new_blk_bh,\n\t\t.vb_access = ocfs2_journal_access_xb,\n\t};\n\n\tret = ocfs2_reflink_lock_xattr_allocators(osb, xh, args->ref_root_bh,\n\t\t\t\t\t\t  &credits, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/* One more credits in case we need to add xattr flags in new inode. */\n\thandle = ocfs2_start_trans(osb, credits + 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(new_oi->ip_dyn_features & OCFS2_HAS_XATTR_FL)) {\n\t\tret = ocfs2_journal_access_di(handle,\n\t\t\t\t\t      INODE_CACHE(args->new_inode),\n\t\t\t\t\t      args->new_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(args->new_inode),\n\t\t\t\t      new_blk_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(new_blk_bh->b_data + header_off, blk_bh->b_data + header_off,\n\t       osb->sb->s_blocksize - header_off);\n\n\tret = ocfs2_reflink_xattr_header(handle, args, blk_bh, xh,\n\t\t\t\t\t new_blk_bh, new_xh, &vb, meta_ac,\n\t\t\t\t\t ocfs2_get_xattr_value_root, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_journal_dirty(handle, new_blk_bh);\n\n\tif (!(new_oi->ip_dyn_features & OCFS2_HAS_XATTR_FL)) {\n\t\tnew_di = (struct ocfs2_dinode *)args->new_bh->b_data;\n\t\tspin_lock(&new_oi->ip_lock);\n\t\tnew_oi->ip_dyn_features |= OCFS2_HAS_XATTR_FL;\n\t\tnew_di->i_dyn_features = cpu_to_le16(new_oi->ip_dyn_features);\n\t\tspin_unlock(&new_oi->ip_lock);\n\n\t\tocfs2_journal_dirty(handle, args->new_bh);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_reflink_xattr_block(struct ocfs2_xattr_reflink *args,\n\t\t\t\t     struct buffer_head *blk_bh,\n\t\t\t\t     struct buffer_head *new_blk_bh)\n{\n\tint ret = 0, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_inode_info *new_oi = OCFS2_I(args->new_inode);\n\tstruct ocfs2_dinode *new_di;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->new_inode->i_sb);\n\tint header_off = offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_xattr_header *xh = &xb->xb_attrs.xb_header;\n\tstruct ocfs2_xattr_block *new_xb =\n\t\t\t(struct ocfs2_xattr_block *)new_blk_bh->b_data;\n\tstruct ocfs2_xattr_header *new_xh = &new_xb->xb_attrs.xb_header;\n\tstruct ocfs2_alloc_context *meta_ac;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = new_blk_bh,\n\t\t.vb_access = ocfs2_journal_access_xb,\n\t};\n\n\tret = ocfs2_reflink_lock_xattr_allocators(osb, xh, args->ref_root_bh,\n\t\t\t\t\t\t  &credits, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/* One more credits in case we need to add xattr flags in new inode. */\n\thandle = ocfs2_start_trans(osb, credits + 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(new_oi->ip_dyn_features & OCFS2_HAS_XATTR_FL)) {\n\t\tret = ocfs2_journal_access_di(handle,\n\t\t\t\t\t      INODE_CACHE(args->new_inode),\n\t\t\t\t\t      args->new_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(args->new_inode),\n\t\t\t\t      new_blk_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(new_blk_bh->b_data + header_off, blk_bh->b_data + header_off,\n\t       osb->sb->s_blocksize - header_off);\n\n\tret = ocfs2_reflink_xattr_header(handle, args, blk_bh, xh,\n\t\t\t\t\t new_blk_bh, new_xh, &vb, meta_ac,\n\t\t\t\t\t ocfs2_get_xattr_value_root, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_journal_dirty(handle, new_blk_bh);\n\n\tif (!(new_oi->ip_dyn_features & OCFS2_HAS_XATTR_FL)) {\n\t\tnew_di = (struct ocfs2_dinode *)args->new_bh->b_data;\n\t\tspin_lock(&new_oi->ip_lock);\n\t\tnew_oi->ip_dyn_features |= OCFS2_HAS_XATTR_FL;\n\t\tnew_di->i_dyn_features = cpu_to_le16(new_oi->ip_dyn_features);\n\t\tspin_unlock(&new_oi->ip_lock);\n\n\t\tocfs2_journal_dirty(handle, args->new_bh);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_empty_xattr_block",
          "args": [
            "args->new_inode",
            "args->new_bh",
            "&new_blk_bh",
            "indexed"
          ],
          "line": 7088
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_empty_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6532-6566",
          "snippet": "static int ocfs2_create_empty_xattr_block(struct inode *inode,\n\t\t\t\t\t  struct buffer_head *fe_bh,\n\t\t\t\t\t  struct buffer_head **ret_bh,\n\t\t\t\t\t  int indexed)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt;\n\n\tmemset(&ctxt, 0, sizeof(ctxt));\n\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &ctxt.meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tctxt.handle = ocfs2_start_trans(osb, OCFS2_XATTR_BLOCK_CREATE_CREDITS);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_create_empty_xattr_block(\n\t\t\t\t(unsigned long long)fe_bh->b_blocknr, indexed);\n\tret = ocfs2_create_xattr_block(inode, fe_bh, &ctxt, indexed,\n\t\t\t\t       ret_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\nout:\n\tocfs2_free_alloc_context(ctxt.meta_ac);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_create_empty_xattr_block(struct inode *inode,\n\t\t\t\t\t  struct buffer_head *fe_bh,\n\t\t\t\t\t  struct buffer_head **ret_bh,\n\t\t\t\t\t  int indexed)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt;\n\n\tmemset(&ctxt, 0, sizeof(ctxt));\n\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &ctxt.meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tctxt.handle = ocfs2_start_trans(osb, OCFS2_XATTR_BLOCK_CREATE_CREDITS);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_create_empty_xattr_block(\n\t\t\t\t(unsigned long long)fe_bh->b_blocknr, indexed);\n\tret = ocfs2_create_xattr_block(inode, fe_bh, &ctxt, indexed,\n\t\t\t\t       ret_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\nout:\n\tocfs2_free_alloc_context(ctxt.meta_ac);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xb->xb_flags"
          ],
          "line": 7085
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_reflink_xattr_in_block(struct ocfs2_xattr_reflink *args,\n\t\t\t\t\tstruct buffer_head *blk_bh)\n{\n\tint ret, indexed = 0;\n\tstruct buffer_head *new_blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\n\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)\n\t\tindexed = 1;\n\n\tret = ocfs2_create_empty_xattr_block(args->new_inode, args->new_bh,\n\t\t\t\t\t     &new_blk_bh, indexed);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!indexed)\n\t\tret = ocfs2_reflink_xattr_block(args, blk_bh, new_blk_bh);\n\telse\n\t\tret = ocfs2_reflink_xattr_tree(args, blk_bh, new_blk_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(new_blk_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reflink_xattr_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "7039-7074",
    "snippet": "static int ocfs2_reflink_xattr_tree(struct ocfs2_xattr_reflink *args,\n\t\t\t\t    struct buffer_head *blk_bh,\n\t\t\t\t    struct buffer_head *new_blk_bh)\n{\n\tint ret;\n\tstruct ocfs2_reflink_xattr_tree_args para;\n\n\tmemset(&para, 0, sizeof(para));\n\tpara.reflink = args;\n\tpara.old_blk_bh = blk_bh;\n\tpara.new_blk_bh = new_blk_bh;\n\n\tpara.old_bucket = ocfs2_xattr_bucket_new(args->old_inode);\n\tif (!para.old_bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tpara.new_bucket = ocfs2_xattr_bucket_new(args->new_inode);\n\tif (!para.new_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_iterate_xattr_index_block(args->old_inode, blk_bh,\n\t\t\t\t\t      ocfs2_reflink_xattr_rec,\n\t\t\t\t\t      &para);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_xattr_bucket_free(para.old_bucket);\n\tocfs2_xattr_bucket_free(para.new_bucket);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_free",
          "args": [
            "para.new_bucket"
          ],
          "line": 7072
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "356-363",
          "snippet": "static void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iterate_xattr_index_block",
          "args": [
            "args->old_inode",
            "blk_bh",
            "ocfs2_reflink_xattr_rec",
            "&para"
          ],
          "line": 7064
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iterate_xattr_index_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4071-4110",
          "snippet": "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *blk_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_extent_list *el = &xb->xb_attrs.xb_root.xt_list;\n\tint ret = 0;\n\tu32 name_hash = UINT_MAX, e_cpos = 0, num_clusters = 0;\n\tu64 p_blkno = 0;\n\n\tif (!el->l_next_free_rec || !rec_func)\n\t\treturn 0;\n\n\twhile (name_hash > 0) {\n\t\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno,\n\t\t\t\t\t  &e_cpos, &num_clusters, el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rec_func(inode, blk_bh, p_blkno, e_cpos,\n\t\t\t       num_clusters, para);\n\t\tif (ret) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e_cpos == 0)\n\t\t\tbreak;\n\n\t\tname_hash = e_cpos - 1;\n\t}\n\n\treturn ret;\n\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *blk_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_extent_list *el = &xb->xb_attrs.xb_root.xt_list;\n\tint ret = 0;\n\tu32 name_hash = UINT_MAX, e_cpos = 0, num_clusters = 0;\n\tu64 p_blkno = 0;\n\n\tif (!el->l_next_free_rec || !rec_func)\n\t\treturn 0;\n\n\twhile (name_hash > 0) {\n\t\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno,\n\t\t\t\t\t  &e_cpos, &num_clusters, el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rec_func(inode, blk_bh, p_blkno, e_cpos,\n\t\t\t       num_clusters, para);\n\t\tif (ret) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e_cpos == 0)\n\t\t\tbreak;\n\n\t\tname_hash = e_cpos - 1;\n\t}\n\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_new",
          "args": [
            "args->new_inode"
          ],
          "line": 7057
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "330-344",
          "snippet": "static struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-ENOMEM"
          ],
          "line": 7053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&para",
            "0",
            "sizeof(para)"
          ],
          "line": 7046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_reflink_xattr_tree(struct ocfs2_xattr_reflink *args,\n\t\t\t\t    struct buffer_head *blk_bh,\n\t\t\t\t    struct buffer_head *new_blk_bh)\n{\n\tint ret;\n\tstruct ocfs2_reflink_xattr_tree_args para;\n\n\tmemset(&para, 0, sizeof(para));\n\tpara.reflink = args;\n\tpara.old_blk_bh = blk_bh;\n\tpara.new_blk_bh = new_blk_bh;\n\n\tpara.old_bucket = ocfs2_xattr_bucket_new(args->old_inode);\n\tif (!para.old_bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tpara.new_bucket = ocfs2_xattr_bucket_new(args->new_inode);\n\tif (!para.new_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_iterate_xattr_index_block(args->old_inode, blk_bh,\n\t\t\t\t\t      ocfs2_reflink_xattr_rec,\n\t\t\t\t\t      &para);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_xattr_bucket_free(para.old_bucket);\n\tocfs2_xattr_bucket_free(para.new_bucket);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reflink_xattr_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6981-7032",
    "snippet": "static int ocfs2_reflink_xattr_rec(struct inode *inode,\n\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t   u64 blkno,\n\t\t\t\t   u32 cpos,\n\t\t\t\t   u32 len,\n\t\t\t\t   void *para)\n{\n\tint ret, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_reflink_xattr_tree_args *args =\n\t\t\t(struct ocfs2_reflink_xattr_tree_args *)para;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_extent_tree et;\n\n\ttrace_ocfs2_reflink_xattr_rec((unsigned long long)blkno, len);\n\n\tocfs2_init_xattr_tree_extent_tree(&et,\n\t\t\t\t\t  INODE_CACHE(args->reflink->new_inode),\n\t\t\t\t\t  args->new_blk_bh);\n\n\tret = ocfs2_lock_reflink_xattr_rec_allocators(args, &et, blkno,\n\t\t\t\t\t\t      len, &credits,\n\t\t\t\t\t\t      &meta_ac, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_reflink_xattr_buckets(handle, inode, args, &et,\n\t\t\t\t\t  meta_ac, data_ac,\n\t\t\t\t\t  blkno, cpos, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "data_ac"
          ],
          "line": 7030
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 7024
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_xattr_buckets",
          "args": [
            "handle",
            "inode",
            "args",
            "&et",
            "meta_ac",
            "data_ac",
            "blkno",
            "cpos",
            "len"
          ],
          "line": 7018
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_xattr_buckets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6910-6976",
          "snippet": "static int ocfs2_reflink_xattr_buckets(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tu64 blkno, u32 cpos, u32 len)\n{\n\tint ret, first_inserted = 0;\n\tu32 p_cluster, num_clusters, reflink_cpos = 0;\n\tu64 new_blkno;\n\tunsigned int num_buckets, reflink_buckets;\n\tunsigned int bpc =\n\t\tocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\n\tret = ocfs2_read_xattr_bucket(args->old_bucket, blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tnum_buckets = le16_to_cpu(bucket_xh(args->old_bucket)->xh_num_buckets);\n\tocfs2_xattr_bucket_relse(args->old_bucket);\n\n\twhile (len && num_buckets) {\n\t\tret = ocfs2_claim_clusters(handle, data_ac,\n\t\t\t\t\t   1, &p_cluster, &num_clusters);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnew_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\treflink_buckets = min(num_buckets, bpc * num_clusters);\n\n\t\tret = ocfs2_reflink_xattr_bucket(handle, blkno,\n\t\t\t\t\t\t new_blkno, num_clusters,\n\t\t\t\t\t\t &reflink_cpos, reflink_buckets,\n\t\t\t\t\t\t meta_ac, data_ac, args);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * For the 1st allocated cluster, we make it use the same cpos\n\t\t * so that the xattr tree looks the same as the original one\n\t\t * in the most case.\n\t\t */\n\t\tif (!first_inserted) {\n\t\t\treflink_cpos = cpos;\n\t\t\tfirst_inserted = 1;\n\t\t}\n\t\tret = ocfs2_insert_extent(handle, et, reflink_cpos, new_blkno,\n\t\t\t\t\t  num_clusters, 0, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\ttrace_ocfs2_reflink_xattr_buckets((unsigned long long)new_blkno,\n\t\t\t\t\t\t  num_clusters, reflink_cpos);\n\n\t\tlen -= num_clusters;\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\tnum_buckets -= reflink_buckets;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_reflink_xattr_buckets(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tu64 blkno, u32 cpos, u32 len)\n{\n\tint ret, first_inserted = 0;\n\tu32 p_cluster, num_clusters, reflink_cpos = 0;\n\tu64 new_blkno;\n\tunsigned int num_buckets, reflink_buckets;\n\tunsigned int bpc =\n\t\tocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\n\tret = ocfs2_read_xattr_bucket(args->old_bucket, blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tnum_buckets = le16_to_cpu(bucket_xh(args->old_bucket)->xh_num_buckets);\n\tocfs2_xattr_bucket_relse(args->old_bucket);\n\n\twhile (len && num_buckets) {\n\t\tret = ocfs2_claim_clusters(handle, data_ac,\n\t\t\t\t\t   1, &p_cluster, &num_clusters);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnew_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\treflink_buckets = min(num_buckets, bpc * num_clusters);\n\n\t\tret = ocfs2_reflink_xattr_bucket(handle, blkno,\n\t\t\t\t\t\t new_blkno, num_clusters,\n\t\t\t\t\t\t &reflink_cpos, reflink_buckets,\n\t\t\t\t\t\t meta_ac, data_ac, args);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * For the 1st allocated cluster, we make it use the same cpos\n\t\t * so that the xattr tree looks the same as the original one\n\t\t * in the most case.\n\t\t */\n\t\tif (!first_inserted) {\n\t\t\treflink_cpos = cpos;\n\t\t\tfirst_inserted = 1;\n\t\t}\n\t\tret = ocfs2_insert_extent(handle, et, reflink_cpos, new_blkno,\n\t\t\t\t\t  num_clusters, 0, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\ttrace_ocfs2_reflink_xattr_buckets((unsigned long long)new_blkno,\n\t\t\t\t\t\t  num_clusters, reflink_cpos);\n\n\t\tlen -= num_clusters;\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\tnum_buckets -= reflink_buckets;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 7013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 7012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 7011
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_reflink_xattr_rec_allocators",
          "args": [
            "args",
            "&et",
            "blkno",
            "len",
            "&credits",
            "&meta_ac",
            "&data_ac"
          ],
          "line": 7003
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_reflink_xattr_rec_allocators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6733-6817",
          "snippet": "static int ocfs2_lock_reflink_xattr_rec_allocators(\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args,\n\t\t\t\tstruct ocfs2_extent_tree *xt_et,\n\t\t\t\tu64 blkno, u32 len, int *credits,\n\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context **data_ac)\n{\n\tint ret, num_free_extents;\n\tstruct ocfs2_value_tree_metas metas;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->reflink->old_inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\n\tmemset(&metas, 0, sizeof(metas));\n\n\tret = ocfs2_iterate_xattr_buckets(args->reflink->old_inode, blkno, len,\n\t\t\t\t\t  ocfs2_calc_value_tree_metas, &metas);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*credits = metas.credits;\n\n\t/*\n\t * Calculate we need for refcount tree change.\n\t *\n\t * We need to add/modify num_recs in refcount tree, so just calculate\n\t * an approximate number we need for refcount tree change.\n\t * Sometimes we need to split the tree, and after split,  half recs\n\t * will be moved to the new block, and a new block can only provide\n\t * half number of recs. So we multiple new blocks by 2.\n\t * In the end, we have to add credits for modifying the already\n\t * existed refcount block.\n\t */\n\trb = (struct ocfs2_refcount_block *)args->reflink->ref_root_bh->b_data;\n\tmetas.num_recs =\n\t\t(metas.num_recs + ocfs2_refcount_recs_per_rb(osb->sb) - 1) /\n\t\t ocfs2_refcount_recs_per_rb(osb->sb) * 2;\n\tmetas.num_metas += metas.num_recs;\n\t*credits += metas.num_recs +\n\t\t    metas.num_recs * OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += le16_to_cpu(rb->rf_list.l_tree_depth) *\n\t\t\t    le16_to_cpu(rb->rf_list.l_next_free_rec) + 1;\n\telse\n\t\t*credits += 1;\n\n\t/* count in the xattr tree change. */\n\tnum_free_extents = ocfs2_num_free_extents(osb, xt_et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (num_free_extents < len)\n\t\tmetas.num_metas += ocfs2_extend_meta_needed(xt_et->et_root_el);\n\n\t*credits += ocfs2_calc_extend_credits(osb->sb,\n\t\t\t\t\t      xt_et->et_root_el);\n\n\tif (metas.num_metas) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, metas.num_metas,\n\t\t\t\t\t\t\tmeta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (len) {\n\t\tret = ocfs2_reserve_clusters(osb, len, data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_lock_reflink_xattr_rec_allocators(\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args,\n\t\t\t\tstruct ocfs2_extent_tree *xt_et,\n\t\t\t\tu64 blkno, u32 len, int *credits,\n\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context **data_ac)\n{\n\tint ret, num_free_extents;\n\tstruct ocfs2_value_tree_metas metas;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->reflink->old_inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\n\tmemset(&metas, 0, sizeof(metas));\n\n\tret = ocfs2_iterate_xattr_buckets(args->reflink->old_inode, blkno, len,\n\t\t\t\t\t  ocfs2_calc_value_tree_metas, &metas);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*credits = metas.credits;\n\n\t/*\n\t * Calculate we need for refcount tree change.\n\t *\n\t * We need to add/modify num_recs in refcount tree, so just calculate\n\t * an approximate number we need for refcount tree change.\n\t * Sometimes we need to split the tree, and after split,  half recs\n\t * will be moved to the new block, and a new block can only provide\n\t * half number of recs. So we multiple new blocks by 2.\n\t * In the end, we have to add credits for modifying the already\n\t * existed refcount block.\n\t */\n\trb = (struct ocfs2_refcount_block *)args->reflink->ref_root_bh->b_data;\n\tmetas.num_recs =\n\t\t(metas.num_recs + ocfs2_refcount_recs_per_rb(osb->sb) - 1) /\n\t\t ocfs2_refcount_recs_per_rb(osb->sb) * 2;\n\tmetas.num_metas += metas.num_recs;\n\t*credits += metas.num_recs +\n\t\t    metas.num_recs * OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += le16_to_cpu(rb->rf_list.l_tree_depth) *\n\t\t\t    le16_to_cpu(rb->rf_list.l_next_free_rec) + 1;\n\telse\n\t\t*credits += 1;\n\n\t/* count in the xattr tree change. */\n\tnum_free_extents = ocfs2_num_free_extents(osb, xt_et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (num_free_extents < len)\n\t\tmetas.num_metas += ocfs2_extend_meta_needed(xt_et->et_root_el);\n\n\t*credits += ocfs2_calc_extend_credits(osb->sb,\n\t\t\t\t\t      xt_et->et_root_el);\n\n\tif (metas.num_metas) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, metas.num_metas,\n\t\t\t\t\t\t\tmeta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (len) {\n\t\tret = ocfs2_reserve_clusters(osb, len, data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_tree_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(args->reflink->new_inode)",
            "args->new_blk_bh"
          ],
          "line": 6999
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_tree_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "466-472",
          "snippet": "void ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t       struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_xb,\n\t\t\t\t NULL, &ocfs2_xattr_tree_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_xattr_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_tree_fill_root_el,\n\t.eo_fill_max_leaf_clusters = ocfs2_xattr_tree_fill_max_leaf_clusters,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_xattr_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_tree_fill_root_el,\n\t.eo_fill_max_leaf_clusters = ocfs2_xattr_tree_fill_max_leaf_clusters,\n};\n\nvoid ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t       struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_xb,\n\t\t\t\t NULL, &ocfs2_xattr_tree_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "args->reflink->new_inode"
          ],
          "line": 7000
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_reflink_xattr_rec",
          "args": [
            "(unsigned long long)blkno",
            "len"
          ],
          "line": 6997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 6992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_reflink_xattr_rec(struct inode *inode,\n\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t   u64 blkno,\n\t\t\t\t   u32 cpos,\n\t\t\t\t   u32 len,\n\t\t\t\t   void *para)\n{\n\tint ret, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_reflink_xattr_tree_args *args =\n\t\t\t(struct ocfs2_reflink_xattr_tree_args *)para;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_extent_tree et;\n\n\ttrace_ocfs2_reflink_xattr_rec((unsigned long long)blkno, len);\n\n\tocfs2_init_xattr_tree_extent_tree(&et,\n\t\t\t\t\t  INODE_CACHE(args->reflink->new_inode),\n\t\t\t\t\t  args->new_blk_bh);\n\n\tret = ocfs2_lock_reflink_xattr_rec_allocators(args, &et, blkno,\n\t\t\t\t\t\t      len, &credits,\n\t\t\t\t\t\t      &meta_ac, &data_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_reflink_xattr_buckets(handle, inode, args, &et,\n\t\t\t\t\t  meta_ac, data_ac,\n\t\t\t\t\t  blkno, cpos, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reflink_xattr_buckets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6910-6976",
    "snippet": "static int ocfs2_reflink_xattr_buckets(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tu64 blkno, u32 cpos, u32 len)\n{\n\tint ret, first_inserted = 0;\n\tu32 p_cluster, num_clusters, reflink_cpos = 0;\n\tu64 new_blkno;\n\tunsigned int num_buckets, reflink_buckets;\n\tunsigned int bpc =\n\t\tocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\n\tret = ocfs2_read_xattr_bucket(args->old_bucket, blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tnum_buckets = le16_to_cpu(bucket_xh(args->old_bucket)->xh_num_buckets);\n\tocfs2_xattr_bucket_relse(args->old_bucket);\n\n\twhile (len && num_buckets) {\n\t\tret = ocfs2_claim_clusters(handle, data_ac,\n\t\t\t\t\t   1, &p_cluster, &num_clusters);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnew_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\treflink_buckets = min(num_buckets, bpc * num_clusters);\n\n\t\tret = ocfs2_reflink_xattr_bucket(handle, blkno,\n\t\t\t\t\t\t new_blkno, num_clusters,\n\t\t\t\t\t\t &reflink_cpos, reflink_buckets,\n\t\t\t\t\t\t meta_ac, data_ac, args);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * For the 1st allocated cluster, we make it use the same cpos\n\t\t * so that the xattr tree looks the same as the original one\n\t\t * in the most case.\n\t\t */\n\t\tif (!first_inserted) {\n\t\t\treflink_cpos = cpos;\n\t\t\tfirst_inserted = 1;\n\t\t}\n\t\tret = ocfs2_insert_extent(handle, et, reflink_cpos, new_blkno,\n\t\t\t\t\t  num_clusters, 0, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\ttrace_ocfs2_reflink_xattr_buckets((unsigned long long)new_blkno,\n\t\t\t\t\t\t  num_clusters, reflink_cpos);\n\n\t\tlen -= num_clusters;\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\tnum_buckets -= reflink_buckets;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "num_clusters"
          ],
          "line": 6971
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_reflink_xattr_buckets",
          "args": [
            "(unsigned long long)new_blkno",
            "num_clusters",
            "reflink_cpos"
          ],
          "line": 6967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_extent",
          "args": [
            "handle",
            "et",
            "reflink_cpos",
            "new_blkno",
            "num_clusters",
            "0",
            "meta_ac"
          ],
          "line": 6962
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4665-4726",
          "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_xattr_bucket",
          "args": [
            "handle",
            "blkno",
            "new_blkno",
            "num_clusters",
            "&reflink_cpos",
            "reflink_buckets",
            "meta_ac",
            "data_ac",
            "args"
          ],
          "line": 6944
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_xattr_buckets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6910-6976",
          "snippet": "static int ocfs2_reflink_xattr_buckets(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tu64 blkno, u32 cpos, u32 len)\n{\n\tint ret, first_inserted = 0;\n\tu32 p_cluster, num_clusters, reflink_cpos = 0;\n\tu64 new_blkno;\n\tunsigned int num_buckets, reflink_buckets;\n\tunsigned int bpc =\n\t\tocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\n\tret = ocfs2_read_xattr_bucket(args->old_bucket, blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tnum_buckets = le16_to_cpu(bucket_xh(args->old_bucket)->xh_num_buckets);\n\tocfs2_xattr_bucket_relse(args->old_bucket);\n\n\twhile (len && num_buckets) {\n\t\tret = ocfs2_claim_clusters(handle, data_ac,\n\t\t\t\t\t   1, &p_cluster, &num_clusters);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnew_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\treflink_buckets = min(num_buckets, bpc * num_clusters);\n\n\t\tret = ocfs2_reflink_xattr_bucket(handle, blkno,\n\t\t\t\t\t\t new_blkno, num_clusters,\n\t\t\t\t\t\t &reflink_cpos, reflink_buckets,\n\t\t\t\t\t\t meta_ac, data_ac, args);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * For the 1st allocated cluster, we make it use the same cpos\n\t\t * so that the xattr tree looks the same as the original one\n\t\t * in the most case.\n\t\t */\n\t\tif (!first_inserted) {\n\t\t\treflink_cpos = cpos;\n\t\t\tfirst_inserted = 1;\n\t\t}\n\t\tret = ocfs2_insert_extent(handle, et, reflink_cpos, new_blkno,\n\t\t\t\t\t  num_clusters, 0, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\ttrace_ocfs2_reflink_xattr_buckets((unsigned long long)new_blkno,\n\t\t\t\t\t\t  num_clusters, reflink_cpos);\n\n\t\tlen -= num_clusters;\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\tnum_buckets -= reflink_buckets;\n\t}\nout:\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "num_buckets",
            "bpc * num_clusters"
          ],
          "line": 6942
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_encode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "154-157",
          "snippet": "u32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_clusters",
          "args": [
            "handle",
            "data_ac",
            "1",
            "&p_cluster",
            "&num_clusters"
          ],
          "line": 6934
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2373-2383",
          "snippet": "int ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_relse",
          "args": [
            "args->old_bucket"
          ],
          "line": 6931
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "346-354",
          "snippet": "static void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bucket_xh(args->old_bucket)->xh_num_buckets"
          ],
          "line": 6930
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "args->old_bucket"
          ],
          "line": 6930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_bucket",
          "args": [
            "args->old_bucket",
            "blkno"
          ],
          "line": 6925
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "404-426",
          "snippet": "static int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_buckets_per_cluster",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 6923
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_buckets_per_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "316-319",
          "snippet": "static inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 6923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_reflink_xattr_buckets(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tu64 blkno, u32 cpos, u32 len)\n{\n\tint ret, first_inserted = 0;\n\tu32 p_cluster, num_clusters, reflink_cpos = 0;\n\tu64 new_blkno;\n\tunsigned int num_buckets, reflink_buckets;\n\tunsigned int bpc =\n\t\tocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\n\tret = ocfs2_read_xattr_bucket(args->old_bucket, blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tnum_buckets = le16_to_cpu(bucket_xh(args->old_bucket)->xh_num_buckets);\n\tocfs2_xattr_bucket_relse(args->old_bucket);\n\n\twhile (len && num_buckets) {\n\t\tret = ocfs2_claim_clusters(handle, data_ac,\n\t\t\t\t\t   1, &p_cluster, &num_clusters);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnew_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\treflink_buckets = min(num_buckets, bpc * num_clusters);\n\n\t\tret = ocfs2_reflink_xattr_bucket(handle, blkno,\n\t\t\t\t\t\t new_blkno, num_clusters,\n\t\t\t\t\t\t &reflink_cpos, reflink_buckets,\n\t\t\t\t\t\t meta_ac, data_ac, args);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * For the 1st allocated cluster, we make it use the same cpos\n\t\t * so that the xattr tree looks the same as the original one\n\t\t * in the most case.\n\t\t */\n\t\tif (!first_inserted) {\n\t\t\treflink_cpos = cpos;\n\t\t\tfirst_inserted = 1;\n\t\t}\n\t\tret = ocfs2_insert_extent(handle, et, reflink_cpos, new_blkno,\n\t\t\t\t\t  num_clusters, 0, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\ttrace_ocfs2_reflink_xattr_buckets((unsigned long long)new_blkno,\n\t\t\t\t\t\t  num_clusters, reflink_cpos);\n\n\t\tlen -= num_clusters;\n\t\tblkno += ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\tnum_buckets -= reflink_buckets;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reflink_xattr_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6819-6908",
    "snippet": "static int ocfs2_reflink_xattr_bucket(handle_t *handle,\n\t\t\t\tu64 blkno, u64 new_blkno, u32 clusters,\n\t\t\t\tu32 *cpos, int num_buckets,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args)\n{\n\tint i, j, ret = 0;\n\tstruct super_block *sb = args->reflink->old_inode->i_sb;\n\tint bpb = args->old_bucket->bu_blocks;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_access = ocfs2_journal_access,\n\t};\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bpb, new_blkno += bpb) {\n\t\tret = ocfs2_read_xattr_bucket(args->old_bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_init_xattr_bucket(args->new_bucket, new_blkno, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_bucket_journal_access(handle,\n\t\t\t\t\t\targs->new_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j = 0; j < bpb; j++)\n\t\t\tmemcpy(bucket_block(args->new_bucket, j),\n\t\t\t       bucket_block(args->old_bucket, j),\n\t\t\t       sb->s_blocksize);\n\n\t\t/*\n\t\t * Record the start cpos so that we can use it to initialize\n\t\t * our xattr tree we also set the xh_num_bucket for the new\n\t\t * bucket.\n\t\t */\n\t\tif (i == 0) {\n\t\t\t*cpos = le32_to_cpu(bucket_xh(args->new_bucket)->\n\t\t\t\t\t    xh_entries[0].xe_name_hash);\n\t\t\tbucket_xh(args->new_bucket)->xh_num_buckets =\n\t\t\t\tcpu_to_le16(num_buckets);\n\t\t}\n\n\t\tocfs2_xattr_bucket_journal_dirty(handle, args->new_bucket);\n\n\t\tret = ocfs2_reflink_xattr_header(handle, args->reflink,\n\t\t\t\t\targs->old_bucket->bu_bhs[0],\n\t\t\t\t\tbucket_xh(args->old_bucket),\n\t\t\t\t\targs->new_bucket->bu_bhs[0],\n\t\t\t\t\tbucket_xh(args->new_bucket),\n\t\t\t\t\t&vb, meta_ac,\n\t\t\t\t\tocfs2_get_reflink_xattr_value_root,\n\t\t\t\t\targs);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Re-access and dirty the bucket to calculate metaecc.\n\t\t * Because we may extend the transaction in reflink_xattr_header\n\t\t * which will let the already accessed block gone.\n\t\t */\n\t\tret = ocfs2_xattr_bucket_journal_access(handle,\n\t\t\t\t\t\targs->new_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_xattr_bucket_journal_dirty(handle, args->new_bucket);\n\n\t\tocfs2_xattr_bucket_relse(args->old_bucket);\n\t\tocfs2_xattr_bucket_relse(args->new_bucket);\n\t}\n\n\tocfs2_xattr_bucket_relse(args->old_bucket);\n\tocfs2_xattr_bucket_relse(args->new_bucket);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_relse",
          "args": [
            "args->new_bucket"
          ],
          "line": 6906
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "346-354",
          "snippet": "static void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_dirty",
          "args": [
            "handle",
            "args->new_bucket"
          ],
          "line": 6899
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "447-460",
          "snippet": "static void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_access",
          "args": [
            "handle",
            "args->new_bucket",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 6891
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "428-445",
          "snippet": "static int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_xattr_header",
          "args": [
            "handle",
            "args->reflink",
            "args->old_bucket->bu_bhs[0]",
            "bucket_xh(args->old_bucket)",
            "args->new_bucket->bu_bhs[0]",
            "bucket_xh(args->new_bucket)",
            "&vb",
            "meta_ac",
            "ocfs2_get_reflink_xattr_value_root",
            "args"
          ],
          "line": 6873
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_xattr_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6324-6448",
          "snippet": "static int ocfs2_reflink_xattr_header(handle_t *handle,\n\t\t\t\t      struct ocfs2_xattr_reflink *args,\n\t\t\t\t      struct buffer_head *old_bh,\n\t\t\t\t      struct ocfs2_xattr_header *xh,\n\t\t\t\t      struct buffer_head *new_bh,\n\t\t\t\t      struct ocfs2_xattr_header *new_xh,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t      get_xattr_value_root *func,\n\t\t\t\t      void *para)\n{\n\tint ret = 0, i, j;\n\tstruct super_block *sb = args->old_inode->i_sb;\n\tstruct buffer_head *value_bh;\n\tstruct ocfs2_xattr_entry *xe, *last;\n\tstruct ocfs2_xattr_value_root *xv, *new_xv;\n\tstruct ocfs2_extent_tree data_et;\n\tu32 clusters, cpos, p_cluster, num_clusters;\n\tunsigned int ext_flags = 0;\n\n\ttrace_ocfs2_reflink_xattr_header((unsigned long long)old_bh->b_blocknr,\n\t\t\t\t\t le16_to_cpu(xh->xh_count));\n\n\tlast = &new_xh->xh_entries[le16_to_cpu(new_xh->xh_count)];\n\tfor (i = 0, j = 0; i < le16_to_cpu(xh->xh_count); i++, j++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (args->xattr_reflinked && !args->xattr_reflinked(xe)) {\n\t\t\txe = &new_xh->xh_entries[j];\n\n\t\t\tle16_add_cpu(&new_xh->xh_count, -1);\n\t\t\tif (new_xh->xh_count) {\n\t\t\t\tmemmove(xe, xe + 1,\n\t\t\t\t\t(void *)last - (void *)xe);\n\t\t\t\tmemset(last, 0,\n\t\t\t\t       sizeof(struct ocfs2_xattr_entry));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't want j to increase in the next round since\n\t\t\t * it is already moved ahead.\n\t\t\t */\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, old_bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = func(sb, new_bh, new_xh, j, &new_xv, &value_bh, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For the xattr which has l_tree_depth = 0, all the extent\n\t\t * recs have already be copied to the new xh with the\n\t\t * propriate OCFS2_EXT_REFCOUNTED flag we just need to\n\t\t * increase the refount count int the refcount tree.\n\t\t *\n\t\t * For the xattr which has l_tree_depth > 0, we need\n\t\t * to initialize it to the empty default value root,\n\t\t * and then insert the extents one by one.\n\t\t */\n\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\tmemcpy(new_xv, &def_xv, sizeof(def_xv));\n\t\t\tvb->vb_xv = new_xv;\n\t\t\tvb->vb_bh = value_bh;\n\t\t\tocfs2_init_xattr_value_extent_tree(&data_et,\n\t\t\t\t\tINODE_CACHE(args->new_inode), vb);\n\t\t}\n\n\t\tclusters = le32_to_cpu(xv->xr_clusters);\n\t\tcpos = 0;\n\t\twhile (cpos < clusters) {\n\t\t\tret = ocfs2_xattr_get_clusters(args->old_inode,\n\t\t\t\t\t\t       cpos,\n\t\t\t\t\t\t       &p_cluster,\n\t\t\t\t\t\t       &num_clusters,\n\t\t\t\t\t\t       &xv->xr_list,\n\t\t\t\t\t\t       &ext_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!p_cluster);\n\n\t\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\t\tret = ocfs2_insert_extent(handle,\n\t\t\t\t\t\t&data_et, cpos,\n\t\t\t\t\t\tocfs2_clusters_to_blocks(\n\t\t\t\t\t\t\targs->old_inode->i_sb,\n\t\t\t\t\t\t\tp_cluster),\n\t\t\t\t\t\tnum_clusters, ext_flags,\n\t\t\t\t\t\tmeta_ac);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = ocfs2_increase_refcount(handle, args->ref_ci,\n\t\t\t\t\t\t      args->ref_root_bh,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      meta_ac, args->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcpos += num_clusters;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};",
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_reflink_xattr_header(handle_t *handle,\n\t\t\t\t      struct ocfs2_xattr_reflink *args,\n\t\t\t\t      struct buffer_head *old_bh,\n\t\t\t\t      struct ocfs2_xattr_header *xh,\n\t\t\t\t      struct buffer_head *new_bh,\n\t\t\t\t      struct ocfs2_xattr_header *new_xh,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t      get_xattr_value_root *func,\n\t\t\t\t      void *para)\n{\n\tint ret = 0, i, j;\n\tstruct super_block *sb = args->old_inode->i_sb;\n\tstruct buffer_head *value_bh;\n\tstruct ocfs2_xattr_entry *xe, *last;\n\tstruct ocfs2_xattr_value_root *xv, *new_xv;\n\tstruct ocfs2_extent_tree data_et;\n\tu32 clusters, cpos, p_cluster, num_clusters;\n\tunsigned int ext_flags = 0;\n\n\ttrace_ocfs2_reflink_xattr_header((unsigned long long)old_bh->b_blocknr,\n\t\t\t\t\t le16_to_cpu(xh->xh_count));\n\n\tlast = &new_xh->xh_entries[le16_to_cpu(new_xh->xh_count)];\n\tfor (i = 0, j = 0; i < le16_to_cpu(xh->xh_count); i++, j++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (args->xattr_reflinked && !args->xattr_reflinked(xe)) {\n\t\t\txe = &new_xh->xh_entries[j];\n\n\t\t\tle16_add_cpu(&new_xh->xh_count, -1);\n\t\t\tif (new_xh->xh_count) {\n\t\t\t\tmemmove(xe, xe + 1,\n\t\t\t\t\t(void *)last - (void *)xe);\n\t\t\t\tmemset(last, 0,\n\t\t\t\t       sizeof(struct ocfs2_xattr_entry));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't want j to increase in the next round since\n\t\t\t * it is already moved ahead.\n\t\t\t */\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, old_bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = func(sb, new_bh, new_xh, j, &new_xv, &value_bh, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For the xattr which has l_tree_depth = 0, all the extent\n\t\t * recs have already be copied to the new xh with the\n\t\t * propriate OCFS2_EXT_REFCOUNTED flag we just need to\n\t\t * increase the refount count int the refcount tree.\n\t\t *\n\t\t * For the xattr which has l_tree_depth > 0, we need\n\t\t * to initialize it to the empty default value root,\n\t\t * and then insert the extents one by one.\n\t\t */\n\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\tmemcpy(new_xv, &def_xv, sizeof(def_xv));\n\t\t\tvb->vb_xv = new_xv;\n\t\t\tvb->vb_bh = value_bh;\n\t\t\tocfs2_init_xattr_value_extent_tree(&data_et,\n\t\t\t\t\tINODE_CACHE(args->new_inode), vb);\n\t\t}\n\n\t\tclusters = le32_to_cpu(xv->xr_clusters);\n\t\tcpos = 0;\n\t\twhile (cpos < clusters) {\n\t\t\tret = ocfs2_xattr_get_clusters(args->old_inode,\n\t\t\t\t\t\t       cpos,\n\t\t\t\t\t\t       &p_cluster,\n\t\t\t\t\t\t       &num_clusters,\n\t\t\t\t\t\t       &xv->xr_list,\n\t\t\t\t\t\t       &ext_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!p_cluster);\n\n\t\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\t\tret = ocfs2_insert_extent(handle,\n\t\t\t\t\t\t&data_et, cpos,\n\t\t\t\t\t\tocfs2_clusters_to_blocks(\n\t\t\t\t\t\t\targs->old_inode->i_sb,\n\t\t\t\t\t\t\tp_cluster),\n\t\t\t\t\t\tnum_clusters, ext_flags,\n\t\t\t\t\t\tmeta_ac);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = ocfs2_increase_refcount(handle, args->ref_ci,\n\t\t\t\t\t\t      args->ref_root_bh,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      meta_ac, args->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcpos += num_clusters;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "args->new_bucket"
          ],
          "line": 6877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "args->old_bucket"
          ],
          "line": 6875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "num_buckets"
          ],
          "line": 6868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "args->new_bucket"
          ],
          "line": 6867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bucket_xh(args->new_bucket)->\n\t\t\t\t\t    xh_entries[0].xe_name_hash"
          ],
          "line": 6865
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "args->new_bucket"
          ],
          "line": 6865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bucket_block(args->new_bucket, j)",
            "bucket_block(args->old_bucket, j)",
            "sb->s_blocksize"
          ],
          "line": 6855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "args->old_bucket",
            "j"
          ],
          "line": 6856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "args->new_bucket",
            "j"
          ],
          "line": 6855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_bucket",
          "args": [
            "args->new_bucket",
            "new_blkno",
            "1"
          ],
          "line": 6840
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_bucket_xa_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2290-2300",
          "snippet": "static void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};\n\nstatic void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_bucket",
          "args": [
            "args->old_bucket",
            "blkno"
          ],
          "line": 6834
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "404-426",
          "snippet": "static int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_reflink_xattr_bucket(handle_t *handle,\n\t\t\t\tu64 blkno, u64 new_blkno, u32 clusters,\n\t\t\t\tu32 *cpos, int num_buckets,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args)\n{\n\tint i, j, ret = 0;\n\tstruct super_block *sb = args->reflink->old_inode->i_sb;\n\tint bpb = args->old_bucket->bu_blocks;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_access = ocfs2_journal_access,\n\t};\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bpb, new_blkno += bpb) {\n\t\tret = ocfs2_read_xattr_bucket(args->old_bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_init_xattr_bucket(args->new_bucket, new_blkno, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_bucket_journal_access(handle,\n\t\t\t\t\t\targs->new_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j = 0; j < bpb; j++)\n\t\t\tmemcpy(bucket_block(args->new_bucket, j),\n\t\t\t       bucket_block(args->old_bucket, j),\n\t\t\t       sb->s_blocksize);\n\n\t\t/*\n\t\t * Record the start cpos so that we can use it to initialize\n\t\t * our xattr tree we also set the xh_num_bucket for the new\n\t\t * bucket.\n\t\t */\n\t\tif (i == 0) {\n\t\t\t*cpos = le32_to_cpu(bucket_xh(args->new_bucket)->\n\t\t\t\t\t    xh_entries[0].xe_name_hash);\n\t\t\tbucket_xh(args->new_bucket)->xh_num_buckets =\n\t\t\t\tcpu_to_le16(num_buckets);\n\t\t}\n\n\t\tocfs2_xattr_bucket_journal_dirty(handle, args->new_bucket);\n\n\t\tret = ocfs2_reflink_xattr_header(handle, args->reflink,\n\t\t\t\t\targs->old_bucket->bu_bhs[0],\n\t\t\t\t\tbucket_xh(args->old_bucket),\n\t\t\t\t\targs->new_bucket->bu_bhs[0],\n\t\t\t\t\tbucket_xh(args->new_bucket),\n\t\t\t\t\t&vb, meta_ac,\n\t\t\t\t\tocfs2_get_reflink_xattr_value_root,\n\t\t\t\t\targs);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Re-access and dirty the bucket to calculate metaecc.\n\t\t * Because we may extend the transaction in reflink_xattr_header\n\t\t * which will let the already accessed block gone.\n\t\t */\n\t\tret = ocfs2_xattr_bucket_journal_access(handle,\n\t\t\t\t\t\targs->new_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_xattr_bucket_journal_dirty(handle, args->new_bucket);\n\n\t\tocfs2_xattr_bucket_relse(args->old_bucket);\n\t\tocfs2_xattr_bucket_relse(args->new_bucket);\n\t}\n\n\tocfs2_xattr_bucket_relse(args->old_bucket);\n\tocfs2_xattr_bucket_relse(args->new_bucket);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_lock_reflink_xattr_rec_allocators",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6733-6817",
    "snippet": "static int ocfs2_lock_reflink_xattr_rec_allocators(\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args,\n\t\t\t\tstruct ocfs2_extent_tree *xt_et,\n\t\t\t\tu64 blkno, u32 len, int *credits,\n\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context **data_ac)\n{\n\tint ret, num_free_extents;\n\tstruct ocfs2_value_tree_metas metas;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->reflink->old_inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\n\tmemset(&metas, 0, sizeof(metas));\n\n\tret = ocfs2_iterate_xattr_buckets(args->reflink->old_inode, blkno, len,\n\t\t\t\t\t  ocfs2_calc_value_tree_metas, &metas);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*credits = metas.credits;\n\n\t/*\n\t * Calculate we need for refcount tree change.\n\t *\n\t * We need to add/modify num_recs in refcount tree, so just calculate\n\t * an approximate number we need for refcount tree change.\n\t * Sometimes we need to split the tree, and after split,  half recs\n\t * will be moved to the new block, and a new block can only provide\n\t * half number of recs. So we multiple new blocks by 2.\n\t * In the end, we have to add credits for modifying the already\n\t * existed refcount block.\n\t */\n\trb = (struct ocfs2_refcount_block *)args->reflink->ref_root_bh->b_data;\n\tmetas.num_recs =\n\t\t(metas.num_recs + ocfs2_refcount_recs_per_rb(osb->sb) - 1) /\n\t\t ocfs2_refcount_recs_per_rb(osb->sb) * 2;\n\tmetas.num_metas += metas.num_recs;\n\t*credits += metas.num_recs +\n\t\t    metas.num_recs * OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += le16_to_cpu(rb->rf_list.l_tree_depth) *\n\t\t\t    le16_to_cpu(rb->rf_list.l_next_free_rec) + 1;\n\telse\n\t\t*credits += 1;\n\n\t/* count in the xattr tree change. */\n\tnum_free_extents = ocfs2_num_free_extents(osb, xt_et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (num_free_extents < len)\n\t\tmetas.num_metas += ocfs2_extend_meta_needed(xt_et->et_root_el);\n\n\t*credits += ocfs2_calc_extend_credits(osb->sb,\n\t\t\t\t\t      xt_et->et_root_el);\n\n\tif (metas.num_metas) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, metas.num_metas,\n\t\t\t\t\t\t\tmeta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (len) {\n\t\tret = ocfs2_reserve_clusters(osb, len, data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "*meta_ac"
          ],
          "line": 6811
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters",
          "args": [
            "osb",
            "len",
            "data_ac"
          ],
          "line": 6804
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1228-1234",
          "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "osb",
            "metas.num_metas",
            "meta_ac"
          ],
          "line": 6795
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_extend_credits",
          "args": [
            "osb->sb",
            "xt_et->et_root_el"
          ],
          "line": 6791
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_extend_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "531-556",
          "snippet": "static inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_meta_needed",
          "args": [
            "xt_et->et_root_el"
          ],
          "line": 6789
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_meta_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "157-168",
          "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_num_free_extents",
          "args": [
            "osb",
            "xt_et"
          ],
          "line": 6781
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_num_free_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "959-990",
          "snippet": "int ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rb->rf_list.l_next_free_rec"
          ],
          "line": 6776
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rb->rf_flags"
          ],
          "line": 6774
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_recs_per_rb",
          "args": [
            "osb->sb"
          ],
          "line": 6770
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_recs_per_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1464-1472",
          "snippet": "static inline u16 ocfs2_refcount_recs_per_rb(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_refcount_block, rf_records.rl_recs);\n\n\treturn size / sizeof(struct ocfs2_refcount_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16 ocfs2_refcount_recs_per_rb(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_refcount_block, rf_records.rl_recs);\n\n\treturn size / sizeof(struct ocfs2_refcount_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iterate_xattr_buckets",
          "args": [
            "args->reflink->old_inode",
            "blkno",
            "len",
            "ocfs2_calc_value_tree_metas",
            "&metas"
          ],
          "line": 6747
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iterate_xattr_buckets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3955-4006",
          "snippet": "static int ocfs2_iterate_xattr_buckets(struct inode *inode,\n\t\t\t\t       u64 blkno,\n\t\t\t\t       u32 clusters,\n\t\t\t\t       xattr_bucket_func *func,\n\t\t\t\t       void *para)\n{\n\tint i, ret = 0;\n\tu32 bpc = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\tu32 num_buckets = clusters * bpc;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tbucket = ocfs2_xattr_bucket_new(inode);\n\tif (!bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace_ocfs2_iterate_xattr_buckets(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)blkno, clusters);\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bucket->bu_blocks) {\n\t\tret = ocfs2_read_xattr_bucket(bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The real bucket num in this series of blocks is stored\n\t\t * in the 1st bucket.\n\t\t */\n\t\tif (i == 0)\n\t\t\tnum_buckets = le16_to_cpu(bucket_xh(bucket)->xh_num_buckets);\n\n\t\ttrace_ocfs2_iterate_xattr_bucket((unsigned long long)blkno,\n\t\t     le32_to_cpu(bucket_xh(bucket)->xh_entries[0].xe_name_hash));\n\t\tif (func) {\n\t\t\tret = func(inode, bucket, para);\n\t\t\tif (ret && ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\t/* Fall through to bucket_relse() */\n\t\t}\n\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tocfs2_xattr_bucket_free(bucket);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_iterate_xattr_buckets(struct inode *inode,\n\t\t\t\t       u64 blkno,\n\t\t\t\t       u32 clusters,\n\t\t\t\t       xattr_bucket_func *func,\n\t\t\t\t       void *para)\n{\n\tint i, ret = 0;\n\tu32 bpc = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\tu32 num_buckets = clusters * bpc;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tbucket = ocfs2_xattr_bucket_new(inode);\n\tif (!bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace_ocfs2_iterate_xattr_buckets(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)blkno, clusters);\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bucket->bu_blocks) {\n\t\tret = ocfs2_read_xattr_bucket(bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The real bucket num in this series of blocks is stored\n\t\t * in the 1st bucket.\n\t\t */\n\t\tif (i == 0)\n\t\t\tnum_buckets = le16_to_cpu(bucket_xh(bucket)->xh_num_buckets);\n\n\t\ttrace_ocfs2_iterate_xattr_bucket((unsigned long long)blkno,\n\t\t     le32_to_cpu(bucket_xh(bucket)->xh_entries[0].xe_name_hash));\n\t\tif (func) {\n\t\t\tret = func(inode, bucket, para);\n\t\t\tif (ret && ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\t/* Fall through to bucket_relse() */\n\t\t}\n\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tocfs2_xattr_bucket_free(bucket);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&metas",
            "0",
            "sizeof(metas)"
          ],
          "line": 6745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "args->reflink->old_inode->i_sb"
          ],
          "line": 6742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_lock_reflink_xattr_rec_allocators(\n\t\t\t\tstruct ocfs2_reflink_xattr_tree_args *args,\n\t\t\t\tstruct ocfs2_extent_tree *xt_et,\n\t\t\t\tu64 blkno, u32 len, int *credits,\n\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\tstruct ocfs2_alloc_context **data_ac)\n{\n\tint ret, num_free_extents;\n\tstruct ocfs2_value_tree_metas metas;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->reflink->old_inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\n\tmemset(&metas, 0, sizeof(metas));\n\n\tret = ocfs2_iterate_xattr_buckets(args->reflink->old_inode, blkno, len,\n\t\t\t\t\t  ocfs2_calc_value_tree_metas, &metas);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*credits = metas.credits;\n\n\t/*\n\t * Calculate we need for refcount tree change.\n\t *\n\t * We need to add/modify num_recs in refcount tree, so just calculate\n\t * an approximate number we need for refcount tree change.\n\t * Sometimes we need to split the tree, and after split,  half recs\n\t * will be moved to the new block, and a new block can only provide\n\t * half number of recs. So we multiple new blocks by 2.\n\t * In the end, we have to add credits for modifying the already\n\t * existed refcount block.\n\t */\n\trb = (struct ocfs2_refcount_block *)args->reflink->ref_root_bh->b_data;\n\tmetas.num_recs =\n\t\t(metas.num_recs + ocfs2_refcount_recs_per_rb(osb->sb) - 1) /\n\t\t ocfs2_refcount_recs_per_rb(osb->sb) * 2;\n\tmetas.num_metas += metas.num_recs;\n\t*credits += metas.num_recs +\n\t\t    metas.num_recs * OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += le16_to_cpu(rb->rf_list.l_tree_depth) *\n\t\t\t    le16_to_cpu(rb->rf_list.l_next_free_rec) + 1;\n\telse\n\t\t*credits += 1;\n\n\t/* count in the xattr tree change. */\n\tnum_free_extents = ocfs2_num_free_extents(osb, xt_et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (num_free_extents < len)\n\t\tmetas.num_metas += ocfs2_extend_meta_needed(xt_et->et_root_el);\n\n\t*credits += ocfs2_calc_extend_credits(osb->sb,\n\t\t\t\t\t      xt_et->et_root_el);\n\n\tif (metas.num_metas) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, metas.num_metas,\n\t\t\t\t\t\t\tmeta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (len) {\n\t\tret = ocfs2_reserve_clusters(osb, len, data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_calc_value_tree_metas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6710-6726",
    "snippet": "static int ocfs2_calc_value_tree_metas(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t      void *para)\n{\n\tstruct ocfs2_value_tree_metas *metas =\n\t\t\t(struct ocfs2_value_tree_metas *)para;\n\tstruct ocfs2_xattr_header *xh =\n\t\t\t(struct ocfs2_xattr_header *)bucket->bu_bhs[0]->b_data;\n\n\t/* Add the credits for this bucket first. */\n\tmetas->credits += bucket->bu_blocks;\n\treturn ocfs2_value_metas_in_xattr_header(inode->i_sb, bucket->bu_bhs[0],\n\t\t\t\t\txh, &metas->num_metas,\n\t\t\t\t\t&metas->credits, &metas->num_recs,\n\t\t\t\t\tocfs2_value_tree_metas_in_bucket,\n\t\t\t\t\tbucket);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_value_metas_in_xattr_header",
          "args": [
            "inode->i_sb",
            "bucket->bu_bhs[0]",
            "xh",
            "&metas->num_metas",
            "&metas->credits",
            "&metas->num_recs",
            "ocfs2_value_tree_metas_in_bucket",
            "bucket"
          ],
          "line": 6721
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_value_metas_in_xattr_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6200-6241",
          "snippet": "static int ocfs2_value_metas_in_xattr_header(struct super_block *sb,\n\t\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int *metas, int *credits,\n\t\t\t\t\t     int *num_recs,\n\t\t\t\t\t     get_xattr_value_root *func,\n\t\t\t\t\t     void *para)\n{\n\tint i, ret = 0;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_xattr_entry *xe;\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t*metas += le16_to_cpu(xv->xr_list.l_tree_depth) *\n\t\t\t  le16_to_cpu(xv->xr_list.l_next_free_rec);\n\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t&def_xv.xv.xr_list);\n\n\t\t/*\n\t\t * If the value is a tree with depth > 1, We don't go deep\n\t\t * to the extent block, so just calculate a maximum record num.\n\t\t */\n\t\tif (!xv->xr_list.l_tree_depth)\n\t\t\t*num_recs += le16_to_cpu(xv->xr_list.l_next_free_rec);\n\t\telse\n\t\t\t*num_recs += ocfs2_clusters_for_bytes(sb,\n\t\t\t\t\t\t\t      XATTR_SIZE_MAX);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};",
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);",
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_value_metas_in_xattr_header(struct super_block *sb,\n\t\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int *metas, int *credits,\n\t\t\t\t\t     int *num_recs,\n\t\t\t\t\t     get_xattr_value_root *func,\n\t\t\t\t\t     void *para)\n{\n\tint i, ret = 0;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_xattr_entry *xe;\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t*metas += le16_to_cpu(xv->xr_list.l_tree_depth) *\n\t\t\t  le16_to_cpu(xv->xr_list.l_next_free_rec);\n\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t&def_xv.xv.xr_list);\n\n\t\t/*\n\t\t * If the value is a tree with depth > 1, We don't go deep\n\t\t * to the extent block, so just calculate a maximum record num.\n\t\t */\n\t\tif (!xv->xr_list.l_tree_depth)\n\t\t\t*num_recs += le16_to_cpu(xv->xr_list.l_next_free_rec);\n\t\telse\n\t\t\t*num_recs += ocfs2_clusters_for_bytes(sb,\n\t\t\t\t\t\t\t      XATTR_SIZE_MAX);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_calc_value_tree_metas(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t      void *para)\n{\n\tstruct ocfs2_value_tree_metas *metas =\n\t\t\t(struct ocfs2_value_tree_metas *)para;\n\tstruct ocfs2_xattr_header *xh =\n\t\t\t(struct ocfs2_xattr_header *)bucket->bu_bhs[0]->b_data;\n\n\t/* Add the credits for this bucket first. */\n\tmetas->credits += bucket->bu_blocks;\n\treturn ocfs2_value_metas_in_xattr_header(inode->i_sb, bucket->bu_bhs[0],\n\t\t\t\t\txh, &metas->num_metas,\n\t\t\t\t\t&metas->credits, &metas->num_recs,\n\t\t\t\t\tocfs2_value_tree_metas_in_bucket,\n\t\t\t\t\tbucket);\n}"
  },
  {
    "function_name": "ocfs2_value_tree_metas_in_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6695-6708",
    "snippet": "static int ocfs2_value_tree_metas_in_bucket(struct super_block *sb,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tint offset,\n\t\t\t\t\tstruct ocfs2_xattr_value_root **xv,\n\t\t\t\t\tstruct buffer_head **ret_bh,\n\t\t\t\t\tvoid *para)\n{\n\tstruct ocfs2_xattr_bucket *bucket =\n\t\t\t\t(struct ocfs2_xattr_bucket *)para;\n\n\treturn ocfs2_get_xattr_tree_value_root(sb, bucket, offset,\n\t\t\t\t\t       xv, ret_bh);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);",
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_get_xattr_tree_value_root",
          "args": [
            "sb",
            "bucket",
            "offset",
            "xv",
            "ret_bh"
          ],
          "line": 6706
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_xattr_tree_value_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5986-6016",
          "snippet": "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh)\n{\n\tint ret, block_off, name_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\tvoid *base;\n\n\tret = ocfs2_xattr_bucket_get_name_value(sb,\n\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t&name_offset);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbase = bucket_block(bucket, block_off);\n\n\t*xv = (struct ocfs2_xattr_value_root *)(base + name_offset +\n\t\t\t OCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (bh)\n\t\t*bh = bucket->bu_bhs[block_off];\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh)\n{\n\tint ret, block_off, name_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\tvoid *base;\n\n\tret = ocfs2_xattr_bucket_get_name_value(sb,\n\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t&name_offset);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbase = bucket_block(bucket, block_off);\n\n\t*xv = (struct ocfs2_xattr_value_root *)(base + name_offset +\n\t\t\t OCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (bh)\n\t\t*bh = bucket->bu_bhs[block_off];\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_value_tree_metas_in_bucket(struct super_block *sb,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tint offset,\n\t\t\t\t\tstruct ocfs2_xattr_value_root **xv,\n\t\t\t\t\tstruct buffer_head **ret_bh,\n\t\t\t\t\tvoid *para)\n{\n\tstruct ocfs2_xattr_bucket *bucket =\n\t\t\t\t(struct ocfs2_xattr_bucket *)para;\n\n\treturn ocfs2_get_xattr_tree_value_root(sb, bucket, offset,\n\t\t\t\t\t       xv, ret_bh);\n}"
  },
  {
    "function_name": "ocfs2_get_reflink_xattr_value_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6668-6687",
    "snippet": "static int ocfs2_get_reflink_xattr_value_root(struct super_block *sb,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tint offset,\n\t\t\t\t\tstruct ocfs2_xattr_value_root **xv,\n\t\t\t\t\tstruct buffer_head **ret_bh,\n\t\t\t\t\tvoid *para)\n{\n\tstruct ocfs2_reflink_xattr_tree_args *args =\n\t\t\t(struct ocfs2_reflink_xattr_tree_args *)para;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tif (bh == args->old_bucket->bu_bhs[0])\n\t\tbucket = args->old_bucket;\n\telse\n\t\tbucket = args->new_bucket;\n\n\treturn ocfs2_get_xattr_tree_value_root(sb, bucket, offset,\n\t\t\t\t\t       xv, ret_bh);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);",
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_get_xattr_tree_value_root",
          "args": [
            "sb",
            "bucket",
            "offset",
            "xv",
            "ret_bh"
          ],
          "line": 6685
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_xattr_tree_value_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5986-6016",
          "snippet": "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh)\n{\n\tint ret, block_off, name_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\tvoid *base;\n\n\tret = ocfs2_xattr_bucket_get_name_value(sb,\n\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t&name_offset);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbase = bucket_block(bucket, block_off);\n\n\t*xv = (struct ocfs2_xattr_value_root *)(base + name_offset +\n\t\t\t OCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (bh)\n\t\t*bh = bucket->bu_bhs[block_off];\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh)\n{\n\tint ret, block_off, name_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\tvoid *base;\n\n\tret = ocfs2_xattr_bucket_get_name_value(sb,\n\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t&name_offset);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbase = bucket_block(bucket, block_off);\n\n\t*xv = (struct ocfs2_xattr_value_root *)(base + name_offset +\n\t\t\t OCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (bh)\n\t\t*bh = bucket->bu_bhs[block_off];\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_get_reflink_xattr_value_root(struct super_block *sb,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tint offset,\n\t\t\t\t\tstruct ocfs2_xattr_value_root **xv,\n\t\t\t\t\tstruct buffer_head **ret_bh,\n\t\t\t\t\tvoid *para)\n{\n\tstruct ocfs2_reflink_xattr_tree_args *args =\n\t\t\t(struct ocfs2_reflink_xattr_tree_args *)para;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tif (bh == args->old_bucket->bu_bhs[0])\n\t\tbucket = args->old_bucket;\n\telse\n\t\tbucket = args->new_bucket;\n\n\treturn ocfs2_get_xattr_tree_value_root(sb, bucket, offset,\n\t\t\t\t\t       xv, ret_bh);\n}"
  },
  {
    "function_name": "ocfs2_reflink_xattr_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6568-6652",
    "snippet": "static int ocfs2_reflink_xattr_block(struct ocfs2_xattr_reflink *args,\n\t\t\t\t     struct buffer_head *blk_bh,\n\t\t\t\t     struct buffer_head *new_blk_bh)\n{\n\tint ret = 0, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_inode_info *new_oi = OCFS2_I(args->new_inode);\n\tstruct ocfs2_dinode *new_di;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->new_inode->i_sb);\n\tint header_off = offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_xattr_header *xh = &xb->xb_attrs.xb_header;\n\tstruct ocfs2_xattr_block *new_xb =\n\t\t\t(struct ocfs2_xattr_block *)new_blk_bh->b_data;\n\tstruct ocfs2_xattr_header *new_xh = &new_xb->xb_attrs.xb_header;\n\tstruct ocfs2_alloc_context *meta_ac;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = new_blk_bh,\n\t\t.vb_access = ocfs2_journal_access_xb,\n\t};\n\n\tret = ocfs2_reflink_lock_xattr_allocators(osb, xh, args->ref_root_bh,\n\t\t\t\t\t\t  &credits, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/* One more credits in case we need to add xattr flags in new inode. */\n\thandle = ocfs2_start_trans(osb, credits + 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(new_oi->ip_dyn_features & OCFS2_HAS_XATTR_FL)) {\n\t\tret = ocfs2_journal_access_di(handle,\n\t\t\t\t\t      INODE_CACHE(args->new_inode),\n\t\t\t\t\t      args->new_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(args->new_inode),\n\t\t\t\t      new_blk_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(new_blk_bh->b_data + header_off, blk_bh->b_data + header_off,\n\t       osb->sb->s_blocksize - header_off);\n\n\tret = ocfs2_reflink_xattr_header(handle, args, blk_bh, xh,\n\t\t\t\t\t new_blk_bh, new_xh, &vb, meta_ac,\n\t\t\t\t\t ocfs2_get_xattr_value_root, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_journal_dirty(handle, new_blk_bh);\n\n\tif (!(new_oi->ip_dyn_features & OCFS2_HAS_XATTR_FL)) {\n\t\tnew_di = (struct ocfs2_dinode *)args->new_bh->b_data;\n\t\tspin_lock(&new_oi->ip_lock);\n\t\tnew_oi->ip_dyn_features |= OCFS2_HAS_XATTR_FL;\n\t\tnew_di->i_dyn_features = cpu_to_le16(new_oi->ip_dyn_features);\n\t\tspin_unlock(&new_oi->ip_lock);\n\n\t\tocfs2_journal_dirty(handle, args->new_bh);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "meta_ac"
          ],
          "line": 6650
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 6647
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "args->new_bh"
          ],
          "line": 6643
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&new_oi->ip_lock"
          ],
          "line": 6641
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "new_oi->ip_dyn_features"
          ],
          "line": 6640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&new_oi->ip_lock"
          ],
          "line": 6638
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_xattr_header",
          "args": [
            "handle",
            "args",
            "blk_bh",
            "xh",
            "new_blk_bh",
            "new_xh",
            "&vb",
            "meta_ac",
            "ocfs2_get_xattr_value_root",
            "NULL"
          ],
          "line": 6626
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_xattr_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6324-6448",
          "snippet": "static int ocfs2_reflink_xattr_header(handle_t *handle,\n\t\t\t\t      struct ocfs2_xattr_reflink *args,\n\t\t\t\t      struct buffer_head *old_bh,\n\t\t\t\t      struct ocfs2_xattr_header *xh,\n\t\t\t\t      struct buffer_head *new_bh,\n\t\t\t\t      struct ocfs2_xattr_header *new_xh,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t      get_xattr_value_root *func,\n\t\t\t\t      void *para)\n{\n\tint ret = 0, i, j;\n\tstruct super_block *sb = args->old_inode->i_sb;\n\tstruct buffer_head *value_bh;\n\tstruct ocfs2_xattr_entry *xe, *last;\n\tstruct ocfs2_xattr_value_root *xv, *new_xv;\n\tstruct ocfs2_extent_tree data_et;\n\tu32 clusters, cpos, p_cluster, num_clusters;\n\tunsigned int ext_flags = 0;\n\n\ttrace_ocfs2_reflink_xattr_header((unsigned long long)old_bh->b_blocknr,\n\t\t\t\t\t le16_to_cpu(xh->xh_count));\n\n\tlast = &new_xh->xh_entries[le16_to_cpu(new_xh->xh_count)];\n\tfor (i = 0, j = 0; i < le16_to_cpu(xh->xh_count); i++, j++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (args->xattr_reflinked && !args->xattr_reflinked(xe)) {\n\t\t\txe = &new_xh->xh_entries[j];\n\n\t\t\tle16_add_cpu(&new_xh->xh_count, -1);\n\t\t\tif (new_xh->xh_count) {\n\t\t\t\tmemmove(xe, xe + 1,\n\t\t\t\t\t(void *)last - (void *)xe);\n\t\t\t\tmemset(last, 0,\n\t\t\t\t       sizeof(struct ocfs2_xattr_entry));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't want j to increase in the next round since\n\t\t\t * it is already moved ahead.\n\t\t\t */\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, old_bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = func(sb, new_bh, new_xh, j, &new_xv, &value_bh, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For the xattr which has l_tree_depth = 0, all the extent\n\t\t * recs have already be copied to the new xh with the\n\t\t * propriate OCFS2_EXT_REFCOUNTED flag we just need to\n\t\t * increase the refount count int the refcount tree.\n\t\t *\n\t\t * For the xattr which has l_tree_depth > 0, we need\n\t\t * to initialize it to the empty default value root,\n\t\t * and then insert the extents one by one.\n\t\t */\n\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\tmemcpy(new_xv, &def_xv, sizeof(def_xv));\n\t\t\tvb->vb_xv = new_xv;\n\t\t\tvb->vb_bh = value_bh;\n\t\t\tocfs2_init_xattr_value_extent_tree(&data_et,\n\t\t\t\t\tINODE_CACHE(args->new_inode), vb);\n\t\t}\n\n\t\tclusters = le32_to_cpu(xv->xr_clusters);\n\t\tcpos = 0;\n\t\twhile (cpos < clusters) {\n\t\t\tret = ocfs2_xattr_get_clusters(args->old_inode,\n\t\t\t\t\t\t       cpos,\n\t\t\t\t\t\t       &p_cluster,\n\t\t\t\t\t\t       &num_clusters,\n\t\t\t\t\t\t       &xv->xr_list,\n\t\t\t\t\t\t       &ext_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!p_cluster);\n\n\t\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\t\tret = ocfs2_insert_extent(handle,\n\t\t\t\t\t\t&data_et, cpos,\n\t\t\t\t\t\tocfs2_clusters_to_blocks(\n\t\t\t\t\t\t\targs->old_inode->i_sb,\n\t\t\t\t\t\t\tp_cluster),\n\t\t\t\t\t\tnum_clusters, ext_flags,\n\t\t\t\t\t\tmeta_ac);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = ocfs2_increase_refcount(handle, args->ref_ci,\n\t\t\t\t\t\t      args->ref_root_bh,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      meta_ac, args->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcpos += num_clusters;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};",
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_reflink_xattr_header(handle_t *handle,\n\t\t\t\t      struct ocfs2_xattr_reflink *args,\n\t\t\t\t      struct buffer_head *old_bh,\n\t\t\t\t      struct ocfs2_xattr_header *xh,\n\t\t\t\t      struct buffer_head *new_bh,\n\t\t\t\t      struct ocfs2_xattr_header *new_xh,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t      get_xattr_value_root *func,\n\t\t\t\t      void *para)\n{\n\tint ret = 0, i, j;\n\tstruct super_block *sb = args->old_inode->i_sb;\n\tstruct buffer_head *value_bh;\n\tstruct ocfs2_xattr_entry *xe, *last;\n\tstruct ocfs2_xattr_value_root *xv, *new_xv;\n\tstruct ocfs2_extent_tree data_et;\n\tu32 clusters, cpos, p_cluster, num_clusters;\n\tunsigned int ext_flags = 0;\n\n\ttrace_ocfs2_reflink_xattr_header((unsigned long long)old_bh->b_blocknr,\n\t\t\t\t\t le16_to_cpu(xh->xh_count));\n\n\tlast = &new_xh->xh_entries[le16_to_cpu(new_xh->xh_count)];\n\tfor (i = 0, j = 0; i < le16_to_cpu(xh->xh_count); i++, j++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (args->xattr_reflinked && !args->xattr_reflinked(xe)) {\n\t\t\txe = &new_xh->xh_entries[j];\n\n\t\t\tle16_add_cpu(&new_xh->xh_count, -1);\n\t\t\tif (new_xh->xh_count) {\n\t\t\t\tmemmove(xe, xe + 1,\n\t\t\t\t\t(void *)last - (void *)xe);\n\t\t\t\tmemset(last, 0,\n\t\t\t\t       sizeof(struct ocfs2_xattr_entry));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't want j to increase in the next round since\n\t\t\t * it is already moved ahead.\n\t\t\t */\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, old_bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = func(sb, new_bh, new_xh, j, &new_xv, &value_bh, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For the xattr which has l_tree_depth = 0, all the extent\n\t\t * recs have already be copied to the new xh with the\n\t\t * propriate OCFS2_EXT_REFCOUNTED flag we just need to\n\t\t * increase the refount count int the refcount tree.\n\t\t *\n\t\t * For the xattr which has l_tree_depth > 0, we need\n\t\t * to initialize it to the empty default value root,\n\t\t * and then insert the extents one by one.\n\t\t */\n\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\tmemcpy(new_xv, &def_xv, sizeof(def_xv));\n\t\t\tvb->vb_xv = new_xv;\n\t\t\tvb->vb_bh = value_bh;\n\t\t\tocfs2_init_xattr_value_extent_tree(&data_et,\n\t\t\t\t\tINODE_CACHE(args->new_inode), vb);\n\t\t}\n\n\t\tclusters = le32_to_cpu(xv->xr_clusters);\n\t\tcpos = 0;\n\t\twhile (cpos < clusters) {\n\t\t\tret = ocfs2_xattr_get_clusters(args->old_inode,\n\t\t\t\t\t\t       cpos,\n\t\t\t\t\t\t       &p_cluster,\n\t\t\t\t\t\t       &num_clusters,\n\t\t\t\t\t\t       &xv->xr_list,\n\t\t\t\t\t\t       &ext_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!p_cluster);\n\n\t\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\t\tret = ocfs2_insert_extent(handle,\n\t\t\t\t\t\t&data_et, cpos,\n\t\t\t\t\t\tocfs2_clusters_to_blocks(\n\t\t\t\t\t\t\targs->old_inode->i_sb,\n\t\t\t\t\t\t\tp_cluster),\n\t\t\t\t\t\tnum_clusters, ext_flags,\n\t\t\t\t\t\tmeta_ac);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = ocfs2_increase_refcount(handle, args->ref_ci,\n\t\t\t\t\t\t      args->ref_root_bh,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      meta_ac, args->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcpos += num_clusters;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_blk_bh->b_data + header_off",
            "blk_bh->b_data + header_off",
            "osb->sb->s_blocksize - header_off"
          ],
          "line": 6623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_xb",
          "args": [
            "handle",
            "INODE_CACHE(args->new_inode)",
            "new_blk_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 6616
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_xb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "741-745",
          "snippet": "int ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};\n\nint ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "args->new_inode"
          ],
          "line": 6616
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(args->new_inode)",
            "args->new_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 6606
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 6600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 6599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits + 1"
          ],
          "line": 6598
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_lock_xattr_allocators",
          "args": [
            "osb",
            "xh",
            "args->ref_root_bh",
            "&credits",
            "&meta_ac"
          ],
          "line": 6590
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_lock_xattr_allocators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6268-6311",
          "snippet": "static int ocfs2_reflink_lock_xattr_allocators(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tint *credits,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac)\n{\n\tint ret, meta_add = 0, num_recs = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\t*credits = 0;\n\n\tret = ocfs2_value_metas_in_xattr_header(osb->sb, NULL, xh,\n\t\t\t\t\t\t&meta_add, credits, &num_recs,\n\t\t\t\t\t\tocfs2_get_xattr_value_root,\n\t\t\t\t\t\tNULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We need to add/modify num_recs in refcount tree, so just calculate\n\t * an approximate number we need for refcount tree change.\n\t * Sometimes we need to split the tree, and after split,  half recs\n\t * will be moved to the new block, and a new block can only provide\n\t * half number of recs. So we multiple new blocks by 2.\n\t */\n\tnum_recs = num_recs / ocfs2_refcount_recs_per_rb(osb->sb) * 2;\n\tmeta_add += num_recs;\n\t*credits += num_recs + num_recs * OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += le16_to_cpu(rb->rf_list.l_tree_depth) *\n\t\t\t    le16_to_cpu(rb->rf_list.l_next_free_rec) + 1;\n\telse\n\t\t*credits += 1;\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, meta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_reflink_lock_xattr_allocators(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tint *credits,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac)\n{\n\tint ret, meta_add = 0, num_recs = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\t*credits = 0;\n\n\tret = ocfs2_value_metas_in_xattr_header(osb->sb, NULL, xh,\n\t\t\t\t\t\t&meta_add, credits, &num_recs,\n\t\t\t\t\t\tocfs2_get_xattr_value_root,\n\t\t\t\t\t\tNULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We need to add/modify num_recs in refcount tree, so just calculate\n\t * an approximate number we need for refcount tree change.\n\t * Sometimes we need to split the tree, and after split,  half recs\n\t * will be moved to the new block, and a new block can only provide\n\t * half number of recs. So we multiple new blocks by 2.\n\t */\n\tnum_recs = num_recs / ocfs2_refcount_recs_per_rb(osb->sb) * 2;\n\tmeta_add += num_recs;\n\t*credits += num_recs + num_recs * OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += le16_to_cpu(rb->rf_list.l_tree_depth) *\n\t\t\t    le16_to_cpu(rb->rf_list.l_next_free_rec) + 1;\n\telse\n\t\t*credits += 1;\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, meta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "args->new_inode->i_sb"
          ],
          "line": 6576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "args->new_inode"
          ],
          "line": 6574
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_reflink_xattr_block(struct ocfs2_xattr_reflink *args,\n\t\t\t\t     struct buffer_head *blk_bh,\n\t\t\t\t     struct buffer_head *new_blk_bh)\n{\n\tint ret = 0, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_inode_info *new_oi = OCFS2_I(args->new_inode);\n\tstruct ocfs2_dinode *new_di;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->new_inode->i_sb);\n\tint header_off = offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_xattr_header *xh = &xb->xb_attrs.xb_header;\n\tstruct ocfs2_xattr_block *new_xb =\n\t\t\t(struct ocfs2_xattr_block *)new_blk_bh->b_data;\n\tstruct ocfs2_xattr_header *new_xh = &new_xb->xb_attrs.xb_header;\n\tstruct ocfs2_alloc_context *meta_ac;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = new_blk_bh,\n\t\t.vb_access = ocfs2_journal_access_xb,\n\t};\n\n\tret = ocfs2_reflink_lock_xattr_allocators(osb, xh, args->ref_root_bh,\n\t\t\t\t\t\t  &credits, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/* One more credits in case we need to add xattr flags in new inode. */\n\thandle = ocfs2_start_trans(osb, credits + 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(new_oi->ip_dyn_features & OCFS2_HAS_XATTR_FL)) {\n\t\tret = ocfs2_journal_access_di(handle,\n\t\t\t\t\t      INODE_CACHE(args->new_inode),\n\t\t\t\t\t      args->new_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(args->new_inode),\n\t\t\t\t      new_blk_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(new_blk_bh->b_data + header_off, blk_bh->b_data + header_off,\n\t       osb->sb->s_blocksize - header_off);\n\n\tret = ocfs2_reflink_xattr_header(handle, args, blk_bh, xh,\n\t\t\t\t\t new_blk_bh, new_xh, &vb, meta_ac,\n\t\t\t\t\t ocfs2_get_xattr_value_root, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_journal_dirty(handle, new_blk_bh);\n\n\tif (!(new_oi->ip_dyn_features & OCFS2_HAS_XATTR_FL)) {\n\t\tnew_di = (struct ocfs2_dinode *)args->new_bh->b_data;\n\t\tspin_lock(&new_oi->ip_lock);\n\t\tnew_oi->ip_dyn_features |= OCFS2_HAS_XATTR_FL;\n\t\tnew_di->i_dyn_features = cpu_to_le16(new_oi->ip_dyn_features);\n\t\tspin_unlock(&new_oi->ip_lock);\n\n\t\tocfs2_journal_dirty(handle, args->new_bh);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_create_empty_xattr_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6532-6566",
    "snippet": "static int ocfs2_create_empty_xattr_block(struct inode *inode,\n\t\t\t\t\t  struct buffer_head *fe_bh,\n\t\t\t\t\t  struct buffer_head **ret_bh,\n\t\t\t\t\t  int indexed)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt;\n\n\tmemset(&ctxt, 0, sizeof(ctxt));\n\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &ctxt.meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tctxt.handle = ocfs2_start_trans(osb, OCFS2_XATTR_BLOCK_CREATE_CREDITS);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_create_empty_xattr_block(\n\t\t\t\t(unsigned long long)fe_bh->b_blocknr, indexed);\n\tret = ocfs2_create_xattr_block(inode, fe_bh, &ctxt, indexed,\n\t\t\t\t       ret_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\nout:\n\tocfs2_free_alloc_context(ctxt.meta_ac);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "ctxt.meta_ac"
          ],
          "line": 6564
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "ctxt.handle"
          ],
          "line": 6562
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_xattr_block",
          "args": [
            "inode",
            "fe_bh",
            "&ctxt",
            "indexed",
            "ret_bh"
          ],
          "line": 6557
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2845-2929",
          "snippet": "static int ocfs2_create_xattr_block(struct inode *inode,\n\t\t\t\t    struct buffer_head *inode_bh,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt,\n\t\t\t\t    int indexed,\n\t\t\t\t    struct buffer_head **ret_bh)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_dinode *di =  (struct ocfs2_dinode *)inode_bh->b_data;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_xattr_block *xblk;\n\n\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      inode_bh, OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tret = ocfs2_claim_metadata(ctxt->handle, ctxt->meta_ac, 1,\n\t\t\t\t   &suballoc_loc, &suballoc_bit_start,\n\t\t\t\t   &num_got, &first_blkno);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n\tif (!new_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tret = ocfs2_journal_access_xb(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\t/* Initialize ocfs2_xattr_block */\n\txblk = (struct ocfs2_xattr_block *)new_bh->b_data;\n\tmemset(xblk, 0, inode->i_sb->s_blocksize);\n\tstrcpy((void *)xblk, OCFS2_XATTR_BLOCK_SIGNATURE);\n\txblk->xb_suballoc_slot = cpu_to_le16(ctxt->meta_ac->ac_alloc_slot);\n\txblk->xb_suballoc_loc = cpu_to_le64(suballoc_loc);\n\txblk->xb_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\txblk->xb_fs_generation =\n\t\tcpu_to_le32(OCFS2_SB(inode->i_sb)->fs_generation);\n\txblk->xb_blkno = cpu_to_le64(first_blkno);\n\tif (indexed) {\n\t\tstruct ocfs2_xattr_tree_root *xr = &xblk->xb_attrs.xb_root;\n\t\txr->xt_clusters = cpu_to_le32(1);\n\t\txr->xt_last_eb_blk = 0;\n\t\txr->xt_list.l_tree_depth = 0;\n\t\txr->xt_list.l_count = cpu_to_le16(\n\t\t\t\t\tocfs2_xattr_recs_per_xb(inode->i_sb));\n\t\txr->xt_list.l_next_free_rec = cpu_to_le16(1);\n\t\txblk->xb_flags = cpu_to_le16(OCFS2_XATTR_INDEXED);\n\t}\n\tocfs2_journal_dirty(ctxt->handle, new_bh);\n\n\t/* Add it to the inode */\n\tdi->i_xattr_loc = cpu_to_le64(first_blkno);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tOCFS2_I(inode)->ip_dyn_features |= OCFS2_HAS_XATTR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tocfs2_journal_dirty(ctxt->handle, inode_bh);\n\n\t*ret_bh = new_bh;\n\tnew_bh = NULL;\n\nend:\n\tbrelse(new_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_create_xattr_block(struct inode *inode,\n\t\t\t\t    struct buffer_head *inode_bh,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt,\n\t\t\t\t    int indexed,\n\t\t\t\t    struct buffer_head **ret_bh)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_dinode *di =  (struct ocfs2_dinode *)inode_bh->b_data;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_xattr_block *xblk;\n\n\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      inode_bh, OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tret = ocfs2_claim_metadata(ctxt->handle, ctxt->meta_ac, 1,\n\t\t\t\t   &suballoc_loc, &suballoc_bit_start,\n\t\t\t\t   &num_got, &first_blkno);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n\tif (!new_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tret = ocfs2_journal_access_xb(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\t/* Initialize ocfs2_xattr_block */\n\txblk = (struct ocfs2_xattr_block *)new_bh->b_data;\n\tmemset(xblk, 0, inode->i_sb->s_blocksize);\n\tstrcpy((void *)xblk, OCFS2_XATTR_BLOCK_SIGNATURE);\n\txblk->xb_suballoc_slot = cpu_to_le16(ctxt->meta_ac->ac_alloc_slot);\n\txblk->xb_suballoc_loc = cpu_to_le64(suballoc_loc);\n\txblk->xb_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\txblk->xb_fs_generation =\n\t\tcpu_to_le32(OCFS2_SB(inode->i_sb)->fs_generation);\n\txblk->xb_blkno = cpu_to_le64(first_blkno);\n\tif (indexed) {\n\t\tstruct ocfs2_xattr_tree_root *xr = &xblk->xb_attrs.xb_root;\n\t\txr->xt_clusters = cpu_to_le32(1);\n\t\txr->xt_last_eb_blk = 0;\n\t\txr->xt_list.l_tree_depth = 0;\n\t\txr->xt_list.l_count = cpu_to_le16(\n\t\t\t\t\tocfs2_xattr_recs_per_xb(inode->i_sb));\n\t\txr->xt_list.l_next_free_rec = cpu_to_le16(1);\n\t\txblk->xb_flags = cpu_to_le16(OCFS2_XATTR_INDEXED);\n\t}\n\tocfs2_journal_dirty(ctxt->handle, new_bh);\n\n\t/* Add it to the inode */\n\tdi->i_xattr_loc = cpu_to_le64(first_blkno);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tOCFS2_I(inode)->ip_dyn_features |= OCFS2_HAS_XATTR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tocfs2_journal_dirty(ctxt->handle, inode_bh);\n\n\t*ret_bh = new_bh;\n\tnew_bh = NULL;\n\nend:\n\tbrelse(new_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_create_empty_xattr_block",
          "args": [
            "(unsigned long long)fe_bh->b_blocknr",
            "indexed"
          ],
          "line": 6555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ctxt.handle"
          ],
          "line": 6550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctxt.handle"
          ],
          "line": 6549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_XATTR_BLOCK_CREATE_CREDITS"
          ],
          "line": 6548
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "osb",
            "1",
            "&ctxt.meta_ac"
          ],
          "line": 6542
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctxt",
            "0",
            "sizeof(ctxt)"
          ],
          "line": 6541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 6538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_create_empty_xattr_block(struct inode *inode,\n\t\t\t\t\t  struct buffer_head *fe_bh,\n\t\t\t\t\t  struct buffer_head **ret_bh,\n\t\t\t\t\t  int indexed)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt;\n\n\tmemset(&ctxt, 0, sizeof(ctxt));\n\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &ctxt.meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tctxt.handle = ocfs2_start_trans(osb, OCFS2_XATTR_BLOCK_CREATE_CREDITS);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_create_empty_xattr_block(\n\t\t\t\t(unsigned long long)fe_bh->b_blocknr, indexed);\n\tret = ocfs2_create_xattr_block(inode, fe_bh, &ctxt, indexed,\n\t\t\t\t       ret_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\nout:\n\tocfs2_free_alloc_context(ctxt.meta_ac);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reflink_xattr_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6450-6530",
    "snippet": "static int ocfs2_reflink_xattr_inline(struct ocfs2_xattr_reflink *args)\n{\n\tint ret = 0, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->old_inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)args->old_bh->b_data;\n\tint inline_size = le16_to_cpu(di->i_xattr_inline_size);\n\tint header_off = osb->sb->s_blocksize - inline_size;\n\tstruct ocfs2_xattr_header *xh = (struct ocfs2_xattr_header *)\n\t\t\t\t\t(args->old_bh->b_data + header_off);\n\tstruct ocfs2_xattr_header *new_xh = (struct ocfs2_xattr_header *)\n\t\t\t\t\t(args->new_bh->b_data + header_off);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_inode_info *new_oi;\n\tstruct ocfs2_dinode *new_di;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = args->new_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\tret = ocfs2_reflink_lock_xattr_allocators(osb, xh, args->ref_root_bh,\n\t\t\t\t\t\t  &credits, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(args->new_inode),\n\t\t\t\t      args->new_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(args->new_bh->b_data + header_off,\n\t       args->old_bh->b_data + header_off, inline_size);\n\n\tnew_di = (struct ocfs2_dinode *)args->new_bh->b_data;\n\tnew_di->i_xattr_inline_size = cpu_to_le16(inline_size);\n\n\tret = ocfs2_reflink_xattr_header(handle, args, args->old_bh, xh,\n\t\t\t\t\t args->new_bh, new_xh, &vb, meta_ac,\n\t\t\t\t\t ocfs2_get_xattr_value_root, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_oi = OCFS2_I(args->new_inode);\n\t/*\n\t * Adjust extent record count to reserve space for extended attribute.\n\t * Inline data count had been adjusted in ocfs2_duplicate_inline_data().\n\t */\n\tif (!(new_oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) &&\n\t    !(ocfs2_inode_is_fast_symlink(args->new_inode))) {\n\t\tstruct ocfs2_extent_list *el = &new_di->id2.i_list;\n\t\tle16_add_cpu(&el->l_count, -(inline_size /\n\t\t\t\t\tsizeof(struct ocfs2_extent_rec)));\n\t}\n\tspin_lock(&new_oi->ip_lock);\n\tnew_oi->ip_dyn_features |= OCFS2_HAS_XATTR_FL | OCFS2_INLINE_XATTR_FL;\n\tnew_di->i_dyn_features = cpu_to_le16(new_oi->ip_dyn_features);\n\tspin_unlock(&new_oi->ip_lock);\n\n\tocfs2_journal_dirty(handle, args->new_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "meta_ac"
          ],
          "line": 6528
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 6524
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "args->new_bh"
          ],
          "line": 6521
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&new_oi->ip_lock"
          ],
          "line": 6519
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "new_oi->ip_dyn_features"
          ],
          "line": 6518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&new_oi->ip_lock"
          ],
          "line": 6516
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&el->l_count",
            "-(inline_size /\n\t\t\t\t\tsizeof(struct ocfs2_extent_rec))"
          ],
          "line": 6513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_is_fast_symlink",
          "args": [
            "args->new_inode"
          ],
          "line": 6511
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/symlink.h",
          "lines": "35-39",
          "snippet": "static inline int ocfs2_inode_is_fast_symlink(struct inode *inode)\n{\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks == 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_inode_is_fast_symlink(struct inode *inode)\n{\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "args->new_inode"
          ],
          "line": 6505
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_xattr_header",
          "args": [
            "handle",
            "args",
            "args->old_bh",
            "xh",
            "args->new_bh",
            "new_xh",
            "&vb",
            "meta_ac",
            "ocfs2_get_xattr_value_root",
            "NULL"
          ],
          "line": 6497
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_xattr_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6324-6448",
          "snippet": "static int ocfs2_reflink_xattr_header(handle_t *handle,\n\t\t\t\t      struct ocfs2_xattr_reflink *args,\n\t\t\t\t      struct buffer_head *old_bh,\n\t\t\t\t      struct ocfs2_xattr_header *xh,\n\t\t\t\t      struct buffer_head *new_bh,\n\t\t\t\t      struct ocfs2_xattr_header *new_xh,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t      get_xattr_value_root *func,\n\t\t\t\t      void *para)\n{\n\tint ret = 0, i, j;\n\tstruct super_block *sb = args->old_inode->i_sb;\n\tstruct buffer_head *value_bh;\n\tstruct ocfs2_xattr_entry *xe, *last;\n\tstruct ocfs2_xattr_value_root *xv, *new_xv;\n\tstruct ocfs2_extent_tree data_et;\n\tu32 clusters, cpos, p_cluster, num_clusters;\n\tunsigned int ext_flags = 0;\n\n\ttrace_ocfs2_reflink_xattr_header((unsigned long long)old_bh->b_blocknr,\n\t\t\t\t\t le16_to_cpu(xh->xh_count));\n\n\tlast = &new_xh->xh_entries[le16_to_cpu(new_xh->xh_count)];\n\tfor (i = 0, j = 0; i < le16_to_cpu(xh->xh_count); i++, j++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (args->xattr_reflinked && !args->xattr_reflinked(xe)) {\n\t\t\txe = &new_xh->xh_entries[j];\n\n\t\t\tle16_add_cpu(&new_xh->xh_count, -1);\n\t\t\tif (new_xh->xh_count) {\n\t\t\t\tmemmove(xe, xe + 1,\n\t\t\t\t\t(void *)last - (void *)xe);\n\t\t\t\tmemset(last, 0,\n\t\t\t\t       sizeof(struct ocfs2_xattr_entry));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't want j to increase in the next round since\n\t\t\t * it is already moved ahead.\n\t\t\t */\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, old_bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = func(sb, new_bh, new_xh, j, &new_xv, &value_bh, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For the xattr which has l_tree_depth = 0, all the extent\n\t\t * recs have already be copied to the new xh with the\n\t\t * propriate OCFS2_EXT_REFCOUNTED flag we just need to\n\t\t * increase the refount count int the refcount tree.\n\t\t *\n\t\t * For the xattr which has l_tree_depth > 0, we need\n\t\t * to initialize it to the empty default value root,\n\t\t * and then insert the extents one by one.\n\t\t */\n\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\tmemcpy(new_xv, &def_xv, sizeof(def_xv));\n\t\t\tvb->vb_xv = new_xv;\n\t\t\tvb->vb_bh = value_bh;\n\t\t\tocfs2_init_xattr_value_extent_tree(&data_et,\n\t\t\t\t\tINODE_CACHE(args->new_inode), vb);\n\t\t}\n\n\t\tclusters = le32_to_cpu(xv->xr_clusters);\n\t\tcpos = 0;\n\t\twhile (cpos < clusters) {\n\t\t\tret = ocfs2_xattr_get_clusters(args->old_inode,\n\t\t\t\t\t\t       cpos,\n\t\t\t\t\t\t       &p_cluster,\n\t\t\t\t\t\t       &num_clusters,\n\t\t\t\t\t\t       &xv->xr_list,\n\t\t\t\t\t\t       &ext_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!p_cluster);\n\n\t\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\t\tret = ocfs2_insert_extent(handle,\n\t\t\t\t\t\t&data_et, cpos,\n\t\t\t\t\t\tocfs2_clusters_to_blocks(\n\t\t\t\t\t\t\targs->old_inode->i_sb,\n\t\t\t\t\t\t\tp_cluster),\n\t\t\t\t\t\tnum_clusters, ext_flags,\n\t\t\t\t\t\tmeta_ac);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = ocfs2_increase_refcount(handle, args->ref_ci,\n\t\t\t\t\t\t      args->ref_root_bh,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      meta_ac, args->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcpos += num_clusters;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};",
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_reflink_xattr_header(handle_t *handle,\n\t\t\t\t      struct ocfs2_xattr_reflink *args,\n\t\t\t\t      struct buffer_head *old_bh,\n\t\t\t\t      struct ocfs2_xattr_header *xh,\n\t\t\t\t      struct buffer_head *new_bh,\n\t\t\t\t      struct ocfs2_xattr_header *new_xh,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t      get_xattr_value_root *func,\n\t\t\t\t      void *para)\n{\n\tint ret = 0, i, j;\n\tstruct super_block *sb = args->old_inode->i_sb;\n\tstruct buffer_head *value_bh;\n\tstruct ocfs2_xattr_entry *xe, *last;\n\tstruct ocfs2_xattr_value_root *xv, *new_xv;\n\tstruct ocfs2_extent_tree data_et;\n\tu32 clusters, cpos, p_cluster, num_clusters;\n\tunsigned int ext_flags = 0;\n\n\ttrace_ocfs2_reflink_xattr_header((unsigned long long)old_bh->b_blocknr,\n\t\t\t\t\t le16_to_cpu(xh->xh_count));\n\n\tlast = &new_xh->xh_entries[le16_to_cpu(new_xh->xh_count)];\n\tfor (i = 0, j = 0; i < le16_to_cpu(xh->xh_count); i++, j++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (args->xattr_reflinked && !args->xattr_reflinked(xe)) {\n\t\t\txe = &new_xh->xh_entries[j];\n\n\t\t\tle16_add_cpu(&new_xh->xh_count, -1);\n\t\t\tif (new_xh->xh_count) {\n\t\t\t\tmemmove(xe, xe + 1,\n\t\t\t\t\t(void *)last - (void *)xe);\n\t\t\t\tmemset(last, 0,\n\t\t\t\t       sizeof(struct ocfs2_xattr_entry));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't want j to increase in the next round since\n\t\t\t * it is already moved ahead.\n\t\t\t */\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, old_bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = func(sb, new_bh, new_xh, j, &new_xv, &value_bh, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For the xattr which has l_tree_depth = 0, all the extent\n\t\t * recs have already be copied to the new xh with the\n\t\t * propriate OCFS2_EXT_REFCOUNTED flag we just need to\n\t\t * increase the refount count int the refcount tree.\n\t\t *\n\t\t * For the xattr which has l_tree_depth > 0, we need\n\t\t * to initialize it to the empty default value root,\n\t\t * and then insert the extents one by one.\n\t\t */\n\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\tmemcpy(new_xv, &def_xv, sizeof(def_xv));\n\t\t\tvb->vb_xv = new_xv;\n\t\t\tvb->vb_bh = value_bh;\n\t\t\tocfs2_init_xattr_value_extent_tree(&data_et,\n\t\t\t\t\tINODE_CACHE(args->new_inode), vb);\n\t\t}\n\n\t\tclusters = le32_to_cpu(xv->xr_clusters);\n\t\tcpos = 0;\n\t\twhile (cpos < clusters) {\n\t\t\tret = ocfs2_xattr_get_clusters(args->old_inode,\n\t\t\t\t\t\t       cpos,\n\t\t\t\t\t\t       &p_cluster,\n\t\t\t\t\t\t       &num_clusters,\n\t\t\t\t\t\t       &xv->xr_list,\n\t\t\t\t\t\t       &ext_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!p_cluster);\n\n\t\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\t\tret = ocfs2_insert_extent(handle,\n\t\t\t\t\t\t&data_et, cpos,\n\t\t\t\t\t\tocfs2_clusters_to_blocks(\n\t\t\t\t\t\t\targs->old_inode->i_sb,\n\t\t\t\t\t\t\tp_cluster),\n\t\t\t\t\t\tnum_clusters, ext_flags,\n\t\t\t\t\t\tmeta_ac);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = ocfs2_increase_refcount(handle, args->ref_ci,\n\t\t\t\t\t\t      args->ref_root_bh,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      meta_ac, args->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcpos += num_clusters;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inline_size"
          ],
          "line": 6495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "args->new_bh->b_data + header_off",
            "args->old_bh->b_data + header_off",
            "inline_size"
          ],
          "line": 6491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(args->new_inode)",
            "args->new_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 6484
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "args->new_inode"
          ],
          "line": 6484
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 6479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 6478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 6477
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_lock_xattr_allocators",
          "args": [
            "osb",
            "xh",
            "args->ref_root_bh",
            "&credits",
            "&meta_ac"
          ],
          "line": 6470
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_lock_xattr_allocators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6268-6311",
          "snippet": "static int ocfs2_reflink_lock_xattr_allocators(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tint *credits,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac)\n{\n\tint ret, meta_add = 0, num_recs = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\t*credits = 0;\n\n\tret = ocfs2_value_metas_in_xattr_header(osb->sb, NULL, xh,\n\t\t\t\t\t\t&meta_add, credits, &num_recs,\n\t\t\t\t\t\tocfs2_get_xattr_value_root,\n\t\t\t\t\t\tNULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We need to add/modify num_recs in refcount tree, so just calculate\n\t * an approximate number we need for refcount tree change.\n\t * Sometimes we need to split the tree, and after split,  half recs\n\t * will be moved to the new block, and a new block can only provide\n\t * half number of recs. So we multiple new blocks by 2.\n\t */\n\tnum_recs = num_recs / ocfs2_refcount_recs_per_rb(osb->sb) * 2;\n\tmeta_add += num_recs;\n\t*credits += num_recs + num_recs * OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += le16_to_cpu(rb->rf_list.l_tree_depth) *\n\t\t\t    le16_to_cpu(rb->rf_list.l_next_free_rec) + 1;\n\telse\n\t\t*credits += 1;\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, meta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_reflink_lock_xattr_allocators(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tint *credits,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac)\n{\n\tint ret, meta_add = 0, num_recs = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\t*credits = 0;\n\n\tret = ocfs2_value_metas_in_xattr_header(osb->sb, NULL, xh,\n\t\t\t\t\t\t&meta_add, credits, &num_recs,\n\t\t\t\t\t\tocfs2_get_xattr_value_root,\n\t\t\t\t\t\tNULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We need to add/modify num_recs in refcount tree, so just calculate\n\t * an approximate number we need for refcount tree change.\n\t * Sometimes we need to split the tree, and after split,  half recs\n\t * will be moved to the new block, and a new block can only provide\n\t * half number of recs. So we multiple new blocks by 2.\n\t */\n\tnum_recs = num_recs / ocfs2_refcount_recs_per_rb(osb->sb) * 2;\n\tmeta_add += num_recs;\n\t*credits += num_recs + num_recs * OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += le16_to_cpu(rb->rf_list.l_tree_depth) *\n\t\t\t    le16_to_cpu(rb->rf_list.l_next_free_rec) + 1;\n\telse\n\t\t*credits += 1;\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, meta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_xattr_inline_size"
          ],
          "line": 6456
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "args->old_inode->i_sb"
          ],
          "line": 6454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_reflink_xattr_inline(struct ocfs2_xattr_reflink *args)\n{\n\tint ret = 0, credits = 0;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(args->old_inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)args->old_bh->b_data;\n\tint inline_size = le16_to_cpu(di->i_xattr_inline_size);\n\tint header_off = osb->sb->s_blocksize - inline_size;\n\tstruct ocfs2_xattr_header *xh = (struct ocfs2_xattr_header *)\n\t\t\t\t\t(args->old_bh->b_data + header_off);\n\tstruct ocfs2_xattr_header *new_xh = (struct ocfs2_xattr_header *)\n\t\t\t\t\t(args->new_bh->b_data + header_off);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_inode_info *new_oi;\n\tstruct ocfs2_dinode *new_di;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = args->new_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\tret = ocfs2_reflink_lock_xattr_allocators(osb, xh, args->ref_root_bh,\n\t\t\t\t\t\t  &credits, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(args->new_inode),\n\t\t\t\t      args->new_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tmemcpy(args->new_bh->b_data + header_off,\n\t       args->old_bh->b_data + header_off, inline_size);\n\n\tnew_di = (struct ocfs2_dinode *)args->new_bh->b_data;\n\tnew_di->i_xattr_inline_size = cpu_to_le16(inline_size);\n\n\tret = ocfs2_reflink_xattr_header(handle, args, args->old_bh, xh,\n\t\t\t\t\t args->new_bh, new_xh, &vb, meta_ac,\n\t\t\t\t\t ocfs2_get_xattr_value_root, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_oi = OCFS2_I(args->new_inode);\n\t/*\n\t * Adjust extent record count to reserve space for extended attribute.\n\t * Inline data count had been adjusted in ocfs2_duplicate_inline_data().\n\t */\n\tif (!(new_oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) &&\n\t    !(ocfs2_inode_is_fast_symlink(args->new_inode))) {\n\t\tstruct ocfs2_extent_list *el = &new_di->id2.i_list;\n\t\tle16_add_cpu(&el->l_count, -(inline_size /\n\t\t\t\t\tsizeof(struct ocfs2_extent_rec)));\n\t}\n\tspin_lock(&new_oi->ip_lock);\n\tnew_oi->ip_dyn_features |= OCFS2_HAS_XATTR_FL | OCFS2_INLINE_XATTR_FL;\n\tnew_di->i_dyn_features = cpu_to_le16(new_oi->ip_dyn_features);\n\tspin_unlock(&new_oi->ip_lock);\n\n\tocfs2_journal_dirty(handle, args->new_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reflink_xattr_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6324-6448",
    "snippet": "static int ocfs2_reflink_xattr_header(handle_t *handle,\n\t\t\t\t      struct ocfs2_xattr_reflink *args,\n\t\t\t\t      struct buffer_head *old_bh,\n\t\t\t\t      struct ocfs2_xattr_header *xh,\n\t\t\t\t      struct buffer_head *new_bh,\n\t\t\t\t      struct ocfs2_xattr_header *new_xh,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t      get_xattr_value_root *func,\n\t\t\t\t      void *para)\n{\n\tint ret = 0, i, j;\n\tstruct super_block *sb = args->old_inode->i_sb;\n\tstruct buffer_head *value_bh;\n\tstruct ocfs2_xattr_entry *xe, *last;\n\tstruct ocfs2_xattr_value_root *xv, *new_xv;\n\tstruct ocfs2_extent_tree data_et;\n\tu32 clusters, cpos, p_cluster, num_clusters;\n\tunsigned int ext_flags = 0;\n\n\ttrace_ocfs2_reflink_xattr_header((unsigned long long)old_bh->b_blocknr,\n\t\t\t\t\t le16_to_cpu(xh->xh_count));\n\n\tlast = &new_xh->xh_entries[le16_to_cpu(new_xh->xh_count)];\n\tfor (i = 0, j = 0; i < le16_to_cpu(xh->xh_count); i++, j++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (args->xattr_reflinked && !args->xattr_reflinked(xe)) {\n\t\t\txe = &new_xh->xh_entries[j];\n\n\t\t\tle16_add_cpu(&new_xh->xh_count, -1);\n\t\t\tif (new_xh->xh_count) {\n\t\t\t\tmemmove(xe, xe + 1,\n\t\t\t\t\t(void *)last - (void *)xe);\n\t\t\t\tmemset(last, 0,\n\t\t\t\t       sizeof(struct ocfs2_xattr_entry));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't want j to increase in the next round since\n\t\t\t * it is already moved ahead.\n\t\t\t */\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, old_bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = func(sb, new_bh, new_xh, j, &new_xv, &value_bh, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For the xattr which has l_tree_depth = 0, all the extent\n\t\t * recs have already be copied to the new xh with the\n\t\t * propriate OCFS2_EXT_REFCOUNTED flag we just need to\n\t\t * increase the refount count int the refcount tree.\n\t\t *\n\t\t * For the xattr which has l_tree_depth > 0, we need\n\t\t * to initialize it to the empty default value root,\n\t\t * and then insert the extents one by one.\n\t\t */\n\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\tmemcpy(new_xv, &def_xv, sizeof(def_xv));\n\t\t\tvb->vb_xv = new_xv;\n\t\t\tvb->vb_bh = value_bh;\n\t\t\tocfs2_init_xattr_value_extent_tree(&data_et,\n\t\t\t\t\tINODE_CACHE(args->new_inode), vb);\n\t\t}\n\n\t\tclusters = le32_to_cpu(xv->xr_clusters);\n\t\tcpos = 0;\n\t\twhile (cpos < clusters) {\n\t\t\tret = ocfs2_xattr_get_clusters(args->old_inode,\n\t\t\t\t\t\t       cpos,\n\t\t\t\t\t\t       &p_cluster,\n\t\t\t\t\t\t       &num_clusters,\n\t\t\t\t\t\t       &xv->xr_list,\n\t\t\t\t\t\t       &ext_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!p_cluster);\n\n\t\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\t\tret = ocfs2_insert_extent(handle,\n\t\t\t\t\t\t&data_et, cpos,\n\t\t\t\t\t\tocfs2_clusters_to_blocks(\n\t\t\t\t\t\t\targs->old_inode->i_sb,\n\t\t\t\t\t\t\tp_cluster),\n\t\t\t\t\t\tnum_clusters, ext_flags,\n\t\t\t\t\t\tmeta_ac);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = ocfs2_increase_refcount(handle, args->ref_ci,\n\t\t\t\t\t\t      args->ref_root_bh,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      meta_ac, args->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcpos += num_clusters;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};",
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_increase_refcount",
          "args": [
            "handle",
            "args->ref_ci",
            "args->ref_root_bh",
            "p_cluster",
            "num_clusters",
            "meta_ac",
            "args->dealloc"
          ],
          "line": 6433
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_increase_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2166-2176",
          "snippet": "int ocfs2_increase_refcount(handle_t *handle,\n\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u64 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\treturn __ocfs2_increase_refcount(handle, ci, ref_root_bh,\n\t\t\t\t\t cpos, len, 1,\n\t\t\t\t\t meta_ac, dealloc);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_increase_refcount(handle_t *handle,\n\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u64 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\treturn __ocfs2_increase_refcount(handle, ci, ref_root_bh,\n\t\t\t\t\t cpos, len, 1,\n\t\t\t\t\t meta_ac, dealloc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_extent",
          "args": [
            "handle",
            "&data_et",
            "cpos",
            "ocfs2_clusters_to_blocks(\n\t\t\t\t\t\t\targs->old_inode->i_sb,\n\t\t\t\t\t\t\tp_cluster)",
            "num_clusters",
            "ext_flags",
            "meta_ac"
          ],
          "line": 6420
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4665-4726",
          "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "args->old_inode->i_sb",
            "p_cluster"
          ],
          "line": 6422
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!p_cluster"
          ],
          "line": 6417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_clusters",
          "args": [
            "args->old_inode",
            "cpos",
            "&p_cluster",
            "&num_clusters",
            "&xv->xr_list",
            "&ext_flags"
          ],
          "line": 6406
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "543-606",
          "snippet": "int ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "xv->xr_clusters"
          ],
          "line": 6403
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_value_extent_tree",
          "args": [
            "&data_et",
            "INODE_CACHE(args->new_inode)",
            "vb"
          ],
          "line": 6399
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_value_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "474-480",
          "snippet": "void ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};\n\nvoid ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "args->new_inode"
          ],
          "line": 6400
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_xv",
            "&def_xv",
            "sizeof(def_xv)"
          ],
          "line": 6396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "sb",
            "new_bh",
            "new_xh",
            "j",
            "&new_xv",
            "&value_bh",
            "para"
          ],
          "line": 6379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "sb",
            "old_bh",
            "xh",
            "i",
            "&xv",
            "NULL",
            "para"
          ],
          "line": 6373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "xe"
          ],
          "line": 6370
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "last",
            "0",
            "sizeof(struct ocfs2_xattr_entry)"
          ],
          "line": 6358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "xe",
            "xe + 1",
            "(void *)last - (void *)xe"
          ],
          "line": 6356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&new_xh->xh_count",
            "-1"
          ],
          "line": 6354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args->xattr_reflinked",
          "args": [
            "xe"
          ],
          "line": 6351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_count"
          ],
          "line": 6348
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_reflink_xattr_header",
          "args": [
            "(unsigned long long)old_bh->b_blocknr",
            "le16_to_cpu(xh->xh_count)"
          ],
          "line": 6344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_reflink_xattr_header(handle_t *handle,\n\t\t\t\t      struct ocfs2_xattr_reflink *args,\n\t\t\t\t      struct buffer_head *old_bh,\n\t\t\t\t      struct ocfs2_xattr_header *xh,\n\t\t\t\t      struct buffer_head *new_bh,\n\t\t\t\t      struct ocfs2_xattr_header *new_xh,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t      get_xattr_value_root *func,\n\t\t\t\t      void *para)\n{\n\tint ret = 0, i, j;\n\tstruct super_block *sb = args->old_inode->i_sb;\n\tstruct buffer_head *value_bh;\n\tstruct ocfs2_xattr_entry *xe, *last;\n\tstruct ocfs2_xattr_value_root *xv, *new_xv;\n\tstruct ocfs2_extent_tree data_et;\n\tu32 clusters, cpos, p_cluster, num_clusters;\n\tunsigned int ext_flags = 0;\n\n\ttrace_ocfs2_reflink_xattr_header((unsigned long long)old_bh->b_blocknr,\n\t\t\t\t\t le16_to_cpu(xh->xh_count));\n\n\tlast = &new_xh->xh_entries[le16_to_cpu(new_xh->xh_count)];\n\tfor (i = 0, j = 0; i < le16_to_cpu(xh->xh_count); i++, j++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (args->xattr_reflinked && !args->xattr_reflinked(xe)) {\n\t\t\txe = &new_xh->xh_entries[j];\n\n\t\t\tle16_add_cpu(&new_xh->xh_count, -1);\n\t\t\tif (new_xh->xh_count) {\n\t\t\t\tmemmove(xe, xe + 1,\n\t\t\t\t\t(void *)last - (void *)xe);\n\t\t\t\tmemset(last, 0,\n\t\t\t\t       sizeof(struct ocfs2_xattr_entry));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't want j to increase in the next round since\n\t\t\t * it is already moved ahead.\n\t\t\t */\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, old_bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = func(sb, new_bh, new_xh, j, &new_xv, &value_bh, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For the xattr which has l_tree_depth = 0, all the extent\n\t\t * recs have already be copied to the new xh with the\n\t\t * propriate OCFS2_EXT_REFCOUNTED flag we just need to\n\t\t * increase the refount count int the refcount tree.\n\t\t *\n\t\t * For the xattr which has l_tree_depth > 0, we need\n\t\t * to initialize it to the empty default value root,\n\t\t * and then insert the extents one by one.\n\t\t */\n\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\tmemcpy(new_xv, &def_xv, sizeof(def_xv));\n\t\t\tvb->vb_xv = new_xv;\n\t\t\tvb->vb_bh = value_bh;\n\t\t\tocfs2_init_xattr_value_extent_tree(&data_et,\n\t\t\t\t\tINODE_CACHE(args->new_inode), vb);\n\t\t}\n\n\t\tclusters = le32_to_cpu(xv->xr_clusters);\n\t\tcpos = 0;\n\t\twhile (cpos < clusters) {\n\t\t\tret = ocfs2_xattr_get_clusters(args->old_inode,\n\t\t\t\t\t\t       cpos,\n\t\t\t\t\t\t       &p_cluster,\n\t\t\t\t\t\t       &num_clusters,\n\t\t\t\t\t\t       &xv->xr_list,\n\t\t\t\t\t\t       &ext_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!p_cluster);\n\n\t\t\tif (xv->xr_list.l_tree_depth) {\n\t\t\t\tret = ocfs2_insert_extent(handle,\n\t\t\t\t\t\t&data_et, cpos,\n\t\t\t\t\t\tocfs2_clusters_to_blocks(\n\t\t\t\t\t\t\targs->old_inode->i_sb,\n\t\t\t\t\t\t\tp_cluster),\n\t\t\t\t\t\tnum_clusters, ext_flags,\n\t\t\t\t\t\tmeta_ac);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = ocfs2_increase_refcount(handle, args->ref_ci,\n\t\t\t\t\t\t      args->ref_root_bh,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      meta_ac, args->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcpos += num_clusters;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reflink_lock_xattr_allocators",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6268-6311",
    "snippet": "static int ocfs2_reflink_lock_xattr_allocators(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tint *credits,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac)\n{\n\tint ret, meta_add = 0, num_recs = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\t*credits = 0;\n\n\tret = ocfs2_value_metas_in_xattr_header(osb->sb, NULL, xh,\n\t\t\t\t\t\t&meta_add, credits, &num_recs,\n\t\t\t\t\t\tocfs2_get_xattr_value_root,\n\t\t\t\t\t\tNULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We need to add/modify num_recs in refcount tree, so just calculate\n\t * an approximate number we need for refcount tree change.\n\t * Sometimes we need to split the tree, and after split,  half recs\n\t * will be moved to the new block, and a new block can only provide\n\t * half number of recs. So we multiple new blocks by 2.\n\t */\n\tnum_recs = num_recs / ocfs2_refcount_recs_per_rb(osb->sb) * 2;\n\tmeta_add += num_recs;\n\t*credits += num_recs + num_recs * OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += le16_to_cpu(rb->rf_list.l_tree_depth) *\n\t\t\t    le16_to_cpu(rb->rf_list.l_next_free_rec) + 1;\n\telse\n\t\t*credits += 1;\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, meta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "osb",
            "meta_add",
            "meta_ac"
          ],
          "line": 6305
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rb->rf_list.l_next_free_rec"
          ],
          "line": 6301
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rb->rf_flags"
          ],
          "line": 6299
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_recs_per_rb",
          "args": [
            "osb->sb"
          ],
          "line": 6296
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_recs_per_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1464-1472",
          "snippet": "static inline u16 ocfs2_refcount_recs_per_rb(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_refcount_block, rf_records.rl_recs);\n\n\treturn size / sizeof(struct ocfs2_refcount_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16 ocfs2_refcount_recs_per_rb(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_refcount_block, rf_records.rl_recs);\n\n\treturn size / sizeof(struct ocfs2_refcount_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_value_metas_in_xattr_header",
          "args": [
            "osb->sb",
            "NULL",
            "xh",
            "&meta_add",
            "credits",
            "&num_recs",
            "ocfs2_get_xattr_value_root",
            "NULL"
          ],
          "line": 6280
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_value_metas_in_xattr_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6200-6241",
          "snippet": "static int ocfs2_value_metas_in_xattr_header(struct super_block *sb,\n\t\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int *metas, int *credits,\n\t\t\t\t\t     int *num_recs,\n\t\t\t\t\t     get_xattr_value_root *func,\n\t\t\t\t\t     void *para)\n{\n\tint i, ret = 0;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_xattr_entry *xe;\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t*metas += le16_to_cpu(xv->xr_list.l_tree_depth) *\n\t\t\t  le16_to_cpu(xv->xr_list.l_next_free_rec);\n\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t&def_xv.xv.xr_list);\n\n\t\t/*\n\t\t * If the value is a tree with depth > 1, We don't go deep\n\t\t * to the extent block, so just calculate a maximum record num.\n\t\t */\n\t\tif (!xv->xr_list.l_tree_depth)\n\t\t\t*num_recs += le16_to_cpu(xv->xr_list.l_next_free_rec);\n\t\telse\n\t\t\t*num_recs += ocfs2_clusters_for_bytes(sb,\n\t\t\t\t\t\t\t      XATTR_SIZE_MAX);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};",
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);",
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_value_metas_in_xattr_header(struct super_block *sb,\n\t\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int *metas, int *credits,\n\t\t\t\t\t     int *num_recs,\n\t\t\t\t\t     get_xattr_value_root *func,\n\t\t\t\t\t     void *para)\n{\n\tint i, ret = 0;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_xattr_entry *xe;\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t*metas += le16_to_cpu(xv->xr_list.l_tree_depth) *\n\t\t\t  le16_to_cpu(xv->xr_list.l_next_free_rec);\n\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t&def_xv.xv.xr_list);\n\n\t\t/*\n\t\t * If the value is a tree with depth > 1, We don't go deep\n\t\t * to the extent block, so just calculate a maximum record num.\n\t\t */\n\t\tif (!xv->xr_list.l_tree_depth)\n\t\t\t*num_recs += le16_to_cpu(xv->xr_list.l_next_free_rec);\n\t\telse\n\t\t\t*num_recs += ocfs2_clusters_for_bytes(sb,\n\t\t\t\t\t\t\t      XATTR_SIZE_MAX);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_reflink_lock_xattr_allocators(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_xattr_header *xh,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tint *credits,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac)\n{\n\tint ret, meta_add = 0, num_recs = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\t*credits = 0;\n\n\tret = ocfs2_value_metas_in_xattr_header(osb->sb, NULL, xh,\n\t\t\t\t\t\t&meta_add, credits, &num_recs,\n\t\t\t\t\t\tocfs2_get_xattr_value_root,\n\t\t\t\t\t\tNULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We need to add/modify num_recs in refcount tree, so just calculate\n\t * an approximate number we need for refcount tree change.\n\t * Sometimes we need to split the tree, and after split,  half recs\n\t * will be moved to the new block, and a new block can only provide\n\t * half number of recs. So we multiple new blocks by 2.\n\t */\n\tnum_recs = num_recs / ocfs2_refcount_recs_per_rb(osb->sb) * 2;\n\tmeta_add += num_recs;\n\t*credits += num_recs + num_recs * OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += le16_to_cpu(rb->rf_list.l_tree_depth) *\n\t\t\t    le16_to_cpu(rb->rf_list.l_next_free_rec) + 1;\n\telse\n\t\t*credits += 1;\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, meta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_get_xattr_value_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6244-6262",
    "snippet": "static int ocfs2_get_xattr_value_root(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      struct ocfs2_xattr_header *xh,\n\t\t\t\t      int offset,\n\t\t\t\t      struct ocfs2_xattr_value_root **xv,\n\t\t\t\t      struct buffer_head **ret_bh,\n\t\t\t\t      void *para)\n{\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\n\t*xv = (struct ocfs2_xattr_value_root *)((void *)xh +\n\t\tle16_to_cpu(xe->xe_name_offset) +\n\t\tOCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (ret_bh)\n\t\t*ret_bh = bh;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);",
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xe->xe_name_len"
          ],
          "line": 6256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xe->xe_name_offset"
          ],
          "line": 6255
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_get_xattr_value_root(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      struct ocfs2_xattr_header *xh,\n\t\t\t\t      int offset,\n\t\t\t\t      struct ocfs2_xattr_value_root **xv,\n\t\t\t\t      struct buffer_head **ret_bh,\n\t\t\t\t      void *para)\n{\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\n\t*xv = (struct ocfs2_xattr_value_root *)((void *)xh +\n\t\tle16_to_cpu(xe->xe_name_offset) +\n\t\tOCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (ret_bh)\n\t\t*ret_bh = bh;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_value_metas_in_xattr_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6200-6241",
    "snippet": "static int ocfs2_value_metas_in_xattr_header(struct super_block *sb,\n\t\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int *metas, int *credits,\n\t\t\t\t\t     int *num_recs,\n\t\t\t\t\t     get_xattr_value_root *func,\n\t\t\t\t\t     void *para)\n{\n\tint i, ret = 0;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_xattr_entry *xe;\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t*metas += le16_to_cpu(xv->xr_list.l_tree_depth) *\n\t\t\t  le16_to_cpu(xv->xr_list.l_next_free_rec);\n\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t&def_xv.xv.xr_list);\n\n\t\t/*\n\t\t * If the value is a tree with depth > 1, We don't go deep\n\t\t * to the extent block, so just calculate a maximum record num.\n\t\t */\n\t\tif (!xv->xr_list.l_tree_depth)\n\t\t\t*num_recs += le16_to_cpu(xv->xr_list.l_next_free_rec);\n\t\telse\n\t\t\t*num_recs += ocfs2_clusters_for_bytes(sb,\n\t\t\t\t\t\t\t      XATTR_SIZE_MAX);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};",
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);",
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "sb",
            "XATTR_SIZE_MAX"
          ],
          "line": 6236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xv->xr_list.l_next_free_rec"
          ],
          "line": 6234
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_extend_credits",
          "args": [
            "sb",
            "&def_xv.xv.xr_list"
          ],
          "line": 6226
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_extend_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "531-556",
          "snippet": "static inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "sb",
            "bh",
            "xh",
            "i",
            "&xv",
            "NULL",
            "para"
          ],
          "line": 6217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "xe"
          ],
          "line": 6214
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_value_metas_in_xattr_header(struct super_block *sb,\n\t\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int *metas, int *credits,\n\t\t\t\t\t     int *num_recs,\n\t\t\t\t\t     get_xattr_value_root *func,\n\t\t\t\t\t     void *para)\n{\n\tint i, ret = 0;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_xattr_entry *xe;\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = func(sb, bh, xh, i, &xv, NULL, para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t*metas += le16_to_cpu(xv->xr_list.l_tree_depth) *\n\t\t\t  le16_to_cpu(xv->xr_list.l_next_free_rec);\n\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t&def_xv.xv.xr_list);\n\n\t\t/*\n\t\t * If the value is a tree with depth > 1, We don't go deep\n\t\t * to the extent block, so just calculate a maximum record num.\n\t\t */\n\t\tif (!xv->xr_list.l_tree_depth)\n\t\t\t*num_recs += le16_to_cpu(xv->xr_list.l_next_free_rec);\n\t\telse\n\t\t\t*num_recs += ocfs2_clusters_for_bytes(sb,\n\t\t\t\t\t\t\t      XATTR_SIZE_MAX);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_attach_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6124-6164",
    "snippet": "int ocfs2_xattr_attach_refcount_tree(struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh,\n\t\t\t\t     struct ocfs2_caching_info *ref_ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)fe_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_inline_attach_refcount(inode, fe_bh,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!di->i_xattr_loc)\n\t\tgoto out;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_block_attach_refcount(inode, blk_bh, ref_ci,\n\t\t\t\t\t\tref_root_bh, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tbrelse(blk_bh);\nout:\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "blk_bh"
          ],
          "line": 6160
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_block_attach_refcount",
          "args": [
            "inode",
            "blk_bh",
            "ref_ci",
            "ref_root_bh",
            "dealloc"
          ],
          "line": 6155
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_block_attach_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6089-6122",
          "snippet": "static int ocfs2_xattr_block_attach_refcount(struct inode *inode,\n\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &xb->xb_attrs.xb_header;\n\t\tstruct ocfs2_xattr_value_buf vb = {\n\t\t\t.vb_bh = blk_bh,\n\t\t\t.vb_access = ocfs2_journal_access_xb,\n\t\t};\n\n\t\tret = ocfs2_xattr_attach_refcount_normal(inode, &vb, header,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t dealloc);\n\t} else {\n\t\tstruct ocfs2_xattr_tree_value_refcount_para para = {\n\t\t\t.ref_ci = ref_ci,\n\t\t\t.ref_root_bh = ref_root_bh,\n\t\t\t.dealloc = dealloc,\n\t\t};\n\n\t\tret = ocfs2_iterate_xattr_index_block(inode, blk_bh,\n\t\t\t\t\t\tocfs2_refcount_xattr_tree_rec,\n\t\t\t\t\t\t&para);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_xattr_block_attach_refcount(struct inode *inode,\n\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &xb->xb_attrs.xb_header;\n\t\tstruct ocfs2_xattr_value_buf vb = {\n\t\t\t.vb_bh = blk_bh,\n\t\t\t.vb_access = ocfs2_journal_access_xb,\n\t\t};\n\n\t\tret = ocfs2_xattr_attach_refcount_normal(inode, &vb, header,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t dealloc);\n\t} else {\n\t\tstruct ocfs2_xattr_tree_value_refcount_para para = {\n\t\t\t.ref_ci = ref_ci,\n\t\t\t.ref_root_bh = ref_root_bh,\n\t\t\t.dealloc = dealloc,\n\t\t};\n\n\t\tret = ocfs2_iterate_xattr_index_block(inode, blk_bh,\n\t\t\t\t\t\tocfs2_refcount_xattr_tree_rec,\n\t\t\t\t\t\t&para);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_block",
          "args": [
            "inode",
            "le64_to_cpu(di->i_xattr_loc)",
            "&blk_bh"
          ],
          "line": 6148
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "531-545",
          "snippet": "static int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_xattr_loc"
          ],
          "line": 6148
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_inline_attach_refcount",
          "args": [
            "inode",
            "fe_bh",
            "ref_ci",
            "ref_root_bh",
            "dealloc"
          ],
          "line": 6136
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_inline_attach_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5961-5978",
          "snippet": "static int ocfs2_xattr_inline_attach_refcount(struct inode *inode,\n\t\t\t\tstruct buffer_head *fe_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)fe_bh->b_data;\n\tstruct ocfs2_xattr_header *header = (struct ocfs2_xattr_header *)\n\t\t\t\t(fe_bh->b_data + inode->i_sb->s_blocksize -\n\t\t\t\tle16_to_cpu(di->i_xattr_inline_size));\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = fe_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\treturn ocfs2_xattr_attach_refcount_normal(inode, &vb, header,\n\t\t\t\t\t\t  ref_ci, ref_root_bh, dealloc);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_inline_attach_refcount(struct inode *inode,\n\t\t\t\tstruct buffer_head *fe_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)fe_bh->b_data;\n\tstruct ocfs2_xattr_header *header = (struct ocfs2_xattr_header *)\n\t\t\t\t(fe_bh->b_data + inode->i_sb->s_blocksize -\n\t\t\t\tle16_to_cpu(di->i_xattr_inline_size));\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = fe_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\treturn ocfs2_xattr_attach_refcount_normal(inode, &vb, header,\n\t\t\t\t\t\t  ref_ci, ref_root_bh, dealloc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 6131
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_xattr_attach_refcount_tree(struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh,\n\t\t\t\t     struct ocfs2_caching_info *ref_ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)fe_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_inline_attach_refcount(inode, fe_bh,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!di->i_xattr_loc)\n\t\tgoto out;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_block_attach_refcount(inode, blk_bh, ref_ci,\n\t\t\t\t\t\tref_root_bh, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tbrelse(blk_bh);\nout:\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_block_attach_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6089-6122",
    "snippet": "static int ocfs2_xattr_block_attach_refcount(struct inode *inode,\n\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &xb->xb_attrs.xb_header;\n\t\tstruct ocfs2_xattr_value_buf vb = {\n\t\t\t.vb_bh = blk_bh,\n\t\t\t.vb_access = ocfs2_journal_access_xb,\n\t\t};\n\n\t\tret = ocfs2_xattr_attach_refcount_normal(inode, &vb, header,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t dealloc);\n\t} else {\n\t\tstruct ocfs2_xattr_tree_value_refcount_para para = {\n\t\t\t.ref_ci = ref_ci,\n\t\t\t.ref_root_bh = ref_root_bh,\n\t\t\t.dealloc = dealloc,\n\t\t};\n\n\t\tret = ocfs2_iterate_xattr_index_block(inode, blk_bh,\n\t\t\t\t\t\tocfs2_refcount_xattr_tree_rec,\n\t\t\t\t\t\t&para);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_iterate_xattr_index_block",
          "args": [
            "inode",
            "blk_bh",
            "ocfs2_refcount_xattr_tree_rec",
            "&para"
          ],
          "line": 6116
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iterate_xattr_index_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4071-4110",
          "snippet": "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *blk_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_extent_list *el = &xb->xb_attrs.xb_root.xt_list;\n\tint ret = 0;\n\tu32 name_hash = UINT_MAX, e_cpos = 0, num_clusters = 0;\n\tu64 p_blkno = 0;\n\n\tif (!el->l_next_free_rec || !rec_func)\n\t\treturn 0;\n\n\twhile (name_hash > 0) {\n\t\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno,\n\t\t\t\t\t  &e_cpos, &num_clusters, el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rec_func(inode, blk_bh, p_blkno, e_cpos,\n\t\t\t       num_clusters, para);\n\t\tif (ret) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e_cpos == 0)\n\t\t\tbreak;\n\n\t\tname_hash = e_cpos - 1;\n\t}\n\n\treturn ret;\n\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *blk_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_extent_list *el = &xb->xb_attrs.xb_root.xt_list;\n\tint ret = 0;\n\tu32 name_hash = UINT_MAX, e_cpos = 0, num_clusters = 0;\n\tu64 p_blkno = 0;\n\n\tif (!el->l_next_free_rec || !rec_func)\n\t\treturn 0;\n\n\twhile (name_hash > 0) {\n\t\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno,\n\t\t\t\t\t  &e_cpos, &num_clusters, el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rec_func(inode, blk_bh, p_blkno, e_cpos,\n\t\t\t       num_clusters, para);\n\t\tif (ret) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e_cpos == 0)\n\t\t\tbreak;\n\n\t\tname_hash = e_cpos - 1;\n\t}\n\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_attach_refcount_normal",
          "args": [
            "inode",
            "&vb",
            "header",
            "ref_ci",
            "ref_root_bh",
            "dealloc"
          ],
          "line": 6106
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_attach_refcount_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5923-5959",
          "snippet": "static int ocfs2_xattr_attach_refcount_normal(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_buf *vb,\n\t\t\t\tstruct ocfs2_xattr_header *header,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_extent_tree et;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\txe = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\txv = (struct ocfs2_xattr_value_root *)((void *)header +\n\t\t\tle16_to_cpu(xe->xe_name_offset) +\n\t\t\tOCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\t\tvb->vb_xv = xv;\n\t\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\t\tret = ocfs2_xattr_value_attach_refcount(inode, xv, &et,\n\t\t\t\t\t\t\tref_ci, ref_root_bh,\n\t\t\t\t\t\t\tdealloc, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_attach_refcount_normal(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_buf *vb,\n\t\t\t\tstruct ocfs2_xattr_header *header,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_extent_tree et;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\txe = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\txv = (struct ocfs2_xattr_value_root *)((void *)header +\n\t\t\tle16_to_cpu(xe->xe_name_offset) +\n\t\t\tOCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\t\tvb->vb_xv = xv;\n\t\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\t\tret = ocfs2_xattr_value_attach_refcount(inode, xv, &et,\n\t\t\t\t\t\t\tref_ci, ref_root_bh,\n\t\t\t\t\t\t\tdealloc, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xb->xb_flags"
          ],
          "line": 6099
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_xattr_block_attach_refcount(struct inode *inode,\n\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &xb->xb_attrs.xb_header;\n\t\tstruct ocfs2_xattr_value_buf vb = {\n\t\t\t.vb_bh = blk_bh,\n\t\t\t.vb_access = ocfs2_journal_access_xb,\n\t\t};\n\n\t\tret = ocfs2_xattr_attach_refcount_normal(inode, &vb, header,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t dealloc);\n\t} else {\n\t\tstruct ocfs2_xattr_tree_value_refcount_para para = {\n\t\t\t.ref_ci = ref_ci,\n\t\t\t.ref_root_bh = ref_root_bh,\n\t\t\t.dealloc = dealloc,\n\t\t};\n\n\t\tret = ocfs2_iterate_xattr_index_block(inode, blk_bh,\n\t\t\t\t\t\tocfs2_refcount_xattr_tree_rec,\n\t\t\t\t\t\t&para);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_refcount_xattr_tree_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6080-6087",
    "snippet": "static int ocfs2_refcount_xattr_tree_rec(struct inode *inode,\n\t\t\t\t     struct buffer_head *root_bh,\n\t\t\t\t     u64 blkno, u32 cpos, u32 len, void *para)\n{\n\treturn ocfs2_iterate_xattr_buckets(inode, blkno, len,\n\t\t\t\t\t   ocfs2_xattr_bucket_value_refcount,\n\t\t\t\t\t   para);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_iterate_xattr_buckets",
          "args": [
            "inode",
            "blkno",
            "len",
            "ocfs2_xattr_bucket_value_refcount",
            "para"
          ],
          "line": 6084
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iterate_xattr_buckets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3955-4006",
          "snippet": "static int ocfs2_iterate_xattr_buckets(struct inode *inode,\n\t\t\t\t       u64 blkno,\n\t\t\t\t       u32 clusters,\n\t\t\t\t       xattr_bucket_func *func,\n\t\t\t\t       void *para)\n{\n\tint i, ret = 0;\n\tu32 bpc = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\tu32 num_buckets = clusters * bpc;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tbucket = ocfs2_xattr_bucket_new(inode);\n\tif (!bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace_ocfs2_iterate_xattr_buckets(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)blkno, clusters);\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bucket->bu_blocks) {\n\t\tret = ocfs2_read_xattr_bucket(bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The real bucket num in this series of blocks is stored\n\t\t * in the 1st bucket.\n\t\t */\n\t\tif (i == 0)\n\t\t\tnum_buckets = le16_to_cpu(bucket_xh(bucket)->xh_num_buckets);\n\n\t\ttrace_ocfs2_iterate_xattr_bucket((unsigned long long)blkno,\n\t\t     le32_to_cpu(bucket_xh(bucket)->xh_entries[0].xe_name_hash));\n\t\tif (func) {\n\t\t\tret = func(inode, bucket, para);\n\t\t\tif (ret && ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\t/* Fall through to bucket_relse() */\n\t\t}\n\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tocfs2_xattr_bucket_free(bucket);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_iterate_xattr_buckets(struct inode *inode,\n\t\t\t\t       u64 blkno,\n\t\t\t\t       u32 clusters,\n\t\t\t\t       xattr_bucket_func *func,\n\t\t\t\t       void *para)\n{\n\tint i, ret = 0;\n\tu32 bpc = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\tu32 num_buckets = clusters * bpc;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tbucket = ocfs2_xattr_bucket_new(inode);\n\tif (!bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace_ocfs2_iterate_xattr_buckets(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)blkno, clusters);\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bucket->bu_blocks) {\n\t\tret = ocfs2_read_xattr_bucket(bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The real bucket num in this series of blocks is stored\n\t\t * in the 1st bucket.\n\t\t */\n\t\tif (i == 0)\n\t\t\tnum_buckets = le16_to_cpu(bucket_xh(bucket)->xh_num_buckets);\n\n\t\ttrace_ocfs2_iterate_xattr_bucket((unsigned long long)blkno,\n\t\t     le32_to_cpu(bucket_xh(bucket)->xh_entries[0].xe_name_hash));\n\t\tif (func) {\n\t\t\tret = func(inode, bucket, para);\n\t\t\tif (ret && ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\t/* Fall through to bucket_relse() */\n\t\t}\n\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tocfs2_xattr_bucket_free(bucket);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_refcount_xattr_tree_rec(struct inode *inode,\n\t\t\t\t     struct buffer_head *root_bh,\n\t\t\t\t     u64 blkno, u32 cpos, u32 len, void *para)\n{\n\treturn ocfs2_iterate_xattr_buckets(inode, blkno, len,\n\t\t\t\t\t   ocfs2_xattr_bucket_value_refcount,\n\t\t\t\t\t   para);\n}"
  },
  {
    "function_name": "ocfs2_xattr_bucket_value_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "6022-6078",
    "snippet": "static int ocfs2_xattr_bucket_value_refcount(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     void *para)\n{\n\tint i, ret = 0;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_xattr_tree_value_refcount_para *ref =\n\t\t\t(struct ocfs2_xattr_tree_value_refcount_para *)para;\n\tstruct ocfs2_xattr_header *xh =\n\t\t\t(struct ocfs2_xattr_header *)bucket->bu_bhs[0]->b_data;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_access = ocfs2_journal_access,\n\t};\n\tstruct ocfs2_post_refcount refcount = {\n\t\t.credits = bucket->bu_blocks,\n\t\t.para = bucket,\n\t\t.func = ocfs2_xattr_bucket_post_refcount,\n\t};\n\tstruct ocfs2_post_refcount *p = NULL;\n\n\t/* We only need post_refcount if we support metaecc. */\n\tif (ocfs2_meta_ecc(OCFS2_SB(inode->i_sb)))\n\t\tp = &refcount;\n\n\ttrace_ocfs2_xattr_bucket_value_refcount(\n\t\t\t\t(unsigned long long)bucket_blkno(bucket),\n\t\t\t\tle16_to_cpu(xh->xh_count));\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = ocfs2_get_xattr_tree_value_root(inode->i_sb, bucket, i,\n\t\t\t\t\t\t      &vb.vb_xv, &vb.vb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_init_xattr_value_extent_tree(&et,\n\t\t\t\t\t\t   INODE_CACHE(inode), &vb);\n\n\t\tret = ocfs2_xattr_value_attach_refcount(inode, vb.vb_xv,\n\t\t\t\t\t\t\t&et, ref->ref_ci,\n\t\t\t\t\t\t\tref->ref_root_bh,\n\t\t\t\t\t\t\tref->dealloc, p);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_value_attach_refcount",
          "args": [
            "inode",
            "vb.vb_xv",
            "&et",
            "ref->ref_ci",
            "ref->ref_root_bh",
            "ref->dealloc",
            "p"
          ],
          "line": 6066
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_value_attach_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5875-5916",
          "snippet": "static int ocfs2_xattr_value_attach_refcount(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\tstruct ocfs2_extent_tree *value_et,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tstruct ocfs2_post_refcount *refcount)\n{\n\tint ret = 0;\n\tu32 clusters = le32_to_cpu(xv->xr_clusters);\n\tu32 cpos, p_cluster, num_clusters;\n\tstruct ocfs2_extent_list *el = &xv->xr_list;\n\tunsigned int ext_flags;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcpos += num_clusters;\n\t\tif ((ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\t\tcontinue;\n\n\t\tBUG_ON(!p_cluster);\n\n\t\tret = ocfs2_add_refcount_flag(inode, value_et,\n\t\t\t\t\t      ref_ci, ref_root_bh,\n\t\t\t\t\t      cpos - num_clusters,\n\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t      dealloc, refcount);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_value_attach_refcount(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\tstruct ocfs2_extent_tree *value_et,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tstruct ocfs2_post_refcount *refcount)\n{\n\tint ret = 0;\n\tu32 clusters = le32_to_cpu(xv->xr_clusters);\n\tu32 cpos, p_cluster, num_clusters;\n\tstruct ocfs2_extent_list *el = &xv->xr_list;\n\tunsigned int ext_flags;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcpos += num_clusters;\n\t\tif ((ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\t\tcontinue;\n\n\t\tBUG_ON(!p_cluster);\n\n\t\tret = ocfs2_add_refcount_flag(inode, value_et,\n\t\t\t\t\t      ref_ci, ref_root_bh,\n\t\t\t\t\t      cpos - num_clusters,\n\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t      dealloc, refcount);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_value_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "&vb"
          ],
          "line": 6063
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_value_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "474-480",
          "snippet": "void ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};\n\nvoid ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 6064
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_xattr_tree_value_root",
          "args": [
            "inode->i_sb",
            "bucket",
            "i",
            "&vb.vb_xv",
            "&vb.vb_bh"
          ],
          "line": 6056
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_xattr_tree_value_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5986-6016",
          "snippet": "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh)\n{\n\tint ret, block_off, name_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\tvoid *base;\n\n\tret = ocfs2_xattr_bucket_get_name_value(sb,\n\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t&name_offset);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbase = bucket_block(bucket, block_off);\n\n\t*xv = (struct ocfs2_xattr_value_root *)(base + name_offset +\n\t\t\t OCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (bh)\n\t\t*bh = bucket->bu_bhs[block_off];\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh)\n{\n\tint ret, block_off, name_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\tvoid *base;\n\n\tret = ocfs2_xattr_bucket_get_name_value(sb,\n\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t&name_offset);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbase = bucket_block(bucket, block_off);\n\n\t*xv = (struct ocfs2_xattr_value_root *)(base + name_offset +\n\t\t\t OCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (bh)\n\t\t*bh = bucket->bu_bhs[block_off];\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "xe"
          ],
          "line": 6053
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_count"
          ],
          "line": 6050
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_xattr_bucket_value_refcount",
          "args": [
            "(unsigned long long)bucket_blkno(bucket)",
            "le16_to_cpu(xh->xh_count)"
          ],
          "line": 6047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "bucket"
          ],
          "line": 6048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_meta_ecc",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 6044
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "525-530",
          "snippet": "static inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 6044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_xattr_bucket_value_refcount(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     void *para)\n{\n\tint i, ret = 0;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_xattr_tree_value_refcount_para *ref =\n\t\t\t(struct ocfs2_xattr_tree_value_refcount_para *)para;\n\tstruct ocfs2_xattr_header *xh =\n\t\t\t(struct ocfs2_xattr_header *)bucket->bu_bhs[0]->b_data;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_access = ocfs2_journal_access,\n\t};\n\tstruct ocfs2_post_refcount refcount = {\n\t\t.credits = bucket->bu_blocks,\n\t\t.para = bucket,\n\t\t.func = ocfs2_xattr_bucket_post_refcount,\n\t};\n\tstruct ocfs2_post_refcount *p = NULL;\n\n\t/* We only need post_refcount if we support metaecc. */\n\tif (ocfs2_meta_ecc(OCFS2_SB(inode->i_sb)))\n\t\tp = &refcount;\n\n\ttrace_ocfs2_xattr_bucket_value_refcount(\n\t\t\t\t(unsigned long long)bucket_blkno(bucket),\n\t\t\t\tle16_to_cpu(xh->xh_count));\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = ocfs2_get_xattr_tree_value_root(inode->i_sb, bucket, i,\n\t\t\t\t\t\t      &vb.vb_xv, &vb.vb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_init_xattr_value_extent_tree(&et,\n\t\t\t\t\t\t   INODE_CACHE(inode), &vb);\n\n\t\tret = ocfs2_xattr_value_attach_refcount(inode, vb.vb_xv,\n\t\t\t\t\t\t\t&et, ref->ref_ci,\n\t\t\t\t\t\t\tref->ref_root_bh,\n\t\t\t\t\t\t\tref->dealloc, p);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n\n}"
  },
  {
    "function_name": "ocfs2_get_xattr_tree_value_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5986-6016",
    "snippet": "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh)\n{\n\tint ret, block_off, name_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\tvoid *base;\n\n\tret = ocfs2_xattr_bucket_get_name_value(sb,\n\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t&name_offset);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbase = bucket_block(bucket, block_off);\n\n\t*xv = (struct ocfs2_xattr_value_root *)(base + name_offset +\n\t\t\t OCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (bh)\n\t\t*bh = bucket->bu_bhs[block_off];\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xe->xe_name_len"
          ],
          "line": 6010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "bucket",
            "block_off"
          ],
          "line": 6007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_get_name_value",
          "args": [
            "sb",
            "bucket_xh(bucket)",
            "offset",
            "&block_off",
            "&name_offset"
          ],
          "line": 5997
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_get_name_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4014-4031",
          "snippet": "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 5998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 5993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh)\n{\n\tint ret, block_off, name_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\tvoid *base;\n\n\tret = ocfs2_xattr_bucket_get_name_value(sb,\n\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t&name_offset);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbase = bucket_block(bucket, block_off);\n\n\t*xv = (struct ocfs2_xattr_value_root *)(base + name_offset +\n\t\t\t OCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (bh)\n\t\t*bh = bucket->bu_bhs[block_off];\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_inline_attach_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5961-5978",
    "snippet": "static int ocfs2_xattr_inline_attach_refcount(struct inode *inode,\n\t\t\t\tstruct buffer_head *fe_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)fe_bh->b_data;\n\tstruct ocfs2_xattr_header *header = (struct ocfs2_xattr_header *)\n\t\t\t\t(fe_bh->b_data + inode->i_sb->s_blocksize -\n\t\t\t\tle16_to_cpu(di->i_xattr_inline_size));\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = fe_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\treturn ocfs2_xattr_attach_refcount_normal(inode, &vb, header,\n\t\t\t\t\t\t  ref_ci, ref_root_bh, dealloc);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_attach_refcount_normal",
          "args": [
            "inode",
            "&vb",
            "header",
            "ref_ci",
            "ref_root_bh",
            "dealloc"
          ],
          "line": 5976
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_attach_refcount_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5923-5959",
          "snippet": "static int ocfs2_xattr_attach_refcount_normal(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_buf *vb,\n\t\t\t\tstruct ocfs2_xattr_header *header,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_extent_tree et;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\txe = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\txv = (struct ocfs2_xattr_value_root *)((void *)header +\n\t\t\tle16_to_cpu(xe->xe_name_offset) +\n\t\t\tOCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\t\tvb->vb_xv = xv;\n\t\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\t\tret = ocfs2_xattr_value_attach_refcount(inode, xv, &et,\n\t\t\t\t\t\t\tref_ci, ref_root_bh,\n\t\t\t\t\t\t\tdealloc, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_attach_refcount_normal(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_buf *vb,\n\t\t\t\tstruct ocfs2_xattr_header *header,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_extent_tree et;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\txe = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\txv = (struct ocfs2_xattr_value_root *)((void *)header +\n\t\t\tle16_to_cpu(xe->xe_name_offset) +\n\t\t\tOCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\t\tvb->vb_xv = xv;\n\t\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\t\tret = ocfs2_xattr_value_attach_refcount(inode, xv, &et,\n\t\t\t\t\t\t\tref_ci, ref_root_bh,\n\t\t\t\t\t\t\tdealloc, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_xattr_inline_size"
          ],
          "line": 5970
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_inline_attach_refcount(struct inode *inode,\n\t\t\t\tstruct buffer_head *fe_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)fe_bh->b_data;\n\tstruct ocfs2_xattr_header *header = (struct ocfs2_xattr_header *)\n\t\t\t\t(fe_bh->b_data + inode->i_sb->s_blocksize -\n\t\t\t\tle16_to_cpu(di->i_xattr_inline_size));\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = fe_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\treturn ocfs2_xattr_attach_refcount_normal(inode, &vb, header,\n\t\t\t\t\t\t  ref_ci, ref_root_bh, dealloc);\n}"
  },
  {
    "function_name": "ocfs2_xattr_attach_refcount_normal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5923-5959",
    "snippet": "static int ocfs2_xattr_attach_refcount_normal(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_buf *vb,\n\t\t\t\tstruct ocfs2_xattr_header *header,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_extent_tree et;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\txe = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\txv = (struct ocfs2_xattr_value_root *)((void *)header +\n\t\t\tle16_to_cpu(xe->xe_name_offset) +\n\t\t\tOCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\t\tvb->vb_xv = xv;\n\t\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\t\tret = ocfs2_xattr_value_attach_refcount(inode, xv, &et,\n\t\t\t\t\t\t\tref_ci, ref_root_bh,\n\t\t\t\t\t\t\tdealloc, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_value_attach_refcount",
          "args": [
            "inode",
            "xv",
            "&et",
            "ref_ci",
            "ref_root_bh",
            "dealloc",
            "NULL"
          ],
          "line": 5949
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_value_attach_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5875-5916",
          "snippet": "static int ocfs2_xattr_value_attach_refcount(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\tstruct ocfs2_extent_tree *value_et,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tstruct ocfs2_post_refcount *refcount)\n{\n\tint ret = 0;\n\tu32 clusters = le32_to_cpu(xv->xr_clusters);\n\tu32 cpos, p_cluster, num_clusters;\n\tstruct ocfs2_extent_list *el = &xv->xr_list;\n\tunsigned int ext_flags;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcpos += num_clusters;\n\t\tif ((ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\t\tcontinue;\n\n\t\tBUG_ON(!p_cluster);\n\n\t\tret = ocfs2_add_refcount_flag(inode, value_et,\n\t\t\t\t\t      ref_ci, ref_root_bh,\n\t\t\t\t\t      cpos - num_clusters,\n\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t      dealloc, refcount);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_value_attach_refcount(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\tstruct ocfs2_extent_tree *value_et,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tstruct ocfs2_post_refcount *refcount)\n{\n\tint ret = 0;\n\tu32 clusters = le32_to_cpu(xv->xr_clusters);\n\tu32 cpos, p_cluster, num_clusters;\n\tstruct ocfs2_extent_list *el = &xv->xr_list;\n\tunsigned int ext_flags;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcpos += num_clusters;\n\t\tif ((ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\t\tcontinue;\n\n\t\tBUG_ON(!p_cluster);\n\n\t\tret = ocfs2_add_refcount_flag(inode, value_et,\n\t\t\t\t\t      ref_ci, ref_root_bh,\n\t\t\t\t\t      cpos - num_clusters,\n\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t      dealloc, refcount);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_value_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "vb"
          ],
          "line": 5947
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_value_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "474-480",
          "snippet": "void ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};\n\nvoid ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 5947
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xe->xe_name_len"
          ],
          "line": 5944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xe->xe_name_offset"
          ],
          "line": 5943
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "xe"
          ],
          "line": 5939
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_attach_refcount_normal(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_buf *vb,\n\t\t\t\tstruct ocfs2_xattr_header *header,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_extent_tree et;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\txe = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\txv = (struct ocfs2_xattr_value_root *)((void *)header +\n\t\t\tle16_to_cpu(xe->xe_name_offset) +\n\t\t\tOCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\t\tvb->vb_xv = xv;\n\t\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\t\tret = ocfs2_xattr_value_attach_refcount(inode, xv, &et,\n\t\t\t\t\t\t\tref_ci, ref_root_bh,\n\t\t\t\t\t\t\tdealloc, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_value_attach_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5875-5916",
    "snippet": "static int ocfs2_xattr_value_attach_refcount(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\tstruct ocfs2_extent_tree *value_et,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tstruct ocfs2_post_refcount *refcount)\n{\n\tint ret = 0;\n\tu32 clusters = le32_to_cpu(xv->xr_clusters);\n\tu32 cpos, p_cluster, num_clusters;\n\tstruct ocfs2_extent_list *el = &xv->xr_list;\n\tunsigned int ext_flags;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcpos += num_clusters;\n\t\tif ((ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\t\tcontinue;\n\n\t\tBUG_ON(!p_cluster);\n\n\t\tret = ocfs2_add_refcount_flag(inode, value_et,\n\t\t\t\t\t      ref_ci, ref_root_bh,\n\t\t\t\t\t      cpos - num_clusters,\n\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t      dealloc, refcount);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_refcount_flag",
          "args": [
            "inode",
            "value_et",
            "ref_ci",
            "ref_root_bh",
            "cpos - num_clusters",
            "p_cluster",
            "num_clusters",
            "dealloc",
            "refcount"
          ],
          "line": 5904
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_refcount_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3703-3775",
          "snippet": "int ocfs2_add_refcount_flag(struct inode *inode,\n\t\t\t    struct ocfs2_extent_tree *data_et,\n\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u32 cpos, u32 p_cluster, u32 num_clusters,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    struct ocfs2_post_refcount *post)\n{\n\tint ret;\n\thandle_t *handle;\n\tint credits = 1, ref_blocks = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &ref_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_add_refcount_flag(ref_blocks, credits);\n\n\tif (ref_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\t\tref_blocks, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (post)\n\t\tcredits += post->credits;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_mark_extent_refcounted(inode, data_et, handle,\n\t\t\t\t\t   cpos, num_clusters, p_cluster,\n\t\t\t\t\t   meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\n\t\t\t\t\tp_cluster, num_clusters, 0,\n\t\t\t\t\tmeta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (post && post->func) {\n\t\tret = post->func(inode, handle, post->para);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_add_refcount_flag(struct inode *inode,\n\t\t\t    struct ocfs2_extent_tree *data_et,\n\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u32 cpos, u32 p_cluster, u32 num_clusters,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    struct ocfs2_post_refcount *post)\n{\n\tint ret;\n\thandle_t *handle;\n\tint credits = 1, ref_blocks = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &ref_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_add_refcount_flag(ref_blocks, credits);\n\n\tif (ref_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\t\tref_blocks, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (post)\n\t\tcredits += post->credits;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_mark_extent_refcounted(inode, data_et, handle,\n\t\t\t\t\t   cpos, num_clusters, p_cluster,\n\t\t\t\t\t   meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\n\t\t\t\t\tp_cluster, num_clusters, 0,\n\t\t\t\t\tmeta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (post && post->func) {\n\t\tret = post->func(inode, handle, post->para);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!p_cluster"
          ],
          "line": 5902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&p_cluster",
            "&num_clusters",
            "el",
            "&ext_flags"
          ],
          "line": 5891
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "543-606",
          "snippet": "int ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "xv->xr_clusters"
          ],
          "line": 5884
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_value_attach_refcount(struct inode *inode,\n\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\tstruct ocfs2_extent_tree *value_et,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tstruct ocfs2_post_refcount *refcount)\n{\n\tint ret = 0;\n\tu32 clusters = le32_to_cpu(xv->xr_clusters);\n\tu32 cpos, p_cluster, num_clusters;\n\tstruct ocfs2_extent_list *el = &xv->xr_list;\n\tunsigned int ext_flags;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcpos += num_clusters;\n\t\tif ((ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\t\tcontinue;\n\n\t\tBUG_ON(!p_cluster);\n\n\t\tret = ocfs2_add_refcount_flag(inode, value_et,\n\t\t\t\t\t      ref_ci, ref_root_bh,\n\t\t\t\t\t      cpos - num_clusters,\n\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t      dealloc, refcount);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_prepare_refcount_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5745-5869",
    "snippet": "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_add,\n\t\t\t\t\tint *credits)\n{\n\tint ret = 0;\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_xattr_entry *xe;\n\tchar *base;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\tint name_offset, name_len;\n\tstruct ocfs2_xattr_value_buf vb;\n\tstruct ocfs2_xattr_bucket *bucket = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_post_refcount refcount;\n\tstruct ocfs2_post_refcount *p = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\n\tif (!xis->not_found) {\n\t\txe = xis->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\tbase = xis->base;\n\t\tvb.vb_bh = xis->inode_bh;\n\t\tvb.vb_access = ocfs2_journal_access_di;\n\t} else {\n\t\tint i, block_off = 0;\n\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\t\txe = xbs->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\ti = xbs->here - xbs->header->xh_entries;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(xbs->bucket),\n\t\t\t\t\t\t\ti, &block_off,\n\t\t\t\t\t\t\t&name_offset);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbase = bucket_block(xbs->bucket, block_off);\n\t\t\tvb.vb_bh = xbs->bucket->bu_bhs[block_off];\n\t\t\tvb.vb_access = ocfs2_journal_access;\n\n\t\t\tif (ocfs2_meta_ecc(osb)) {\n\t\t\t\t/*create parameters for ocfs2_post_refcount. */\n\t\t\t\tbucket = xbs->bucket;\n\t\t\t\trefcount.credits = bucket->bu_blocks;\n\t\t\t\trefcount.para = bucket;\n\t\t\t\trefcount.func =\n\t\t\t\t\tocfs2_xattr_bucket_post_refcount;\n\t\t\t\tp = &refcount;\n\t\t\t}\n\t\t} else {\n\t\t\tbase = xbs->base;\n\t\t\tvb.vb_bh = xbs->xattr_bh;\n\t\t\tvb.vb_access = ocfs2_journal_access_xb;\n\t\t}\n\t}\n\n\tif (ocfs2_xattr_is_local(xe))\n\t\tgoto out;\n\n\tvb.vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(base + name_offset + name_len);\n\n\tret = ocfs2_xattr_get_clusters(inode, 0, &p_cluster,\n\t\t\t\t       &num_clusters, &vb.vb_xv->xr_list,\n\t\t\t\t       &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We just need to check the 1st extent record, since we always\n\t * CoW the whole xattr. So there shouldn't be a xattr with\n\t * some REFCOUNT extent recs after the 1st one.\n\t */\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we are deleting the xattr or the new size will be stored inside,\n\t * cool, leave it there, the xattr truncate process will remove them\n\t * for us(it still needs the refcount tree lock and the meta, credits).\n\t * And the worse case is that every cluster truncate will split the\n\t * refcount tree, and make the original extent become 3. So we will need\n\t * 2 * cluster more extent recs at most.\n\t */\n\tif (!xi->xi_value || xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE) {\n\n\t\tret = ocfs2_refcounted_xattr_delete_need(inode,\n\t\t\t\t\t\t\t &(*ref_tree)->rf_ci,\n\t\t\t\t\t\t\t ref_root_bh, vb.vb_xv,\n\t\t\t\t\t\t\t meta_add, credits);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_refcount_cow_xattr(inode, di, &vb,\n\t\t\t\t       *ref_tree, ref_root_bh, 0,\n\t\t\t\t       le32_to_cpu(vb.vb_xv->xr_clusters), p);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_INLINE_SIZE\t80"
    ],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_root_bh"
          ],
          "line": 5867
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_cow_xattr",
          "args": [
            "inode",
            "di",
            "&vb",
            "*ref_tree",
            "ref_root_bh",
            "0",
            "le32_to_cpu(vb.vb_xv->xr_clusters)",
            "p"
          ],
          "line": 5860
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_cow_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3640-3697",
          "snippet": "int ocfs2_refcount_cow_xattr(struct inode *inode,\n\t\t\t     struct ocfs2_dinode *di,\n\t\t\t     struct ocfs2_xattr_value_buf *vb,\n\t\t\t     struct ocfs2_refcount_tree *ref_tree,\n\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t     u32 cpos, u32 write_len,\n\t\t\t     struct ocfs2_post_refcount *post)\n{\n\tint ret;\n\tstruct ocfs2_xattr_value_root *xv = vb->vb_xv;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_cow_context *context = NULL;\n\tu32 cow_start, cow_len;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_refcount_cal_cow_clusters(inode, &xv->xr_list,\n\t\t\t\t\t      cpos, write_len, UINT_MAX,\n\t\t\t\t\t      &cow_start, &cow_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(cow_len == 0);\n\n\tcontext = kzalloc(sizeof(struct ocfs2_cow_context), GFP_NOFS);\n\tif (!context) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->cow_start = cow_start;\n\tcontext->cow_len = cow_len;\n\tcontext->ref_tree = ref_tree;\n\tcontext->ref_root_bh = ref_root_bh;\n\tcontext->cow_object = xv;\n\n\tcontext->cow_duplicate_clusters = ocfs2_duplicate_clusters_by_jbd;\n\t/* We need the extra credits for duplicate_clusters by jbd. */\n\tcontext->extra_credits =\n\t\tocfs2_clusters_to_blocks(inode->i_sb, 1) * cow_len;\n\tcontext->get_clusters = ocfs2_xattr_value_get_clusters;\n\tcontext->post_refcount = post;\n\n\tocfs2_init_xattr_value_extent_tree(&context->data_et,\n\t\t\t\t\t   INODE_CACHE(inode), vb);\n\n\tret = ocfs2_replace_cow(context);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(context);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_refcount_cow_xattr(struct inode *inode,\n\t\t\t     struct ocfs2_dinode *di,\n\t\t\t     struct ocfs2_xattr_value_buf *vb,\n\t\t\t     struct ocfs2_refcount_tree *ref_tree,\n\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t     u32 cpos, u32 write_len,\n\t\t\t     struct ocfs2_post_refcount *post)\n{\n\tint ret;\n\tstruct ocfs2_xattr_value_root *xv = vb->vb_xv;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_cow_context *context = NULL;\n\tu32 cow_start, cow_len;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_refcount_cal_cow_clusters(inode, &xv->xr_list,\n\t\t\t\t\t      cpos, write_len, UINT_MAX,\n\t\t\t\t\t      &cow_start, &cow_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(cow_len == 0);\n\n\tcontext = kzalloc(sizeof(struct ocfs2_cow_context), GFP_NOFS);\n\tif (!context) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->cow_start = cow_start;\n\tcontext->cow_len = cow_len;\n\tcontext->ref_tree = ref_tree;\n\tcontext->ref_root_bh = ref_root_bh;\n\tcontext->cow_object = xv;\n\n\tcontext->cow_duplicate_clusters = ocfs2_duplicate_clusters_by_jbd;\n\t/* We need the extra credits for duplicate_clusters by jbd. */\n\tcontext->extra_credits =\n\t\tocfs2_clusters_to_blocks(inode->i_sb, 1) * cow_len;\n\tcontext->get_clusters = ocfs2_xattr_value_get_clusters;\n\tcontext->post_refcount = post;\n\n\tocfs2_init_xattr_value_extent_tree(&context->data_et,\n\t\t\t\t\t   INODE_CACHE(inode), vb);\n\n\tret = ocfs2_replace_cow(context);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(context);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "vb.vb_xv->xr_clusters"
          ],
          "line": 5862
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcounted_xattr_delete_need",
          "args": [
            "inode",
            "&(*ref_tree)->rf_ci",
            "ref_root_bh",
            "vb.vb_xv",
            "meta_add",
            "credits"
          ],
          "line": 5851
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcounted_xattr_delete_need",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3556-3635",
          "snippet": "int ocfs2_refcounted_xattr_delete_need(struct inode *inode,\n\t\t\t\t       struct ocfs2_caching_info *ref_ci,\n\t\t\t\t       struct buffer_head *ref_root_bh,\n\t\t\t\t       struct ocfs2_xattr_value_root *xv,\n\t\t\t\t       int *meta_add, int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0;\n\tu32 p_cluster, num_clusters;\n\tu32 cpos = 0, clusters = le32_to_cpu(xv->xr_clusters);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, &xv->xr_list,\n\t\t\t\t\t       NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcpos += num_clusters;\n\n\t\twhile (num_clusters) {\n\t\t\tret = ocfs2_get_refcount_rec(ref_ci, ref_root_bh,\n\t\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t\t     &rec, &index,\n\t\t\t\t\t\t     &ref_leaf_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!rec.r_refcount);\n\n\t\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\n\t\t\t/*\n\t\t\t * We really don't know whether the other clusters is in\n\t\t\t * this refcount block or not, so just take the worst\n\t\t\t * case that all the clusters are in this block and each\n\t\t\t * one will split a refcount rec, so totally we need\n\t\t\t * clusters * 2 new refcount rec.\n\t\t\t */\n\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) + clusters * 2 >\n\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\tref_blocks++;\n\n\t\t\t*credits += 1;\n\t\t\tbrelse(ref_leaf_bh);\n\t\t\tref_leaf_bh = NULL;\n\n\t\t\tif (num_clusters <= le32_to_cpu(rec.r_clusters))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tnum_clusters -= le32_to_cpu(rec.r_clusters);\n\t\t\tp_cluster += num_clusters;\n\t\t}\n\t}\n\n\t*meta_add += ref_blocks;\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\telse {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ref_ci, ref_root_bh);\n\t\t*credits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_refcounted_xattr_delete_need(struct inode *inode,\n\t\t\t\t       struct ocfs2_caching_info *ref_ci,\n\t\t\t\t       struct buffer_head *ref_root_bh,\n\t\t\t\t       struct ocfs2_xattr_value_root *xv,\n\t\t\t\t       int *meta_add, int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0;\n\tu32 p_cluster, num_clusters;\n\tu32 cpos = 0, clusters = le32_to_cpu(xv->xr_clusters);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, &xv->xr_list,\n\t\t\t\t\t       NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcpos += num_clusters;\n\n\t\twhile (num_clusters) {\n\t\t\tret = ocfs2_get_refcount_rec(ref_ci, ref_root_bh,\n\t\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t\t     &rec, &index,\n\t\t\t\t\t\t     &ref_leaf_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!rec.r_refcount);\n\n\t\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\n\t\t\t/*\n\t\t\t * We really don't know whether the other clusters is in\n\t\t\t * this refcount block or not, so just take the worst\n\t\t\t * case that all the clusters are in this block and each\n\t\t\t * one will split a refcount rec, so totally we need\n\t\t\t * clusters * 2 new refcount rec.\n\t\t\t */\n\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) + clusters * 2 >\n\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\tref_blocks++;\n\n\t\t\t*credits += 1;\n\t\t\tbrelse(ref_leaf_bh);\n\t\t\tref_leaf_bh = NULL;\n\n\t\t\tif (num_clusters <= le32_to_cpu(rec.r_clusters))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tnum_clusters -= le32_to_cpu(rec.r_clusters);\n\t\t\tp_cluster += num_clusters;\n\t\t}\n\t}\n\n\t*meta_add += ref_blocks;\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\telse {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ref_ci, ref_root_bh);\n\t\t*credits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "le64_to_cpu(di->i_refcount_loc)",
            "1",
            "ref_tree",
            "&ref_root_bh"
          ],
          "line": 5834
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "452-524",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_refcount_loc"
          ],
          "line": 5834
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_clusters",
          "args": [
            "inode",
            "0",
            "&p_cluster",
            "&num_clusters",
            "&vb.vb_xv->xr_list",
            "&ext_flags"
          ],
          "line": 5818
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "543-606",
          "snippet": "int ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "xe"
          ],
          "line": 5812
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_meta_ecc",
          "args": [
            "osb"
          ],
          "line": 5796
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "525-530",
          "snippet": "static inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "xbs->bucket",
            "block_off"
          ],
          "line": 5792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_get_name_value",
          "args": [
            "inode->i_sb",
            "bucket_xh(xbs->bucket)",
            "i",
            "&block_off",
            "&name_offset"
          ],
          "line": 5784
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_get_name_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4014-4031",
          "snippet": "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "xbs->bucket"
          ],
          "line": 5785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xb->xb_flags"
          ],
          "line": 5783
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xe->xe_name_len"
          ],
          "line": 5780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xe->xe_name_len"
          ],
          "line": 5771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_add,\n\t\t\t\t\tint *credits)\n{\n\tint ret = 0;\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_xattr_entry *xe;\n\tchar *base;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\tint name_offset, name_len;\n\tstruct ocfs2_xattr_value_buf vb;\n\tstruct ocfs2_xattr_bucket *bucket = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_post_refcount refcount;\n\tstruct ocfs2_post_refcount *p = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\n\tif (!xis->not_found) {\n\t\txe = xis->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\tbase = xis->base;\n\t\tvb.vb_bh = xis->inode_bh;\n\t\tvb.vb_access = ocfs2_journal_access_di;\n\t} else {\n\t\tint i, block_off = 0;\n\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\t\txe = xbs->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\ti = xbs->here - xbs->header->xh_entries;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(xbs->bucket),\n\t\t\t\t\t\t\ti, &block_off,\n\t\t\t\t\t\t\t&name_offset);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbase = bucket_block(xbs->bucket, block_off);\n\t\t\tvb.vb_bh = xbs->bucket->bu_bhs[block_off];\n\t\t\tvb.vb_access = ocfs2_journal_access;\n\n\t\t\tif (ocfs2_meta_ecc(osb)) {\n\t\t\t\t/*create parameters for ocfs2_post_refcount. */\n\t\t\t\tbucket = xbs->bucket;\n\t\t\t\trefcount.credits = bucket->bu_blocks;\n\t\t\t\trefcount.para = bucket;\n\t\t\t\trefcount.func =\n\t\t\t\t\tocfs2_xattr_bucket_post_refcount;\n\t\t\t\tp = &refcount;\n\t\t\t}\n\t\t} else {\n\t\t\tbase = xbs->base;\n\t\t\tvb.vb_bh = xbs->xattr_bh;\n\t\t\tvb.vb_access = ocfs2_journal_access_xb;\n\t\t}\n\t}\n\n\tif (ocfs2_xattr_is_local(xe))\n\t\tgoto out;\n\n\tvb.vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(base + name_offset + name_len);\n\n\tret = ocfs2_xattr_get_clusters(inode, 0, &p_cluster,\n\t\t\t\t       &num_clusters, &vb.vb_xv->xr_list,\n\t\t\t\t       &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We just need to check the 1st extent record, since we always\n\t * CoW the whole xattr. So there shouldn't be a xattr with\n\t * some REFCOUNT extent recs after the 1st one.\n\t */\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we are deleting the xattr or the new size will be stored inside,\n\t * cool, leave it there, the xattr truncate process will remove them\n\t * for us(it still needs the refcount tree lock and the meta, credits).\n\t * And the worse case is that every cluster truncate will split the\n\t * refcount tree, and make the original extent become 3. So we will need\n\t * 2 * cluster more extent recs at most.\n\t */\n\tif (!xi->xi_value || xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE) {\n\n\t\tret = ocfs2_refcounted_xattr_delete_need(inode,\n\t\t\t\t\t\t\t &(*ref_tree)->rf_ci,\n\t\t\t\t\t\t\t ref_root_bh, vb.vb_xv,\n\t\t\t\t\t\t\t meta_add, credits);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_refcount_cow_xattr(inode, di, &vb,\n\t\t\t\t       *ref_tree, ref_root_bh, 0,\n\t\t\t\t       le32_to_cpu(vb.vb_xv->xr_clusters), p);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_bucket_post_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5711-5729",
    "snippet": "static int ocfs2_xattr_bucket_post_refcount(struct inode *inode,\n\t\t\t\t\t    handle_t *handle,\n\t\t\t\t\t    void *para)\n{\n\tint ret;\n\tstruct ocfs2_xattr_bucket *bucket =\n\t\t\t(struct ocfs2_xattr_bucket *)para;\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_xattr_bucket_journal_dirty(handle, bucket);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_dirty",
          "args": [
            "handle",
            "bucket"
          ],
          "line": 5726
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "447-460",
          "snippet": "static void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_access",
          "args": [
            "handle",
            "bucket",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 5719
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "428-445",
          "snippet": "static int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_xattr_bucket_post_refcount(struct inode *inode,\n\t\t\t\t\t    handle_t *handle,\n\t\t\t\t\t    void *para)\n{\n\tint ret;\n\tstruct ocfs2_xattr_bucket *bucket =\n\t\t\t(struct ocfs2_xattr_bucket *)para;\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_xattr_bucket_journal_dirty(handle, bucket);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_delete_xattr_in_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5643-5701",
    "snippet": "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para)\n{\n\tint ret = 0, ref_credits;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu16 i;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt = {NULL, NULL,};\n\tint credits = ocfs2_remove_extent_credits(osb->sb) +\n\t\tocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_rm_xattr_bucket_para *args =\n\t\t\t(struct ocfs2_rm_xattr_bucket_para *)para;\n\n\tocfs2_init_dealloc_ctxt(&ctxt.dealloc);\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = ocfs2_get_xattr_tree_value_root(inode->i_sb, bucket,\n\t\t\t\t\t\t      i, &xv, NULL);\n\n\t\tret = ocfs2_lock_xattr_remove_allocators(inode, xv,\n\t\t\t\t\t\t\t args->ref_ci,\n\t\t\t\t\t\t\t args->ref_root_bh,\n\t\t\t\t\t\t\t &ctxt.meta_ac,\n\t\t\t\t\t\t\t &ref_credits);\n\n\t\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\t\tif (IS_ERR(ctxt.handle)) {\n\t\t\tret = PTR_ERR(ctxt.handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_bucket_value_truncate(inode, bucket,\n\t\t\t\t\t\t\ti, 0, &ctxt);\n\n\t\tocfs2_commit_trans(osb, ctxt.handle);\n\t\tif (ctxt.meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\t\t\tctxt.meta_ac = NULL;\n\t\t}\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "osb",
            "&ctxt.dealloc"
          ],
          "line": 5699
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6472-6513",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "1"
          ],
          "line": 5698
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "ctxt.meta_ac"
          ],
          "line": 5697
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "ctxt.handle"
          ],
          "line": 5685
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_value_truncate",
          "args": [
            "inode",
            "bucket",
            "i",
            "0",
            "&ctxt"
          ],
          "line": 5682
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_value_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5344-5405",
          "snippet": "static int ocfs2_xattr_bucket_value_truncate(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int xe_off,\n\t\t\t\t\t     int len,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret, offset;\n\tu64 value_blk;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_access = ocfs2_journal_access,\n\t};\n\n\txe = &xh->xh_entries[xe_off];\n\n\tBUG_ON(!xe || ocfs2_xattr_is_local(xe));\n\n\toffset = le16_to_cpu(xe->xe_name_offset) +\n\t\t OCFS2_XATTR_SIZE(xe->xe_name_len);\n\n\tvalue_blk = offset / blocksize;\n\n\t/* We don't allow ocfs2_xattr_value to be stored in different block. */\n\tBUG_ON(value_blk != (offset + OCFS2_XATTR_ROOT_SIZE - 1) / blocksize);\n\n\tvb.vb_bh = bucket->bu_bhs[value_blk];\n\tBUG_ON(!vb.vb_bh);\n\n\tvb.vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t(vb.vb_bh->b_data + offset % blocksize);\n\n\t/*\n\t * From here on out we have to dirty the bucket.  The generic\n\t * value calls only modify one of the bucket's bhs, but we need\n\t * to send the bucket at once.  So if they error, they *could* have\n\t * modified something.  We have to assume they did, and dirty\n\t * the whole bucket.  This leaves us in a consistent state.\n\t */\n\ttrace_ocfs2_xattr_bucket_value_truncate(\n\t\t\t(unsigned long long)bucket_blkno(bucket), xe_off, len);\n\tret = ocfs2_xattr_value_truncate(inode, &vb, len, ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(ctxt->handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txe->xe_value_size = cpu_to_le64(len);\n\n\tocfs2_xattr_bucket_journal_dirty(ctxt->handle, bucket);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
          ],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_bucket_value_truncate(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int xe_off,\n\t\t\t\t\t     int len,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret, offset;\n\tu64 value_blk;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_access = ocfs2_journal_access,\n\t};\n\n\txe = &xh->xh_entries[xe_off];\n\n\tBUG_ON(!xe || ocfs2_xattr_is_local(xe));\n\n\toffset = le16_to_cpu(xe->xe_name_offset) +\n\t\t OCFS2_XATTR_SIZE(xe->xe_name_len);\n\n\tvalue_blk = offset / blocksize;\n\n\t/* We don't allow ocfs2_xattr_value to be stored in different block. */\n\tBUG_ON(value_blk != (offset + OCFS2_XATTR_ROOT_SIZE - 1) / blocksize);\n\n\tvb.vb_bh = bucket->bu_bhs[value_blk];\n\tBUG_ON(!vb.vb_bh);\n\n\tvb.vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t(vb.vb_bh->b_data + offset % blocksize);\n\n\t/*\n\t * From here on out we have to dirty the bucket.  The generic\n\t * value calls only modify one of the bucket's bhs, but we need\n\t * to send the bucket at once.  So if they error, they *could* have\n\t * modified something.  We have to assume they did, and dirty\n\t * the whole bucket.  This leaves us in a consistent state.\n\t */\n\ttrace_ocfs2_xattr_bucket_value_truncate(\n\t\t\t(unsigned long long)bucket_blkno(bucket), xe_off, len);\n\tret = ocfs2_xattr_value_truncate(inode, &vb, len, ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(ctxt->handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txe->xe_value_size = cpu_to_le64(len);\n\n\tocfs2_xattr_bucket_journal_dirty(ctxt->handle, bucket);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ctxt.handle"
          ],
          "line": 5677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctxt.handle"
          ],
          "line": 5676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits + ref_credits"
          ],
          "line": 5675
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_xattr_remove_allocators",
          "args": [
            "inode",
            "xv",
            "args->ref_ci",
            "args->ref_root_bh",
            "&ctxt.meta_ac",
            "&ref_credits"
          ],
          "line": 5669
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_xattr_remove_allocators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2306-2345",
          "snippet": "static int ocfs2_lock_xattr_remove_allocators(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tint *ref_credits)\n{\n\tint ret, meta_add = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\t*ref_credits = 0;\n\tret = ocfs2_xattr_get_clusters(inode, 0, &p_cluster,\n\t\t\t\t       &num_clusters,\n\t\t\t\t       &xv->xr_list,\n\t\t\t\t       &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\tret = ocfs2_refcounted_xattr_delete_need(inode, ref_ci,\n\t\t\t\t\t\t ref_root_bh, xv,\n\t\t\t\t\t\t &meta_add, ref_credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\tmeta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_lock_xattr_remove_allocators(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tint *ref_credits)\n{\n\tint ret, meta_add = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\t*ref_credits = 0;\n\tret = ocfs2_xattr_get_clusters(inode, 0, &p_cluster,\n\t\t\t\t       &num_clusters,\n\t\t\t\t       &xv->xr_list,\n\t\t\t\t       &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\tret = ocfs2_refcounted_xattr_delete_need(inode, ref_ci,\n\t\t\t\t\t\t ref_root_bh, xv,\n\t\t\t\t\t\t &meta_add, ref_credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\tmeta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_xattr_tree_value_root",
          "args": [
            "inode->i_sb",
            "bucket",
            "i",
            "&xv",
            "NULL"
          ],
          "line": 5666
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_xattr_tree_value_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5986-6016",
          "snippet": "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh)\n{\n\tint ret, block_off, name_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\tvoid *base;\n\n\tret = ocfs2_xattr_bucket_get_name_value(sb,\n\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t&name_offset);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbase = bucket_block(bucket, block_off);\n\n\t*xv = (struct ocfs2_xattr_value_root *)(base + name_offset +\n\t\t\t OCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (bh)\n\t\t*bh = bucket->bu_bhs[block_off];\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh)\n{\n\tint ret, block_off, name_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tstruct ocfs2_xattr_entry *xe = &xh->xh_entries[offset];\n\tvoid *base;\n\n\tret = ocfs2_xattr_bucket_get_name_value(sb,\n\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t&name_offset);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tbase = bucket_block(bucket, block_off);\n\n\t*xv = (struct ocfs2_xattr_value_root *)(base + name_offset +\n\t\t\t OCFS2_XATTR_SIZE(xe->xe_name_len));\n\n\tif (bh)\n\t\t*bh = bucket->bu_bhs[block_off];\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "xe"
          ],
          "line": 5663
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_count"
          ],
          "line": 5661
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&ctxt.dealloc"
          ],
          "line": 5659
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "205-209",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_per_xattr_bucket",
          "args": [
            "inode->i_sb"
          ],
          "line": 5654
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_per_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "321-324",
          "snippet": "static inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_extent_credits",
          "args": [
            "osb->sb"
          ],
          "line": 5653
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_extent_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "412-416",
          "snippet": "static inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS",
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 5648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para)\n{\n\tint ret = 0, ref_credits;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu16 i;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt = {NULL, NULL,};\n\tint credits = ocfs2_remove_extent_credits(osb->sb) +\n\t\tocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tstruct ocfs2_xattr_value_root *xv;\n\tstruct ocfs2_rm_xattr_bucket_para *args =\n\t\t\t(struct ocfs2_rm_xattr_bucket_para *)para;\n\n\tocfs2_init_dealloc_ctxt(&ctxt.dealloc);\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (ocfs2_xattr_is_local(xe))\n\t\t\tcontinue;\n\n\t\tret = ocfs2_get_xattr_tree_value_root(inode->i_sb, bucket,\n\t\t\t\t\t\t      i, &xv, NULL);\n\n\t\tret = ocfs2_lock_xattr_remove_allocators(inode, xv,\n\t\t\t\t\t\t\t args->ref_ci,\n\t\t\t\t\t\t\t args->ref_root_bh,\n\t\t\t\t\t\t\t &ctxt.meta_ac,\n\t\t\t\t\t\t\t &ref_credits);\n\n\t\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\t\tif (IS_ERR(ctxt.handle)) {\n\t\t\tret = PTR_ERR(ctxt.handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_bucket_value_truncate(inode, bucket,\n\t\t\t\t\t\t\ti, 0, &ctxt);\n\n\t\tocfs2_commit_trans(osb, ctxt.handle);\n\t\tif (ctxt.meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\t\t\tctxt.meta_ac = NULL;\n\t\t}\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_set_entry_index_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5577-5641",
    "snippet": "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\n\ttrace_ocfs2_xattr_set_entry_index_block(xi->xi_name);\n\n\tret = ocfs2_xattr_set_entry_bucket(inode, xi, xs, ctxt);\n\tif (!ret)\n\t\tgoto out;\n\tif (ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Ack, need more space.  Let's try to get another bucket! */\n\n\t/*\n\t * We do not allow for overlapping ranges between buckets. And\n\t * the maximum number of collisions we will allow for then is\n\t * one bucket's worth, so check it here whether we need to\n\t * add a new bucket for the insert.\n\t */\n\tret = ocfs2_check_xattr_bucket_collision(inode,\n\t\t\t\t\t\t xs->bucket,\n\t\t\t\t\t\t xi->xi_name);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_add_new_xattr_bucket(inode,\n\t\t\t\t\t xs->xattr_bh,\n\t\t\t\t\t xs->bucket,\n\t\t\t\t\t ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * ocfs2_add_new_xattr_bucket() will have updated\n\t * xs->bucket if it moved, but it will not have updated\n\t * any of the other search fields.  Thus, we drop it and\n\t * re-search.  Everything should be cached, so it'll be\n\t * quick.\n\t */\n\tocfs2_xattr_bucket_relse(xs->bucket);\n\tret = ocfs2_xattr_index_block_find(inode, xs->xattr_bh,\n\t\t\t\t\t   xi->xi_name_index,\n\t\t\t\t\t   xi->xi_name, xs);\n\tif (ret && ret != -ENODATA)\n\t\tgoto out;\n\txs->not_found = ret;\n\n\t/* Ok, we have a new bucket, let's try again */\n\tret = ocfs2_xattr_set_entry_bucket(inode, xi, xs, ctxt);\n\tif (ret && (ret != -ENOSPC))\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_set_entry_bucket",
          "args": [
            "inode",
            "xi",
            "xs",
            "ctxt"
          ],
          "line": 5635
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_set_entry_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5534-5575",
          "snippet": "static int ocfs2_xattr_set_entry_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs,\n\t\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_xa_loc loc;\n\n\ttrace_ocfs2_xattr_set_entry_bucket(xi->xi_name);\n\n\tocfs2_init_xattr_bucket_xa_loc(&loc, xs->bucket,\n\t\t\t\t       xs->not_found ? NULL : xs->here);\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (!ret) {\n\t\txs->here = loc.xl_entry;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Ok, we need space.  Let's try defragmenting the bucket. */\n\tret = ocfs2_defrag_xattr_bucket(inode, ctxt->handle,\n\t\t\t\t\txs->bucket);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (!ret) {\n\t\txs->here = loc.xl_entry;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOSPC)\n\t\tmlog_errno(ret);\n\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_set_entry_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs,\n\t\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_xa_loc loc;\n\n\ttrace_ocfs2_xattr_set_entry_bucket(xi->xi_name);\n\n\tocfs2_init_xattr_bucket_xa_loc(&loc, xs->bucket,\n\t\t\t\t       xs->not_found ? NULL : xs->here);\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (!ret) {\n\t\txs->here = loc.xl_entry;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Ok, we need space.  Let's try defragmenting the bucket. */\n\tret = ocfs2_defrag_xattr_bucket(inode, ctxt->handle,\n\t\t\t\t\txs->bucket);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (!ret) {\n\t\txs->here = loc.xl_entry;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOSPC)\n\t\tmlog_errno(ret);\n\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_index_block_find",
          "args": [
            "inode",
            "xs->xattr_bh",
            "xi->xi_name_index",
            "xi->xi_name",
            "xs"
          ],
          "line": 5627
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_index_block_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3911-3953",
          "snippet": "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs)\n{\n\tint ret;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)root_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xb_root = &xb->xb_attrs.xb_root;\n\tstruct ocfs2_extent_list *el = &xb_root->xt_list;\n\tu64 p_blkno = 0;\n\tu32 first_hash, num_clusters = 0;\n\tu32 name_hash = ocfs2_xattr_name_hash(inode, name, strlen(name));\n\n\tif (le16_to_cpu(el->l_next_free_rec) == 0)\n\t\treturn -ENODATA;\n\n\ttrace_ocfs2_xattr_index_block_find(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, name_hash,\n\t\t\t\t\t(unsigned long long)root_bh->b_blocknr,\n\t\t\t\t\t-1);\n\n\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno, &first_hash,\n\t\t\t\t  &num_clusters, el);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(p_blkno == 0 || num_clusters == 0 || first_hash > name_hash);\n\n\ttrace_ocfs2_xattr_index_block_find_rec(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, first_hash,\n\t\t\t\t\t(unsigned long long)p_blkno,\n\t\t\t\t\tnum_clusters);\n\n\tret = ocfs2_xattr_bucket_find(inode, name_index, name, name_hash,\n\t\t\t\t      p_blkno, first_hash, num_clusters, xs);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
            "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\n\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs)\n{\n\tint ret;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)root_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xb_root = &xb->xb_attrs.xb_root;\n\tstruct ocfs2_extent_list *el = &xb_root->xt_list;\n\tu64 p_blkno = 0;\n\tu32 first_hash, num_clusters = 0;\n\tu32 name_hash = ocfs2_xattr_name_hash(inode, name, strlen(name));\n\n\tif (le16_to_cpu(el->l_next_free_rec) == 0)\n\t\treturn -ENODATA;\n\n\ttrace_ocfs2_xattr_index_block_find(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, name_hash,\n\t\t\t\t\t(unsigned long long)root_bh->b_blocknr,\n\t\t\t\t\t-1);\n\n\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno, &first_hash,\n\t\t\t\t  &num_clusters, el);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(p_blkno == 0 || num_clusters == 0 || first_hash > name_hash);\n\n\ttrace_ocfs2_xattr_index_block_find_rec(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, first_hash,\n\t\t\t\t\t(unsigned long long)p_blkno,\n\t\t\t\t\tnum_clusters);\n\n\tret = ocfs2_xattr_bucket_find(inode, name_index, name, name_hash,\n\t\t\t\t      p_blkno, first_hash, num_clusters, xs);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_relse",
          "args": [
            "xs->bucket"
          ],
          "line": 5626
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "346-354",
          "snippet": "static void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_new_xattr_bucket",
          "args": [
            "inode",
            "xs->xattr_bh",
            "xs->bucket",
            "ctxt"
          ],
          "line": 5610
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_new_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5259-5335",
          "snippet": "static int ocfs2_add_new_xattr_bucket(struct inode *inode,\n\t\t\t\t      struct buffer_head *xb_bh,\n\t\t\t\t      struct ocfs2_xattr_bucket *target,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xb_root = &xb->xb_attrs.xb_root;\n\tstruct ocfs2_extent_list *el = &xb_root->xt_list;\n\tu32 name_hash =\n\t\tle32_to_cpu(bucket_xh(target)->xh_entries[0].xe_name_hash);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint ret, num_buckets, extend = 1;\n\tu64 p_blkno;\n\tu32 e_cpos, num_clusters;\n\t/* The bucket at the front of the extent */\n\tstruct ocfs2_xattr_bucket *first;\n\n\ttrace_ocfs2_add_new_xattr_bucket(\n\t\t\t\t(unsigned long long)bucket_blkno(target));\n\n\t/* The first bucket of the original extent */\n\tfirst = ocfs2_xattr_bucket_new(inode);\n\tif (!first) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno, &e_cpos,\n\t\t\t\t  &num_clusters, el);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(first, p_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnum_buckets = ocfs2_xattr_buckets_per_cluster(osb) * num_clusters;\n\tif (num_buckets == le16_to_cpu(bucket_xh(first)->xh_num_buckets)) {\n\t\t/*\n\t\t * This can move first+target if the target bucket moves\n\t\t * to the new extent.\n\t\t */\n\t\tret = ocfs2_add_new_xattr_cluster(inode,\n\t\t\t\t\t\t  xb_bh,\n\t\t\t\t\t\t  first,\n\t\t\t\t\t\t  target,\n\t\t\t\t\t\t  &num_clusters,\n\t\t\t\t\t\t  e_cpos,\n\t\t\t\t\t\t  &extend,\n\t\t\t\t\t\t  ctxt);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (extend) {\n\t\tret = ocfs2_extend_xattr_bucket(inode,\n\t\t\t\t\t\tctxt->handle,\n\t\t\t\t\t\tfirst,\n\t\t\t\t\t\tbucket_blkno(target),\n\t\t\t\t\t\tnum_clusters);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tocfs2_xattr_bucket_free(first);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_add_new_xattr_bucket(struct inode *inode,\n\t\t\t\t      struct buffer_head *xb_bh,\n\t\t\t\t      struct ocfs2_xattr_bucket *target,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xb_root = &xb->xb_attrs.xb_root;\n\tstruct ocfs2_extent_list *el = &xb_root->xt_list;\n\tu32 name_hash =\n\t\tle32_to_cpu(bucket_xh(target)->xh_entries[0].xe_name_hash);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint ret, num_buckets, extend = 1;\n\tu64 p_blkno;\n\tu32 e_cpos, num_clusters;\n\t/* The bucket at the front of the extent */\n\tstruct ocfs2_xattr_bucket *first;\n\n\ttrace_ocfs2_add_new_xattr_bucket(\n\t\t\t\t(unsigned long long)bucket_blkno(target));\n\n\t/* The first bucket of the original extent */\n\tfirst = ocfs2_xattr_bucket_new(inode);\n\tif (!first) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno, &e_cpos,\n\t\t\t\t  &num_clusters, el);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(first, p_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnum_buckets = ocfs2_xattr_buckets_per_cluster(osb) * num_clusters;\n\tif (num_buckets == le16_to_cpu(bucket_xh(first)->xh_num_buckets)) {\n\t\t/*\n\t\t * This can move first+target if the target bucket moves\n\t\t * to the new extent.\n\t\t */\n\t\tret = ocfs2_add_new_xattr_cluster(inode,\n\t\t\t\t\t\t  xb_bh,\n\t\t\t\t\t\t  first,\n\t\t\t\t\t\t  target,\n\t\t\t\t\t\t  &num_clusters,\n\t\t\t\t\t\t  e_cpos,\n\t\t\t\t\t\t  &extend,\n\t\t\t\t\t\t  ctxt);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (extend) {\n\t\tret = ocfs2_extend_xattr_bucket(inode,\n\t\t\t\t\t\tctxt->handle,\n\t\t\t\t\t\tfirst,\n\t\t\t\t\t\tbucket_blkno(target),\n\t\t\t\t\t\tnum_clusters);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tocfs2_xattr_bucket_free(first);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_check_xattr_bucket_collision",
          "args": [
            "inode",
            "xs->bucket",
            "xi->xi_name"
          ],
          "line": 5602
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_xattr_bucket_collision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5508-5528",
          "snippet": "static int ocfs2_check_xattr_bucket_collision(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t      const char *name)\n{\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu32 name_hash = ocfs2_xattr_name_hash(inode, name, strlen(name));\n\n\tif (name_hash != le32_to_cpu(xh->xh_entries[0].xe_name_hash))\n\t\treturn 0;\n\n\tif (xh->xh_entries[le16_to_cpu(xh->xh_count) - 1].xe_name_hash ==\n\t    xh->xh_entries[0].xe_name_hash) {\n\t\tmlog(ML_ERROR, \"Too much hash collision in xattr bucket %llu, \"\n\t\t     \"hash = %u\\n\",\n\t\t     (unsigned long long)bucket_blkno(bucket),\n\t\t     le32_to_cpu(xh->xh_entries[0].xe_name_hash));\n\t\treturn -ENOSPC;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_check_xattr_bucket_collision(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t      const char *name)\n{\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu32 name_hash = ocfs2_xattr_name_hash(inode, name, strlen(name));\n\n\tif (name_hash != le32_to_cpu(xh->xh_entries[0].xe_name_hash))\n\t\treturn 0;\n\n\tif (xh->xh_entries[le16_to_cpu(xh->xh_count) - 1].xe_name_hash ==\n\t    xh->xh_entries[0].xe_name_hash) {\n\t\tmlog(ML_ERROR, \"Too much hash collision in xattr bucket %llu, \"\n\t\t     \"hash = %u\\n\",\n\t\t     (unsigned long long)bucket_blkno(bucket),\n\t\t     le32_to_cpu(xh->xh_entries[0].xe_name_hash));\n\t\treturn -ENOSPC;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_xattr_set_entry_index_block",
          "args": [
            "xi->xi_name"
          ],
          "line": 5584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\n\ttrace_ocfs2_xattr_set_entry_index_block(xi->xi_name);\n\n\tret = ocfs2_xattr_set_entry_bucket(inode, xi, xs, ctxt);\n\tif (!ret)\n\t\tgoto out;\n\tif (ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Ack, need more space.  Let's try to get another bucket! */\n\n\t/*\n\t * We do not allow for overlapping ranges between buckets. And\n\t * the maximum number of collisions we will allow for then is\n\t * one bucket's worth, so check it here whether we need to\n\t * add a new bucket for the insert.\n\t */\n\tret = ocfs2_check_xattr_bucket_collision(inode,\n\t\t\t\t\t\t xs->bucket,\n\t\t\t\t\t\t xi->xi_name);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_add_new_xattr_bucket(inode,\n\t\t\t\t\t xs->xattr_bh,\n\t\t\t\t\t xs->bucket,\n\t\t\t\t\t ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * ocfs2_add_new_xattr_bucket() will have updated\n\t * xs->bucket if it moved, but it will not have updated\n\t * any of the other search fields.  Thus, we drop it and\n\t * re-search.  Everything should be cached, so it'll be\n\t * quick.\n\t */\n\tocfs2_xattr_bucket_relse(xs->bucket);\n\tret = ocfs2_xattr_index_block_find(inode, xs->xattr_bh,\n\t\t\t\t\t   xi->xi_name_index,\n\t\t\t\t\t   xi->xi_name, xs);\n\tif (ret && ret != -ENODATA)\n\t\tgoto out;\n\txs->not_found = ret;\n\n\t/* Ok, we have a new bucket, let's try again */\n\tret = ocfs2_xattr_set_entry_bucket(inode, xi, xs, ctxt);\n\tif (ret && (ret != -ENOSPC))\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_set_entry_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5534-5575",
    "snippet": "static int ocfs2_xattr_set_entry_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs,\n\t\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_xa_loc loc;\n\n\ttrace_ocfs2_xattr_set_entry_bucket(xi->xi_name);\n\n\tocfs2_init_xattr_bucket_xa_loc(&loc, xs->bucket,\n\t\t\t\t       xs->not_found ? NULL : xs->here);\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (!ret) {\n\t\txs->here = loc.xl_entry;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Ok, we need space.  Let's try defragmenting the bucket. */\n\tret = ocfs2_defrag_xattr_bucket(inode, ctxt->handle,\n\t\t\t\t\txs->bucket);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (!ret) {\n\t\txs->here = loc.xl_entry;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOSPC)\n\t\tmlog_errno(ret);\n\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_set",
          "args": [
            "&loc",
            "xi",
            "ctxt"
          ],
          "line": 5564
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2207-2250",
          "snippet": "static int ocfs2_xa_set(struct ocfs2_xa_loc *loc,\n\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 name_hash = ocfs2_xattr_name_hash(loc->xl_inode, xi->xi_name,\n\t\t\t\t\t      xi->xi_name_len);\n\n\tret = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * From here on out, everything is going to modify the buffer a\n\t * little.  Errors are going to leave the xattr header in a\n\t * sane state.  Thus, even with errors we dirty the sucker.\n\t */\n\n\t/* Don't worry, we are never called with !xi_value and !xl_entry */\n\tif (!xi->xi_value) {\n\t\tret = ocfs2_xa_remove(loc, ctxt);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_prepare_entry(loc, xi, name_hash, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_store_value(loc, xi, ctxt);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_dirty:\n\tocfs2_xa_journal_dirty(ctxt->handle, loc);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_set(struct ocfs2_xa_loc *loc,\n\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 name_hash = ocfs2_xattr_name_hash(loc->xl_inode, xi->xi_name,\n\t\t\t\t\t      xi->xi_name_len);\n\n\tret = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * From here on out, everything is going to modify the buffer a\n\t * little.  Errors are going to leave the xattr header in a\n\t * sane state.  Thus, even with errors we dirty the sucker.\n\t */\n\n\t/* Don't worry, we are never called with !xi_value and !xl_entry */\n\tif (!xi->xi_value) {\n\t\tret = ocfs2_xa_remove(loc, ctxt);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_prepare_entry(loc, xi, name_hash, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_store_value(loc, xi, ctxt);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_dirty:\n\tocfs2_xa_journal_dirty(ctxt->handle, loc);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_defrag_xattr_bucket",
          "args": [
            "inode",
            "ctxt->handle",
            "xs->bucket"
          ],
          "line": 5557
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_defrag_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4375-4478",
          "snippet": "static int ocfs2_defrag_xattr_bucket(struct inode *inode,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint ret, i;\n\tsize_t end, offset, len;\n\tstruct ocfs2_xattr_header *xh;\n\tchar *entries, *buf, *bucket_buf = NULL;\n\tu64 blkno = bucket_blkno(bucket);\n\tu16 xh_free_start;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tstruct ocfs2_xattr_entry *xe;\n\n\t/*\n\t * In order to make the operation more efficient and generic,\n\t * we copy all the blocks into a contiguous memory and do the\n\t * defragment there, so if anything is error, we will not touch\n\t * the real block.\n\t */\n\tbucket_buf = kmalloc(OCFS2_XATTR_BUCKET_SIZE, GFP_NOFS);\n\tif (!bucket_buf) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tbuf = bucket_buf;\n\tfor (i = 0; i < bucket->bu_blocks; i++, buf += blocksize)\n\t\tmemcpy(buf, bucket_block(bucket, i), blocksize);\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = (struct ocfs2_xattr_header *)bucket_buf;\n\tentries = (char *)xh->xh_entries;\n\txh_free_start = le16_to_cpu(xh->xh_free_start);\n\n\ttrace_ocfs2_defrag_xattr_bucket(\n\t     (unsigned long long)blkno, le16_to_cpu(xh->xh_count),\n\t     xh_free_start, le16_to_cpu(xh->xh_name_value_len));\n\n\t/*\n\t * sort all the entries by their offset.\n\t * the largest will be the first, so that we can\n\t * move them to the end one by one.\n\t */\n\tsort(entries, le16_to_cpu(xh->xh_count),\n\t     sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe_offset, swap_xe);\n\n\t/* Move all name/values to the end of the bucket. */\n\txe = xh->xh_entries;\n\tend = OCFS2_XATTR_BUCKET_SIZE;\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++, xe++) {\n\t\toffset = le16_to_cpu(xe->xe_name_offset);\n\t\tlen = namevalue_size_xe(xe);\n\n\t\t/*\n\t\t * We must make sure that the name/value pair\n\t\t * exist in the same block. So adjust end to\n\t\t * the previous block end if needed.\n\t\t */\n\t\tif (((end - len) / blocksize !=\n\t\t\t(end - 1) / blocksize))\n\t\t\tend = end - end % blocksize;\n\n\t\tif (end > offset + len) {\n\t\t\tmemmove(bucket_buf + end - len,\n\t\t\t\tbucket_buf + offset, len);\n\t\t\txe->xe_name_offset = cpu_to_le16(end - len);\n\t\t}\n\n\t\tmlog_bug_on_msg(end < offset + len, \"Defrag check failed for \"\n\t\t\t\t\"bucket %llu\\n\", (unsigned long long)blkno);\n\n\t\tend -= len;\n\t}\n\n\tmlog_bug_on_msg(xh_free_start > end, \"Defrag check failed for \"\n\t\t\t\"bucket %llu\\n\", (unsigned long long)blkno);\n\n\tif (xh_free_start == end)\n\t\tgoto out;\n\n\tmemset(bucket_buf + xh_free_start, 0, end - xh_free_start);\n\txh->xh_free_start = cpu_to_le16(end);\n\n\t/* sort the entries by their name_hash. */\n\tsort(entries, le16_to_cpu(xh->xh_count),\n\t     sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe, swap_xe);\n\n\tbuf = bucket_buf;\n\tfor (i = 0; i < bucket->bu_blocks; i++, buf += blocksize)\n\t\tmemcpy(bucket_block(bucket, i), buf, blocksize);\n\tocfs2_xattr_bucket_journal_dirty(handle, bucket);\n\nout:\n\tkfree(bucket_buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_defrag_xattr_bucket(struct inode *inode,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint ret, i;\n\tsize_t end, offset, len;\n\tstruct ocfs2_xattr_header *xh;\n\tchar *entries, *buf, *bucket_buf = NULL;\n\tu64 blkno = bucket_blkno(bucket);\n\tu16 xh_free_start;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tstruct ocfs2_xattr_entry *xe;\n\n\t/*\n\t * In order to make the operation more efficient and generic,\n\t * we copy all the blocks into a contiguous memory and do the\n\t * defragment there, so if anything is error, we will not touch\n\t * the real block.\n\t */\n\tbucket_buf = kmalloc(OCFS2_XATTR_BUCKET_SIZE, GFP_NOFS);\n\tif (!bucket_buf) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tbuf = bucket_buf;\n\tfor (i = 0; i < bucket->bu_blocks; i++, buf += blocksize)\n\t\tmemcpy(buf, bucket_block(bucket, i), blocksize);\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = (struct ocfs2_xattr_header *)bucket_buf;\n\tentries = (char *)xh->xh_entries;\n\txh_free_start = le16_to_cpu(xh->xh_free_start);\n\n\ttrace_ocfs2_defrag_xattr_bucket(\n\t     (unsigned long long)blkno, le16_to_cpu(xh->xh_count),\n\t     xh_free_start, le16_to_cpu(xh->xh_name_value_len));\n\n\t/*\n\t * sort all the entries by their offset.\n\t * the largest will be the first, so that we can\n\t * move them to the end one by one.\n\t */\n\tsort(entries, le16_to_cpu(xh->xh_count),\n\t     sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe_offset, swap_xe);\n\n\t/* Move all name/values to the end of the bucket. */\n\txe = xh->xh_entries;\n\tend = OCFS2_XATTR_BUCKET_SIZE;\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++, xe++) {\n\t\toffset = le16_to_cpu(xe->xe_name_offset);\n\t\tlen = namevalue_size_xe(xe);\n\n\t\t/*\n\t\t * We must make sure that the name/value pair\n\t\t * exist in the same block. So adjust end to\n\t\t * the previous block end if needed.\n\t\t */\n\t\tif (((end - len) / blocksize !=\n\t\t\t(end - 1) / blocksize))\n\t\t\tend = end - end % blocksize;\n\n\t\tif (end > offset + len) {\n\t\t\tmemmove(bucket_buf + end - len,\n\t\t\t\tbucket_buf + offset, len);\n\t\t\txe->xe_name_offset = cpu_to_le16(end - len);\n\t\t}\n\n\t\tmlog_bug_on_msg(end < offset + len, \"Defrag check failed for \"\n\t\t\t\t\"bucket %llu\\n\", (unsigned long long)blkno);\n\n\t\tend -= len;\n\t}\n\n\tmlog_bug_on_msg(xh_free_start > end, \"Defrag check failed for \"\n\t\t\t\"bucket %llu\\n\", (unsigned long long)blkno);\n\n\tif (xh_free_start == end)\n\t\tgoto out;\n\n\tmemset(bucket_buf + xh_free_start, 0, end - xh_free_start);\n\txh->xh_free_start = cpu_to_le16(end);\n\n\t/* sort the entries by their name_hash. */\n\tsort(entries, le16_to_cpu(xh->xh_count),\n\t     sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe, swap_xe);\n\n\tbuf = bucket_buf;\n\tfor (i = 0; i < bucket->bu_blocks; i++, buf += blocksize)\n\t\tmemcpy(bucket_block(bucket, i), buf, blocksize);\n\tocfs2_xattr_bucket_journal_dirty(handle, bucket);\n\nout:\n\tkfree(bucket_buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_bucket_xa_loc",
          "args": [
            "&loc",
            "xs->bucket",
            "xs->not_found ? NULL : xs->here"
          ],
          "line": 5544
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_bucket_xa_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2290-2300",
          "snippet": "static void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};\n\nstatic void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_xattr_set_entry_bucket",
          "args": [
            "xi->xi_name"
          ],
          "line": 5542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_set_entry_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs,\n\t\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_xa_loc loc;\n\n\ttrace_ocfs2_xattr_set_entry_bucket(xi->xi_name);\n\n\tocfs2_init_xattr_bucket_xa_loc(&loc, xs->bucket,\n\t\t\t\t       xs->not_found ? NULL : xs->here);\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (!ret) {\n\t\txs->here = loc.xl_entry;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Ok, we need space.  Let's try defragmenting the bucket. */\n\tret = ocfs2_defrag_xattr_bucket(inode, ctxt->handle,\n\t\t\t\t\txs->bucket);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (!ret) {\n\t\txs->here = loc.xl_entry;\n\t\tgoto out;\n\t}\n\tif (ret != -ENOSPC)\n\t\tmlog_errno(ret);\n\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_check_xattr_bucket_collision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5508-5528",
    "snippet": "static int ocfs2_check_xattr_bucket_collision(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t      const char *name)\n{\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu32 name_hash = ocfs2_xattr_name_hash(inode, name, strlen(name));\n\n\tif (name_hash != le32_to_cpu(xh->xh_entries[0].xe_name_hash))\n\t\treturn 0;\n\n\tif (xh->xh_entries[le16_to_cpu(xh->xh_count) - 1].xe_name_hash ==\n\t    xh->xh_entries[0].xe_name_hash) {\n\t\tmlog(ML_ERROR, \"Too much hash collision in xattr bucket %llu, \"\n\t\t     \"hash = %u\\n\",\n\t\t     (unsigned long long)bucket_blkno(bucket),\n\t\t     le32_to_cpu(xh->xh_entries[0].xe_name_hash));\n\t\treturn -ENOSPC;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Too much hash collision in xattr bucket %llu, \"\n\t\t     \"hash = %u\\n\"",
            "(unsigned long long)bucket_blkno(bucket)",
            "le32_to_cpu(xh->xh_entries[0].xe_name_hash)"
          ],
          "line": 5520
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "xh->xh_entries[0].xe_name_hash"
          ],
          "line": 5523
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "bucket"
          ],
          "line": 5522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_count"
          ],
          "line": 5518
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_name_hash",
          "args": [
            "inode",
            "name",
            "strlen(name)"
          ],
          "line": 5513
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "557-573",
          "snippet": "static u32 ocfs2_xattr_name_hash(struct inode *inode,\n\t\t\t\t const char *name,\n\t\t\t\t int name_len)\n{\n\t/* Get hash value of uuid from super block */\n\tu32 hash = OCFS2_SB(inode->i_sb)->uuid_hash;\n\tint i;\n\n\t/* hash extended attribute name */\n\tfor (i = 0; i < name_len; i++) {\n\t\thash = (hash << OCFS2_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - OCFS2_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\treturn hash;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic u32 ocfs2_xattr_name_hash(struct inode *inode,\n\t\t\t\t const char *name,\n\t\t\t\t int name_len)\n{\n\t/* Get hash value of uuid from super block */\n\tu32 hash = OCFS2_SB(inode->i_sb)->uuid_hash;\n\tint i;\n\n\t/* hash extended attribute name */\n\tfor (i = 0; i < name_len; i++) {\n\t\thash = (hash << OCFS2_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - OCFS2_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 5513
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 5512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_check_xattr_bucket_collision(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t      const char *name)\n{\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu32 name_hash = ocfs2_xattr_name_hash(inode, name, strlen(name));\n\n\tif (name_hash != le32_to_cpu(xh->xh_entries[0].xe_name_hash))\n\t\treturn 0;\n\n\tif (xh->xh_entries[le16_to_cpu(xh->xh_count) - 1].xe_name_hash ==\n\t    xh->xh_entries[0].xe_name_hash) {\n\t\tmlog(ML_ERROR, \"Too much hash collision in xattr bucket %llu, \"\n\t\t     \"hash = %u\\n\",\n\t\t     (unsigned long long)bucket_blkno(bucket),\n\t\t     le32_to_cpu(xh->xh_entries[0].xe_name_hash));\n\t\treturn -ENOSPC;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_rm_xattr_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5407-5500",
    "snippet": "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)root_bh->b_data;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree et;\n\n\tret = ocfs2_iterate_xattr_buckets(inode, blkno, len,\n\t\t\t\t\t  ocfs2_delete_xattr_in_bucket, para);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_init_xattr_tree_extent_tree(&et, INODE_CACHE(inode), root_bh);\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\ttrace_ocfs2_rm_xattr_cluster(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)blkno, cpos, len);\n\n\tocfs2_remove_xattr_clusters_from_cache(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       len);\n\n\tret = ocfs2_lock_allocators(inode, &et, 0, 1, NULL, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_remove_extent_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_remove_extent(handle, &et, cpos, len, meta_ac,\n\t\t\t\t  &dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tle32_add_cpu(&xb->xb_attrs.xb_root.xt_clusters, -len);\n\tocfs2_journal_dirty(handle, root_bh);\n\n\tret = ocfs2_truncate_log_append(osb, handle, blkno, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "osb",
            "&dealloc"
          ],
          "line": 5497
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6472-6513",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "meta_ac"
          ],
          "line": 5495
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 5492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "1"
          ],
          "line": 5490
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 5488
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "0"
          ],
          "line": 5485
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_append",
          "args": [
            "osb",
            "handle",
            "blkno",
            "len"
          ],
          "line": 5482
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5808-5882",
          "snippet": "int ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "root_bh"
          ],
          "line": 5480
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&xb->xb_attrs.xb_root.xt_clusters",
            "-len"
          ],
          "line": 5479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_extent",
          "args": [
            "handle",
            "&et",
            "cpos",
            "len",
            "meta_ac",
            "&dealloc"
          ],
          "line": 5472
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5470-5607",
          "snippet": "int ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record.\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u\"\n\t\t\t\t    \"trunc len %u, existing record is (%u,%u)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record.\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u\"\n\t\t\t\t    \"trunc len %u, existing record is (%u,%u)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_xb",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "root_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 5465
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_xb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "741-745",
          "snippet": "int ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};\n\nint ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 5465
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 5459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_remove_extent_credits(osb->sb)"
          ],
          "line": 5458
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_extent_credits",
          "args": [
            "osb->sb"
          ],
          "line": 5458
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_extent_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "412-416",
          "snippet": "static inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS",
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 5451
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5956-6028",
          "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_needs_flush",
          "args": [
            "osb"
          ],
          "line": 5450
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_needs_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5775-5789",
          "snippet": "int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 5448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_allocators",
          "args": [
            "inode",
            "&et",
            "0",
            "1",
            "NULL",
            "&meta_ac"
          ],
          "line": 5442
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_allocators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2674-2743",
          "snippet": "int ocfs2_lock_allocators(struct inode *inode,\n\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t  u32 clusters_to_add, u32 extents_to_split,\n\t\t\t  struct ocfs2_alloc_context **data_ac,\n\t\t\t  struct ocfs2_alloc_context **meta_ac)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = clusters_to_add + 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*meta_ac = NULL;\n\tif (data_ac)\n\t\t*data_ac = NULL;\n\n\tBUG_ON(clusters_to_add != 0 && data_ac == NULL);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Sparse allocation file systems need to be more conservative\n\t * with reserving room for expansion - the actual allocation\n\t * happens while we've got a journal handle open so re-taking\n\t * a cluster lock (because we ran out of room for another\n\t * extent) will violate ordering rules.\n\t *\n\t * Most of the time we'll only be seeing this 1 cluster at a time\n\t * anyway.\n\t *\n\t * Always lock for any unwritten extents - we might want to\n\t * add blocks during a split.\n\t */\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed)) {\n\t\tret = ocfs2_reserve_new_metadata(osb, et->et_root_el, meta_ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_to_add == 0)\n\t\tgoto out;\n\n\tret = ocfs2_reserve_clusters(osb, clusters_to_add, data_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\n\t\t/*\n\t\t * We cannot have an error and a non null *data_ac.\n\t\t */\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_lock_allocators(struct inode *inode,\n\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t  u32 clusters_to_add, u32 extents_to_split,\n\t\t\t  struct ocfs2_alloc_context **data_ac,\n\t\t\t  struct ocfs2_alloc_context **meta_ac)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = clusters_to_add + 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*meta_ac = NULL;\n\tif (data_ac)\n\t\t*data_ac = NULL;\n\n\tBUG_ON(clusters_to_add != 0 && data_ac == NULL);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Sparse allocation file systems need to be more conservative\n\t * with reserving room for expansion - the actual allocation\n\t * happens while we've got a journal handle open so re-taking\n\t * a cluster lock (because we ran out of room for another\n\t * extent) will violate ordering rules.\n\t *\n\t * Most of the time we'll only be seeing this 1 cluster at a time\n\t * anyway.\n\t *\n\t * Always lock for any unwritten extents - we might want to\n\t * add blocks during a split.\n\t */\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed)) {\n\t\tret = ocfs2_reserve_new_metadata(osb, et->et_root_el, meta_ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_to_add == 0)\n\t\tgoto out;\n\n\tret = ocfs2_reserve_clusters(osb, clusters_to_add, data_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\n\t\t/*\n\t\t * We cannot have an error and a non null *data_ac.\n\t\t */\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_xattr_clusters_from_cache",
          "args": [
            "INODE_CACHE(inode)",
            "blkno",
            "len"
          ],
          "line": 5439
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_xattr_clusters_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "612-621",
          "snippet": "void ocfs2_remove_xattr_clusters_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t\t\t    sector_t block,\n\t\t\t\t\t    u32 c_len)\n{\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tunsigned int i, b_len = ocfs2_clusters_to_blocks(sb, 1) * c_len;\n\n\tfor (i = 0; i < b_len; i++, block++)\n\t\tocfs2_remove_block_from_cache(ci, block);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_remove_xattr_clusters_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t\t\t    sector_t block,\n\t\t\t\t\t    u32 c_len)\n{\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tunsigned int i, b_len = ocfs2_clusters_to_blocks(sb, 1) * c_len;\n\n\tfor (i = 0; i < b_len; i++, block++)\n\t\tocfs2_remove_block_from_cache(ci, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rm_xattr_cluster",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)blkno",
            "cpos",
            "len"
          ],
          "line": 5435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 5436
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&dealloc"
          ],
          "line": 5433
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "205-209",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_tree_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "root_bh"
          ],
          "line": 5431
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_tree_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "466-472",
          "snippet": "void ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t       struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_xb,\n\t\t\t\t NULL, &ocfs2_xattr_tree_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_xattr_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_tree_fill_root_el,\n\t.eo_fill_max_leaf_clusters = ocfs2_xattr_tree_fill_max_leaf_clusters,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_xattr_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_tree_fill_root_el,\n\t.eo_fill_max_leaf_clusters = ocfs2_xattr_tree_fill_max_leaf_clusters,\n};\n\nvoid ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t       struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_xb,\n\t\t\t\t NULL, &ocfs2_xattr_tree_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iterate_xattr_buckets",
          "args": [
            "inode",
            "blkno",
            "len",
            "ocfs2_delete_xattr_in_bucket",
            "para"
          ],
          "line": 5424
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iterate_xattr_buckets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3955-4006",
          "snippet": "static int ocfs2_iterate_xattr_buckets(struct inode *inode,\n\t\t\t\t       u64 blkno,\n\t\t\t\t       u32 clusters,\n\t\t\t\t       xattr_bucket_func *func,\n\t\t\t\t       void *para)\n{\n\tint i, ret = 0;\n\tu32 bpc = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\tu32 num_buckets = clusters * bpc;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tbucket = ocfs2_xattr_bucket_new(inode);\n\tif (!bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace_ocfs2_iterate_xattr_buckets(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)blkno, clusters);\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bucket->bu_blocks) {\n\t\tret = ocfs2_read_xattr_bucket(bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The real bucket num in this series of blocks is stored\n\t\t * in the 1st bucket.\n\t\t */\n\t\tif (i == 0)\n\t\t\tnum_buckets = le16_to_cpu(bucket_xh(bucket)->xh_num_buckets);\n\n\t\ttrace_ocfs2_iterate_xattr_bucket((unsigned long long)blkno,\n\t\t     le32_to_cpu(bucket_xh(bucket)->xh_entries[0].xe_name_hash));\n\t\tif (func) {\n\t\t\tret = func(inode, bucket, para);\n\t\t\tif (ret && ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\t/* Fall through to bucket_relse() */\n\t\t}\n\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tocfs2_xattr_bucket_free(bucket);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_iterate_xattr_buckets(struct inode *inode,\n\t\t\t\t       u64 blkno,\n\t\t\t\t       u32 clusters,\n\t\t\t\t       xattr_bucket_func *func,\n\t\t\t\t       void *para)\n{\n\tint i, ret = 0;\n\tu32 bpc = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\tu32 num_buckets = clusters * bpc;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tbucket = ocfs2_xattr_bucket_new(inode);\n\tif (!bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace_ocfs2_iterate_xattr_buckets(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)blkno, clusters);\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bucket->bu_blocks) {\n\t\tret = ocfs2_read_xattr_bucket(bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The real bucket num in this series of blocks is stored\n\t\t * in the 1st bucket.\n\t\t */\n\t\tif (i == 0)\n\t\t\tnum_buckets = le16_to_cpu(bucket_xh(bucket)->xh_num_buckets);\n\n\t\ttrace_ocfs2_iterate_xattr_bucket((unsigned long long)blkno,\n\t\t     le32_to_cpu(bucket_xh(bucket)->xh_entries[0].xe_name_hash));\n\t\tif (func) {\n\t\t\tret = func(inode, bucket, para);\n\t\t\tif (ret && ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\t/* Fall through to bucket_relse() */\n\t\t}\n\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tocfs2_xattr_bucket_free(bucket);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)root_bh->b_data;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree et;\n\n\tret = ocfs2_iterate_xattr_buckets(inode, blkno, len,\n\t\t\t\t\t  ocfs2_delete_xattr_in_bucket, para);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_init_xattr_tree_extent_tree(&et, INODE_CACHE(inode), root_bh);\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\ttrace_ocfs2_rm_xattr_cluster(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)blkno, cpos, len);\n\n\tocfs2_remove_xattr_clusters_from_cache(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       len);\n\n\tret = ocfs2_lock_allocators(inode, &et, 0, 1, NULL, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_remove_extent_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_remove_extent(handle, &et, cpos, len, meta_ac,\n\t\t\t\t  &dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tle32_add_cpu(&xb->xb_attrs.xb_root.xt_clusters, -len);\n\tocfs2_journal_dirty(handle, root_bh);\n\n\tret = ocfs2_truncate_log_append(osb, handle, blkno, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_bucket_value_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5344-5405",
    "snippet": "static int ocfs2_xattr_bucket_value_truncate(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int xe_off,\n\t\t\t\t\t     int len,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret, offset;\n\tu64 value_blk;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_access = ocfs2_journal_access,\n\t};\n\n\txe = &xh->xh_entries[xe_off];\n\n\tBUG_ON(!xe || ocfs2_xattr_is_local(xe));\n\n\toffset = le16_to_cpu(xe->xe_name_offset) +\n\t\t OCFS2_XATTR_SIZE(xe->xe_name_len);\n\n\tvalue_blk = offset / blocksize;\n\n\t/* We don't allow ocfs2_xattr_value to be stored in different block. */\n\tBUG_ON(value_blk != (offset + OCFS2_XATTR_ROOT_SIZE - 1) / blocksize);\n\n\tvb.vb_bh = bucket->bu_bhs[value_blk];\n\tBUG_ON(!vb.vb_bh);\n\n\tvb.vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t(vb.vb_bh->b_data + offset % blocksize);\n\n\t/*\n\t * From here on out we have to dirty the bucket.  The generic\n\t * value calls only modify one of the bucket's bhs, but we need\n\t * to send the bucket at once.  So if they error, they *could* have\n\t * modified something.  We have to assume they did, and dirty\n\t * the whole bucket.  This leaves us in a consistent state.\n\t */\n\ttrace_ocfs2_xattr_bucket_value_truncate(\n\t\t\t(unsigned long long)bucket_blkno(bucket), xe_off, len);\n\tret = ocfs2_xattr_value_truncate(inode, &vb, len, ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(ctxt->handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txe->xe_value_size = cpu_to_le64(len);\n\n\tocfs2_xattr_bucket_journal_dirty(ctxt->handle, bucket);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
    ],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_dirty",
          "args": [
            "ctxt->handle",
            "bucket"
          ],
          "line": 5401
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "447-460",
          "snippet": "static void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "len"
          ],
          "line": 5399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_access",
          "args": [
            "ctxt->handle",
            "bucket",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 5392
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "428-445",
          "snippet": "static int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_value_truncate",
          "args": [
            "inode",
            "&vb",
            "len",
            "ctxt"
          ],
          "line": 5386
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_value_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "869-891",
          "snippet": "static int ocfs2_xattr_value_truncate(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      int len,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb, len);\n\tu32 old_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\n\tif (new_clusters == old_clusters)\n\t\treturn 0;\n\n\tif (new_clusters > old_clusters)\n\t\tret = ocfs2_xattr_extend_allocation(inode,\n\t\t\t\t\t\t    new_clusters - old_clusters,\n\t\t\t\t\t\t    vb, ctxt);\n\telse\n\t\tret = ocfs2_xattr_shrink_size(inode,\n\t\t\t\t\t      old_clusters, new_clusters,\n\t\t\t\t\t      vb, ctxt);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_value_truncate(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      int len,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb, len);\n\tu32 old_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\n\tif (new_clusters == old_clusters)\n\t\treturn 0;\n\n\tif (new_clusters > old_clusters)\n\t\tret = ocfs2_xattr_extend_allocation(inode,\n\t\t\t\t\t\t    new_clusters - old_clusters,\n\t\t\t\t\t\t    vb, ctxt);\n\telse\n\t\tret = ocfs2_xattr_shrink_size(inode,\n\t\t\t\t\t      old_clusters, new_clusters,\n\t\t\t\t\t      vb, ctxt);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_xattr_bucket_value_truncate",
          "args": [
            "(unsigned long long)bucket_blkno(bucket)",
            "xe_off",
            "len"
          ],
          "line": 5384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "bucket"
          ],
          "line": 5385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!vb.vb_bh"
          ],
          "line": 5372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "value_blk != (offset + OCFS2_XATTR_ROOT_SIZE - 1) / blocksize"
          ],
          "line": 5369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xe->xe_name_len"
          ],
          "line": 5364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xe->xe_name_offset"
          ],
          "line": 5363
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!xe || ocfs2_xattr_is_local(xe)"
          ],
          "line": 5361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "xe"
          ],
          "line": 5361
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 5353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_bucket_value_truncate(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int xe_off,\n\t\t\t\t\t     int len,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret, offset;\n\tu64 value_blk;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_access = ocfs2_journal_access,\n\t};\n\n\txe = &xh->xh_entries[xe_off];\n\n\tBUG_ON(!xe || ocfs2_xattr_is_local(xe));\n\n\toffset = le16_to_cpu(xe->xe_name_offset) +\n\t\t OCFS2_XATTR_SIZE(xe->xe_name_len);\n\n\tvalue_blk = offset / blocksize;\n\n\t/* We don't allow ocfs2_xattr_value to be stored in different block. */\n\tBUG_ON(value_blk != (offset + OCFS2_XATTR_ROOT_SIZE - 1) / blocksize);\n\n\tvb.vb_bh = bucket->bu_bhs[value_blk];\n\tBUG_ON(!vb.vb_bh);\n\n\tvb.vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t(vb.vb_bh->b_data + offset % blocksize);\n\n\t/*\n\t * From here on out we have to dirty the bucket.  The generic\n\t * value calls only modify one of the bucket's bhs, but we need\n\t * to send the bucket at once.  So if they error, they *could* have\n\t * modified something.  We have to assume they did, and dirty\n\t * the whole bucket.  This leaves us in a consistent state.\n\t */\n\ttrace_ocfs2_xattr_bucket_value_truncate(\n\t\t\t(unsigned long long)bucket_blkno(bucket), xe_off, len);\n\tret = ocfs2_xattr_value_truncate(inode, &vb, len, ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(ctxt->handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txe->xe_value_size = cpu_to_le64(len);\n\n\tocfs2_xattr_bucket_journal_dirty(ctxt->handle, bucket);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_add_new_xattr_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5259-5335",
    "snippet": "static int ocfs2_add_new_xattr_bucket(struct inode *inode,\n\t\t\t\t      struct buffer_head *xb_bh,\n\t\t\t\t      struct ocfs2_xattr_bucket *target,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xb_root = &xb->xb_attrs.xb_root;\n\tstruct ocfs2_extent_list *el = &xb_root->xt_list;\n\tu32 name_hash =\n\t\tle32_to_cpu(bucket_xh(target)->xh_entries[0].xe_name_hash);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint ret, num_buckets, extend = 1;\n\tu64 p_blkno;\n\tu32 e_cpos, num_clusters;\n\t/* The bucket at the front of the extent */\n\tstruct ocfs2_xattr_bucket *first;\n\n\ttrace_ocfs2_add_new_xattr_bucket(\n\t\t\t\t(unsigned long long)bucket_blkno(target));\n\n\t/* The first bucket of the original extent */\n\tfirst = ocfs2_xattr_bucket_new(inode);\n\tif (!first) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno, &e_cpos,\n\t\t\t\t  &num_clusters, el);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(first, p_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnum_buckets = ocfs2_xattr_buckets_per_cluster(osb) * num_clusters;\n\tif (num_buckets == le16_to_cpu(bucket_xh(first)->xh_num_buckets)) {\n\t\t/*\n\t\t * This can move first+target if the target bucket moves\n\t\t * to the new extent.\n\t\t */\n\t\tret = ocfs2_add_new_xattr_cluster(inode,\n\t\t\t\t\t\t  xb_bh,\n\t\t\t\t\t\t  first,\n\t\t\t\t\t\t  target,\n\t\t\t\t\t\t  &num_clusters,\n\t\t\t\t\t\t  e_cpos,\n\t\t\t\t\t\t  &extend,\n\t\t\t\t\t\t  ctxt);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (extend) {\n\t\tret = ocfs2_extend_xattr_bucket(inode,\n\t\t\t\t\t\tctxt->handle,\n\t\t\t\t\t\tfirst,\n\t\t\t\t\t\tbucket_blkno(target),\n\t\t\t\t\t\tnum_clusters);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tocfs2_xattr_bucket_free(first);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_free",
          "args": [
            "first"
          ],
          "line": 5332
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "356-363",
          "snippet": "static void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_xattr_bucket",
          "args": [
            "inode",
            "ctxt->handle",
            "first",
            "bucket_blkno(target)",
            "num_clusters"
          ],
          "line": 5322
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5183-5244",
          "snippet": "static int ocfs2_extend_xattr_bucket(struct inode *inode,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct ocfs2_xattr_bucket *first,\n\t\t\t\t     u64 target_blk,\n\t\t\t\t     u32 num_clusters)\n{\n\tint ret, credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tu64 end_blk;\n\tu16 new_bucket = le16_to_cpu(bucket_xh(first)->xh_num_buckets);\n\n\ttrace_ocfs2_extend_xattr_bucket((unsigned long long)target_blk,\n\t\t\t\t\t(unsigned long long)bucket_blkno(first),\n\t\t\t\t\tnum_clusters, new_bucket);\n\n\t/* The extent must have room for an additional bucket */\n\tBUG_ON(new_bucket >=\n\t       (num_clusters * ocfs2_xattr_buckets_per_cluster(osb)));\n\n\t/* end_blk points to the last existing bucket */\n\tend_blk = bucket_blkno(first) + ((new_bucket - 1) * blk_per_bucket);\n\n\t/*\n\t * end_blk is the start of the last existing bucket.\n\t * Thus, (end_blk - target_blk) covers the target bucket and\n\t * every bucket after it up to, but not including, the last\n\t * existing bucket.  Then we add the last existing bucket, the\n\t * new bucket, and the first bucket (3 * blk_per_bucket).\n\t */\n\tcredits = (end_blk - target_blk) + (3 * blk_per_bucket);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (end_blk != target_blk) {\n\t\tret = ocfs2_cp_xattr_bucket(inode, handle, end_blk,\n\t\t\t\t\t    end_blk + blk_per_bucket, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tend_blk -= blk_per_bucket;\n\t}\n\n\t/* Move half of the xattr in target_blkno to the next bucket. */\n\tret = ocfs2_divide_xattr_bucket(inode, handle, target_blk,\n\t\t\t\t\ttarget_blk + blk_per_bucket, NULL, 0);\n\n\tle16_add_cpu(&bucket_xh(first)->xh_num_buckets, 1);\n\tocfs2_xattr_bucket_journal_dirty(handle, first);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_extend_xattr_bucket(struct inode *inode,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct ocfs2_xattr_bucket *first,\n\t\t\t\t     u64 target_blk,\n\t\t\t\t     u32 num_clusters)\n{\n\tint ret, credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tu64 end_blk;\n\tu16 new_bucket = le16_to_cpu(bucket_xh(first)->xh_num_buckets);\n\n\ttrace_ocfs2_extend_xattr_bucket((unsigned long long)target_blk,\n\t\t\t\t\t(unsigned long long)bucket_blkno(first),\n\t\t\t\t\tnum_clusters, new_bucket);\n\n\t/* The extent must have room for an additional bucket */\n\tBUG_ON(new_bucket >=\n\t       (num_clusters * ocfs2_xattr_buckets_per_cluster(osb)));\n\n\t/* end_blk points to the last existing bucket */\n\tend_blk = bucket_blkno(first) + ((new_bucket - 1) * blk_per_bucket);\n\n\t/*\n\t * end_blk is the start of the last existing bucket.\n\t * Thus, (end_blk - target_blk) covers the target bucket and\n\t * every bucket after it up to, but not including, the last\n\t * existing bucket.  Then we add the last existing bucket, the\n\t * new bucket, and the first bucket (3 * blk_per_bucket).\n\t */\n\tcredits = (end_blk - target_blk) + (3 * blk_per_bucket);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (end_blk != target_blk) {\n\t\tret = ocfs2_cp_xattr_bucket(inode, handle, end_blk,\n\t\t\t\t\t    end_blk + blk_per_bucket, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tend_blk -= blk_per_bucket;\n\t}\n\n\t/* Move half of the xattr in target_blkno to the next bucket. */\n\tret = ocfs2_divide_xattr_bucket(inode, handle, target_blk,\n\t\t\t\t\ttarget_blk + blk_per_bucket, NULL, 0);\n\n\tle16_add_cpu(&bucket_xh(first)->xh_num_buckets, 1);\n\tocfs2_xattr_bucket_journal_dirty(handle, first);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "target"
          ],
          "line": 5325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_new_xattr_cluster",
          "args": [
            "inode",
            "xb_bh",
            "first",
            "target",
            "&num_clusters",
            "e_cpos",
            "&extend",
            "ctxt"
          ],
          "line": 5307
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_new_xattr_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5085-5172",
          "snippet": "static int ocfs2_add_new_xattr_cluster(struct inode *inode,\n\t\t\t\t       struct buffer_head *root_bh,\n\t\t\t\t       struct ocfs2_xattr_bucket *first,\n\t\t\t\t       struct ocfs2_xattr_bucket *target,\n\t\t\t\t       u32 *num_clusters,\n\t\t\t\t       u32 prev_cpos,\n\t\t\t\t       int *extend,\n\t\t\t\t       struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu16 bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 prev_clusters = *num_clusters;\n\tu32 clusters_to_add = 1, bit_off, num_bits, v_start = 0;\n\tu64 block;\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\n\ttrace_ocfs2_add_new_xattr_cluster_begin(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)bucket_blkno(first),\n\t\tprev_cpos, prev_clusters);\n\n\tocfs2_init_xattr_tree_extent_tree(&et, INODE_CACHE(inode), root_bh);\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, ctxt->data_ac, 1,\n\t\t\t\t     clusters_to_add, &bit_off, &num_bits);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_new_xattr_cluster((unsigned long long)block, num_bits);\n\n\tif (bucket_blkno(first) + (prev_clusters * bpc) == block &&\n\t    (prev_clusters + num_bits) << osb->s_clustersize_bits <=\n\t     OCFS2_MAX_XATTR_TREE_LEAF_SIZE) {\n\t\t/*\n\t\t * If this cluster is contiguous with the old one and\n\t\t * adding this new cluster, we don't surpass the limit of\n\t\t * OCFS2_MAX_XATTR_TREE_LEAF_SIZE, cool. We will let it be\n\t\t * initialized and used like other buckets in the previous\n\t\t * cluster.\n\t\t * So add it as a contiguous one. The caller will handle\n\t\t * its init process.\n\t\t */\n\t\tv_start = prev_cpos + prev_clusters;\n\t\t*num_clusters = prev_clusters + num_bits;\n\t} else {\n\t\tret = ocfs2_adjust_xattr_cross_cluster(inode,\n\t\t\t\t\t\t       handle,\n\t\t\t\t\t\t       first,\n\t\t\t\t\t\t       target,\n\t\t\t\t\t\t       block,\n\t\t\t\t\t\t       prev_clusters,\n\t\t\t\t\t\t       &v_start,\n\t\t\t\t\t\t       extend);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\ttrace_ocfs2_add_new_xattr_cluster_insert((unsigned long long)block,\n\t\t\t\t\t\t v_start, num_bits);\n\tret = ocfs2_insert_extent(handle, &et, v_start, block,\n\t\t\t\t  num_bits, 0, ctxt->meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tocfs2_journal_dirty(handle, root_bh);\n\nleave:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_add_new_xattr_cluster(struct inode *inode,\n\t\t\t\t       struct buffer_head *root_bh,\n\t\t\t\t       struct ocfs2_xattr_bucket *first,\n\t\t\t\t       struct ocfs2_xattr_bucket *target,\n\t\t\t\t       u32 *num_clusters,\n\t\t\t\t       u32 prev_cpos,\n\t\t\t\t       int *extend,\n\t\t\t\t       struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu16 bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 prev_clusters = *num_clusters;\n\tu32 clusters_to_add = 1, bit_off, num_bits, v_start = 0;\n\tu64 block;\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\n\ttrace_ocfs2_add_new_xattr_cluster_begin(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)bucket_blkno(first),\n\t\tprev_cpos, prev_clusters);\n\n\tocfs2_init_xattr_tree_extent_tree(&et, INODE_CACHE(inode), root_bh);\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, ctxt->data_ac, 1,\n\t\t\t\t     clusters_to_add, &bit_off, &num_bits);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_new_xattr_cluster((unsigned long long)block, num_bits);\n\n\tif (bucket_blkno(first) + (prev_clusters * bpc) == block &&\n\t    (prev_clusters + num_bits) << osb->s_clustersize_bits <=\n\t     OCFS2_MAX_XATTR_TREE_LEAF_SIZE) {\n\t\t/*\n\t\t * If this cluster is contiguous with the old one and\n\t\t * adding this new cluster, we don't surpass the limit of\n\t\t * OCFS2_MAX_XATTR_TREE_LEAF_SIZE, cool. We will let it be\n\t\t * initialized and used like other buckets in the previous\n\t\t * cluster.\n\t\t * So add it as a contiguous one. The caller will handle\n\t\t * its init process.\n\t\t */\n\t\tv_start = prev_cpos + prev_clusters;\n\t\t*num_clusters = prev_clusters + num_bits;\n\t} else {\n\t\tret = ocfs2_adjust_xattr_cross_cluster(inode,\n\t\t\t\t\t\t       handle,\n\t\t\t\t\t\t       first,\n\t\t\t\t\t\t       target,\n\t\t\t\t\t\t       block,\n\t\t\t\t\t\t       prev_clusters,\n\t\t\t\t\t\t       &v_start,\n\t\t\t\t\t\t       extend);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\ttrace_ocfs2_add_new_xattr_cluster_insert((unsigned long long)block,\n\t\t\t\t\t\t v_start, num_bits);\n\tret = ocfs2_insert_extent(handle, &et, v_start, block,\n\t\t\t\t  num_bits, 0, ctxt->meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tocfs2_journal_dirty(handle, root_bh);\n\nleave:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bucket_xh(first)->xh_num_buckets"
          ],
          "line": 5302
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "first"
          ],
          "line": 5302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_buckets_per_cluster",
          "args": [
            "osb"
          ],
          "line": 5301
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_buckets_per_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "316-319",
          "snippet": "static inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_bucket",
          "args": [
            "first",
            "p_blkno"
          ],
          "line": 5295
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "404-426",
          "snippet": "static int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_rec",
          "args": [
            "inode",
            "name_hash",
            "&p_blkno",
            "&e_cpos",
            "&num_clusters",
            "el"
          ],
          "line": 5288
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3668-3727",
          "snippet": "static int ocfs2_xattr_get_rec(struct inode *inode,\n\t\t\t       u32 name_hash,\n\t\t\t       u64 *p_blkno,\n\t\t\t       u32 *e_cpos,\n\t\t\t       u32 *num_clusters,\n\t\t\t       struct ocfs2_extent_list *el)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tu64 e_blkno = 0;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, name_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= name_hash) {\n\t\t\te_blkno = le64_to_cpu(rec->e_blkno);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*p_blkno = le64_to_cpu(rec->e_blkno);\n\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tif (e_cpos)\n\t\t*e_cpos = le32_to_cpu(rec->e_cpos);\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_get_rec(struct inode *inode,\n\t\t\t       u32 name_hash,\n\t\t\t       u64 *p_blkno,\n\t\t\t       u32 *e_cpos,\n\t\t\t       u32 *num_clusters,\n\t\t\t       struct ocfs2_extent_list *el)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tu64 e_blkno = 0;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, name_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= name_hash) {\n\t\t\te_blkno = le64_to_cpu(rec->e_blkno);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*p_blkno = le64_to_cpu(rec->e_blkno);\n\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tif (e_cpos)\n\t\t*e_cpos = le32_to_cpu(rec->e_cpos);\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_new",
          "args": [
            "inode"
          ],
          "line": 5281
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "330-344",
          "snippet": "static struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_add_new_xattr_bucket",
          "args": [
            "(unsigned long long)bucket_blkno(target)"
          ],
          "line": 5277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "target"
          ],
          "line": 5278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bucket_xh(target)->xh_entries[0].xe_name_hash"
          ],
          "line": 5269
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "target"
          ],
          "line": 5269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_add_new_xattr_bucket(struct inode *inode,\n\t\t\t\t      struct buffer_head *xb_bh,\n\t\t\t\t      struct ocfs2_xattr_bucket *target,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xb_root = &xb->xb_attrs.xb_root;\n\tstruct ocfs2_extent_list *el = &xb_root->xt_list;\n\tu32 name_hash =\n\t\tle32_to_cpu(bucket_xh(target)->xh_entries[0].xe_name_hash);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint ret, num_buckets, extend = 1;\n\tu64 p_blkno;\n\tu32 e_cpos, num_clusters;\n\t/* The bucket at the front of the extent */\n\tstruct ocfs2_xattr_bucket *first;\n\n\ttrace_ocfs2_add_new_xattr_bucket(\n\t\t\t\t(unsigned long long)bucket_blkno(target));\n\n\t/* The first bucket of the original extent */\n\tfirst = ocfs2_xattr_bucket_new(inode);\n\tif (!first) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno, &e_cpos,\n\t\t\t\t  &num_clusters, el);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(first, p_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnum_buckets = ocfs2_xattr_buckets_per_cluster(osb) * num_clusters;\n\tif (num_buckets == le16_to_cpu(bucket_xh(first)->xh_num_buckets)) {\n\t\t/*\n\t\t * This can move first+target if the target bucket moves\n\t\t * to the new extent.\n\t\t */\n\t\tret = ocfs2_add_new_xattr_cluster(inode,\n\t\t\t\t\t\t  xb_bh,\n\t\t\t\t\t\t  first,\n\t\t\t\t\t\t  target,\n\t\t\t\t\t\t  &num_clusters,\n\t\t\t\t\t\t  e_cpos,\n\t\t\t\t\t\t  &extend,\n\t\t\t\t\t\t  ctxt);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (extend) {\n\t\tret = ocfs2_extend_xattr_bucket(inode,\n\t\t\t\t\t\tctxt->handle,\n\t\t\t\t\t\tfirst,\n\t\t\t\t\t\tbucket_blkno(target),\n\t\t\t\t\t\tnum_clusters);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tocfs2_xattr_bucket_free(first);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_extend_xattr_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5183-5244",
    "snippet": "static int ocfs2_extend_xattr_bucket(struct inode *inode,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct ocfs2_xattr_bucket *first,\n\t\t\t\t     u64 target_blk,\n\t\t\t\t     u32 num_clusters)\n{\n\tint ret, credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tu64 end_blk;\n\tu16 new_bucket = le16_to_cpu(bucket_xh(first)->xh_num_buckets);\n\n\ttrace_ocfs2_extend_xattr_bucket((unsigned long long)target_blk,\n\t\t\t\t\t(unsigned long long)bucket_blkno(first),\n\t\t\t\t\tnum_clusters, new_bucket);\n\n\t/* The extent must have room for an additional bucket */\n\tBUG_ON(new_bucket >=\n\t       (num_clusters * ocfs2_xattr_buckets_per_cluster(osb)));\n\n\t/* end_blk points to the last existing bucket */\n\tend_blk = bucket_blkno(first) + ((new_bucket - 1) * blk_per_bucket);\n\n\t/*\n\t * end_blk is the start of the last existing bucket.\n\t * Thus, (end_blk - target_blk) covers the target bucket and\n\t * every bucket after it up to, but not including, the last\n\t * existing bucket.  Then we add the last existing bucket, the\n\t * new bucket, and the first bucket (3 * blk_per_bucket).\n\t */\n\tcredits = (end_blk - target_blk) + (3 * blk_per_bucket);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (end_blk != target_blk) {\n\t\tret = ocfs2_cp_xattr_bucket(inode, handle, end_blk,\n\t\t\t\t\t    end_blk + blk_per_bucket, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tend_blk -= blk_per_bucket;\n\t}\n\n\t/* Move half of the xattr in target_blkno to the next bucket. */\n\tret = ocfs2_divide_xattr_bucket(inode, handle, target_blk,\n\t\t\t\t\ttarget_blk + blk_per_bucket, NULL, 0);\n\n\tle16_add_cpu(&bucket_xh(first)->xh_num_buckets, 1);\n\tocfs2_xattr_bucket_journal_dirty(handle, first);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_dirty",
          "args": [
            "handle",
            "first"
          ],
          "line": 5240
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "447-460",
          "snippet": "static void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&bucket_xh(first)->xh_num_buckets",
            "1"
          ],
          "line": 5239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "first"
          ],
          "line": 5239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_divide_xattr_bucket",
          "args": [
            "inode",
            "handle",
            "target_blk",
            "target_blk + blk_per_bucket",
            "NULL",
            "0"
          ],
          "line": 5236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_divide_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4615-4784",
          "snippet": "static int ocfs2_divide_xattr_bucket(struct inode *inode,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    u64 blk,\n\t\t\t\t    u64 new_blk,\n\t\t\t\t    u32 *first_hash,\n\t\t\t\t    int new_bucket_head)\n{\n\tint ret, i;\n\tint count, start, len, name_value_len = 0, name_offset = 0;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\tstruct ocfs2_xattr_header *xh;\n\tstruct ocfs2_xattr_entry *xe;\n\tint blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ocfs2_divide_xattr_bucket_begin((unsigned long long)blk,\n\t\t\t\t\t      (unsigned long long)new_blk);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, s_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Even if !new_bucket_head, we're overwriting t_bucket.  Thus,\n\t * there's no need to read it.\n\t */\n\tret = ocfs2_init_xattr_bucket(t_bucket, new_blk, new_bucket_head);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Hey, if we're overwriting t_bucket, what difference does\n\t * ACCESS_CREATE vs ACCESS_WRITE make?  See the comment in the\n\t * same part of ocfs2_cp_xattr_bucket().\n\t */\n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tnew_bucket_head ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = bucket_xh(s_bucket);\n\tcount = le16_to_cpu(xh->xh_count);\n\tstart = ocfs2_xattr_find_divide_pos(xh);\n\n\tif (start == count) {\n\t\txe = &xh->xh_entries[start-1];\n\n\t\t/*\n\t\t * initialized a new empty bucket here.\n\t\t * The hash value is set as one larger than\n\t\t * that of the last entry in the previous bucket.\n\t\t */\n\t\tfor (i = 0; i < t_bucket->bu_blocks; i++)\n\t\t\tmemset(bucket_block(t_bucket, i), 0, blocksize);\n\n\t\txh = bucket_xh(t_bucket);\n\t\txh->xh_free_start = cpu_to_le16(blocksize);\n\t\txh->xh_entries[0].xe_name_hash = xe->xe_name_hash;\n\t\tle32_add_cpu(&xh->xh_entries[0].xe_name_hash, 1);\n\n\t\tgoto set_num_buckets;\n\t}\n\n\t/* copy the whole bucket to the new first. */\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\n\t/* update the new bucket. */\n\txh = bucket_xh(t_bucket);\n\n\t/*\n\t * Calculate the total name/value len and xh_free_start for\n\t * the old bucket first.\n\t */\n\tname_offset = OCFS2_XATTR_BUCKET_SIZE;\n\tname_value_len = 0;\n\tfor (i = 0; i < start; i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tname_value_len += namevalue_size_xe(xe);\n\t\tif (le16_to_cpu(xe->xe_name_offset) < name_offset)\n\t\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t}\n\n\t/*\n\t * Now begin the modification to the new bucket.\n\t *\n\t * In the new bucket, We just move the xattr entry to the beginning\n\t * and don't touch the name/value. So there will be some holes in the\n\t * bucket, and they will be removed when ocfs2_defrag_xattr_bucket is\n\t * called.\n\t */\n\txe = &xh->xh_entries[start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * (count - start);\n\ttrace_ocfs2_divide_xattr_bucket_move(len,\n\t\t\t(int)((char *)xe - (char *)xh),\n\t\t\t(int)((char *)xh->xh_entries - (char *)xh));\n\tmemmove((char *)xh->xh_entries, (char *)xe, len);\n\txe = &xh->xh_entries[count - start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * start;\n\tmemset((char *)xe, 0, len);\n\n\tle16_add_cpu(&xh->xh_count, -start);\n\tle16_add_cpu(&xh->xh_name_value_len, -name_value_len);\n\n\t/* Calculate xh_free_start for the new bucket. */\n\txh->xh_free_start = cpu_to_le16(OCFS2_XATTR_BUCKET_SIZE);\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (le16_to_cpu(xe->xe_name_offset) <\n\t\t    le16_to_cpu(xh->xh_free_start))\n\t\t\txh->xh_free_start = xe->xe_name_offset;\n\t}\n\nset_num_buckets:\n\t/* set xh->xh_num_buckets for the new xh. */\n\tif (new_bucket_head)\n\t\txh->xh_num_buckets = cpu_to_le16(1);\n\telse\n\t\txh->xh_num_buckets = 0;\n\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\n\t/* store the first_hash of the new bucket. */\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(xh->xh_entries[0].xe_name_hash);\n\n\t/*\n\t * Now only update the 1st block of the old bucket.  If we\n\t * just added a new empty bucket, there is no need to modify\n\t * it.\n\t */\n\tif (start == count)\n\t\tgoto out;\n\n\txh = bucket_xh(s_bucket);\n\tmemset(&xh->xh_entries[start], 0,\n\t       sizeof(struct ocfs2_xattr_entry) * (count - start));\n\txh->xh_count = cpu_to_le16(start);\n\txh->xh_free_start = cpu_to_le16(name_offset);\n\txh->xh_name_value_len = cpu_to_le16(name_value_len);\n\n\tocfs2_xattr_bucket_journal_dirty(handle, s_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(s_bucket);\n\tocfs2_xattr_bucket_free(t_bucket);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\n\nstatic int ocfs2_divide_xattr_bucket(struct inode *inode,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    u64 blk,\n\t\t\t\t    u64 new_blk,\n\t\t\t\t    u32 *first_hash,\n\t\t\t\t    int new_bucket_head)\n{\n\tint ret, i;\n\tint count, start, len, name_value_len = 0, name_offset = 0;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\tstruct ocfs2_xattr_header *xh;\n\tstruct ocfs2_xattr_entry *xe;\n\tint blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ocfs2_divide_xattr_bucket_begin((unsigned long long)blk,\n\t\t\t\t\t      (unsigned long long)new_blk);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, s_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Even if !new_bucket_head, we're overwriting t_bucket.  Thus,\n\t * there's no need to read it.\n\t */\n\tret = ocfs2_init_xattr_bucket(t_bucket, new_blk, new_bucket_head);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Hey, if we're overwriting t_bucket, what difference does\n\t * ACCESS_CREATE vs ACCESS_WRITE make?  See the comment in the\n\t * same part of ocfs2_cp_xattr_bucket().\n\t */\n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tnew_bucket_head ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = bucket_xh(s_bucket);\n\tcount = le16_to_cpu(xh->xh_count);\n\tstart = ocfs2_xattr_find_divide_pos(xh);\n\n\tif (start == count) {\n\t\txe = &xh->xh_entries[start-1];\n\n\t\t/*\n\t\t * initialized a new empty bucket here.\n\t\t * The hash value is set as one larger than\n\t\t * that of the last entry in the previous bucket.\n\t\t */\n\t\tfor (i = 0; i < t_bucket->bu_blocks; i++)\n\t\t\tmemset(bucket_block(t_bucket, i), 0, blocksize);\n\n\t\txh = bucket_xh(t_bucket);\n\t\txh->xh_free_start = cpu_to_le16(blocksize);\n\t\txh->xh_entries[0].xe_name_hash = xe->xe_name_hash;\n\t\tle32_add_cpu(&xh->xh_entries[0].xe_name_hash, 1);\n\n\t\tgoto set_num_buckets;\n\t}\n\n\t/* copy the whole bucket to the new first. */\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\n\t/* update the new bucket. */\n\txh = bucket_xh(t_bucket);\n\n\t/*\n\t * Calculate the total name/value len and xh_free_start for\n\t * the old bucket first.\n\t */\n\tname_offset = OCFS2_XATTR_BUCKET_SIZE;\n\tname_value_len = 0;\n\tfor (i = 0; i < start; i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tname_value_len += namevalue_size_xe(xe);\n\t\tif (le16_to_cpu(xe->xe_name_offset) < name_offset)\n\t\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t}\n\n\t/*\n\t * Now begin the modification to the new bucket.\n\t *\n\t * In the new bucket, We just move the xattr entry to the beginning\n\t * and don't touch the name/value. So there will be some holes in the\n\t * bucket, and they will be removed when ocfs2_defrag_xattr_bucket is\n\t * called.\n\t */\n\txe = &xh->xh_entries[start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * (count - start);\n\ttrace_ocfs2_divide_xattr_bucket_move(len,\n\t\t\t(int)((char *)xe - (char *)xh),\n\t\t\t(int)((char *)xh->xh_entries - (char *)xh));\n\tmemmove((char *)xh->xh_entries, (char *)xe, len);\n\txe = &xh->xh_entries[count - start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * start;\n\tmemset((char *)xe, 0, len);\n\n\tle16_add_cpu(&xh->xh_count, -start);\n\tle16_add_cpu(&xh->xh_name_value_len, -name_value_len);\n\n\t/* Calculate xh_free_start for the new bucket. */\n\txh->xh_free_start = cpu_to_le16(OCFS2_XATTR_BUCKET_SIZE);\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (le16_to_cpu(xe->xe_name_offset) <\n\t\t    le16_to_cpu(xh->xh_free_start))\n\t\t\txh->xh_free_start = xe->xe_name_offset;\n\t}\n\nset_num_buckets:\n\t/* set xh->xh_num_buckets for the new xh. */\n\tif (new_bucket_head)\n\t\txh->xh_num_buckets = cpu_to_le16(1);\n\telse\n\t\txh->xh_num_buckets = 0;\n\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\n\t/* store the first_hash of the new bucket. */\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(xh->xh_entries[0].xe_name_hash);\n\n\t/*\n\t * Now only update the 1st block of the old bucket.  If we\n\t * just added a new empty bucket, there is no need to modify\n\t * it.\n\t */\n\tif (start == count)\n\t\tgoto out;\n\n\txh = bucket_xh(s_bucket);\n\tmemset(&xh->xh_entries[start], 0,\n\t       sizeof(struct ocfs2_xattr_entry) * (count - start));\n\txh->xh_count = cpu_to_le16(start);\n\txh->xh_free_start = cpu_to_le16(name_offset);\n\txh->xh_name_value_len = cpu_to_le16(name_value_len);\n\n\tocfs2_xattr_bucket_journal_dirty(handle, s_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(s_bucket);\n\tocfs2_xattr_bucket_free(t_bucket);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cp_xattr_bucket",
          "args": [
            "inode",
            "handle",
            "end_blk",
            "end_blk + blk_per_bucket",
            "0"
          ],
          "line": 5228
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cp_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4792-4855",
          "snippet": "static int ocfs2_cp_xattr_bucket(struct inode *inode,\n\t\t\t\t handle_t *handle,\n\t\t\t\t u64 s_blkno,\n\t\t\t\t u64 t_blkno,\n\t\t\t\t int t_is_new)\n{\n\tint ret;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\n\tBUG_ON(s_blkno == t_blkno);\n\n\ttrace_ocfs2_cp_xattr_bucket((unsigned long long)s_blkno,\n\t\t\t\t    (unsigned long long)t_blkno,\n\t\t\t\t    t_is_new);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, s_blkno);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Even if !t_is_new, we're overwriting t_bucket.  Thus,\n\t * there's no need to read it.\n\t */\n\tret = ocfs2_init_xattr_bucket(t_bucket, t_blkno, t_is_new);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Hey, if we're overwriting t_bucket, what difference does\n\t * ACCESS_CREATE vs ACCESS_WRITE make?  Well, if we allocated a new\n\t * cluster to fill, we came here from\n\t * ocfs2_mv_xattr_buckets(), and it is really new -\n\t * ACCESS_CREATE is required.  But we also might have moved data\n\t * out of t_bucket before extending back into it.\n\t * ocfs2_add_new_xattr_bucket() can do this - its call to\n\t * ocfs2_add_new_xattr_cluster() may have created a new extent\n\t * and copied out the end of the old extent.  Then it re-extends\n\t * the old extent back to create space for new xattrs.  That's\n\t * how we get here, and the bucket isn't really new.\n\t */\n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tt_is_new ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(t_bucket);\n\tocfs2_xattr_bucket_free(s_bucket);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_cp_xattr_bucket(struct inode *inode,\n\t\t\t\t handle_t *handle,\n\t\t\t\t u64 s_blkno,\n\t\t\t\t u64 t_blkno,\n\t\t\t\t int t_is_new)\n{\n\tint ret;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\n\tBUG_ON(s_blkno == t_blkno);\n\n\ttrace_ocfs2_cp_xattr_bucket((unsigned long long)s_blkno,\n\t\t\t\t    (unsigned long long)t_blkno,\n\t\t\t\t    t_is_new);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, s_blkno);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Even if !t_is_new, we're overwriting t_bucket.  Thus,\n\t * there's no need to read it.\n\t */\n\tret = ocfs2_init_xattr_bucket(t_bucket, t_blkno, t_is_new);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Hey, if we're overwriting t_bucket, what difference does\n\t * ACCESS_CREATE vs ACCESS_WRITE make?  Well, if we allocated a new\n\t * cluster to fill, we came here from\n\t * ocfs2_mv_xattr_buckets(), and it is really new -\n\t * ACCESS_CREATE is required.  But we also might have moved data\n\t * out of t_bucket before extending back into it.\n\t * ocfs2_add_new_xattr_bucket() can do this - its call to\n\t * ocfs2_add_new_xattr_cluster() may have created a new extent\n\t * and copied out the end of the old extent.  Then it re-extends\n\t * the old extent back to create space for new xattrs.  That's\n\t * how we get here, and the bucket isn't really new.\n\t */\n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tt_is_new ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(t_bucket);\n\tocfs2_xattr_bucket_free(s_bucket);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_access",
          "args": [
            "handle",
            "first",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 5220
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "428-445",
          "snippet": "static int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "credits"
          ],
          "line": 5214
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "first"
          ],
          "line": 5204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_bucket >=\n\t       (num_clusters * ocfs2_xattr_buckets_per_cluster(osb))"
          ],
          "line": 5200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_buckets_per_cluster",
          "args": [
            "osb"
          ],
          "line": 5201
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_buckets_per_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "316-319",
          "snippet": "static inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_extend_xattr_bucket",
          "args": [
            "(unsigned long long)target_blk",
            "(unsigned long long)bucket_blkno(first)",
            "num_clusters",
            "new_bucket"
          ],
          "line": 5195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "first"
          ],
          "line": 5196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bucket_xh(first)->xh_num_buckets"
          ],
          "line": 5193
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "first"
          ],
          "line": 5193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_per_xattr_bucket",
          "args": [
            "inode->i_sb"
          ],
          "line": 5191
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_per_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "321-324",
          "snippet": "static inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_extend_xattr_bucket(struct inode *inode,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct ocfs2_xattr_bucket *first,\n\t\t\t\t     u64 target_blk,\n\t\t\t\t     u32 num_clusters)\n{\n\tint ret, credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tu64 end_blk;\n\tu16 new_bucket = le16_to_cpu(bucket_xh(first)->xh_num_buckets);\n\n\ttrace_ocfs2_extend_xattr_bucket((unsigned long long)target_blk,\n\t\t\t\t\t(unsigned long long)bucket_blkno(first),\n\t\t\t\t\tnum_clusters, new_bucket);\n\n\t/* The extent must have room for an additional bucket */\n\tBUG_ON(new_bucket >=\n\t       (num_clusters * ocfs2_xattr_buckets_per_cluster(osb)));\n\n\t/* end_blk points to the last existing bucket */\n\tend_blk = bucket_blkno(first) + ((new_bucket - 1) * blk_per_bucket);\n\n\t/*\n\t * end_blk is the start of the last existing bucket.\n\t * Thus, (end_blk - target_blk) covers the target bucket and\n\t * every bucket after it up to, but not including, the last\n\t * existing bucket.  Then we add the last existing bucket, the\n\t * new bucket, and the first bucket (3 * blk_per_bucket).\n\t */\n\tcredits = (end_blk - target_blk) + (3 * blk_per_bucket);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (end_blk != target_blk) {\n\t\tret = ocfs2_cp_xattr_bucket(inode, handle, end_blk,\n\t\t\t\t\t    end_blk + blk_per_bucket, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tend_blk -= blk_per_bucket;\n\t}\n\n\t/* Move half of the xattr in target_blkno to the next bucket. */\n\tret = ocfs2_divide_xattr_bucket(inode, handle, target_blk,\n\t\t\t\t\ttarget_blk + blk_per_bucket, NULL, 0);\n\n\tle16_add_cpu(&bucket_xh(first)->xh_num_buckets, 1);\n\tocfs2_xattr_bucket_journal_dirty(handle, first);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_add_new_xattr_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5085-5172",
    "snippet": "static int ocfs2_add_new_xattr_cluster(struct inode *inode,\n\t\t\t\t       struct buffer_head *root_bh,\n\t\t\t\t       struct ocfs2_xattr_bucket *first,\n\t\t\t\t       struct ocfs2_xattr_bucket *target,\n\t\t\t\t       u32 *num_clusters,\n\t\t\t\t       u32 prev_cpos,\n\t\t\t\t       int *extend,\n\t\t\t\t       struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu16 bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 prev_clusters = *num_clusters;\n\tu32 clusters_to_add = 1, bit_off, num_bits, v_start = 0;\n\tu64 block;\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\n\ttrace_ocfs2_add_new_xattr_cluster_begin(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)bucket_blkno(first),\n\t\tprev_cpos, prev_clusters);\n\n\tocfs2_init_xattr_tree_extent_tree(&et, INODE_CACHE(inode), root_bh);\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, ctxt->data_ac, 1,\n\t\t\t\t     clusters_to_add, &bit_off, &num_bits);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_new_xattr_cluster((unsigned long long)block, num_bits);\n\n\tif (bucket_blkno(first) + (prev_clusters * bpc) == block &&\n\t    (prev_clusters + num_bits) << osb->s_clustersize_bits <=\n\t     OCFS2_MAX_XATTR_TREE_LEAF_SIZE) {\n\t\t/*\n\t\t * If this cluster is contiguous with the old one and\n\t\t * adding this new cluster, we don't surpass the limit of\n\t\t * OCFS2_MAX_XATTR_TREE_LEAF_SIZE, cool. We will let it be\n\t\t * initialized and used like other buckets in the previous\n\t\t * cluster.\n\t\t * So add it as a contiguous one. The caller will handle\n\t\t * its init process.\n\t\t */\n\t\tv_start = prev_cpos + prev_clusters;\n\t\t*num_clusters = prev_clusters + num_bits;\n\t} else {\n\t\tret = ocfs2_adjust_xattr_cross_cluster(inode,\n\t\t\t\t\t\t       handle,\n\t\t\t\t\t\t       first,\n\t\t\t\t\t\t       target,\n\t\t\t\t\t\t       block,\n\t\t\t\t\t\t       prev_clusters,\n\t\t\t\t\t\t       &v_start,\n\t\t\t\t\t\t       extend);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\ttrace_ocfs2_add_new_xattr_cluster_insert((unsigned long long)block,\n\t\t\t\t\t\t v_start, num_bits);\n\tret = ocfs2_insert_extent(handle, &et, v_start, block,\n\t\t\t\t  num_bits, 0, ctxt->meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tocfs2_journal_dirty(handle, root_bh);\n\nleave:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "root_bh"
          ],
          "line": 5168
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_extent",
          "args": [
            "handle",
            "&et",
            "v_start",
            "block",
            "num_bits",
            "0",
            "ctxt->meta_ac"
          ],
          "line": 5161
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4665-4726",
          "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_add_new_xattr_cluster_insert",
          "args": [
            "(unsigned long long)block",
            "v_start",
            "num_bits"
          ],
          "line": 5159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_xattr_cross_cluster",
          "args": [
            "inode",
            "handle",
            "first",
            "target",
            "block",
            "prev_clusters",
            "&v_start",
            "extend"
          ],
          "line": 5145
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_xattr_cross_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5017-5067",
          "snippet": "static int ocfs2_adjust_xattr_cross_cluster(struct inode *inode,\n\t\t\t\t\t    handle_t *handle,\n\t\t\t\t\t    struct ocfs2_xattr_bucket *first,\n\t\t\t\t\t    struct ocfs2_xattr_bucket *target,\n\t\t\t\t\t    u64 new_blk,\n\t\t\t\t\t    u32 prev_clusters,\n\t\t\t\t\t    u32 *v_start,\n\t\t\t\t\t    int *extend)\n{\n\tint ret;\n\n\ttrace_ocfs2_adjust_xattr_cross_cluster(\n\t\t\t(unsigned long long)bucket_blkno(first),\n\t\t\t(unsigned long long)new_blk, prev_clusters);\n\n\tif (ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb)) > 1) {\n\t\tret = ocfs2_mv_xattr_bucket_cross_cluster(inode,\n\t\t\t\t\t\t\t  handle,\n\t\t\t\t\t\t\t  first, target,\n\t\t\t\t\t\t\t  new_blk,\n\t\t\t\t\t\t\t  prev_clusters,\n\t\t\t\t\t\t\t  v_start);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\t/* The start of the last cluster in the first extent */\n\t\tu64 last_blk = bucket_blkno(first) +\n\t\t\t((prev_clusters - 1) *\n\t\t\t ocfs2_clusters_to_blocks(inode->i_sb, 1));\n\n\t\tif (prev_clusters > 1 && bucket_blkno(target) != last_blk) {\n\t\t\tret = ocfs2_mv_xattr_buckets(inode, handle,\n\t\t\t\t\t\t     bucket_blkno(first),\n\t\t\t\t\t\t     last_blk, new_blk, 0,\n\t\t\t\t\t\t     v_start);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t} else {\n\t\t\tret = ocfs2_divide_xattr_cluster(inode, handle,\n\t\t\t\t\t\t\t last_blk, new_blk,\n\t\t\t\t\t\t\t v_start);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tif ((bucket_blkno(target) == last_blk) && extend)\n\t\t\t\t*extend = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_adjust_xattr_cross_cluster(struct inode *inode,\n\t\t\t\t\t    handle_t *handle,\n\t\t\t\t\t    struct ocfs2_xattr_bucket *first,\n\t\t\t\t\t    struct ocfs2_xattr_bucket *target,\n\t\t\t\t\t    u64 new_blk,\n\t\t\t\t\t    u32 prev_clusters,\n\t\t\t\t\t    u32 *v_start,\n\t\t\t\t\t    int *extend)\n{\n\tint ret;\n\n\ttrace_ocfs2_adjust_xattr_cross_cluster(\n\t\t\t(unsigned long long)bucket_blkno(first),\n\t\t\t(unsigned long long)new_blk, prev_clusters);\n\n\tif (ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb)) > 1) {\n\t\tret = ocfs2_mv_xattr_bucket_cross_cluster(inode,\n\t\t\t\t\t\t\t  handle,\n\t\t\t\t\t\t\t  first, target,\n\t\t\t\t\t\t\t  new_blk,\n\t\t\t\t\t\t\t  prev_clusters,\n\t\t\t\t\t\t\t  v_start);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\t/* The start of the last cluster in the first extent */\n\t\tu64 last_blk = bucket_blkno(first) +\n\t\t\t((prev_clusters - 1) *\n\t\t\t ocfs2_clusters_to_blocks(inode->i_sb, 1));\n\n\t\tif (prev_clusters > 1 && bucket_blkno(target) != last_blk) {\n\t\t\tret = ocfs2_mv_xattr_buckets(inode, handle,\n\t\t\t\t\t\t     bucket_blkno(first),\n\t\t\t\t\t\t     last_blk, new_blk, 0,\n\t\t\t\t\t\t     v_start);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t} else {\n\t\t\tret = ocfs2_divide_xattr_cluster(inode, handle,\n\t\t\t\t\t\t\t last_blk, new_blk,\n\t\t\t\t\t\t\t v_start);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tif ((bucket_blkno(target) == last_blk) && extend)\n\t\t\t\t*extend = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "first"
          ],
          "line": 5130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_add_new_xattr_cluster",
          "args": [
            "(unsigned long long)block",
            "num_bits"
          ],
          "line": 5128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "bit_off"
          ],
          "line": 5127
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "num_bits > clusters_to_add"
          ],
          "line": 5125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_claim_clusters",
          "args": [
            "handle",
            "ctxt->data_ac",
            "1",
            "clusters_to_add",
            "&bit_off",
            "&num_bits"
          ],
          "line": 5117
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2302-2371",
          "snippet": "int __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_xb",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "root_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 5110
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_xb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "741-745",
          "snippet": "int ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};\n\nint ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 5110
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_tree_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "root_bh"
          ],
          "line": 5108
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_tree_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "466-472",
          "snippet": "void ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t       struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_xb,\n\t\t\t\t NULL, &ocfs2_xattr_tree_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_xattr_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_tree_fill_root_el,\n\t.eo_fill_max_leaf_clusters = ocfs2_xattr_tree_fill_max_leaf_clusters,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_xattr_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_tree_fill_root_el,\n\t.eo_fill_max_leaf_clusters = ocfs2_xattr_tree_fill_max_leaf_clusters,\n};\n\nvoid ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t       struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_xb,\n\t\t\t\t NULL, &ocfs2_xattr_tree_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_add_new_xattr_cluster_begin",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)bucket_blkno(first)",
            "prev_cpos",
            "prev_clusters"
          ],
          "line": 5103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "first"
          ],
          "line": 5105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 5104
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_add_new_xattr_cluster(struct inode *inode,\n\t\t\t\t       struct buffer_head *root_bh,\n\t\t\t\t       struct ocfs2_xattr_bucket *first,\n\t\t\t\t       struct ocfs2_xattr_bucket *target,\n\t\t\t\t       u32 *num_clusters,\n\t\t\t\t       u32 prev_cpos,\n\t\t\t\t       int *extend,\n\t\t\t\t       struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu16 bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 prev_clusters = *num_clusters;\n\tu32 clusters_to_add = 1, bit_off, num_bits, v_start = 0;\n\tu64 block;\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\n\ttrace_ocfs2_add_new_xattr_cluster_begin(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)bucket_blkno(first),\n\t\tprev_cpos, prev_clusters);\n\n\tocfs2_init_xattr_tree_extent_tree(&et, INODE_CACHE(inode), root_bh);\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, ctxt->data_ac, 1,\n\t\t\t\t     clusters_to_add, &bit_off, &num_bits);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_new_xattr_cluster((unsigned long long)block, num_bits);\n\n\tif (bucket_blkno(first) + (prev_clusters * bpc) == block &&\n\t    (prev_clusters + num_bits) << osb->s_clustersize_bits <=\n\t     OCFS2_MAX_XATTR_TREE_LEAF_SIZE) {\n\t\t/*\n\t\t * If this cluster is contiguous with the old one and\n\t\t * adding this new cluster, we don't surpass the limit of\n\t\t * OCFS2_MAX_XATTR_TREE_LEAF_SIZE, cool. We will let it be\n\t\t * initialized and used like other buckets in the previous\n\t\t * cluster.\n\t\t * So add it as a contiguous one. The caller will handle\n\t\t * its init process.\n\t\t */\n\t\tv_start = prev_cpos + prev_clusters;\n\t\t*num_clusters = prev_clusters + num_bits;\n\t} else {\n\t\tret = ocfs2_adjust_xattr_cross_cluster(inode,\n\t\t\t\t\t\t       handle,\n\t\t\t\t\t\t       first,\n\t\t\t\t\t\t       target,\n\t\t\t\t\t\t       block,\n\t\t\t\t\t\t       prev_clusters,\n\t\t\t\t\t\t       &v_start,\n\t\t\t\t\t\t       extend);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\ttrace_ocfs2_add_new_xattr_cluster_insert((unsigned long long)block,\n\t\t\t\t\t\t v_start, num_bits);\n\tret = ocfs2_insert_extent(handle, &et, v_start, block,\n\t\t\t\t  num_bits, 0, ctxt->meta_ac);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tocfs2_journal_dirty(handle, root_bh);\n\nleave:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_adjust_xattr_cross_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "5017-5067",
    "snippet": "static int ocfs2_adjust_xattr_cross_cluster(struct inode *inode,\n\t\t\t\t\t    handle_t *handle,\n\t\t\t\t\t    struct ocfs2_xattr_bucket *first,\n\t\t\t\t\t    struct ocfs2_xattr_bucket *target,\n\t\t\t\t\t    u64 new_blk,\n\t\t\t\t\t    u32 prev_clusters,\n\t\t\t\t\t    u32 *v_start,\n\t\t\t\t\t    int *extend)\n{\n\tint ret;\n\n\ttrace_ocfs2_adjust_xattr_cross_cluster(\n\t\t\t(unsigned long long)bucket_blkno(first),\n\t\t\t(unsigned long long)new_blk, prev_clusters);\n\n\tif (ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb)) > 1) {\n\t\tret = ocfs2_mv_xattr_bucket_cross_cluster(inode,\n\t\t\t\t\t\t\t  handle,\n\t\t\t\t\t\t\t  first, target,\n\t\t\t\t\t\t\t  new_blk,\n\t\t\t\t\t\t\t  prev_clusters,\n\t\t\t\t\t\t\t  v_start);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\t/* The start of the last cluster in the first extent */\n\t\tu64 last_blk = bucket_blkno(first) +\n\t\t\t((prev_clusters - 1) *\n\t\t\t ocfs2_clusters_to_blocks(inode->i_sb, 1));\n\n\t\tif (prev_clusters > 1 && bucket_blkno(target) != last_blk) {\n\t\t\tret = ocfs2_mv_xattr_buckets(inode, handle,\n\t\t\t\t\t\t     bucket_blkno(first),\n\t\t\t\t\t\t     last_blk, new_blk, 0,\n\t\t\t\t\t\t     v_start);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t} else {\n\t\t\tret = ocfs2_divide_xattr_cluster(inode, handle,\n\t\t\t\t\t\t\t last_blk, new_blk,\n\t\t\t\t\t\t\t v_start);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tif ((bucket_blkno(target) == last_blk) && extend)\n\t\t\t\t*extend = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "target"
          ],
          "line": 5061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_divide_xattr_cluster",
          "args": [
            "inode",
            "handle",
            "last_blk",
            "new_blk",
            "v_start"
          ],
          "line": 5055
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_divide_xattr_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4969-4989",
          "snippet": "static int ocfs2_divide_xattr_cluster(struct inode *inode,\n\t\t\t\t      handle_t *handle,\n\t\t\t\t      u64 prev_blk,\n\t\t\t\t      u64 new_blk,\n\t\t\t\t      u32 *first_hash)\n{\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint ret, credits = 2 * blk_per_bucket;\n\n\tBUG_ON(OCFS2_XATTR_BUCKET_SIZE < OCFS2_SB(inode->i_sb)->s_clustersize);\n\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/* Move half of the xattr in start_blk to the next bucket. */\n\treturn  ocfs2_divide_xattr_bucket(inode, handle, prev_blk,\n\t\t\t\t\t  new_blk, first_hash, 1);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_divide_xattr_cluster(struct inode *inode,\n\t\t\t\t      handle_t *handle,\n\t\t\t\t      u64 prev_blk,\n\t\t\t\t      u64 new_blk,\n\t\t\t\t      u32 *first_hash)\n{\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint ret, credits = 2 * blk_per_bucket;\n\n\tBUG_ON(OCFS2_XATTR_BUCKET_SIZE < OCFS2_SB(inode->i_sb)->s_clustersize);\n\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/* Move half of the xattr in start_blk to the next bucket. */\n\treturn  ocfs2_divide_xattr_bucket(inode, handle, prev_blk,\n\t\t\t\t\t  new_blk, first_hash, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mv_xattr_buckets",
          "args": [
            "inode",
            "handle",
            "bucket_blkno(first)",
            "last_blk",
            "new_blk",
            "0",
            "v_start"
          ],
          "line": 5048
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mv_xattr_buckets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4866-4962",
          "snippet": "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash)\n{\n\tint i, ret, credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint blks_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint num_buckets = ocfs2_xattr_buckets_per_cluster(osb);\n\tstruct ocfs2_xattr_bucket *old_first, *new_first;\n\n\ttrace_ocfs2_mv_xattr_buckets((unsigned long long)last_blk,\n\t\t\t\t     (unsigned long long)to_blk);\n\n\tBUG_ON(start_bucket >= num_buckets);\n\tif (start_bucket) {\n\t\tnum_buckets -= start_bucket;\n\t\tlast_blk += (start_bucket * blks_per_bucket);\n\t}\n\n\t/* The first bucket of the original extent */\n\told_first = ocfs2_xattr_bucket_new(inode);\n\t/* The first bucket of the new extent */\n\tnew_first = ocfs2_xattr_bucket_new(inode);\n\tif (!old_first || !new_first) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(old_first, src_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We need to update the first bucket of the old extent and all\n\t * the buckets going to the new extent.\n\t */\n\tcredits = ((num_buckets + 1) * blks_per_bucket);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, old_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_buckets; i++) {\n\t\tret = ocfs2_cp_xattr_bucket(inode, handle,\n\t\t\t\t\t    last_blk + (i * blks_per_bucket),\n\t\t\t\t\t    to_blk + (i * blks_per_bucket),\n\t\t\t\t\t    1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Get the new bucket ready before we dirty anything\n\t * (This actually shouldn't fail, because we already dirtied\n\t * it once in ocfs2_cp_xattr_bucket()).\n\t */\n\tret = ocfs2_read_xattr_bucket(new_first, to_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tret = ocfs2_xattr_bucket_journal_access(handle, new_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Now update the headers */\n\tle16_add_cpu(&bucket_xh(old_first)->xh_num_buckets, -num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, old_first);\n\n\tbucket_xh(new_first)->xh_num_buckets = cpu_to_le16(num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, new_first);\n\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(bucket_xh(new_first)->xh_entries[0].xe_name_hash);\n\nout:\n\tocfs2_xattr_bucket_free(new_first);\n\tocfs2_xattr_bucket_free(old_first);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash)\n{\n\tint i, ret, credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint blks_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint num_buckets = ocfs2_xattr_buckets_per_cluster(osb);\n\tstruct ocfs2_xattr_bucket *old_first, *new_first;\n\n\ttrace_ocfs2_mv_xattr_buckets((unsigned long long)last_blk,\n\t\t\t\t     (unsigned long long)to_blk);\n\n\tBUG_ON(start_bucket >= num_buckets);\n\tif (start_bucket) {\n\t\tnum_buckets -= start_bucket;\n\t\tlast_blk += (start_bucket * blks_per_bucket);\n\t}\n\n\t/* The first bucket of the original extent */\n\told_first = ocfs2_xattr_bucket_new(inode);\n\t/* The first bucket of the new extent */\n\tnew_first = ocfs2_xattr_bucket_new(inode);\n\tif (!old_first || !new_first) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(old_first, src_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We need to update the first bucket of the old extent and all\n\t * the buckets going to the new extent.\n\t */\n\tcredits = ((num_buckets + 1) * blks_per_bucket);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, old_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_buckets; i++) {\n\t\tret = ocfs2_cp_xattr_bucket(inode, handle,\n\t\t\t\t\t    last_blk + (i * blks_per_bucket),\n\t\t\t\t\t    to_blk + (i * blks_per_bucket),\n\t\t\t\t\t    1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Get the new bucket ready before we dirty anything\n\t * (This actually shouldn't fail, because we already dirtied\n\t * it once in ocfs2_cp_xattr_bucket()).\n\t */\n\tret = ocfs2_read_xattr_bucket(new_first, to_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tret = ocfs2_xattr_bucket_journal_access(handle, new_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Now update the headers */\n\tle16_add_cpu(&bucket_xh(old_first)->xh_num_buckets, -num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, old_first);\n\n\tbucket_xh(new_first)->xh_num_buckets = cpu_to_le16(num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, new_first);\n\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(bucket_xh(new_first)->xh_entries[0].xe_name_hash);\n\nout:\n\tocfs2_xattr_bucket_free(new_first);\n\tocfs2_xattr_bucket_free(old_first);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "first"
          ],
          "line": 5049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "target"
          ],
          "line": 5047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "1"
          ],
          "line": 5045
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "first"
          ],
          "line": 5043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mv_xattr_bucket_cross_cluster",
          "args": [
            "inode",
            "handle",
            "first",
            "target",
            "new_blk",
            "prev_clusters",
            "v_start"
          ],
          "line": 5033
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mv_xattr_bucket_cross_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4497-4561",
          "snippet": "static int ocfs2_mv_xattr_bucket_cross_cluster(struct inode *inode,\n\t\t\t\t\t       handle_t *handle,\n\t\t\t\t\t       struct ocfs2_xattr_bucket *first,\n\t\t\t\t\t       struct ocfs2_xattr_bucket *target,\n\t\t\t\t\t       u64 new_blkno,\n\t\t\t\t\t       u32 num_clusters,\n\t\t\t\t\t       u32 *first_hash)\n{\n\tint ret;\n\tstruct super_block *sb = inode->i_sb;\n\tint blks_per_bucket = ocfs2_blocks_per_xattr_bucket(sb);\n\tint num_buckets = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(sb));\n\tint to_move = num_buckets / 2;\n\tu64 src_blkno;\n\tu64 last_cluster_blkno = bucket_blkno(first) +\n\t\t((num_clusters - 1) * ocfs2_clusters_to_blocks(sb, 1));\n\n\tBUG_ON(le16_to_cpu(bucket_xh(first)->xh_num_buckets) < num_buckets);\n\tBUG_ON(OCFS2_XATTR_BUCKET_SIZE == OCFS2_SB(sb)->s_clustersize);\n\n\ttrace_ocfs2_mv_xattr_bucket_cross_cluster(\n\t\t\t\t(unsigned long long)last_cluster_blkno,\n\t\t\t\t(unsigned long long)new_blkno);\n\n\tret = ocfs2_mv_xattr_buckets(inode, handle, bucket_blkno(first),\n\t\t\t\t     last_cluster_blkno, new_blkno,\n\t\t\t\t     to_move, first_hash);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This is the first bucket that got moved */\n\tsrc_blkno = last_cluster_blkno + (to_move * blks_per_bucket);\n\n\t/*\n\t * If the target bucket was part of the moved buckets, we need to\n\t * update first and target.\n\t */\n\tif (bucket_blkno(target) >= src_blkno) {\n\t\t/* Find the block for the new target bucket */\n\t\tsrc_blkno = new_blkno +\n\t\t\t(bucket_blkno(target) - src_blkno);\n\n\t\tocfs2_xattr_bucket_relse(first);\n\t\tocfs2_xattr_bucket_relse(target);\n\n\t\t/*\n\t\t * These shouldn't fail - the buffers are in the\n\t\t * journal from ocfs2_cp_xattr_bucket().\n\t\t */\n\t\tret = ocfs2_read_xattr_bucket(first, new_blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = ocfs2_read_xattr_bucket(target, src_blkno);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\n\nstatic int ocfs2_mv_xattr_bucket_cross_cluster(struct inode *inode,\n\t\t\t\t\t       handle_t *handle,\n\t\t\t\t\t       struct ocfs2_xattr_bucket *first,\n\t\t\t\t\t       struct ocfs2_xattr_bucket *target,\n\t\t\t\t\t       u64 new_blkno,\n\t\t\t\t\t       u32 num_clusters,\n\t\t\t\t\t       u32 *first_hash)\n{\n\tint ret;\n\tstruct super_block *sb = inode->i_sb;\n\tint blks_per_bucket = ocfs2_blocks_per_xattr_bucket(sb);\n\tint num_buckets = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(sb));\n\tint to_move = num_buckets / 2;\n\tu64 src_blkno;\n\tu64 last_cluster_blkno = bucket_blkno(first) +\n\t\t((num_clusters - 1) * ocfs2_clusters_to_blocks(sb, 1));\n\n\tBUG_ON(le16_to_cpu(bucket_xh(first)->xh_num_buckets) < num_buckets);\n\tBUG_ON(OCFS2_XATTR_BUCKET_SIZE == OCFS2_SB(sb)->s_clustersize);\n\n\ttrace_ocfs2_mv_xattr_bucket_cross_cluster(\n\t\t\t\t(unsigned long long)last_cluster_blkno,\n\t\t\t\t(unsigned long long)new_blkno);\n\n\tret = ocfs2_mv_xattr_buckets(inode, handle, bucket_blkno(first),\n\t\t\t\t     last_cluster_blkno, new_blkno,\n\t\t\t\t     to_move, first_hash);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This is the first bucket that got moved */\n\tsrc_blkno = last_cluster_blkno + (to_move * blks_per_bucket);\n\n\t/*\n\t * If the target bucket was part of the moved buckets, we need to\n\t * update first and target.\n\t */\n\tif (bucket_blkno(target) >= src_blkno) {\n\t\t/* Find the block for the new target bucket */\n\t\tsrc_blkno = new_blkno +\n\t\t\t(bucket_blkno(target) - src_blkno);\n\n\t\tocfs2_xattr_bucket_relse(first);\n\t\tocfs2_xattr_bucket_relse(target);\n\n\t\t/*\n\t\t * These shouldn't fail - the buffers are in the\n\t\t * journal from ocfs2_cp_xattr_bucket().\n\t\t */\n\t\tret = ocfs2_read_xattr_bucket(first, new_blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = ocfs2_read_xattr_bucket(target, src_blkno);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_buckets_per_cluster",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 5032
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_buckets_per_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "316-319",
          "snippet": "static inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_adjust_xattr_cross_cluster",
          "args": [
            "(unsigned long long)bucket_blkno(first)",
            "(unsigned long long)new_blk",
            "prev_clusters"
          ],
          "line": 5028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "first"
          ],
          "line": 5029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_adjust_xattr_cross_cluster(struct inode *inode,\n\t\t\t\t\t    handle_t *handle,\n\t\t\t\t\t    struct ocfs2_xattr_bucket *first,\n\t\t\t\t\t    struct ocfs2_xattr_bucket *target,\n\t\t\t\t\t    u64 new_blk,\n\t\t\t\t\t    u32 prev_clusters,\n\t\t\t\t\t    u32 *v_start,\n\t\t\t\t\t    int *extend)\n{\n\tint ret;\n\n\ttrace_ocfs2_adjust_xattr_cross_cluster(\n\t\t\t(unsigned long long)bucket_blkno(first),\n\t\t\t(unsigned long long)new_blk, prev_clusters);\n\n\tif (ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb)) > 1) {\n\t\tret = ocfs2_mv_xattr_bucket_cross_cluster(inode,\n\t\t\t\t\t\t\t  handle,\n\t\t\t\t\t\t\t  first, target,\n\t\t\t\t\t\t\t  new_blk,\n\t\t\t\t\t\t\t  prev_clusters,\n\t\t\t\t\t\t\t  v_start);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\t/* The start of the last cluster in the first extent */\n\t\tu64 last_blk = bucket_blkno(first) +\n\t\t\t((prev_clusters - 1) *\n\t\t\t ocfs2_clusters_to_blocks(inode->i_sb, 1));\n\n\t\tif (prev_clusters > 1 && bucket_blkno(target) != last_blk) {\n\t\t\tret = ocfs2_mv_xattr_buckets(inode, handle,\n\t\t\t\t\t\t     bucket_blkno(first),\n\t\t\t\t\t\t     last_blk, new_blk, 0,\n\t\t\t\t\t\t     v_start);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t} else {\n\t\t\tret = ocfs2_divide_xattr_cluster(inode, handle,\n\t\t\t\t\t\t\t last_blk, new_blk,\n\t\t\t\t\t\t\t v_start);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tif ((bucket_blkno(target) == last_blk) && extend)\n\t\t\t\t*extend = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_divide_xattr_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4969-4989",
    "snippet": "static int ocfs2_divide_xattr_cluster(struct inode *inode,\n\t\t\t\t      handle_t *handle,\n\t\t\t\t      u64 prev_blk,\n\t\t\t\t      u64 new_blk,\n\t\t\t\t      u32 *first_hash)\n{\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint ret, credits = 2 * blk_per_bucket;\n\n\tBUG_ON(OCFS2_XATTR_BUCKET_SIZE < OCFS2_SB(inode->i_sb)->s_clustersize);\n\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/* Move half of the xattr in start_blk to the next bucket. */\n\treturn  ocfs2_divide_xattr_bucket(inode, handle, prev_blk,\n\t\t\t\t\t  new_blk, first_hash, 1);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_divide_xattr_bucket",
          "args": [
            "inode",
            "handle",
            "prev_blk",
            "new_blk",
            "first_hash",
            "1"
          ],
          "line": 4987
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_divide_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4615-4784",
          "snippet": "static int ocfs2_divide_xattr_bucket(struct inode *inode,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    u64 blk,\n\t\t\t\t    u64 new_blk,\n\t\t\t\t    u32 *first_hash,\n\t\t\t\t    int new_bucket_head)\n{\n\tint ret, i;\n\tint count, start, len, name_value_len = 0, name_offset = 0;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\tstruct ocfs2_xattr_header *xh;\n\tstruct ocfs2_xattr_entry *xe;\n\tint blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ocfs2_divide_xattr_bucket_begin((unsigned long long)blk,\n\t\t\t\t\t      (unsigned long long)new_blk);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, s_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Even if !new_bucket_head, we're overwriting t_bucket.  Thus,\n\t * there's no need to read it.\n\t */\n\tret = ocfs2_init_xattr_bucket(t_bucket, new_blk, new_bucket_head);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Hey, if we're overwriting t_bucket, what difference does\n\t * ACCESS_CREATE vs ACCESS_WRITE make?  See the comment in the\n\t * same part of ocfs2_cp_xattr_bucket().\n\t */\n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tnew_bucket_head ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = bucket_xh(s_bucket);\n\tcount = le16_to_cpu(xh->xh_count);\n\tstart = ocfs2_xattr_find_divide_pos(xh);\n\n\tif (start == count) {\n\t\txe = &xh->xh_entries[start-1];\n\n\t\t/*\n\t\t * initialized a new empty bucket here.\n\t\t * The hash value is set as one larger than\n\t\t * that of the last entry in the previous bucket.\n\t\t */\n\t\tfor (i = 0; i < t_bucket->bu_blocks; i++)\n\t\t\tmemset(bucket_block(t_bucket, i), 0, blocksize);\n\n\t\txh = bucket_xh(t_bucket);\n\t\txh->xh_free_start = cpu_to_le16(blocksize);\n\t\txh->xh_entries[0].xe_name_hash = xe->xe_name_hash;\n\t\tle32_add_cpu(&xh->xh_entries[0].xe_name_hash, 1);\n\n\t\tgoto set_num_buckets;\n\t}\n\n\t/* copy the whole bucket to the new first. */\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\n\t/* update the new bucket. */\n\txh = bucket_xh(t_bucket);\n\n\t/*\n\t * Calculate the total name/value len and xh_free_start for\n\t * the old bucket first.\n\t */\n\tname_offset = OCFS2_XATTR_BUCKET_SIZE;\n\tname_value_len = 0;\n\tfor (i = 0; i < start; i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tname_value_len += namevalue_size_xe(xe);\n\t\tif (le16_to_cpu(xe->xe_name_offset) < name_offset)\n\t\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t}\n\n\t/*\n\t * Now begin the modification to the new bucket.\n\t *\n\t * In the new bucket, We just move the xattr entry to the beginning\n\t * and don't touch the name/value. So there will be some holes in the\n\t * bucket, and they will be removed when ocfs2_defrag_xattr_bucket is\n\t * called.\n\t */\n\txe = &xh->xh_entries[start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * (count - start);\n\ttrace_ocfs2_divide_xattr_bucket_move(len,\n\t\t\t(int)((char *)xe - (char *)xh),\n\t\t\t(int)((char *)xh->xh_entries - (char *)xh));\n\tmemmove((char *)xh->xh_entries, (char *)xe, len);\n\txe = &xh->xh_entries[count - start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * start;\n\tmemset((char *)xe, 0, len);\n\n\tle16_add_cpu(&xh->xh_count, -start);\n\tle16_add_cpu(&xh->xh_name_value_len, -name_value_len);\n\n\t/* Calculate xh_free_start for the new bucket. */\n\txh->xh_free_start = cpu_to_le16(OCFS2_XATTR_BUCKET_SIZE);\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (le16_to_cpu(xe->xe_name_offset) <\n\t\t    le16_to_cpu(xh->xh_free_start))\n\t\t\txh->xh_free_start = xe->xe_name_offset;\n\t}\n\nset_num_buckets:\n\t/* set xh->xh_num_buckets for the new xh. */\n\tif (new_bucket_head)\n\t\txh->xh_num_buckets = cpu_to_le16(1);\n\telse\n\t\txh->xh_num_buckets = 0;\n\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\n\t/* store the first_hash of the new bucket. */\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(xh->xh_entries[0].xe_name_hash);\n\n\t/*\n\t * Now only update the 1st block of the old bucket.  If we\n\t * just added a new empty bucket, there is no need to modify\n\t * it.\n\t */\n\tif (start == count)\n\t\tgoto out;\n\n\txh = bucket_xh(s_bucket);\n\tmemset(&xh->xh_entries[start], 0,\n\t       sizeof(struct ocfs2_xattr_entry) * (count - start));\n\txh->xh_count = cpu_to_le16(start);\n\txh->xh_free_start = cpu_to_le16(name_offset);\n\txh->xh_name_value_len = cpu_to_le16(name_value_len);\n\n\tocfs2_xattr_bucket_journal_dirty(handle, s_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(s_bucket);\n\tocfs2_xattr_bucket_free(t_bucket);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\n\nstatic int ocfs2_divide_xattr_bucket(struct inode *inode,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    u64 blk,\n\t\t\t\t    u64 new_blk,\n\t\t\t\t    u32 *first_hash,\n\t\t\t\t    int new_bucket_head)\n{\n\tint ret, i;\n\tint count, start, len, name_value_len = 0, name_offset = 0;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\tstruct ocfs2_xattr_header *xh;\n\tstruct ocfs2_xattr_entry *xe;\n\tint blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ocfs2_divide_xattr_bucket_begin((unsigned long long)blk,\n\t\t\t\t\t      (unsigned long long)new_blk);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, s_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Even if !new_bucket_head, we're overwriting t_bucket.  Thus,\n\t * there's no need to read it.\n\t */\n\tret = ocfs2_init_xattr_bucket(t_bucket, new_blk, new_bucket_head);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Hey, if we're overwriting t_bucket, what difference does\n\t * ACCESS_CREATE vs ACCESS_WRITE make?  See the comment in the\n\t * same part of ocfs2_cp_xattr_bucket().\n\t */\n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tnew_bucket_head ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = bucket_xh(s_bucket);\n\tcount = le16_to_cpu(xh->xh_count);\n\tstart = ocfs2_xattr_find_divide_pos(xh);\n\n\tif (start == count) {\n\t\txe = &xh->xh_entries[start-1];\n\n\t\t/*\n\t\t * initialized a new empty bucket here.\n\t\t * The hash value is set as one larger than\n\t\t * that of the last entry in the previous bucket.\n\t\t */\n\t\tfor (i = 0; i < t_bucket->bu_blocks; i++)\n\t\t\tmemset(bucket_block(t_bucket, i), 0, blocksize);\n\n\t\txh = bucket_xh(t_bucket);\n\t\txh->xh_free_start = cpu_to_le16(blocksize);\n\t\txh->xh_entries[0].xe_name_hash = xe->xe_name_hash;\n\t\tle32_add_cpu(&xh->xh_entries[0].xe_name_hash, 1);\n\n\t\tgoto set_num_buckets;\n\t}\n\n\t/* copy the whole bucket to the new first. */\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\n\t/* update the new bucket. */\n\txh = bucket_xh(t_bucket);\n\n\t/*\n\t * Calculate the total name/value len and xh_free_start for\n\t * the old bucket first.\n\t */\n\tname_offset = OCFS2_XATTR_BUCKET_SIZE;\n\tname_value_len = 0;\n\tfor (i = 0; i < start; i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tname_value_len += namevalue_size_xe(xe);\n\t\tif (le16_to_cpu(xe->xe_name_offset) < name_offset)\n\t\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t}\n\n\t/*\n\t * Now begin the modification to the new bucket.\n\t *\n\t * In the new bucket, We just move the xattr entry to the beginning\n\t * and don't touch the name/value. So there will be some holes in the\n\t * bucket, and they will be removed when ocfs2_defrag_xattr_bucket is\n\t * called.\n\t */\n\txe = &xh->xh_entries[start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * (count - start);\n\ttrace_ocfs2_divide_xattr_bucket_move(len,\n\t\t\t(int)((char *)xe - (char *)xh),\n\t\t\t(int)((char *)xh->xh_entries - (char *)xh));\n\tmemmove((char *)xh->xh_entries, (char *)xe, len);\n\txe = &xh->xh_entries[count - start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * start;\n\tmemset((char *)xe, 0, len);\n\n\tle16_add_cpu(&xh->xh_count, -start);\n\tle16_add_cpu(&xh->xh_name_value_len, -name_value_len);\n\n\t/* Calculate xh_free_start for the new bucket. */\n\txh->xh_free_start = cpu_to_le16(OCFS2_XATTR_BUCKET_SIZE);\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (le16_to_cpu(xe->xe_name_offset) <\n\t\t    le16_to_cpu(xh->xh_free_start))\n\t\t\txh->xh_free_start = xe->xe_name_offset;\n\t}\n\nset_num_buckets:\n\t/* set xh->xh_num_buckets for the new xh. */\n\tif (new_bucket_head)\n\t\txh->xh_num_buckets = cpu_to_le16(1);\n\telse\n\t\txh->xh_num_buckets = 0;\n\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\n\t/* store the first_hash of the new bucket. */\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(xh->xh_entries[0].xe_name_hash);\n\n\t/*\n\t * Now only update the 1st block of the old bucket.  If we\n\t * just added a new empty bucket, there is no need to modify\n\t * it.\n\t */\n\tif (start == count)\n\t\tgoto out;\n\n\txh = bucket_xh(s_bucket);\n\tmemset(&xh->xh_entries[start], 0,\n\t       sizeof(struct ocfs2_xattr_entry) * (count - start));\n\txh->xh_count = cpu_to_le16(start);\n\txh->xh_free_start = cpu_to_le16(name_offset);\n\txh->xh_name_value_len = cpu_to_le16(name_value_len);\n\n\tocfs2_xattr_bucket_journal_dirty(handle, s_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(s_bucket);\n\tocfs2_xattr_bucket_free(t_bucket);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "credits"
          ],
          "line": 4980
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "OCFS2_XATTR_BUCKET_SIZE < OCFS2_SB(inode->i_sb)->s_clustersize"
          ],
          "line": 4978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 4978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_per_xattr_bucket",
          "args": [
            "inode->i_sb"
          ],
          "line": 4975
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_per_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "321-324",
          "snippet": "static inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_divide_xattr_cluster(struct inode *inode,\n\t\t\t\t      handle_t *handle,\n\t\t\t\t      u64 prev_blk,\n\t\t\t\t      u64 new_blk,\n\t\t\t\t      u32 *first_hash)\n{\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint ret, credits = 2 * blk_per_bucket;\n\n\tBUG_ON(OCFS2_XATTR_BUCKET_SIZE < OCFS2_SB(inode->i_sb)->s_clustersize);\n\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/* Move half of the xattr in start_blk to the next bucket. */\n\treturn  ocfs2_divide_xattr_bucket(inode, handle, prev_blk,\n\t\t\t\t\t  new_blk, first_hash, 1);\n}"
  },
  {
    "function_name": "ocfs2_mv_xattr_buckets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4866-4962",
    "snippet": "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash)\n{\n\tint i, ret, credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint blks_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint num_buckets = ocfs2_xattr_buckets_per_cluster(osb);\n\tstruct ocfs2_xattr_bucket *old_first, *new_first;\n\n\ttrace_ocfs2_mv_xattr_buckets((unsigned long long)last_blk,\n\t\t\t\t     (unsigned long long)to_blk);\n\n\tBUG_ON(start_bucket >= num_buckets);\n\tif (start_bucket) {\n\t\tnum_buckets -= start_bucket;\n\t\tlast_blk += (start_bucket * blks_per_bucket);\n\t}\n\n\t/* The first bucket of the original extent */\n\told_first = ocfs2_xattr_bucket_new(inode);\n\t/* The first bucket of the new extent */\n\tnew_first = ocfs2_xattr_bucket_new(inode);\n\tif (!old_first || !new_first) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(old_first, src_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We need to update the first bucket of the old extent and all\n\t * the buckets going to the new extent.\n\t */\n\tcredits = ((num_buckets + 1) * blks_per_bucket);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, old_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_buckets; i++) {\n\t\tret = ocfs2_cp_xattr_bucket(inode, handle,\n\t\t\t\t\t    last_blk + (i * blks_per_bucket),\n\t\t\t\t\t    to_blk + (i * blks_per_bucket),\n\t\t\t\t\t    1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Get the new bucket ready before we dirty anything\n\t * (This actually shouldn't fail, because we already dirtied\n\t * it once in ocfs2_cp_xattr_bucket()).\n\t */\n\tret = ocfs2_read_xattr_bucket(new_first, to_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tret = ocfs2_xattr_bucket_journal_access(handle, new_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Now update the headers */\n\tle16_add_cpu(&bucket_xh(old_first)->xh_num_buckets, -num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, old_first);\n\n\tbucket_xh(new_first)->xh_num_buckets = cpu_to_le16(num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, new_first);\n\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(bucket_xh(new_first)->xh_entries[0].xe_name_hash);\n\nout:\n\tocfs2_xattr_bucket_free(new_first);\n\tocfs2_xattr_bucket_free(old_first);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_free",
          "args": [
            "old_first"
          ],
          "line": 4960
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "356-363",
          "snippet": "static void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bucket_xh(new_first)->xh_entries[0].xe_name_hash"
          ],
          "line": 4956
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "new_first"
          ],
          "line": 4956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_dirty",
          "args": [
            "handle",
            "new_first"
          ],
          "line": 4953
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "447-460",
          "snippet": "static void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "num_buckets"
          ],
          "line": 4952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "new_first"
          ],
          "line": 4952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&bucket_xh(old_first)->xh_num_buckets",
            "-num_buckets"
          ],
          "line": 4949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "old_first"
          ],
          "line": 4949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_access",
          "args": [
            "handle",
            "new_first",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 4941
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "428-445",
          "snippet": "static int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_bucket",
          "args": [
            "new_first",
            "to_blk"
          ],
          "line": 4936
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "404-426",
          "snippet": "static int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cp_xattr_bucket",
          "args": [
            "inode",
            "handle",
            "last_blk + (i * blks_per_bucket)",
            "to_blk + (i * blks_per_bucket)",
            "1"
          ],
          "line": 4921
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cp_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4792-4855",
          "snippet": "static int ocfs2_cp_xattr_bucket(struct inode *inode,\n\t\t\t\t handle_t *handle,\n\t\t\t\t u64 s_blkno,\n\t\t\t\t u64 t_blkno,\n\t\t\t\t int t_is_new)\n{\n\tint ret;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\n\tBUG_ON(s_blkno == t_blkno);\n\n\ttrace_ocfs2_cp_xattr_bucket((unsigned long long)s_blkno,\n\t\t\t\t    (unsigned long long)t_blkno,\n\t\t\t\t    t_is_new);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, s_blkno);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Even if !t_is_new, we're overwriting t_bucket.  Thus,\n\t * there's no need to read it.\n\t */\n\tret = ocfs2_init_xattr_bucket(t_bucket, t_blkno, t_is_new);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Hey, if we're overwriting t_bucket, what difference does\n\t * ACCESS_CREATE vs ACCESS_WRITE make?  Well, if we allocated a new\n\t * cluster to fill, we came here from\n\t * ocfs2_mv_xattr_buckets(), and it is really new -\n\t * ACCESS_CREATE is required.  But we also might have moved data\n\t * out of t_bucket before extending back into it.\n\t * ocfs2_add_new_xattr_bucket() can do this - its call to\n\t * ocfs2_add_new_xattr_cluster() may have created a new extent\n\t * and copied out the end of the old extent.  Then it re-extends\n\t * the old extent back to create space for new xattrs.  That's\n\t * how we get here, and the bucket isn't really new.\n\t */\n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tt_is_new ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(t_bucket);\n\tocfs2_xattr_bucket_free(s_bucket);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_cp_xattr_bucket(struct inode *inode,\n\t\t\t\t handle_t *handle,\n\t\t\t\t u64 s_blkno,\n\t\t\t\t u64 t_blkno,\n\t\t\t\t int t_is_new)\n{\n\tint ret;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\n\tBUG_ON(s_blkno == t_blkno);\n\n\ttrace_ocfs2_cp_xattr_bucket((unsigned long long)s_blkno,\n\t\t\t\t    (unsigned long long)t_blkno,\n\t\t\t\t    t_is_new);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, s_blkno);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Even if !t_is_new, we're overwriting t_bucket.  Thus,\n\t * there's no need to read it.\n\t */\n\tret = ocfs2_init_xattr_bucket(t_bucket, t_blkno, t_is_new);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Hey, if we're overwriting t_bucket, what difference does\n\t * ACCESS_CREATE vs ACCESS_WRITE make?  Well, if we allocated a new\n\t * cluster to fill, we came here from\n\t * ocfs2_mv_xattr_buckets(), and it is really new -\n\t * ACCESS_CREATE is required.  But we also might have moved data\n\t * out of t_bucket before extending back into it.\n\t * ocfs2_add_new_xattr_bucket() can do this - its call to\n\t * ocfs2_add_new_xattr_cluster() may have created a new extent\n\t * and copied out the end of the old extent.  Then it re-extends\n\t * the old extent back to create space for new xattrs.  That's\n\t * how we get here, and the bucket isn't really new.\n\t */\n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tt_is_new ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(t_bucket);\n\tocfs2_xattr_bucket_free(s_bucket);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "credits"
          ],
          "line": 4907
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_new",
          "args": [
            "inode"
          ],
          "line": 4889
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "330-344",
          "snippet": "static struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start_bucket >= num_buckets"
          ],
          "line": 4880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_mv_xattr_buckets",
          "args": [
            "(unsigned long long)last_blk",
            "(unsigned long long)to_blk"
          ],
          "line": 4877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_buckets_per_cluster",
          "args": [
            "osb"
          ],
          "line": 4874
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_buckets_per_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "316-319",
          "snippet": "static inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_per_xattr_bucket",
          "args": [
            "inode->i_sb"
          ],
          "line": 4873
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_per_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "321-324",
          "snippet": "static inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 4872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash)\n{\n\tint i, ret, credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint blks_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint num_buckets = ocfs2_xattr_buckets_per_cluster(osb);\n\tstruct ocfs2_xattr_bucket *old_first, *new_first;\n\n\ttrace_ocfs2_mv_xattr_buckets((unsigned long long)last_blk,\n\t\t\t\t     (unsigned long long)to_blk);\n\n\tBUG_ON(start_bucket >= num_buckets);\n\tif (start_bucket) {\n\t\tnum_buckets -= start_bucket;\n\t\tlast_blk += (start_bucket * blks_per_bucket);\n\t}\n\n\t/* The first bucket of the original extent */\n\told_first = ocfs2_xattr_bucket_new(inode);\n\t/* The first bucket of the new extent */\n\tnew_first = ocfs2_xattr_bucket_new(inode);\n\tif (!old_first || !new_first) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(old_first, src_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We need to update the first bucket of the old extent and all\n\t * the buckets going to the new extent.\n\t */\n\tcredits = ((num_buckets + 1) * blks_per_bucket);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, old_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_buckets; i++) {\n\t\tret = ocfs2_cp_xattr_bucket(inode, handle,\n\t\t\t\t\t    last_blk + (i * blks_per_bucket),\n\t\t\t\t\t    to_blk + (i * blks_per_bucket),\n\t\t\t\t\t    1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Get the new bucket ready before we dirty anything\n\t * (This actually shouldn't fail, because we already dirtied\n\t * it once in ocfs2_cp_xattr_bucket()).\n\t */\n\tret = ocfs2_read_xattr_bucket(new_first, to_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tret = ocfs2_xattr_bucket_journal_access(handle, new_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Now update the headers */\n\tle16_add_cpu(&bucket_xh(old_first)->xh_num_buckets, -num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, old_first);\n\n\tbucket_xh(new_first)->xh_num_buckets = cpu_to_le16(num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, new_first);\n\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(bucket_xh(new_first)->xh_entries[0].xe_name_hash);\n\nout:\n\tocfs2_xattr_bucket_free(new_first);\n\tocfs2_xattr_bucket_free(old_first);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_cp_xattr_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4792-4855",
    "snippet": "static int ocfs2_cp_xattr_bucket(struct inode *inode,\n\t\t\t\t handle_t *handle,\n\t\t\t\t u64 s_blkno,\n\t\t\t\t u64 t_blkno,\n\t\t\t\t int t_is_new)\n{\n\tint ret;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\n\tBUG_ON(s_blkno == t_blkno);\n\n\ttrace_ocfs2_cp_xattr_bucket((unsigned long long)s_blkno,\n\t\t\t\t    (unsigned long long)t_blkno,\n\t\t\t\t    t_is_new);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, s_blkno);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Even if !t_is_new, we're overwriting t_bucket.  Thus,\n\t * there's no need to read it.\n\t */\n\tret = ocfs2_init_xattr_bucket(t_bucket, t_blkno, t_is_new);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Hey, if we're overwriting t_bucket, what difference does\n\t * ACCESS_CREATE vs ACCESS_WRITE make?  Well, if we allocated a new\n\t * cluster to fill, we came here from\n\t * ocfs2_mv_xattr_buckets(), and it is really new -\n\t * ACCESS_CREATE is required.  But we also might have moved data\n\t * out of t_bucket before extending back into it.\n\t * ocfs2_add_new_xattr_bucket() can do this - its call to\n\t * ocfs2_add_new_xattr_cluster() may have created a new extent\n\t * and copied out the end of the old extent.  Then it re-extends\n\t * the old extent back to create space for new xattrs.  That's\n\t * how we get here, and the bucket isn't really new.\n\t */\n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tt_is_new ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(t_bucket);\n\tocfs2_xattr_bucket_free(s_bucket);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_free",
          "args": [
            "s_bucket"
          ],
          "line": 4852
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "356-363",
          "snippet": "static void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_dirty",
          "args": [
            "handle",
            "t_bucket"
          ],
          "line": 4848
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "447-460",
          "snippet": "static void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_copy_data",
          "args": [
            "t_bucket",
            "s_bucket"
          ],
          "line": 4847
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_copy_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "462-475",
          "snippet": "static void ocfs2_xattr_bucket_copy_data(struct ocfs2_xattr_bucket *dest,\n\t\t\t\t\t struct ocfs2_xattr_bucket *src)\n{\n\tint i;\n\tint blocksize = src->bu_inode->i_sb->s_blocksize;\n\n\tBUG_ON(dest->bu_blocks != src->bu_blocks);\n\tBUG_ON(dest->bu_inode != src->bu_inode);\n\n\tfor (i = 0; i < src->bu_blocks; i++) {\n\t\tmemcpy(bucket_block(dest, i), bucket_block(src, i),\n\t\t       blocksize);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_copy_data(struct ocfs2_xattr_bucket *dest,\n\t\t\t\t\t struct ocfs2_xattr_bucket *src)\n{\n\tint i;\n\tint blocksize = src->bu_inode->i_sb->s_blocksize;\n\n\tBUG_ON(dest->bu_blocks != src->bu_blocks);\n\tBUG_ON(dest->bu_inode != src->bu_inode);\n\n\tfor (i = 0; i < src->bu_blocks; i++) {\n\t\tmemcpy(bucket_block(dest, i), bucket_block(src, i),\n\t\t       blocksize);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_access",
          "args": [
            "handle",
            "t_bucket",
            "t_is_new ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 4840
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "428-445",
          "snippet": "static int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_bucket",
          "args": [
            "t_bucket",
            "t_blkno",
            "t_is_new"
          ],
          "line": 4823
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_bucket_xa_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2290-2300",
          "snippet": "static void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};\n\nstatic void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_bucket",
          "args": [
            "s_bucket",
            "s_blkno"
          ],
          "line": 4815
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "404-426",
          "snippet": "static int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_new",
          "args": [
            "inode"
          ],
          "line": 4808
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "330-344",
          "snippet": "static struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_cp_xattr_bucket",
          "args": [
            "(unsigned long long)s_blkno",
            "(unsigned long long)t_blkno",
            "t_is_new"
          ],
          "line": 4803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "s_blkno == t_blkno"
          ],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_cp_xattr_bucket(struct inode *inode,\n\t\t\t\t handle_t *handle,\n\t\t\t\t u64 s_blkno,\n\t\t\t\t u64 t_blkno,\n\t\t\t\t int t_is_new)\n{\n\tint ret;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\n\tBUG_ON(s_blkno == t_blkno);\n\n\ttrace_ocfs2_cp_xattr_bucket((unsigned long long)s_blkno,\n\t\t\t\t    (unsigned long long)t_blkno,\n\t\t\t\t    t_is_new);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, s_blkno);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Even if !t_is_new, we're overwriting t_bucket.  Thus,\n\t * there's no need to read it.\n\t */\n\tret = ocfs2_init_xattr_bucket(t_bucket, t_blkno, t_is_new);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Hey, if we're overwriting t_bucket, what difference does\n\t * ACCESS_CREATE vs ACCESS_WRITE make?  Well, if we allocated a new\n\t * cluster to fill, we came here from\n\t * ocfs2_mv_xattr_buckets(), and it is really new -\n\t * ACCESS_CREATE is required.  But we also might have moved data\n\t * out of t_bucket before extending back into it.\n\t * ocfs2_add_new_xattr_bucket() can do this - its call to\n\t * ocfs2_add_new_xattr_cluster() may have created a new extent\n\t * and copied out the end of the old extent.  Then it re-extends\n\t * the old extent back to create space for new xattrs.  That's\n\t * how we get here, and the bucket isn't really new.\n\t */\n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tt_is_new ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(t_bucket);\n\tocfs2_xattr_bucket_free(s_bucket);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_divide_xattr_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4615-4784",
    "snippet": "static int ocfs2_divide_xattr_bucket(struct inode *inode,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    u64 blk,\n\t\t\t\t    u64 new_blk,\n\t\t\t\t    u32 *first_hash,\n\t\t\t\t    int new_bucket_head)\n{\n\tint ret, i;\n\tint count, start, len, name_value_len = 0, name_offset = 0;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\tstruct ocfs2_xattr_header *xh;\n\tstruct ocfs2_xattr_entry *xe;\n\tint blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ocfs2_divide_xattr_bucket_begin((unsigned long long)blk,\n\t\t\t\t\t      (unsigned long long)new_blk);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, s_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Even if !new_bucket_head, we're overwriting t_bucket.  Thus,\n\t * there's no need to read it.\n\t */\n\tret = ocfs2_init_xattr_bucket(t_bucket, new_blk, new_bucket_head);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Hey, if we're overwriting t_bucket, what difference does\n\t * ACCESS_CREATE vs ACCESS_WRITE make?  See the comment in the\n\t * same part of ocfs2_cp_xattr_bucket().\n\t */\n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tnew_bucket_head ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = bucket_xh(s_bucket);\n\tcount = le16_to_cpu(xh->xh_count);\n\tstart = ocfs2_xattr_find_divide_pos(xh);\n\n\tif (start == count) {\n\t\txe = &xh->xh_entries[start-1];\n\n\t\t/*\n\t\t * initialized a new empty bucket here.\n\t\t * The hash value is set as one larger than\n\t\t * that of the last entry in the previous bucket.\n\t\t */\n\t\tfor (i = 0; i < t_bucket->bu_blocks; i++)\n\t\t\tmemset(bucket_block(t_bucket, i), 0, blocksize);\n\n\t\txh = bucket_xh(t_bucket);\n\t\txh->xh_free_start = cpu_to_le16(blocksize);\n\t\txh->xh_entries[0].xe_name_hash = xe->xe_name_hash;\n\t\tle32_add_cpu(&xh->xh_entries[0].xe_name_hash, 1);\n\n\t\tgoto set_num_buckets;\n\t}\n\n\t/* copy the whole bucket to the new first. */\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\n\t/* update the new bucket. */\n\txh = bucket_xh(t_bucket);\n\n\t/*\n\t * Calculate the total name/value len and xh_free_start for\n\t * the old bucket first.\n\t */\n\tname_offset = OCFS2_XATTR_BUCKET_SIZE;\n\tname_value_len = 0;\n\tfor (i = 0; i < start; i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tname_value_len += namevalue_size_xe(xe);\n\t\tif (le16_to_cpu(xe->xe_name_offset) < name_offset)\n\t\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t}\n\n\t/*\n\t * Now begin the modification to the new bucket.\n\t *\n\t * In the new bucket, We just move the xattr entry to the beginning\n\t * and don't touch the name/value. So there will be some holes in the\n\t * bucket, and they will be removed when ocfs2_defrag_xattr_bucket is\n\t * called.\n\t */\n\txe = &xh->xh_entries[start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * (count - start);\n\ttrace_ocfs2_divide_xattr_bucket_move(len,\n\t\t\t(int)((char *)xe - (char *)xh),\n\t\t\t(int)((char *)xh->xh_entries - (char *)xh));\n\tmemmove((char *)xh->xh_entries, (char *)xe, len);\n\txe = &xh->xh_entries[count - start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * start;\n\tmemset((char *)xe, 0, len);\n\n\tle16_add_cpu(&xh->xh_count, -start);\n\tle16_add_cpu(&xh->xh_name_value_len, -name_value_len);\n\n\t/* Calculate xh_free_start for the new bucket. */\n\txh->xh_free_start = cpu_to_le16(OCFS2_XATTR_BUCKET_SIZE);\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (le16_to_cpu(xe->xe_name_offset) <\n\t\t    le16_to_cpu(xh->xh_free_start))\n\t\t\txh->xh_free_start = xe->xe_name_offset;\n\t}\n\nset_num_buckets:\n\t/* set xh->xh_num_buckets for the new xh. */\n\tif (new_bucket_head)\n\t\txh->xh_num_buckets = cpu_to_le16(1);\n\telse\n\t\txh->xh_num_buckets = 0;\n\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\n\t/* store the first_hash of the new bucket. */\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(xh->xh_entries[0].xe_name_hash);\n\n\t/*\n\t * Now only update the 1st block of the old bucket.  If we\n\t * just added a new empty bucket, there is no need to modify\n\t * it.\n\t */\n\tif (start == count)\n\t\tgoto out;\n\n\txh = bucket_xh(s_bucket);\n\tmemset(&xh->xh_entries[start], 0,\n\t       sizeof(struct ocfs2_xattr_entry) * (count - start));\n\txh->xh_count = cpu_to_le16(start);\n\txh->xh_free_start = cpu_to_le16(name_offset);\n\txh->xh_name_value_len = cpu_to_le16(name_value_len);\n\n\tocfs2_xattr_bucket_journal_dirty(handle, s_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(s_bucket);\n\tocfs2_xattr_bucket_free(t_bucket);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_free",
          "args": [
            "t_bucket"
          ],
          "line": 4781
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "356-363",
          "snippet": "static void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_dirty",
          "args": [
            "handle",
            "s_bucket"
          ],
          "line": 4777
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "447-460",
          "snippet": "static void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_value_len"
          ],
          "line": 4775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_offset"
          ],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "start"
          ],
          "line": 4773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&xh->xh_entries[start]",
            "0",
            "sizeof(struct ocfs2_xattr_entry) * (count - start)"
          ],
          "line": 4771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "s_bucket"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "xh->xh_entries[0].xe_name_hash"
          ],
          "line": 4760
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 4752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_free_start"
          ],
          "line": 4745
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "OCFS2_XATTR_BUCKET_SIZE"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&xh->xh_name_value_len",
            "-name_value_len"
          ],
          "line": 4738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&xh->xh_count",
            "-start"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)xe",
            "0",
            "len"
          ],
          "line": 4735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(char *)xh->xh_entries",
            "(char *)xe",
            "len"
          ],
          "line": 4732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_divide_xattr_bucket_move",
          "args": [
            "len",
            "(int)((char *)xe - (char *)xh)",
            "(int)((char *)xh->xh_entries - (char *)xh)"
          ],
          "line": 4729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namevalue_size_xe",
          "args": [
            "xe"
          ],
          "line": 4714
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "241-248",
          "snippet": "static int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "t_bucket"
          ],
          "line": 4704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_copy_data",
          "args": [
            "t_bucket",
            "s_bucket"
          ],
          "line": 4701
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_copy_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "462-475",
          "snippet": "static void ocfs2_xattr_bucket_copy_data(struct ocfs2_xattr_bucket *dest,\n\t\t\t\t\t struct ocfs2_xattr_bucket *src)\n{\n\tint i;\n\tint blocksize = src->bu_inode->i_sb->s_blocksize;\n\n\tBUG_ON(dest->bu_blocks != src->bu_blocks);\n\tBUG_ON(dest->bu_inode != src->bu_inode);\n\n\tfor (i = 0; i < src->bu_blocks; i++) {\n\t\tmemcpy(bucket_block(dest, i), bucket_block(src, i),\n\t\t       blocksize);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_copy_data(struct ocfs2_xattr_bucket *dest,\n\t\t\t\t\t struct ocfs2_xattr_bucket *src)\n{\n\tint i;\n\tint blocksize = src->bu_inode->i_sb->s_blocksize;\n\n\tBUG_ON(dest->bu_blocks != src->bu_blocks);\n\tBUG_ON(dest->bu_inode != src->bu_inode);\n\n\tfor (i = 0; i < src->bu_blocks; i++) {\n\t\tmemcpy(bucket_block(dest, i), bucket_block(src, i),\n\t\t       blocksize);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&xh->xh_entries[0].xe_name_hash",
            "1"
          ],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "blocksize"
          ],
          "line": 4693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "t_bucket"
          ],
          "line": 4692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bucket_block(t_bucket, i)",
            "0",
            "blocksize"
          ],
          "line": 4690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "t_bucket",
            "i"
          ],
          "line": 4690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_find_divide_pos",
          "args": [
            "xh"
          ],
          "line": 4679
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_find_divide_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4573-4603",
          "snippet": "static int ocfs2_xattr_find_divide_pos(struct ocfs2_xattr_header *xh)\n{\n\tstruct ocfs2_xattr_entry *entries = xh->xh_entries;\n\tint count = le16_to_cpu(xh->xh_count);\n\tint delta, middle = count / 2;\n\n\t/*\n\t * We start at the middle.  Each step gets farther away in both\n\t * directions.  We therefore hit the change in hash value\n\t * nearest to the middle.  Note that this loop does not execute for\n\t * count < 2.\n\t */\n\tfor (delta = 0; delta < middle; delta++) {\n\t\t/* Let's check delta earlier than middle */\n\t\tif (cmp_xe(&entries[middle - delta - 1],\n\t\t\t   &entries[middle - delta]))\n\t\t\treturn middle - delta;\n\n\t\t/* For even counts, don't walk off the end */\n\t\tif ((middle + delta + 1) == count)\n\t\t\tcontinue;\n\n\t\t/* Now try delta past middle */\n\t\tif (cmp_xe(&entries[middle + delta],\n\t\t\t   &entries[middle + delta + 1]))\n\t\t\treturn middle + delta + 1;\n\t}\n\n\t/* Every entry had the same hash */\n\treturn count;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_find_divide_pos(struct ocfs2_xattr_header *xh)\n{\n\tstruct ocfs2_xattr_entry *entries = xh->xh_entries;\n\tint count = le16_to_cpu(xh->xh_count);\n\tint delta, middle = count / 2;\n\n\t/*\n\t * We start at the middle.  Each step gets farther away in both\n\t * directions.  We therefore hit the change in hash value\n\t * nearest to the middle.  Note that this loop does not execute for\n\t * count < 2.\n\t */\n\tfor (delta = 0; delta < middle; delta++) {\n\t\t/* Let's check delta earlier than middle */\n\t\tif (cmp_xe(&entries[middle - delta - 1],\n\t\t\t   &entries[middle - delta]))\n\t\t\treturn middle - delta;\n\n\t\t/* For even counts, don't walk off the end */\n\t\tif ((middle + delta + 1) == count)\n\t\t\tcontinue;\n\n\t\t/* Now try delta past middle */\n\t\tif (cmp_xe(&entries[middle + delta],\n\t\t\t   &entries[middle + delta + 1]))\n\t\t\treturn middle + delta + 1;\n\t}\n\n\t/* Every entry had the same hash */\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "s_bucket"
          ],
          "line": 4677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_access",
          "args": [
            "handle",
            "t_bucket",
            "new_bucket_head ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 4668
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "428-445",
          "snippet": "static int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_bucket",
          "args": [
            "t_bucket",
            "new_blk",
            "new_bucket_head"
          ],
          "line": 4657
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_bucket_xa_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2290-2300",
          "snippet": "static void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};\n\nstatic void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_bucket",
          "args": [
            "s_bucket",
            "blk"
          ],
          "line": 4640
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "404-426",
          "snippet": "static int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_new",
          "args": [
            "inode"
          ],
          "line": 4633
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "330-344",
          "snippet": "static struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_divide_xattr_bucket_begin",
          "args": [
            "(unsigned long long)blk",
            "(unsigned long long)new_blk"
          ],
          "line": 4629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\n\nstatic int ocfs2_divide_xattr_bucket(struct inode *inode,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    u64 blk,\n\t\t\t\t    u64 new_blk,\n\t\t\t\t    u32 *first_hash,\n\t\t\t\t    int new_bucket_head)\n{\n\tint ret, i;\n\tint count, start, len, name_value_len = 0, name_offset = 0;\n\tstruct ocfs2_xattr_bucket *s_bucket = NULL, *t_bucket = NULL;\n\tstruct ocfs2_xattr_header *xh;\n\tstruct ocfs2_xattr_entry *xe;\n\tint blocksize = inode->i_sb->s_blocksize;\n\n\ttrace_ocfs2_divide_xattr_bucket_begin((unsigned long long)blk,\n\t\t\t\t\t      (unsigned long long)new_blk);\n\n\ts_bucket = ocfs2_xattr_bucket_new(inode);\n\tt_bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!s_bucket || !t_bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(s_bucket, blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, s_bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Even if !new_bucket_head, we're overwriting t_bucket.  Thus,\n\t * there's no need to read it.\n\t */\n\tret = ocfs2_init_xattr_bucket(t_bucket, new_blk, new_bucket_head);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Hey, if we're overwriting t_bucket, what difference does\n\t * ACCESS_CREATE vs ACCESS_WRITE make?  See the comment in the\n\t * same part of ocfs2_cp_xattr_bucket().\n\t */\n\tret = ocfs2_xattr_bucket_journal_access(handle, t_bucket,\n\t\t\t\t\t\tnew_bucket_head ?\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE :\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = bucket_xh(s_bucket);\n\tcount = le16_to_cpu(xh->xh_count);\n\tstart = ocfs2_xattr_find_divide_pos(xh);\n\n\tif (start == count) {\n\t\txe = &xh->xh_entries[start-1];\n\n\t\t/*\n\t\t * initialized a new empty bucket here.\n\t\t * The hash value is set as one larger than\n\t\t * that of the last entry in the previous bucket.\n\t\t */\n\t\tfor (i = 0; i < t_bucket->bu_blocks; i++)\n\t\t\tmemset(bucket_block(t_bucket, i), 0, blocksize);\n\n\t\txh = bucket_xh(t_bucket);\n\t\txh->xh_free_start = cpu_to_le16(blocksize);\n\t\txh->xh_entries[0].xe_name_hash = xe->xe_name_hash;\n\t\tle32_add_cpu(&xh->xh_entries[0].xe_name_hash, 1);\n\n\t\tgoto set_num_buckets;\n\t}\n\n\t/* copy the whole bucket to the new first. */\n\tocfs2_xattr_bucket_copy_data(t_bucket, s_bucket);\n\n\t/* update the new bucket. */\n\txh = bucket_xh(t_bucket);\n\n\t/*\n\t * Calculate the total name/value len and xh_free_start for\n\t * the old bucket first.\n\t */\n\tname_offset = OCFS2_XATTR_BUCKET_SIZE;\n\tname_value_len = 0;\n\tfor (i = 0; i < start; i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tname_value_len += namevalue_size_xe(xe);\n\t\tif (le16_to_cpu(xe->xe_name_offset) < name_offset)\n\t\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t}\n\n\t/*\n\t * Now begin the modification to the new bucket.\n\t *\n\t * In the new bucket, We just move the xattr entry to the beginning\n\t * and don't touch the name/value. So there will be some holes in the\n\t * bucket, and they will be removed when ocfs2_defrag_xattr_bucket is\n\t * called.\n\t */\n\txe = &xh->xh_entries[start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * (count - start);\n\ttrace_ocfs2_divide_xattr_bucket_move(len,\n\t\t\t(int)((char *)xe - (char *)xh),\n\t\t\t(int)((char *)xh->xh_entries - (char *)xh));\n\tmemmove((char *)xh->xh_entries, (char *)xe, len);\n\txe = &xh->xh_entries[count - start];\n\tlen = sizeof(struct ocfs2_xattr_entry) * start;\n\tmemset((char *)xe, 0, len);\n\n\tle16_add_cpu(&xh->xh_count, -start);\n\tle16_add_cpu(&xh->xh_name_value_len, -name_value_len);\n\n\t/* Calculate xh_free_start for the new bucket. */\n\txh->xh_free_start = cpu_to_le16(OCFS2_XATTR_BUCKET_SIZE);\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\t\tif (le16_to_cpu(xe->xe_name_offset) <\n\t\t    le16_to_cpu(xh->xh_free_start))\n\t\t\txh->xh_free_start = xe->xe_name_offset;\n\t}\n\nset_num_buckets:\n\t/* set xh->xh_num_buckets for the new xh. */\n\tif (new_bucket_head)\n\t\txh->xh_num_buckets = cpu_to_le16(1);\n\telse\n\t\txh->xh_num_buckets = 0;\n\n\tocfs2_xattr_bucket_journal_dirty(handle, t_bucket);\n\n\t/* store the first_hash of the new bucket. */\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(xh->xh_entries[0].xe_name_hash);\n\n\t/*\n\t * Now only update the 1st block of the old bucket.  If we\n\t * just added a new empty bucket, there is no need to modify\n\t * it.\n\t */\n\tif (start == count)\n\t\tgoto out;\n\n\txh = bucket_xh(s_bucket);\n\tmemset(&xh->xh_entries[start], 0,\n\t       sizeof(struct ocfs2_xattr_entry) * (count - start));\n\txh->xh_count = cpu_to_le16(start);\n\txh->xh_free_start = cpu_to_le16(name_offset);\n\txh->xh_name_value_len = cpu_to_le16(name_value_len);\n\n\tocfs2_xattr_bucket_journal_dirty(handle, s_bucket);\n\nout:\n\tocfs2_xattr_bucket_free(s_bucket);\n\tocfs2_xattr_bucket_free(t_bucket);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_find_divide_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4573-4603",
    "snippet": "static int ocfs2_xattr_find_divide_pos(struct ocfs2_xattr_header *xh)\n{\n\tstruct ocfs2_xattr_entry *entries = xh->xh_entries;\n\tint count = le16_to_cpu(xh->xh_count);\n\tint delta, middle = count / 2;\n\n\t/*\n\t * We start at the middle.  Each step gets farther away in both\n\t * directions.  We therefore hit the change in hash value\n\t * nearest to the middle.  Note that this loop does not execute for\n\t * count < 2.\n\t */\n\tfor (delta = 0; delta < middle; delta++) {\n\t\t/* Let's check delta earlier than middle */\n\t\tif (cmp_xe(&entries[middle - delta - 1],\n\t\t\t   &entries[middle - delta]))\n\t\t\treturn middle - delta;\n\n\t\t/* For even counts, don't walk off the end */\n\t\tif ((middle + delta + 1) == count)\n\t\t\tcontinue;\n\n\t\t/* Now try delta past middle */\n\t\tif (cmp_xe(&entries[middle + delta],\n\t\t\t   &entries[middle + delta + 1]))\n\t\t\treturn middle + delta + 1;\n\t}\n\n\t/* Every entry had the same hash */\n\treturn count;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmp_xe",
          "args": [
            "&entries[middle + delta]",
            "&entries[middle + delta + 1]"
          ],
          "line": 4596
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_xe_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4356-4367",
          "snippet": "static int cmp_xe_offset(const void *a, const void *b)\n{\n\tconst struct ocfs2_xattr_entry *l = a, *r = b;\n\tu32 l_name_offset = le16_to_cpu(l->xe_name_offset);\n\tu32 r_name_offset = le16_to_cpu(r->xe_name_offset);\n\n\tif (l_name_offset < r_name_offset)\n\t\treturn 1;\n\tif (l_name_offset > r_name_offset)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int cmp_xe_offset(const void *a, const void *b)\n{\n\tconst struct ocfs2_xattr_entry *l = a, *r = b;\n\tu32 l_name_offset = le16_to_cpu(l->xe_name_offset);\n\tu32 r_name_offset = le16_to_cpu(r->xe_name_offset);\n\n\tif (l_name_offset < r_name_offset)\n\t\treturn 1;\n\tif (l_name_offset > r_name_offset)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_count"
          ],
          "line": 4576
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_find_divide_pos(struct ocfs2_xattr_header *xh)\n{\n\tstruct ocfs2_xattr_entry *entries = xh->xh_entries;\n\tint count = le16_to_cpu(xh->xh_count);\n\tint delta, middle = count / 2;\n\n\t/*\n\t * We start at the middle.  Each step gets farther away in both\n\t * directions.  We therefore hit the change in hash value\n\t * nearest to the middle.  Note that this loop does not execute for\n\t * count < 2.\n\t */\n\tfor (delta = 0; delta < middle; delta++) {\n\t\t/* Let's check delta earlier than middle */\n\t\tif (cmp_xe(&entries[middle - delta - 1],\n\t\t\t   &entries[middle - delta]))\n\t\t\treturn middle - delta;\n\n\t\t/* For even counts, don't walk off the end */\n\t\tif ((middle + delta + 1) == count)\n\t\t\tcontinue;\n\n\t\t/* Now try delta past middle */\n\t\tif (cmp_xe(&entries[middle + delta],\n\t\t\t   &entries[middle + delta + 1]))\n\t\t\treturn middle + delta + 1;\n\t}\n\n\t/* Every entry had the same hash */\n\treturn count;\n}"
  },
  {
    "function_name": "ocfs2_mv_xattr_bucket_cross_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4497-4561",
    "snippet": "static int ocfs2_mv_xattr_bucket_cross_cluster(struct inode *inode,\n\t\t\t\t\t       handle_t *handle,\n\t\t\t\t\t       struct ocfs2_xattr_bucket *first,\n\t\t\t\t\t       struct ocfs2_xattr_bucket *target,\n\t\t\t\t\t       u64 new_blkno,\n\t\t\t\t\t       u32 num_clusters,\n\t\t\t\t\t       u32 *first_hash)\n{\n\tint ret;\n\tstruct super_block *sb = inode->i_sb;\n\tint blks_per_bucket = ocfs2_blocks_per_xattr_bucket(sb);\n\tint num_buckets = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(sb));\n\tint to_move = num_buckets / 2;\n\tu64 src_blkno;\n\tu64 last_cluster_blkno = bucket_blkno(first) +\n\t\t((num_clusters - 1) * ocfs2_clusters_to_blocks(sb, 1));\n\n\tBUG_ON(le16_to_cpu(bucket_xh(first)->xh_num_buckets) < num_buckets);\n\tBUG_ON(OCFS2_XATTR_BUCKET_SIZE == OCFS2_SB(sb)->s_clustersize);\n\n\ttrace_ocfs2_mv_xattr_bucket_cross_cluster(\n\t\t\t\t(unsigned long long)last_cluster_blkno,\n\t\t\t\t(unsigned long long)new_blkno);\n\n\tret = ocfs2_mv_xattr_buckets(inode, handle, bucket_blkno(first),\n\t\t\t\t     last_cluster_blkno, new_blkno,\n\t\t\t\t     to_move, first_hash);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This is the first bucket that got moved */\n\tsrc_blkno = last_cluster_blkno + (to_move * blks_per_bucket);\n\n\t/*\n\t * If the target bucket was part of the moved buckets, we need to\n\t * update first and target.\n\t */\n\tif (bucket_blkno(target) >= src_blkno) {\n\t\t/* Find the block for the new target bucket */\n\t\tsrc_blkno = new_blkno +\n\t\t\t(bucket_blkno(target) - src_blkno);\n\n\t\tocfs2_xattr_bucket_relse(first);\n\t\tocfs2_xattr_bucket_relse(target);\n\n\t\t/*\n\t\t * These shouldn't fail - the buffers are in the\n\t\t * journal from ocfs2_cp_xattr_bucket().\n\t\t */\n\t\tret = ocfs2_read_xattr_bucket(first, new_blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = ocfs2_read_xattr_bucket(target, src_blkno);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_bucket",
          "args": [
            "target",
            "src_blkno"
          ],
          "line": 4553
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "404-426",
          "snippet": "static int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_relse",
          "args": [
            "target"
          ],
          "line": 4542
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "346-354",
          "snippet": "static void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "target"
          ],
          "line": 4539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "target"
          ],
          "line": 4536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mv_xattr_buckets",
          "args": [
            "inode",
            "handle",
            "bucket_blkno(first)",
            "last_cluster_blkno",
            "new_blkno",
            "to_move",
            "first_hash"
          ],
          "line": 4521
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mv_xattr_buckets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4866-4962",
          "snippet": "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash)\n{\n\tint i, ret, credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint blks_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint num_buckets = ocfs2_xattr_buckets_per_cluster(osb);\n\tstruct ocfs2_xattr_bucket *old_first, *new_first;\n\n\ttrace_ocfs2_mv_xattr_buckets((unsigned long long)last_blk,\n\t\t\t\t     (unsigned long long)to_blk);\n\n\tBUG_ON(start_bucket >= num_buckets);\n\tif (start_bucket) {\n\t\tnum_buckets -= start_bucket;\n\t\tlast_blk += (start_bucket * blks_per_bucket);\n\t}\n\n\t/* The first bucket of the original extent */\n\told_first = ocfs2_xattr_bucket_new(inode);\n\t/* The first bucket of the new extent */\n\tnew_first = ocfs2_xattr_bucket_new(inode);\n\tif (!old_first || !new_first) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(old_first, src_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We need to update the first bucket of the old extent and all\n\t * the buckets going to the new extent.\n\t */\n\tcredits = ((num_buckets + 1) * blks_per_bucket);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, old_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_buckets; i++) {\n\t\tret = ocfs2_cp_xattr_bucket(inode, handle,\n\t\t\t\t\t    last_blk + (i * blks_per_bucket),\n\t\t\t\t\t    to_blk + (i * blks_per_bucket),\n\t\t\t\t\t    1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Get the new bucket ready before we dirty anything\n\t * (This actually shouldn't fail, because we already dirtied\n\t * it once in ocfs2_cp_xattr_bucket()).\n\t */\n\tret = ocfs2_read_xattr_bucket(new_first, to_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tret = ocfs2_xattr_bucket_journal_access(handle, new_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Now update the headers */\n\tle16_add_cpu(&bucket_xh(old_first)->xh_num_buckets, -num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, old_first);\n\n\tbucket_xh(new_first)->xh_num_buckets = cpu_to_le16(num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, new_first);\n\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(bucket_xh(new_first)->xh_entries[0].xe_name_hash);\n\nout:\n\tocfs2_xattr_bucket_free(new_first);\n\tocfs2_xattr_bucket_free(old_first);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash)\n{\n\tint i, ret, credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint blks_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint num_buckets = ocfs2_xattr_buckets_per_cluster(osb);\n\tstruct ocfs2_xattr_bucket *old_first, *new_first;\n\n\ttrace_ocfs2_mv_xattr_buckets((unsigned long long)last_blk,\n\t\t\t\t     (unsigned long long)to_blk);\n\n\tBUG_ON(start_bucket >= num_buckets);\n\tif (start_bucket) {\n\t\tnum_buckets -= start_bucket;\n\t\tlast_blk += (start_bucket * blks_per_bucket);\n\t}\n\n\t/* The first bucket of the original extent */\n\told_first = ocfs2_xattr_bucket_new(inode);\n\t/* The first bucket of the new extent */\n\tnew_first = ocfs2_xattr_bucket_new(inode);\n\tif (!old_first || !new_first) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(old_first, src_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We need to update the first bucket of the old extent and all\n\t * the buckets going to the new extent.\n\t */\n\tcredits = ((num_buckets + 1) * blks_per_bucket);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, old_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_buckets; i++) {\n\t\tret = ocfs2_cp_xattr_bucket(inode, handle,\n\t\t\t\t\t    last_blk + (i * blks_per_bucket),\n\t\t\t\t\t    to_blk + (i * blks_per_bucket),\n\t\t\t\t\t    1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Get the new bucket ready before we dirty anything\n\t * (This actually shouldn't fail, because we already dirtied\n\t * it once in ocfs2_cp_xattr_bucket()).\n\t */\n\tret = ocfs2_read_xattr_bucket(new_first, to_blk);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tret = ocfs2_xattr_bucket_journal_access(handle, new_first,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Now update the headers */\n\tle16_add_cpu(&bucket_xh(old_first)->xh_num_buckets, -num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, old_first);\n\n\tbucket_xh(new_first)->xh_num_buckets = cpu_to_le16(num_buckets);\n\tocfs2_xattr_bucket_journal_dirty(handle, new_first);\n\n\tif (first_hash)\n\t\t*first_hash = le32_to_cpu(bucket_xh(new_first)->xh_entries[0].xe_name_hash);\n\nout:\n\tocfs2_xattr_bucket_free(new_first);\n\tocfs2_xattr_bucket_free(old_first);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "first"
          ],
          "line": 4521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_mv_xattr_bucket_cross_cluster",
          "args": [
            "(unsigned long long)last_cluster_blkno",
            "(unsigned long long)new_blkno"
          ],
          "line": 4517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "OCFS2_XATTR_BUCKET_SIZE == OCFS2_SB(sb)->s_clustersize"
          ],
          "line": 4515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 4515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(bucket_xh(first)->xh_num_buckets) < num_buckets"
          ],
          "line": 4514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bucket_xh(first)->xh_num_buckets"
          ],
          "line": 4514
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "first"
          ],
          "line": 4514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "1"
          ],
          "line": 4512
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "first"
          ],
          "line": 4511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_buckets_per_cluster",
          "args": [
            "OCFS2_SB(sb)"
          ],
          "line": 4508
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_buckets_per_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "316-319",
          "snippet": "static inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 4508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_per_xattr_bucket",
          "args": [
            "sb"
          ],
          "line": 4507
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_per_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "321-324",
          "snippet": "static inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\n\nstatic int ocfs2_mv_xattr_bucket_cross_cluster(struct inode *inode,\n\t\t\t\t\t       handle_t *handle,\n\t\t\t\t\t       struct ocfs2_xattr_bucket *first,\n\t\t\t\t\t       struct ocfs2_xattr_bucket *target,\n\t\t\t\t\t       u64 new_blkno,\n\t\t\t\t\t       u32 num_clusters,\n\t\t\t\t\t       u32 *first_hash)\n{\n\tint ret;\n\tstruct super_block *sb = inode->i_sb;\n\tint blks_per_bucket = ocfs2_blocks_per_xattr_bucket(sb);\n\tint num_buckets = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(sb));\n\tint to_move = num_buckets / 2;\n\tu64 src_blkno;\n\tu64 last_cluster_blkno = bucket_blkno(first) +\n\t\t((num_clusters - 1) * ocfs2_clusters_to_blocks(sb, 1));\n\n\tBUG_ON(le16_to_cpu(bucket_xh(first)->xh_num_buckets) < num_buckets);\n\tBUG_ON(OCFS2_XATTR_BUCKET_SIZE == OCFS2_SB(sb)->s_clustersize);\n\n\ttrace_ocfs2_mv_xattr_bucket_cross_cluster(\n\t\t\t\t(unsigned long long)last_cluster_blkno,\n\t\t\t\t(unsigned long long)new_blkno);\n\n\tret = ocfs2_mv_xattr_buckets(inode, handle, bucket_blkno(first),\n\t\t\t\t     last_cluster_blkno, new_blkno,\n\t\t\t\t     to_move, first_hash);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This is the first bucket that got moved */\n\tsrc_blkno = last_cluster_blkno + (to_move * blks_per_bucket);\n\n\t/*\n\t * If the target bucket was part of the moved buckets, we need to\n\t * update first and target.\n\t */\n\tif (bucket_blkno(target) >= src_blkno) {\n\t\t/* Find the block for the new target bucket */\n\t\tsrc_blkno = new_blkno +\n\t\t\t(bucket_blkno(target) - src_blkno);\n\n\t\tocfs2_xattr_bucket_relse(first);\n\t\tocfs2_xattr_bucket_relse(target);\n\n\t\t/*\n\t\t * These shouldn't fail - the buffers are in the\n\t\t * journal from ocfs2_cp_xattr_bucket().\n\t\t */\n\t\tret = ocfs2_read_xattr_bucket(first, new_blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = ocfs2_read_xattr_bucket(target, src_blkno);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_defrag_xattr_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4375-4478",
    "snippet": "static int ocfs2_defrag_xattr_bucket(struct inode *inode,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint ret, i;\n\tsize_t end, offset, len;\n\tstruct ocfs2_xattr_header *xh;\n\tchar *entries, *buf, *bucket_buf = NULL;\n\tu64 blkno = bucket_blkno(bucket);\n\tu16 xh_free_start;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tstruct ocfs2_xattr_entry *xe;\n\n\t/*\n\t * In order to make the operation more efficient and generic,\n\t * we copy all the blocks into a contiguous memory and do the\n\t * defragment there, so if anything is error, we will not touch\n\t * the real block.\n\t */\n\tbucket_buf = kmalloc(OCFS2_XATTR_BUCKET_SIZE, GFP_NOFS);\n\tif (!bucket_buf) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tbuf = bucket_buf;\n\tfor (i = 0; i < bucket->bu_blocks; i++, buf += blocksize)\n\t\tmemcpy(buf, bucket_block(bucket, i), blocksize);\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = (struct ocfs2_xattr_header *)bucket_buf;\n\tentries = (char *)xh->xh_entries;\n\txh_free_start = le16_to_cpu(xh->xh_free_start);\n\n\ttrace_ocfs2_defrag_xattr_bucket(\n\t     (unsigned long long)blkno, le16_to_cpu(xh->xh_count),\n\t     xh_free_start, le16_to_cpu(xh->xh_name_value_len));\n\n\t/*\n\t * sort all the entries by their offset.\n\t * the largest will be the first, so that we can\n\t * move them to the end one by one.\n\t */\n\tsort(entries, le16_to_cpu(xh->xh_count),\n\t     sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe_offset, swap_xe);\n\n\t/* Move all name/values to the end of the bucket. */\n\txe = xh->xh_entries;\n\tend = OCFS2_XATTR_BUCKET_SIZE;\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++, xe++) {\n\t\toffset = le16_to_cpu(xe->xe_name_offset);\n\t\tlen = namevalue_size_xe(xe);\n\n\t\t/*\n\t\t * We must make sure that the name/value pair\n\t\t * exist in the same block. So adjust end to\n\t\t * the previous block end if needed.\n\t\t */\n\t\tif (((end - len) / blocksize !=\n\t\t\t(end - 1) / blocksize))\n\t\t\tend = end - end % blocksize;\n\n\t\tif (end > offset + len) {\n\t\t\tmemmove(bucket_buf + end - len,\n\t\t\t\tbucket_buf + offset, len);\n\t\t\txe->xe_name_offset = cpu_to_le16(end - len);\n\t\t}\n\n\t\tmlog_bug_on_msg(end < offset + len, \"Defrag check failed for \"\n\t\t\t\t\"bucket %llu\\n\", (unsigned long long)blkno);\n\n\t\tend -= len;\n\t}\n\n\tmlog_bug_on_msg(xh_free_start > end, \"Defrag check failed for \"\n\t\t\t\"bucket %llu\\n\", (unsigned long long)blkno);\n\n\tif (xh_free_start == end)\n\t\tgoto out;\n\n\tmemset(bucket_buf + xh_free_start, 0, end - xh_free_start);\n\txh->xh_free_start = cpu_to_le16(end);\n\n\t/* sort the entries by their name_hash. */\n\tsort(entries, le16_to_cpu(xh->xh_count),\n\t     sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe, swap_xe);\n\n\tbuf = bucket_buf;\n\tfor (i = 0; i < bucket->bu_blocks; i++, buf += blocksize)\n\t\tmemcpy(bucket_block(bucket, i), buf, blocksize);\n\tocfs2_xattr_bucket_journal_dirty(handle, bucket);\n\nout:\n\tkfree(bucket_buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bucket_buf"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_dirty",
          "args": [
            "handle",
            "bucket"
          ],
          "line": 4473
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "447-460",
          "snippet": "static void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bucket_block(bucket, i)",
            "buf",
            "blocksize"
          ],
          "line": 4472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "bucket",
            "i"
          ],
          "line": 4472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "entries",
            "le16_to_cpu(xh->xh_count)",
            "sizeof(struct ocfs2_xattr_entry)",
            "cmp_xe",
            "swap_xe"
          ],
          "line": 4466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_count"
          ],
          "line": 4466
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "end"
          ],
          "line": 4463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bucket_buf + xh_free_start",
            "0",
            "end - xh_free_start"
          ],
          "line": 4462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "xh_free_start > end",
            "\"Defrag check failed for \"\n\t\t\t\"bucket %llu\\n\"",
            "(unsigned long long)blkno"
          ],
          "line": 4456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "end < offset + len",
            "\"Defrag check failed for \"\n\t\t\t\t\"bucket %llu\\n\"",
            "(unsigned long long)blkno"
          ],
          "line": 4450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "end - len"
          ],
          "line": 4447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "bucket_buf + end - len",
            "bucket_buf + offset",
            "len"
          ],
          "line": 4445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namevalue_size_xe",
          "args": [
            "xe"
          ],
          "line": 4433
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "241-248",
          "snippet": "static int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "entries",
            "le16_to_cpu(xh->xh_count)",
            "sizeof(struct ocfs2_xattr_entry)",
            "cmp_xe_offset",
            "swap_xe"
          ],
          "line": 4424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_defrag_xattr_bucket",
          "args": [
            "(unsigned long long)blkno",
            "le16_to_cpu(xh->xh_count)",
            "xh_free_start",
            "le16_to_cpu(xh->xh_name_value_len)"
          ],
          "line": 4415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_access",
          "args": [
            "handle",
            "bucket",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 4404
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "428-445",
          "snippet": "static int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "bucket_block(bucket, i)",
            "blocksize"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "bucket",
            "i"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "OCFS2_XATTR_BUCKET_SIZE",
            "GFP_NOFS"
          ],
          "line": 4394
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "bucket"
          ],
          "line": 4383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_defrag_xattr_bucket(struct inode *inode,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint ret, i;\n\tsize_t end, offset, len;\n\tstruct ocfs2_xattr_header *xh;\n\tchar *entries, *buf, *bucket_buf = NULL;\n\tu64 blkno = bucket_blkno(bucket);\n\tu16 xh_free_start;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tstruct ocfs2_xattr_entry *xe;\n\n\t/*\n\t * In order to make the operation more efficient and generic,\n\t * we copy all the blocks into a contiguous memory and do the\n\t * defragment there, so if anything is error, we will not touch\n\t * the real block.\n\t */\n\tbucket_buf = kmalloc(OCFS2_XATTR_BUCKET_SIZE, GFP_NOFS);\n\tif (!bucket_buf) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tbuf = bucket_buf;\n\tfor (i = 0; i < bucket->bu_blocks; i++, buf += blocksize)\n\t\tmemcpy(buf, bucket_block(bucket, i), blocksize);\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = (struct ocfs2_xattr_header *)bucket_buf;\n\tentries = (char *)xh->xh_entries;\n\txh_free_start = le16_to_cpu(xh->xh_free_start);\n\n\ttrace_ocfs2_defrag_xattr_bucket(\n\t     (unsigned long long)blkno, le16_to_cpu(xh->xh_count),\n\t     xh_free_start, le16_to_cpu(xh->xh_name_value_len));\n\n\t/*\n\t * sort all the entries by their offset.\n\t * the largest will be the first, so that we can\n\t * move them to the end one by one.\n\t */\n\tsort(entries, le16_to_cpu(xh->xh_count),\n\t     sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe_offset, swap_xe);\n\n\t/* Move all name/values to the end of the bucket. */\n\txe = xh->xh_entries;\n\tend = OCFS2_XATTR_BUCKET_SIZE;\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++, xe++) {\n\t\toffset = le16_to_cpu(xe->xe_name_offset);\n\t\tlen = namevalue_size_xe(xe);\n\n\t\t/*\n\t\t * We must make sure that the name/value pair\n\t\t * exist in the same block. So adjust end to\n\t\t * the previous block end if needed.\n\t\t */\n\t\tif (((end - len) / blocksize !=\n\t\t\t(end - 1) / blocksize))\n\t\t\tend = end - end % blocksize;\n\n\t\tif (end > offset + len) {\n\t\t\tmemmove(bucket_buf + end - len,\n\t\t\t\tbucket_buf + offset, len);\n\t\t\txe->xe_name_offset = cpu_to_le16(end - len);\n\t\t}\n\n\t\tmlog_bug_on_msg(end < offset + len, \"Defrag check failed for \"\n\t\t\t\t\"bucket %llu\\n\", (unsigned long long)blkno);\n\n\t\tend -= len;\n\t}\n\n\tmlog_bug_on_msg(xh_free_start > end, \"Defrag check failed for \"\n\t\t\t\"bucket %llu\\n\", (unsigned long long)blkno);\n\n\tif (xh_free_start == end)\n\t\tgoto out;\n\n\tmemset(bucket_buf + xh_free_start, 0, end - xh_free_start);\n\txh->xh_free_start = cpu_to_le16(end);\n\n\t/* sort the entries by their name_hash. */\n\tsort(entries, le16_to_cpu(xh->xh_count),\n\t     sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe, swap_xe);\n\n\tbuf = bucket_buf;\n\tfor (i = 0; i < bucket->bu_blocks; i++, buf += blocksize)\n\t\tmemcpy(bucket_block(bucket, i), buf, blocksize);\n\tocfs2_xattr_bucket_journal_dirty(handle, bucket);\n\nout:\n\tkfree(bucket_buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "cmp_xe_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4356-4367",
    "snippet": "static int cmp_xe_offset(const void *a, const void *b)\n{\n\tconst struct ocfs2_xattr_entry *l = a, *r = b;\n\tu32 l_name_offset = le16_to_cpu(l->xe_name_offset);\n\tu32 r_name_offset = le16_to_cpu(r->xe_name_offset);\n\n\tif (l_name_offset < r_name_offset)\n\t\treturn 1;\n\tif (l_name_offset > r_name_offset)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "r->xe_name_offset"
          ],
          "line": 4360
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int cmp_xe_offset(const void *a, const void *b)\n{\n\tconst struct ocfs2_xattr_entry *l = a, *r = b;\n\tu32 l_name_offset = le16_to_cpu(l->xe_name_offset);\n\tu32 r_name_offset = le16_to_cpu(r->xe_name_offset);\n\n\tif (l_name_offset < r_name_offset)\n\t\treturn 1;\n\tif (l_name_offset > r_name_offset)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_xattr_create_index_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4262-4354",
    "snippet": "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 bit_off, len;\n\tu64 blkno;\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *xb_bh = xs->xattr_bh;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xr;\n\tu16 xb_flags = le16_to_cpu(xb->xb_flags);\n\n\ttrace_ocfs2_xattr_create_index_block_begin(\n\t\t\t\t(unsigned long long)xb_bh->b_blocknr);\n\n\tBUG_ON(xb_flags & OCFS2_XATTR_INDEXED);\n\tBUG_ON(!xs->bucket);\n\n\t/*\n\t * XXX:\n\t * We can use this lock for now, and maybe move to a dedicated mutex\n\t * if performance becomes a problem later.\n\t */\n\tdown_write(&oi->ip_alloc_sem);\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), xb_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, ctxt->data_ac,\n\t\t\t\t     1, 1, &bit_off, &len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The bucket may spread in many blocks, and\n\t * we will only touch the 1st block and the last block\n\t * in the whole bucket(one for entry and one for data).\n\t */\n\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\ttrace_ocfs2_xattr_create_index_block((unsigned long long)blkno);\n\n\tret = ocfs2_init_xattr_bucket(xs->bucket, blkno, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, xs->bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_xattr_block_to_bucket(inode, xb_bh, xs->bucket);\n\tocfs2_xattr_bucket_journal_dirty(handle, xs->bucket);\n\n\tocfs2_xattr_update_xattr_search(inode, xs, xb_bh);\n\n\t/* Change from ocfs2_xattr_header to ocfs2_xattr_tree_root */\n\tmemset(&xb->xb_attrs, 0, inode->i_sb->s_blocksize -\n\t       offsetof(struct ocfs2_xattr_block, xb_attrs));\n\n\txr = &xb->xb_attrs.xb_root;\n\txr->xt_clusters = cpu_to_le32(1);\n\txr->xt_last_eb_blk = 0;\n\txr->xt_list.l_tree_depth = 0;\n\txr->xt_list.l_count = cpu_to_le16(ocfs2_xattr_recs_per_xb(inode->i_sb));\n\txr->xt_list.l_next_free_rec = cpu_to_le16(1);\n\n\txr->xt_list.l_recs[0].e_cpos = 0;\n\txr->xt_list.l_recs[0].e_blkno = cpu_to_le64(blkno);\n\txr->xt_list.l_recs[0].e_leaf_clusters = cpu_to_le16(1);\n\n\txb->xb_flags = cpu_to_le16(xb_flags | OCFS2_XATTR_INDEXED);\n\n\tocfs2_journal_dirty(handle, xb_bh);\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 4351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "xb_bh"
          ],
          "line": 4348
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "xb_flags | OCFS2_XATTR_INDEXED"
          ],
          "line": 4346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 4340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_xattr_recs_per_xb(inode->i_sb)"
          ],
          "line": 4339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_recs_per_xb",
          "args": [
            "inode->i_sb"
          ],
          "line": 4339
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_recs_per_xb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1590-1599",
          "snippet": "static inline int ocfs2_xattr_recs_per_xb(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_xattr_block,\n\t\t\t xb_attrs.xb_root.xt_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_xattr_recs_per_xb(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_xattr_block,\n\t\t\t xb_attrs.xb_root.xt_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 4336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&xb->xb_attrs",
            "0",
            "inode->i_sb->s_blocksize -\n\t       offsetof(struct ocfs2_xattr_block, xb_attrs)"
          ],
          "line": 4332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_update_xattr_search",
          "args": [
            "inode",
            "xs",
            "xb_bh"
          ],
          "line": 4329
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_update_xattr_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4242-4260",
          "snippet": "static void ocfs2_xattr_update_xattr_search(struct inode *inode,\n\t\t\t\t\t    struct ocfs2_xattr_search *xs,\n\t\t\t\t\t    struct buffer_head *old_bh)\n{\n\tchar *buf = old_bh->b_data;\n\tstruct ocfs2_xattr_block *old_xb = (struct ocfs2_xattr_block *)buf;\n\tstruct ocfs2_xattr_header *old_xh = &old_xb->xb_attrs.xb_header;\n\tint i;\n\n\txs->header = bucket_xh(xs->bucket);\n\txs->base = bucket_block(xs->bucket, 0);\n\txs->end = xs->base + inode->i_sb->s_blocksize;\n\n\tif (xs->not_found)\n\t\treturn;\n\n\ti = xs->here - old_xh->xh_entries;\n\txs->here = &xs->header->xh_entries[i];\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic void ocfs2_xattr_update_xattr_search(struct inode *inode,\n\t\t\t\t\t    struct ocfs2_xattr_search *xs,\n\t\t\t\t\t    struct buffer_head *old_bh)\n{\n\tchar *buf = old_bh->b_data;\n\tstruct ocfs2_xattr_block *old_xb = (struct ocfs2_xattr_block *)buf;\n\tstruct ocfs2_xattr_header *old_xh = &old_xb->xb_attrs.xb_header;\n\tint i;\n\n\txs->header = bucket_xh(xs->bucket);\n\txs->base = bucket_block(xs->bucket, 0);\n\txs->end = xs->base + inode->i_sb->s_blocksize;\n\n\tif (xs->not_found)\n\t\treturn;\n\n\ti = xs->here - old_xh->xh_entries;\n\txs->here = &xs->header->xh_entries[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_dirty",
          "args": [
            "handle",
            "xs->bucket"
          ],
          "line": 4327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "447-460",
          "snippet": "static void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cp_xattr_block_to_bucket",
          "args": [
            "inode",
            "xb_bh",
            "xs->bucket"
          ],
          "line": 4326
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cp_xattr_block_to_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4174-4232",
          "snippet": "static void ocfs2_cp_xattr_block_to_bucket(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *xb_bh,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket)\n{\n\tint i, blocksize = inode->i_sb->s_blocksize;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tu16 offset, size, off_change;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_header *xb_xh = &xb->xb_attrs.xb_header;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu16 count = le16_to_cpu(xb_xh->xh_count);\n\tchar *src = xb_bh->b_data;\n\tchar *target = bucket_block(bucket, blks - 1);\n\n\ttrace_ocfs2_cp_xattr_block_to_bucket_begin(\n\t\t\t\t(unsigned long long)xb_bh->b_blocknr,\n\t\t\t\t(unsigned long long)bucket_blkno(bucket));\n\n\tfor (i = 0; i < blks; i++)\n\t\tmemset(bucket_block(bucket, i), 0, blocksize);\n\n\t/*\n\t * Since the xe_name_offset is based on ocfs2_xattr_header,\n\t * there is a offset change corresponding to the change of\n\t * ocfs2_xattr_header's position.\n\t */\n\toff_change = offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\txe = &xb_xh->xh_entries[count - 1];\n\toffset = le16_to_cpu(xe->xe_name_offset) + off_change;\n\tsize = blocksize - offset;\n\n\t/* copy all the names and values. */\n\tmemcpy(target + offset, src + offset, size);\n\n\t/* Init new header now. */\n\txh->xh_count = xb_xh->xh_count;\n\txh->xh_num_buckets = cpu_to_le16(1);\n\txh->xh_name_value_len = cpu_to_le16(size);\n\txh->xh_free_start = cpu_to_le16(OCFS2_XATTR_BUCKET_SIZE - size);\n\n\t/* copy all the entries. */\n\ttarget = bucket_block(bucket, 0);\n\toffset = offsetof(struct ocfs2_xattr_header, xh_entries);\n\tsize = count * sizeof(struct ocfs2_xattr_entry);\n\tmemcpy(target + offset, (char *)xb_xh + offset, size);\n\n\t/* Change the xe offset for all the xe because of the move. */\n\toff_change = OCFS2_XATTR_BUCKET_SIZE - blocksize +\n\t\t offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\tfor (i = 0; i < count; i++)\n\t\tle16_add_cpu(&xh->xh_entries[i].xe_name_offset, off_change);\n\n\ttrace_ocfs2_cp_xattr_block_to_bucket_end(offset, size, off_change);\n\n\tsort(target + offset, count, sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe, swap_xe);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_cp_xattr_block_to_bucket(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *xb_bh,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket)\n{\n\tint i, blocksize = inode->i_sb->s_blocksize;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tu16 offset, size, off_change;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_header *xb_xh = &xb->xb_attrs.xb_header;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu16 count = le16_to_cpu(xb_xh->xh_count);\n\tchar *src = xb_bh->b_data;\n\tchar *target = bucket_block(bucket, blks - 1);\n\n\ttrace_ocfs2_cp_xattr_block_to_bucket_begin(\n\t\t\t\t(unsigned long long)xb_bh->b_blocknr,\n\t\t\t\t(unsigned long long)bucket_blkno(bucket));\n\n\tfor (i = 0; i < blks; i++)\n\t\tmemset(bucket_block(bucket, i), 0, blocksize);\n\n\t/*\n\t * Since the xe_name_offset is based on ocfs2_xattr_header,\n\t * there is a offset change corresponding to the change of\n\t * ocfs2_xattr_header's position.\n\t */\n\toff_change = offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\txe = &xb_xh->xh_entries[count - 1];\n\toffset = le16_to_cpu(xe->xe_name_offset) + off_change;\n\tsize = blocksize - offset;\n\n\t/* copy all the names and values. */\n\tmemcpy(target + offset, src + offset, size);\n\n\t/* Init new header now. */\n\txh->xh_count = xb_xh->xh_count;\n\txh->xh_num_buckets = cpu_to_le16(1);\n\txh->xh_name_value_len = cpu_to_le16(size);\n\txh->xh_free_start = cpu_to_le16(OCFS2_XATTR_BUCKET_SIZE - size);\n\n\t/* copy all the entries. */\n\ttarget = bucket_block(bucket, 0);\n\toffset = offsetof(struct ocfs2_xattr_header, xh_entries);\n\tsize = count * sizeof(struct ocfs2_xattr_entry);\n\tmemcpy(target + offset, (char *)xb_xh + offset, size);\n\n\t/* Change the xe offset for all the xe because of the move. */\n\toff_change = OCFS2_XATTR_BUCKET_SIZE - blocksize +\n\t\t offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\tfor (i = 0; i < count; i++)\n\t\tle16_add_cpu(&xh->xh_entries[i].xe_name_offset, off_change);\n\n\ttrace_ocfs2_cp_xattr_block_to_bucket_end(offset, size, off_change);\n\n\tsort(target + offset, count, sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe, swap_xe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_access",
          "args": [
            "handle",
            "xs->bucket",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 4319
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "428-445",
          "snippet": "static int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_bucket",
          "args": [
            "xs->bucket",
            "blkno",
            "1"
          ],
          "line": 4313
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_bucket_xa_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2290-2300",
          "snippet": "static void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};\n\nstatic void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_xattr_create_index_block",
          "args": [
            "(unsigned long long)blkno"
          ],
          "line": 4311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "bit_off"
          ],
          "line": 4309
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_claim_clusters",
          "args": [
            "handle",
            "ctxt->data_ac",
            "1",
            "1",
            "&bit_off",
            "&len"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2302-2371",
          "snippet": "int __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_xb",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "xb_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 4290
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_xb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "741-745",
          "snippet": "int ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};\n\nint ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 4290
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 4288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!xs->bucket"
          ],
          "line": 4281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "xb_flags & OCFS2_XATTR_INDEXED"
          ],
          "line": 4280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_xattr_create_index_block_begin",
          "args": [
            "(unsigned long long)xb_bh->b_blocknr"
          ],
          "line": 4277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xb->xb_flags"
          ],
          "line": 4275
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 4270
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 bit_off, len;\n\tu64 blkno;\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *xb_bh = xs->xattr_bh;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xr;\n\tu16 xb_flags = le16_to_cpu(xb->xb_flags);\n\n\ttrace_ocfs2_xattr_create_index_block_begin(\n\t\t\t\t(unsigned long long)xb_bh->b_blocknr);\n\n\tBUG_ON(xb_flags & OCFS2_XATTR_INDEXED);\n\tBUG_ON(!xs->bucket);\n\n\t/*\n\t * XXX:\n\t * We can use this lock for now, and maybe move to a dedicated mutex\n\t * if performance becomes a problem later.\n\t */\n\tdown_write(&oi->ip_alloc_sem);\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), xb_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, ctxt->data_ac,\n\t\t\t\t     1, 1, &bit_off, &len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The bucket may spread in many blocks, and\n\t * we will only touch the 1st block and the last block\n\t * in the whole bucket(one for entry and one for data).\n\t */\n\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\ttrace_ocfs2_xattr_create_index_block((unsigned long long)blkno);\n\n\tret = ocfs2_init_xattr_bucket(xs->bucket, blkno, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, xs->bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_xattr_block_to_bucket(inode, xb_bh, xs->bucket);\n\tocfs2_xattr_bucket_journal_dirty(handle, xs->bucket);\n\n\tocfs2_xattr_update_xattr_search(inode, xs, xb_bh);\n\n\t/* Change from ocfs2_xattr_header to ocfs2_xattr_tree_root */\n\tmemset(&xb->xb_attrs, 0, inode->i_sb->s_blocksize -\n\t       offsetof(struct ocfs2_xattr_block, xb_attrs));\n\n\txr = &xb->xb_attrs.xb_root;\n\txr->xt_clusters = cpu_to_le32(1);\n\txr->xt_last_eb_blk = 0;\n\txr->xt_list.l_tree_depth = 0;\n\txr->xt_list.l_count = cpu_to_le16(ocfs2_xattr_recs_per_xb(inode->i_sb));\n\txr->xt_list.l_next_free_rec = cpu_to_le16(1);\n\n\txr->xt_list.l_recs[0].e_cpos = 0;\n\txr->xt_list.l_recs[0].e_blkno = cpu_to_le64(blkno);\n\txr->xt_list.l_recs[0].e_leaf_clusters = cpu_to_le16(1);\n\n\txb->xb_flags = cpu_to_le16(xb_flags | OCFS2_XATTR_INDEXED);\n\n\tocfs2_journal_dirty(handle, xb_bh);\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_update_xattr_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4242-4260",
    "snippet": "static void ocfs2_xattr_update_xattr_search(struct inode *inode,\n\t\t\t\t\t    struct ocfs2_xattr_search *xs,\n\t\t\t\t\t    struct buffer_head *old_bh)\n{\n\tchar *buf = old_bh->b_data;\n\tstruct ocfs2_xattr_block *old_xb = (struct ocfs2_xattr_block *)buf;\n\tstruct ocfs2_xattr_header *old_xh = &old_xb->xb_attrs.xb_header;\n\tint i;\n\n\txs->header = bucket_xh(xs->bucket);\n\txs->base = bucket_block(xs->bucket, 0);\n\txs->end = xs->base + inode->i_sb->s_blocksize;\n\n\tif (xs->not_found)\n\t\treturn;\n\n\ti = xs->here - old_xh->xh_entries;\n\txs->here = &xs->header->xh_entries[i];\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "xs->bucket",
            "0"
          ],
          "line": 4252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "xs->bucket"
          ],
          "line": 4251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic void ocfs2_xattr_update_xattr_search(struct inode *inode,\n\t\t\t\t\t    struct ocfs2_xattr_search *xs,\n\t\t\t\t\t    struct buffer_head *old_bh)\n{\n\tchar *buf = old_bh->b_data;\n\tstruct ocfs2_xattr_block *old_xb = (struct ocfs2_xattr_block *)buf;\n\tstruct ocfs2_xattr_header *old_xh = &old_xb->xb_attrs.xb_header;\n\tint i;\n\n\txs->header = bucket_xh(xs->bucket);\n\txs->base = bucket_block(xs->bucket, 0);\n\txs->end = xs->base + inode->i_sb->s_blocksize;\n\n\tif (xs->not_found)\n\t\treturn;\n\n\ti = xs->here - old_xh->xh_entries;\n\txs->here = &xs->header->xh_entries[i];\n}"
  },
  {
    "function_name": "ocfs2_cp_xattr_block_to_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4174-4232",
    "snippet": "static void ocfs2_cp_xattr_block_to_bucket(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *xb_bh,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket)\n{\n\tint i, blocksize = inode->i_sb->s_blocksize;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tu16 offset, size, off_change;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_header *xb_xh = &xb->xb_attrs.xb_header;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu16 count = le16_to_cpu(xb_xh->xh_count);\n\tchar *src = xb_bh->b_data;\n\tchar *target = bucket_block(bucket, blks - 1);\n\n\ttrace_ocfs2_cp_xattr_block_to_bucket_begin(\n\t\t\t\t(unsigned long long)xb_bh->b_blocknr,\n\t\t\t\t(unsigned long long)bucket_blkno(bucket));\n\n\tfor (i = 0; i < blks; i++)\n\t\tmemset(bucket_block(bucket, i), 0, blocksize);\n\n\t/*\n\t * Since the xe_name_offset is based on ocfs2_xattr_header,\n\t * there is a offset change corresponding to the change of\n\t * ocfs2_xattr_header's position.\n\t */\n\toff_change = offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\txe = &xb_xh->xh_entries[count - 1];\n\toffset = le16_to_cpu(xe->xe_name_offset) + off_change;\n\tsize = blocksize - offset;\n\n\t/* copy all the names and values. */\n\tmemcpy(target + offset, src + offset, size);\n\n\t/* Init new header now. */\n\txh->xh_count = xb_xh->xh_count;\n\txh->xh_num_buckets = cpu_to_le16(1);\n\txh->xh_name_value_len = cpu_to_le16(size);\n\txh->xh_free_start = cpu_to_le16(OCFS2_XATTR_BUCKET_SIZE - size);\n\n\t/* copy all the entries. */\n\ttarget = bucket_block(bucket, 0);\n\toffset = offsetof(struct ocfs2_xattr_header, xh_entries);\n\tsize = count * sizeof(struct ocfs2_xattr_entry);\n\tmemcpy(target + offset, (char *)xb_xh + offset, size);\n\n\t/* Change the xe offset for all the xe because of the move. */\n\toff_change = OCFS2_XATTR_BUCKET_SIZE - blocksize +\n\t\t offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\tfor (i = 0; i < count; i++)\n\t\tle16_add_cpu(&xh->xh_entries[i].xe_name_offset, off_change);\n\n\ttrace_ocfs2_cp_xattr_block_to_bucket_end(offset, size, off_change);\n\n\tsort(target + offset, count, sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe, swap_xe);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "target + offset",
            "count",
            "sizeof(struct ocfs2_xattr_entry)",
            "cmp_xe",
            "swap_xe"
          ],
          "line": 4230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_cp_xattr_block_to_bucket_end",
          "args": [
            "offset",
            "size",
            "off_change"
          ],
          "line": 4228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&xh->xh_entries[i].xe_name_offset",
            "off_change"
          ],
          "line": 4226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "target + offset",
            "(char *)xb_xh + offset",
            "size"
          ],
          "line": 4220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "bucket",
            "0"
          ],
          "line": 4217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "OCFS2_XATTR_BUCKET_SIZE - size"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "size"
          ],
          "line": 4213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 4212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "target + offset",
            "src + offset",
            "size"
          ],
          "line": 4208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xe->xe_name_offset"
          ],
          "line": 4204
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bucket_block(bucket, i)",
            "0",
            "blocksize"
          ],
          "line": 4195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "bucket",
            "i"
          ],
          "line": 4195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_cp_xattr_block_to_bucket_begin",
          "args": [
            "(unsigned long long)xb_bh->b_blocknr",
            "(unsigned long long)bucket_blkno(bucket)"
          ],
          "line": 4190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "bucket"
          ],
          "line": 4192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "bucket",
            "blks - 1"
          ],
          "line": 4188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 4185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_per_xattr_bucket",
          "args": [
            "inode->i_sb"
          ],
          "line": 4179
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_per_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "321-324",
          "snippet": "static inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_cp_xattr_block_to_bucket(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *xb_bh,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket)\n{\n\tint i, blocksize = inode->i_sb->s_blocksize;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tu16 offset, size, off_change;\n\tstruct ocfs2_xattr_entry *xe;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_header *xb_xh = &xb->xb_attrs.xb_header;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tu16 count = le16_to_cpu(xb_xh->xh_count);\n\tchar *src = xb_bh->b_data;\n\tchar *target = bucket_block(bucket, blks - 1);\n\n\ttrace_ocfs2_cp_xattr_block_to_bucket_begin(\n\t\t\t\t(unsigned long long)xb_bh->b_blocknr,\n\t\t\t\t(unsigned long long)bucket_blkno(bucket));\n\n\tfor (i = 0; i < blks; i++)\n\t\tmemset(bucket_block(bucket, i), 0, blocksize);\n\n\t/*\n\t * Since the xe_name_offset is based on ocfs2_xattr_header,\n\t * there is a offset change corresponding to the change of\n\t * ocfs2_xattr_header's position.\n\t */\n\toff_change = offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\txe = &xb_xh->xh_entries[count - 1];\n\toffset = le16_to_cpu(xe->xe_name_offset) + off_change;\n\tsize = blocksize - offset;\n\n\t/* copy all the names and values. */\n\tmemcpy(target + offset, src + offset, size);\n\n\t/* Init new header now. */\n\txh->xh_count = xb_xh->xh_count;\n\txh->xh_num_buckets = cpu_to_le16(1);\n\txh->xh_name_value_len = cpu_to_le16(size);\n\txh->xh_free_start = cpu_to_le16(OCFS2_XATTR_BUCKET_SIZE - size);\n\n\t/* copy all the entries. */\n\ttarget = bucket_block(bucket, 0);\n\toffset = offsetof(struct ocfs2_xattr_header, xh_entries);\n\tsize = count * sizeof(struct ocfs2_xattr_entry);\n\tmemcpy(target + offset, (char *)xb_xh + offset, size);\n\n\t/* Change the xe offset for all the xe because of the move. */\n\toff_change = OCFS2_XATTR_BUCKET_SIZE - blocksize +\n\t\t offsetof(struct ocfs2_xattr_block, xb_attrs.xb_header);\n\tfor (i = 0; i < count; i++)\n\t\tle16_add_cpu(&xh->xh_entries[i].xe_name_offset, off_change);\n\n\ttrace_ocfs2_cp_xattr_block_to_bucket_end(offset, size, off_change);\n\n\tsort(target + offset, count, sizeof(struct ocfs2_xattr_entry),\n\t     cmp_xe, swap_xe);\n}"
  },
  {
    "function_name": "swap_xe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4157-4164",
    "snippet": "static void swap_xe(void *a, void *b, int size)\n{\n\tstruct ocfs2_xattr_entry *l = a, *r = b, tmp;\n\n\ttmp = *l;\n\tmemcpy(l, r, sizeof(struct ocfs2_xattr_entry));\n\tmemcpy(r, &tmp, sizeof(struct ocfs2_xattr_entry));\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r",
            "&tmp",
            "sizeof(struct ocfs2_xattr_entry)"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "l",
            "r",
            "sizeof(struct ocfs2_xattr_entry)"
          ],
          "line": 4162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void swap_xe(void *a, void *b, int size)\n{\n\tstruct ocfs2_xattr_entry *l = a, *r = b, tmp;\n\n\ttmp = *l;\n\tmemcpy(l, r, sizeof(struct ocfs2_xattr_entry));\n\tmemcpy(r, &tmp, sizeof(struct ocfs2_xattr_entry));\n}"
  },
  {
    "function_name": "cmp_xe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4144-4155",
    "snippet": "static int cmp_xe(const void *a, const void *b)\n{\n\tconst struct ocfs2_xattr_entry *l = a, *r = b;\n\tu32 l_hash = le32_to_cpu(l->xe_name_hash);\n\tu32 r_hash = le32_to_cpu(r->xe_name_hash);\n\n\tif (l_hash > r_hash)\n\t\treturn 1;\n\tif (l_hash < r_hash)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "r->xe_name_hash"
          ],
          "line": 4148
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int cmp_xe(const void *a, const void *b)\n{\n\tconst struct ocfs2_xattr_entry *l = a, *r = b;\n\tu32 l_hash = le32_to_cpu(l->xe_name_hash);\n\tu32 r_hash = le32_to_cpu(r->xe_name_hash);\n\n\tif (l_hash > r_hash)\n\t\treturn 1;\n\tif (l_hash < r_hash)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_xattr_tree_list_index_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4120-4142",
    "snippet": "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\t     struct buffer_head *blk_bh,\n\t\t\t\t\t     char *buffer,\n\t\t\t\t\t     size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_xattr_tree_list xl = {\n\t\t.buffer = buffer,\n\t\t.buffer_size = buffer_size,\n\t\t.result = 0,\n\t};\n\n\tret = ocfs2_iterate_xattr_index_block(inode, blk_bh,\n\t\t\t\t\t      ocfs2_list_xattr_tree_rec, &xl);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = xl.result;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iterate_xattr_index_block",
          "args": [
            "inode",
            "blk_bh",
            "ocfs2_list_xattr_tree_rec",
            "&xl"
          ],
          "line": 4132
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iterate_xattr_index_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4071-4110",
          "snippet": "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *blk_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_extent_list *el = &xb->xb_attrs.xb_root.xt_list;\n\tint ret = 0;\n\tu32 name_hash = UINT_MAX, e_cpos = 0, num_clusters = 0;\n\tu64 p_blkno = 0;\n\n\tif (!el->l_next_free_rec || !rec_func)\n\t\treturn 0;\n\n\twhile (name_hash > 0) {\n\t\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno,\n\t\t\t\t\t  &e_cpos, &num_clusters, el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rec_func(inode, blk_bh, p_blkno, e_cpos,\n\t\t\t       num_clusters, para);\n\t\tif (ret) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e_cpos == 0)\n\t\t\tbreak;\n\n\t\tname_hash = e_cpos - 1;\n\t}\n\n\treturn ret;\n\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *blk_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_extent_list *el = &xb->xb_attrs.xb_root.xt_list;\n\tint ret = 0;\n\tu32 name_hash = UINT_MAX, e_cpos = 0, num_clusters = 0;\n\tu64 p_blkno = 0;\n\n\tif (!el->l_next_free_rec || !rec_func)\n\t\treturn 0;\n\n\twhile (name_hash > 0) {\n\t\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno,\n\t\t\t\t\t  &e_cpos, &num_clusters, el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rec_func(inode, blk_bh, p_blkno, e_cpos,\n\t\t\t       num_clusters, para);\n\t\tif (ret) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e_cpos == 0)\n\t\t\tbreak;\n\n\t\tname_hash = e_cpos - 1;\n\t}\n\n\treturn ret;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\t     struct buffer_head *blk_bh,\n\t\t\t\t\t     char *buffer,\n\t\t\t\t\t     size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_xattr_tree_list xl = {\n\t\t.buffer = buffer,\n\t\t.buffer_size = buffer_size,\n\t\t.result = 0,\n\t};\n\n\tret = ocfs2_iterate_xattr_index_block(inode, blk_bh,\n\t\t\t\t\t      ocfs2_list_xattr_tree_rec, &xl);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = xl.result;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_list_xattr_tree_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4112-4118",
    "snippet": "static int ocfs2_list_xattr_tree_rec(struct inode *inode,\n\t\t\t\t     struct buffer_head *root_bh,\n\t\t\t\t     u64 blkno, u32 cpos, u32 len, void *para)\n{\n\treturn ocfs2_iterate_xattr_buckets(inode, blkno, len,\n\t\t\t\t\t   ocfs2_list_xattr_bucket, para);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_iterate_xattr_buckets",
          "args": [
            "inode",
            "blkno",
            "len",
            "ocfs2_list_xattr_bucket",
            "para"
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iterate_xattr_buckets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3955-4006",
          "snippet": "static int ocfs2_iterate_xattr_buckets(struct inode *inode,\n\t\t\t\t       u64 blkno,\n\t\t\t\t       u32 clusters,\n\t\t\t\t       xattr_bucket_func *func,\n\t\t\t\t       void *para)\n{\n\tint i, ret = 0;\n\tu32 bpc = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\tu32 num_buckets = clusters * bpc;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tbucket = ocfs2_xattr_bucket_new(inode);\n\tif (!bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace_ocfs2_iterate_xattr_buckets(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)blkno, clusters);\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bucket->bu_blocks) {\n\t\tret = ocfs2_read_xattr_bucket(bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The real bucket num in this series of blocks is stored\n\t\t * in the 1st bucket.\n\t\t */\n\t\tif (i == 0)\n\t\t\tnum_buckets = le16_to_cpu(bucket_xh(bucket)->xh_num_buckets);\n\n\t\ttrace_ocfs2_iterate_xattr_bucket((unsigned long long)blkno,\n\t\t     le32_to_cpu(bucket_xh(bucket)->xh_entries[0].xe_name_hash));\n\t\tif (func) {\n\t\t\tret = func(inode, bucket, para);\n\t\t\tif (ret && ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\t/* Fall through to bucket_relse() */\n\t\t}\n\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tocfs2_xattr_bucket_free(bucket);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_iterate_xattr_buckets(struct inode *inode,\n\t\t\t\t       u64 blkno,\n\t\t\t\t       u32 clusters,\n\t\t\t\t       xattr_bucket_func *func,\n\t\t\t\t       void *para)\n{\n\tint i, ret = 0;\n\tu32 bpc = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\tu32 num_buckets = clusters * bpc;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tbucket = ocfs2_xattr_bucket_new(inode);\n\tif (!bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace_ocfs2_iterate_xattr_buckets(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)blkno, clusters);\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bucket->bu_blocks) {\n\t\tret = ocfs2_read_xattr_bucket(bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The real bucket num in this series of blocks is stored\n\t\t * in the 1st bucket.\n\t\t */\n\t\tif (i == 0)\n\t\t\tnum_buckets = le16_to_cpu(bucket_xh(bucket)->xh_num_buckets);\n\n\t\ttrace_ocfs2_iterate_xattr_bucket((unsigned long long)blkno,\n\t\t     le32_to_cpu(bucket_xh(bucket)->xh_entries[0].xe_name_hash));\n\t\tif (func) {\n\t\t\tret = func(inode, bucket, para);\n\t\t\tif (ret && ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\t/* Fall through to bucket_relse() */\n\t\t}\n\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tocfs2_xattr_bucket_free(bucket);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_list_xattr_tree_rec(struct inode *inode,\n\t\t\t\t     struct buffer_head *root_bh,\n\t\t\t\t     u64 blkno, u32 cpos, u32 len, void *para)\n{\n\treturn ocfs2_iterate_xattr_buckets(inode, blkno, len,\n\t\t\t\t\t   ocfs2_list_xattr_bucket, para);\n}"
  },
  {
    "function_name": "ocfs2_iterate_xattr_index_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4071-4110",
    "snippet": "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *blk_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_extent_list *el = &xb->xb_attrs.xb_root.xt_list;\n\tint ret = 0;\n\tu32 name_hash = UINT_MAX, e_cpos = 0, num_clusters = 0;\n\tu64 p_blkno = 0;\n\n\tif (!el->l_next_free_rec || !rec_func)\n\t\treturn 0;\n\n\twhile (name_hash > 0) {\n\t\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno,\n\t\t\t\t\t  &e_cpos, &num_clusters, el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rec_func(inode, blk_bh, p_blkno, e_cpos,\n\t\t\t       num_clusters, para);\n\t\tif (ret) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e_cpos == 0)\n\t\t\tbreak;\n\n\t\tname_hash = e_cpos - 1;\n\t}\n\n\treturn ret;\n\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rec_func",
          "args": [
            "inode",
            "blk_bh",
            "p_blkno",
            "e_cpos",
            "num_clusters",
            "para"
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_rec",
          "args": [
            "inode",
            "name_hash",
            "&p_blkno",
            "&e_cpos",
            "&num_clusters",
            "el"
          ],
          "line": 4087
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3668-3727",
          "snippet": "static int ocfs2_xattr_get_rec(struct inode *inode,\n\t\t\t       u32 name_hash,\n\t\t\t       u64 *p_blkno,\n\t\t\t       u32 *e_cpos,\n\t\t\t       u32 *num_clusters,\n\t\t\t       struct ocfs2_extent_list *el)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tu64 e_blkno = 0;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, name_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= name_hash) {\n\t\t\te_blkno = le64_to_cpu(rec->e_blkno);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*p_blkno = le64_to_cpu(rec->e_blkno);\n\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tif (e_cpos)\n\t\t*e_cpos = le32_to_cpu(rec->e_cpos);\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_get_rec(struct inode *inode,\n\t\t\t       u32 name_hash,\n\t\t\t       u64 *p_blkno,\n\t\t\t       u32 *e_cpos,\n\t\t\t       u32 *num_clusters,\n\t\t\t       struct ocfs2_extent_list *el)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tu64 e_blkno = 0;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, name_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= name_hash) {\n\t\t\te_blkno = le64_to_cpu(rec->e_blkno);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*p_blkno = le64_to_cpu(rec->e_blkno);\n\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tif (e_cpos)\n\t\t*e_cpos = le32_to_cpu(rec->e_cpos);\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *blk_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_extent_list *el = &xb->xb_attrs.xb_root.xt_list;\n\tint ret = 0;\n\tu32 name_hash = UINT_MAX, e_cpos = 0, num_clusters = 0;\n\tu64 p_blkno = 0;\n\n\tif (!el->l_next_free_rec || !rec_func)\n\t\treturn 0;\n\n\twhile (name_hash > 0) {\n\t\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno,\n\t\t\t\t\t  &e_cpos, &num_clusters, el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rec_func(inode, blk_bh, p_blkno, e_cpos,\n\t\t\t       num_clusters, para);\n\t\tif (ret) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e_cpos == 0)\n\t\t\tbreak;\n\n\t\tname_hash = e_cpos - 1;\n\t}\n\n\treturn ret;\n\n}"
  },
  {
    "function_name": "ocfs2_list_xattr_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4033-4069",
    "snippet": "static int ocfs2_list_xattr_bucket(struct inode *inode,\n\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   void *para)\n{\n\tint ret = 0, type;\n\tstruct ocfs2_xattr_tree_list *xl = (struct ocfs2_xattr_tree_list *)para;\n\tint i, block_off, new_offset;\n\tconst char *prefix, *name;\n\n\tfor (i = 0 ; i < le16_to_cpu(bucket_xh(bucket)->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &bucket_xh(bucket)->xh_entries[i];\n\t\ttype = ocfs2_xattr_get_type(entry);\n\t\tprefix = ocfs2_xattr_prefix(type);\n\n\t\tif (prefix) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t\t&new_offset);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tname = (const char *)bucket_block(bucket, block_off) +\n\t\t\t\tnew_offset;\n\t\t\tret = ocfs2_xattr_list_entry(xl->buffer,\n\t\t\t\t\t\t     xl->buffer_size,\n\t\t\t\t\t\t     &xl->result,\n\t\t\t\t\t\t     prefix, name,\n\t\t\t\t\t\t     entry->xe_name_len);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);",
      "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);",
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_list_entry",
          "args": [
            "xl->buffer",
            "xl->buffer_size",
            "&xl->result",
            "prefix",
            "name",
            "entry->xe_name_len"
          ],
          "line": 4058
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_list_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "893-915",
          "snippet": "static int ocfs2_xattr_list_entry(char *buffer, size_t size,\n\t\t\t\t  size_t *result, const char *prefix,\n\t\t\t\t  const char *name, int name_len)\n{\n\tchar *p = buffer + *result;\n\tint prefix_len = strlen(prefix);\n\tint total_len = prefix_len + name_len + 1;\n\n\t*result += total_len;\n\n\t/* we are just looking for how big our buffer needs to be */\n\tif (!size)\n\t\treturn 0;\n\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tmemcpy(p, prefix, prefix_len);\n\tmemcpy(p + prefix_len, name, name_len);\n\tp[prefix_len + name_len] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_list_entry(char *buffer, size_t size,\n\t\t\t\t  size_t *result, const char *prefix,\n\t\t\t\t  const char *name, int name_len)\n{\n\tchar *p = buffer + *result;\n\tint prefix_len = strlen(prefix);\n\tint total_len = prefix_len + name_len + 1;\n\n\t*result += total_len;\n\n\t/* we are just looking for how big our buffer needs to be */\n\tif (!size)\n\t\treturn 0;\n\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tmemcpy(p, prefix, prefix_len);\n\tmemcpy(p + prefix_len, name, name_len);\n\tp[prefix_len + name_len] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "bucket",
            "block_off"
          ],
          "line": 4056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_get_name_value",
          "args": [
            "inode->i_sb",
            "bucket_xh(bucket)",
            "i",
            "&block_off",
            "&new_offset"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_get_name_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4014-4031",
          "snippet": "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 4049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_prefix",
          "args": [
            "type"
          ],
          "line": 4045
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "547-555",
          "snippet": "static inline const char *ocfs2_xattr_prefix(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < OCFS2_XATTR_MAX)\n\t\thandler = ocfs2_xattr_handler_map[name_index];\n\n\treturn handler ? handler->prefix : NULL;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xattr_handler *ocfs2_xattr_handler_map[OCFS2_XATTR_MAX] = {\n\t[OCFS2_XATTR_INDEX_USER]\t= &ocfs2_xattr_user_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS]\n\t\t\t\t\t= &posix_acl_access_xattr_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT]\n\t\t\t\t\t= &posix_acl_default_xattr_handler,\n\t[OCFS2_XATTR_INDEX_TRUSTED]\t= &ocfs2_xattr_trusted_handler,\n\t[OCFS2_XATTR_INDEX_SECURITY]\t= &ocfs2_xattr_security_handler,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic const struct xattr_handler *ocfs2_xattr_handler_map[OCFS2_XATTR_MAX] = {\n\t[OCFS2_XATTR_INDEX_USER]\t= &ocfs2_xattr_user_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS]\n\t\t\t\t\t= &posix_acl_access_xattr_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT]\n\t\t\t\t\t= &posix_acl_default_xattr_handler,\n\t[OCFS2_XATTR_INDEX_TRUSTED]\t= &ocfs2_xattr_trusted_handler,\n\t[OCFS2_XATTR_INDEX_SECURITY]\t= &ocfs2_xattr_security_handler,\n};\n\nstatic inline const char *ocfs2_xattr_prefix(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < OCFS2_XATTR_MAX)\n\t\thandler = ocfs2_xattr_handler_map[name_index];\n\n\treturn handler ? handler->prefix : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_type",
          "args": [
            "entry"
          ],
          "line": 4044
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1153-1156",
          "snippet": "static inline int ocfs2_xattr_get_type(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_TYPE_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_TYPE_MASK\t\t0x7F"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_TYPE_MASK\t\t0x7F\n\nstatic inline int ocfs2_xattr_get_type(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_TYPE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 4043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bucket_xh(bucket)->xh_count"
          ],
          "line": 4042
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 4042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_list_xattr_bucket(struct inode *inode,\n\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   void *para)\n{\n\tint ret = 0, type;\n\tstruct ocfs2_xattr_tree_list *xl = (struct ocfs2_xattr_tree_list *)para;\n\tint i, block_off, new_offset;\n\tconst char *prefix, *name;\n\n\tfor (i = 0 ; i < le16_to_cpu(bucket_xh(bucket)->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &bucket_xh(bucket)->xh_entries[i];\n\t\ttype = ocfs2_xattr_get_type(entry);\n\t\tprefix = ocfs2_xattr_prefix(type);\n\n\t\tif (prefix) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\t\tbucket_xh(bucket),\n\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t\t&new_offset);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tname = (const char *)bucket_block(bucket, block_off) +\n\t\t\t\tnew_offset;\n\t\t\tret = ocfs2_xattr_list_entry(xl->buffer,\n\t\t\t\t\t\t     xl->buffer_size,\n\t\t\t\t\t\t     &xl->result,\n\t\t\t\t\t\t     prefix, name,\n\t\t\t\t\t\t     entry->xe_name_len);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_bucket_get_name_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "4014-4031",
    "snippet": "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_entries[index].xe_name_offset"
          ],
          "line": 4025
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_iterate_xattr_buckets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "3955-4006",
    "snippet": "static int ocfs2_iterate_xattr_buckets(struct inode *inode,\n\t\t\t\t       u64 blkno,\n\t\t\t\t       u32 clusters,\n\t\t\t\t       xattr_bucket_func *func,\n\t\t\t\t       void *para)\n{\n\tint i, ret = 0;\n\tu32 bpc = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\tu32 num_buckets = clusters * bpc;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tbucket = ocfs2_xattr_bucket_new(inode);\n\tif (!bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace_ocfs2_iterate_xattr_buckets(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)blkno, clusters);\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bucket->bu_blocks) {\n\t\tret = ocfs2_read_xattr_bucket(bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The real bucket num in this series of blocks is stored\n\t\t * in the 1st bucket.\n\t\t */\n\t\tif (i == 0)\n\t\t\tnum_buckets = le16_to_cpu(bucket_xh(bucket)->xh_num_buckets);\n\n\t\ttrace_ocfs2_iterate_xattr_bucket((unsigned long long)blkno,\n\t\t     le32_to_cpu(bucket_xh(bucket)->xh_entries[0].xe_name_hash));\n\t\tif (func) {\n\t\t\tret = func(inode, bucket, para);\n\t\t\tif (ret && ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\t/* Fall through to bucket_relse() */\n\t\t}\n\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tocfs2_xattr_bucket_free(bucket);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
      "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
      "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_free",
          "args": [
            "bucket"
          ],
          "line": 4004
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "356-363",
          "snippet": "static void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_relse",
          "args": [
            "bucket"
          ],
          "line": 3999
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "346-354",
          "snippet": "static void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "inode",
            "bucket",
            "para"
          ],
          "line": 3993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_iterate_xattr_bucket",
          "args": [
            "(unsigned long long)blkno",
            "le32_to_cpu(bucket_xh(bucket)->xh_entries[0].xe_name_hash)"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bucket_xh(bucket)->xh_entries[0].xe_name_hash"
          ],
          "line": 3991
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 3991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bucket_xh(bucket)->xh_num_buckets"
          ],
          "line": 3988
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_bucket",
          "args": [
            "bucket",
            "blkno"
          ],
          "line": 3977
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "404-426",
          "snippet": "static int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_iterate_xattr_buckets",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)blkno",
            "clusters"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 3973
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-ENOMEM"
          ],
          "line": 3968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_new",
          "args": [
            "inode"
          ],
          "line": 3966
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "330-344",
          "snippet": "static struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_buckets_per_cluster",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 3962
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_buckets_per_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "316-319",
          "snippet": "static inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_iterate_xattr_buckets(struct inode *inode,\n\t\t\t\t       u64 blkno,\n\t\t\t\t       u32 clusters,\n\t\t\t\t       xattr_bucket_func *func,\n\t\t\t\t       void *para)\n{\n\tint i, ret = 0;\n\tu32 bpc = ocfs2_xattr_buckets_per_cluster(OCFS2_SB(inode->i_sb));\n\tu32 num_buckets = clusters * bpc;\n\tstruct ocfs2_xattr_bucket *bucket;\n\n\tbucket = ocfs2_xattr_bucket_new(inode);\n\tif (!bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\ttrace_ocfs2_iterate_xattr_buckets(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)blkno, clusters);\n\n\tfor (i = 0; i < num_buckets; i++, blkno += bucket->bu_blocks) {\n\t\tret = ocfs2_read_xattr_bucket(bucket, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The real bucket num in this series of blocks is stored\n\t\t * in the 1st bucket.\n\t\t */\n\t\tif (i == 0)\n\t\t\tnum_buckets = le16_to_cpu(bucket_xh(bucket)->xh_num_buckets);\n\n\t\ttrace_ocfs2_iterate_xattr_bucket((unsigned long long)blkno,\n\t\t     le32_to_cpu(bucket_xh(bucket)->xh_entries[0].xe_name_hash));\n\t\tif (func) {\n\t\t\tret = func(inode, bucket, para);\n\t\t\tif (ret && ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\t/* Fall through to bucket_relse() */\n\t\t}\n\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tocfs2_xattr_bucket_free(bucket);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_index_block_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "3911-3953",
    "snippet": "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs)\n{\n\tint ret;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)root_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xb_root = &xb->xb_attrs.xb_root;\n\tstruct ocfs2_extent_list *el = &xb_root->xt_list;\n\tu64 p_blkno = 0;\n\tu32 first_hash, num_clusters = 0;\n\tu32 name_hash = ocfs2_xattr_name_hash(inode, name, strlen(name));\n\n\tif (le16_to_cpu(el->l_next_free_rec) == 0)\n\t\treturn -ENODATA;\n\n\ttrace_ocfs2_xattr_index_block_find(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, name_hash,\n\t\t\t\t\t(unsigned long long)root_bh->b_blocknr,\n\t\t\t\t\t-1);\n\n\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno, &first_hash,\n\t\t\t\t  &num_clusters, el);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(p_blkno == 0 || num_clusters == 0 || first_hash > name_hash);\n\n\ttrace_ocfs2_xattr_index_block_find_rec(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, first_hash,\n\t\t\t\t\t(unsigned long long)p_blkno,\n\t\t\t\t\tnum_clusters);\n\n\tret = ocfs2_xattr_bucket_find(inode, name_index, name, name_hash,\n\t\t\t\t      p_blkno, first_hash, num_clusters, xs);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
      "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_find",
          "args": [
            "inode",
            "name_index",
            "name",
            "name_hash",
            "p_blkno",
            "first_hash",
            "num_clusters",
            "xs"
          ],
          "line": 3948
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3797-3909",
          "snippet": "static int ocfs2_xattr_bucket_find(struct inode *inode,\n\t\t\t\t   int name_index,\n\t\t\t\t   const char *name,\n\t\t\t\t   u32 name_hash,\n\t\t\t\t   u64 p_blkno,\n\t\t\t\t   u32 first_hash,\n\t\t\t\t   u32 num_clusters,\n\t\t\t\t   struct ocfs2_xattr_search *xs)\n{\n\tint ret, found = 0;\n\tstruct ocfs2_xattr_header *xh = NULL;\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tu16 index = 0;\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint low_bucket = 0, bucket, high_bucket;\n\tstruct ocfs2_xattr_bucket *search;\n\tu32 last_hash;\n\tu64 blkno, lower_blkno = 0;\n\n\tsearch = ocfs2_xattr_bucket_new(inode);\n\tif (!search) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(search, p_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = bucket_xh(search);\n\thigh_bucket = le16_to_cpu(xh->xh_num_buckets) - 1;\n\twhile (low_bucket <= high_bucket) {\n\t\tocfs2_xattr_bucket_relse(search);\n\n\t\tbucket = (low_bucket + high_bucket) / 2;\n\t\tblkno = p_blkno + bucket * blk_per_bucket;\n\t\tret = ocfs2_read_xattr_bucket(search, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\txh = bucket_xh(search);\n\t\txe = &xh->xh_entries[0];\n\t\tif (name_hash < le32_to_cpu(xe->xe_name_hash)) {\n\t\t\thigh_bucket = bucket - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check whether the hash of the last entry in our\n\t\t * bucket is larger than the search one. for an empty\n\t\t * bucket, the last one is also the first one.\n\t\t */\n\t\tif (xh->xh_count)\n\t\t\txe = &xh->xh_entries[le16_to_cpu(xh->xh_count) - 1];\n\n\t\tlast_hash = le32_to_cpu(xe->xe_name_hash);\n\n\t\t/* record lower_blkno which may be the insert place. */\n\t\tlower_blkno = blkno;\n\n\t\tif (name_hash > le32_to_cpu(xe->xe_name_hash)) {\n\t\t\tlow_bucket = bucket + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* the searched xattr should reside in this bucket if exists. */\n\t\tret = ocfs2_find_xe_in_bucket(inode, search,\n\t\t\t\t\t      name_index, name, name_hash,\n\t\t\t\t\t      &index, &found);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Record the bucket we have found.\n\t * When the xattr's hash value is in the gap of 2 buckets, we will\n\t * always set it to the previous bucket.\n\t */\n\tif (!lower_blkno)\n\t\tlower_blkno = p_blkno;\n\n\t/* This should be in cache - we just read it during the search */\n\tret = ocfs2_read_xattr_bucket(xs->bucket, lower_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txs->header = bucket_xh(xs->bucket);\n\txs->base = bucket_block(xs->bucket, 0);\n\txs->end = xs->base + inode->i_sb->s_blocksize;\n\n\tif (found) {\n\t\txs->here = &xs->header->xh_entries[index];\n\t\ttrace_ocfs2_xattr_bucket_find(OCFS2_I(inode)->ip_blkno,\n\t\t\tname, name_index, name_hash,\n\t\t\t(unsigned long long)bucket_blkno(xs->bucket),\n\t\t\tindex);\n\t} else\n\t\tret = -ENODATA;\n\nout:\n\tocfs2_xattr_bucket_free(search);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
            "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\n\nstatic int ocfs2_xattr_bucket_find(struct inode *inode,\n\t\t\t\t   int name_index,\n\t\t\t\t   const char *name,\n\t\t\t\t   u32 name_hash,\n\t\t\t\t   u64 p_blkno,\n\t\t\t\t   u32 first_hash,\n\t\t\t\t   u32 num_clusters,\n\t\t\t\t   struct ocfs2_xattr_search *xs)\n{\n\tint ret, found = 0;\n\tstruct ocfs2_xattr_header *xh = NULL;\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tu16 index = 0;\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint low_bucket = 0, bucket, high_bucket;\n\tstruct ocfs2_xattr_bucket *search;\n\tu32 last_hash;\n\tu64 blkno, lower_blkno = 0;\n\n\tsearch = ocfs2_xattr_bucket_new(inode);\n\tif (!search) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(search, p_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = bucket_xh(search);\n\thigh_bucket = le16_to_cpu(xh->xh_num_buckets) - 1;\n\twhile (low_bucket <= high_bucket) {\n\t\tocfs2_xattr_bucket_relse(search);\n\n\t\tbucket = (low_bucket + high_bucket) / 2;\n\t\tblkno = p_blkno + bucket * blk_per_bucket;\n\t\tret = ocfs2_read_xattr_bucket(search, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\txh = bucket_xh(search);\n\t\txe = &xh->xh_entries[0];\n\t\tif (name_hash < le32_to_cpu(xe->xe_name_hash)) {\n\t\t\thigh_bucket = bucket - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check whether the hash of the last entry in our\n\t\t * bucket is larger than the search one. for an empty\n\t\t * bucket, the last one is also the first one.\n\t\t */\n\t\tif (xh->xh_count)\n\t\t\txe = &xh->xh_entries[le16_to_cpu(xh->xh_count) - 1];\n\n\t\tlast_hash = le32_to_cpu(xe->xe_name_hash);\n\n\t\t/* record lower_blkno which may be the insert place. */\n\t\tlower_blkno = blkno;\n\n\t\tif (name_hash > le32_to_cpu(xe->xe_name_hash)) {\n\t\t\tlow_bucket = bucket + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* the searched xattr should reside in this bucket if exists. */\n\t\tret = ocfs2_find_xe_in_bucket(inode, search,\n\t\t\t\t\t      name_index, name, name_hash,\n\t\t\t\t\t      &index, &found);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Record the bucket we have found.\n\t * When the xattr's hash value is in the gap of 2 buckets, we will\n\t * always set it to the previous bucket.\n\t */\n\tif (!lower_blkno)\n\t\tlower_blkno = p_blkno;\n\n\t/* This should be in cache - we just read it during the search */\n\tret = ocfs2_read_xattr_bucket(xs->bucket, lower_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txs->header = bucket_xh(xs->bucket);\n\txs->base = bucket_block(xs->bucket, 0);\n\txs->end = xs->base + inode->i_sb->s_blocksize;\n\n\tif (found) {\n\t\txs->here = &xs->header->xh_entries[index];\n\t\ttrace_ocfs2_xattr_bucket_find(OCFS2_I(inode)->ip_blkno,\n\t\t\tname, name_index, name_hash,\n\t\t\t(unsigned long long)bucket_blkno(xs->bucket),\n\t\t\tindex);\n\t} else\n\t\tret = -ENODATA;\n\nout:\n\tocfs2_xattr_bucket_free(search);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_xattr_index_block_find_rec",
          "args": [
            "OCFS2_I(inode)->ip_blkno",
            "name",
            "name_index",
            "first_hash",
            "(unsigned long long)p_blkno",
            "num_clusters"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 3943
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "p_blkno == 0 || num_clusters == 0 || first_hash > name_hash"
          ],
          "line": 3941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_rec",
          "args": [
            "inode",
            "name_hash",
            "&p_blkno",
            "&first_hash",
            "&num_clusters",
            "el"
          ],
          "line": 3934
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3668-3727",
          "snippet": "static int ocfs2_xattr_get_rec(struct inode *inode,\n\t\t\t       u32 name_hash,\n\t\t\t       u64 *p_blkno,\n\t\t\t       u32 *e_cpos,\n\t\t\t       u32 *num_clusters,\n\t\t\t       struct ocfs2_extent_list *el)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tu64 e_blkno = 0;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, name_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= name_hash) {\n\t\t\te_blkno = le64_to_cpu(rec->e_blkno);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*p_blkno = le64_to_cpu(rec->e_blkno);\n\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tif (e_cpos)\n\t\t*e_cpos = le32_to_cpu(rec->e_cpos);\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_get_rec(struct inode *inode,\n\t\t\t       u32 name_hash,\n\t\t\t       u64 *p_blkno,\n\t\t\t       u32 *e_cpos,\n\t\t\t       u32 *num_clusters,\n\t\t\t       struct ocfs2_extent_list *el)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tu64 e_blkno = 0;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, name_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= name_hash) {\n\t\t\te_blkno = le64_to_cpu(rec->e_blkno);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*p_blkno = le64_to_cpu(rec->e_blkno);\n\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tif (e_cpos)\n\t\t*e_cpos = le32_to_cpu(rec->e_cpos);\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_xattr_index_block_find",
          "args": [
            "OCFS2_I(inode)->ip_blkno",
            "name",
            "name_index",
            "name_hash",
            "(unsigned long long)root_bh->b_blocknr",
            "-1"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 3926
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_name_hash",
          "args": [
            "inode",
            "name",
            "strlen(name)"
          ],
          "line": 3924
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "557-573",
          "snippet": "static u32 ocfs2_xattr_name_hash(struct inode *inode,\n\t\t\t\t const char *name,\n\t\t\t\t int name_len)\n{\n\t/* Get hash value of uuid from super block */\n\tu32 hash = OCFS2_SB(inode->i_sb)->uuid_hash;\n\tint i;\n\n\t/* hash extended attribute name */\n\tfor (i = 0; i < name_len; i++) {\n\t\thash = (hash << OCFS2_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - OCFS2_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\treturn hash;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic u32 ocfs2_xattr_name_hash(struct inode *inode,\n\t\t\t\t const char *name,\n\t\t\t\t int name_len)\n{\n\t/* Get hash value of uuid from super block */\n\tu32 hash = OCFS2_SB(inode->i_sb)->uuid_hash;\n\tint i;\n\n\t/* hash extended attribute name */\n\tfor (i = 0; i < name_len; i++) {\n\t\thash = (hash << OCFS2_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - OCFS2_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 3924
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\n\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs)\n{\n\tint ret;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)root_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xb_root = &xb->xb_attrs.xb_root;\n\tstruct ocfs2_extent_list *el = &xb_root->xt_list;\n\tu64 p_blkno = 0;\n\tu32 first_hash, num_clusters = 0;\n\tu32 name_hash = ocfs2_xattr_name_hash(inode, name, strlen(name));\n\n\tif (le16_to_cpu(el->l_next_free_rec) == 0)\n\t\treturn -ENODATA;\n\n\ttrace_ocfs2_xattr_index_block_find(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, name_hash,\n\t\t\t\t\t(unsigned long long)root_bh->b_blocknr,\n\t\t\t\t\t-1);\n\n\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno, &first_hash,\n\t\t\t\t  &num_clusters, el);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(p_blkno == 0 || num_clusters == 0 || first_hash > name_hash);\n\n\ttrace_ocfs2_xattr_index_block_find_rec(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, first_hash,\n\t\t\t\t\t(unsigned long long)p_blkno,\n\t\t\t\t\tnum_clusters);\n\n\tret = ocfs2_xattr_bucket_find(inode, name_index, name, name_hash,\n\t\t\t\t      p_blkno, first_hash, num_clusters, xs);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_bucket_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "3797-3909",
    "snippet": "static int ocfs2_xattr_bucket_find(struct inode *inode,\n\t\t\t\t   int name_index,\n\t\t\t\t   const char *name,\n\t\t\t\t   u32 name_hash,\n\t\t\t\t   u64 p_blkno,\n\t\t\t\t   u32 first_hash,\n\t\t\t\t   u32 num_clusters,\n\t\t\t\t   struct ocfs2_xattr_search *xs)\n{\n\tint ret, found = 0;\n\tstruct ocfs2_xattr_header *xh = NULL;\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tu16 index = 0;\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint low_bucket = 0, bucket, high_bucket;\n\tstruct ocfs2_xattr_bucket *search;\n\tu32 last_hash;\n\tu64 blkno, lower_blkno = 0;\n\n\tsearch = ocfs2_xattr_bucket_new(inode);\n\tif (!search) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(search, p_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = bucket_xh(search);\n\thigh_bucket = le16_to_cpu(xh->xh_num_buckets) - 1;\n\twhile (low_bucket <= high_bucket) {\n\t\tocfs2_xattr_bucket_relse(search);\n\n\t\tbucket = (low_bucket + high_bucket) / 2;\n\t\tblkno = p_blkno + bucket * blk_per_bucket;\n\t\tret = ocfs2_read_xattr_bucket(search, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\txh = bucket_xh(search);\n\t\txe = &xh->xh_entries[0];\n\t\tif (name_hash < le32_to_cpu(xe->xe_name_hash)) {\n\t\t\thigh_bucket = bucket - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check whether the hash of the last entry in our\n\t\t * bucket is larger than the search one. for an empty\n\t\t * bucket, the last one is also the first one.\n\t\t */\n\t\tif (xh->xh_count)\n\t\t\txe = &xh->xh_entries[le16_to_cpu(xh->xh_count) - 1];\n\n\t\tlast_hash = le32_to_cpu(xe->xe_name_hash);\n\n\t\t/* record lower_blkno which may be the insert place. */\n\t\tlower_blkno = blkno;\n\n\t\tif (name_hash > le32_to_cpu(xe->xe_name_hash)) {\n\t\t\tlow_bucket = bucket + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* the searched xattr should reside in this bucket if exists. */\n\t\tret = ocfs2_find_xe_in_bucket(inode, search,\n\t\t\t\t\t      name_index, name, name_hash,\n\t\t\t\t\t      &index, &found);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Record the bucket we have found.\n\t * When the xattr's hash value is in the gap of 2 buckets, we will\n\t * always set it to the previous bucket.\n\t */\n\tif (!lower_blkno)\n\t\tlower_blkno = p_blkno;\n\n\t/* This should be in cache - we just read it during the search */\n\tret = ocfs2_read_xattr_bucket(xs->bucket, lower_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txs->header = bucket_xh(xs->bucket);\n\txs->base = bucket_block(xs->bucket, 0);\n\txs->end = xs->base + inode->i_sb->s_blocksize;\n\n\tif (found) {\n\t\txs->here = &xs->header->xh_entries[index];\n\t\ttrace_ocfs2_xattr_bucket_find(OCFS2_I(inode)->ip_blkno,\n\t\t\tname, name_index, name_hash,\n\t\t\t(unsigned long long)bucket_blkno(xs->bucket),\n\t\t\tindex);\n\t} else\n\t\tret = -ENODATA;\n\nout:\n\tocfs2_xattr_bucket_free(search);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
      "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_free",
          "args": [
            "search"
          ],
          "line": 3907
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "356-363",
          "snippet": "static void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_xattr_bucket_find",
          "args": [
            "OCFS2_I(inode)->ip_blkno",
            "name",
            "name_index",
            "name_hash",
            "(unsigned long long)bucket_blkno(xs->bucket)",
            "index"
          ],
          "line": 3899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_blkno",
          "args": [
            "xs->bucket"
          ],
          "line": 3901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "xs->bucket",
            "0"
          ],
          "line": 3894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "xs->bucket"
          ],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_bucket",
          "args": [
            "xs->bucket",
            "lower_blkno"
          ],
          "line": 3887
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "404-426",
          "snippet": "static int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_xe_in_bucket",
          "args": [
            "inode",
            "search",
            "name_index",
            "name",
            "name_hash",
            "&index",
            "&found"
          ],
          "line": 3868
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_xe_in_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3733-3786",
          "snippet": "static int ocfs2_find_xe_in_bucket(struct inode *inode,\n\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   int name_index,\n\t\t\t\t   const char *name,\n\t\t\t\t   u32 name_hash,\n\t\t\t\t   u16 *xe_index,\n\t\t\t\t   int *found)\n{\n\tint i, ret = 0, cmp = 1, block_off, new_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tsize_t name_len = strlen(name);\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tchar *xe_name;\n\n\t/*\n\t * We don't use binary search in the bucket because there\n\t * may be multiple entries with the same name hash.\n\t */\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (name_hash > le32_to_cpu(xe->xe_name_hash))\n\t\t\tcontinue;\n\t\telse if (name_hash < le32_to_cpu(xe->xe_name_hash))\n\t\t\tbreak;\n\n\t\tcmp = name_index - ocfs2_xattr_get_type(xe);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - xe->xe_name_len;\n\t\tif (cmp)\n\t\t\tcontinue;\n\n\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\txh,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t&new_offset);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\n\t\txe_name = bucket_block(bucket, block_off) + new_offset;\n\t\tif (!memcmp(name, xe_name, name_len)) {\n\t\t\t*xe_index = i;\n\t\t\t*found = 1;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);\n\nstatic int ocfs2_find_xe_in_bucket(struct inode *inode,\n\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   int name_index,\n\t\t\t\t   const char *name,\n\t\t\t\t   u32 name_hash,\n\t\t\t\t   u16 *xe_index,\n\t\t\t\t   int *found)\n{\n\tint i, ret = 0, cmp = 1, block_off, new_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tsize_t name_len = strlen(name);\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tchar *xe_name;\n\n\t/*\n\t * We don't use binary search in the bucket because there\n\t * may be multiple entries with the same name hash.\n\t */\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (name_hash > le32_to_cpu(xe->xe_name_hash))\n\t\t\tcontinue;\n\t\telse if (name_hash < le32_to_cpu(xe->xe_name_hash))\n\t\t\tbreak;\n\n\t\tcmp = name_index - ocfs2_xattr_get_type(xe);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - xe->xe_name_len;\n\t\tif (cmp)\n\t\t\tcontinue;\n\n\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\txh,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t&new_offset);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\n\t\txe_name = bucket_block(bucket, block_off) + new_offset;\n\t\tif (!memcmp(name, xe_name, name_len)) {\n\t\t\t*xe_index = i;\n\t\t\t*found = 1;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "xe->xe_name_hash"
          ],
          "line": 3862
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_count"
          ],
          "line": 3855
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "search"
          ],
          "line": 3842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_relse",
          "args": [
            "search"
          ],
          "line": 3832
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "346-354",
          "snippet": "static void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "search"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_new",
          "args": [
            "inode"
          ],
          "line": 3816
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "330-344",
          "snippet": "static struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_per_xattr_bucket",
          "args": [
            "inode->i_sb"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_per_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "321-324",
          "snippet": "static inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\n\nstatic int ocfs2_xattr_bucket_find(struct inode *inode,\n\t\t\t\t   int name_index,\n\t\t\t\t   const char *name,\n\t\t\t\t   u32 name_hash,\n\t\t\t\t   u64 p_blkno,\n\t\t\t\t   u32 first_hash,\n\t\t\t\t   u32 num_clusters,\n\t\t\t\t   struct ocfs2_xattr_search *xs)\n{\n\tint ret, found = 0;\n\tstruct ocfs2_xattr_header *xh = NULL;\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tu16 index = 0;\n\tu16 blk_per_bucket = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\tint low_bucket = 0, bucket, high_bucket;\n\tstruct ocfs2_xattr_bucket *search;\n\tu32 last_hash;\n\tu64 blkno, lower_blkno = 0;\n\n\tsearch = ocfs2_xattr_bucket_new(inode);\n\tif (!search) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_xattr_bucket(search, p_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txh = bucket_xh(search);\n\thigh_bucket = le16_to_cpu(xh->xh_num_buckets) - 1;\n\twhile (low_bucket <= high_bucket) {\n\t\tocfs2_xattr_bucket_relse(search);\n\n\t\tbucket = (low_bucket + high_bucket) / 2;\n\t\tblkno = p_blkno + bucket * blk_per_bucket;\n\t\tret = ocfs2_read_xattr_bucket(search, blkno);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\txh = bucket_xh(search);\n\t\txe = &xh->xh_entries[0];\n\t\tif (name_hash < le32_to_cpu(xe->xe_name_hash)) {\n\t\t\thigh_bucket = bucket - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check whether the hash of the last entry in our\n\t\t * bucket is larger than the search one. for an empty\n\t\t * bucket, the last one is also the first one.\n\t\t */\n\t\tif (xh->xh_count)\n\t\t\txe = &xh->xh_entries[le16_to_cpu(xh->xh_count) - 1];\n\n\t\tlast_hash = le32_to_cpu(xe->xe_name_hash);\n\n\t\t/* record lower_blkno which may be the insert place. */\n\t\tlower_blkno = blkno;\n\n\t\tif (name_hash > le32_to_cpu(xe->xe_name_hash)) {\n\t\t\tlow_bucket = bucket + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* the searched xattr should reside in this bucket if exists. */\n\t\tret = ocfs2_find_xe_in_bucket(inode, search,\n\t\t\t\t\t      name_index, name, name_hash,\n\t\t\t\t\t      &index, &found);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Record the bucket we have found.\n\t * When the xattr's hash value is in the gap of 2 buckets, we will\n\t * always set it to the previous bucket.\n\t */\n\tif (!lower_blkno)\n\t\tlower_blkno = p_blkno;\n\n\t/* This should be in cache - we just read it during the search */\n\tret = ocfs2_read_xattr_bucket(xs->bucket, lower_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txs->header = bucket_xh(xs->bucket);\n\txs->base = bucket_block(xs->bucket, 0);\n\txs->end = xs->base + inode->i_sb->s_blocksize;\n\n\tif (found) {\n\t\txs->here = &xs->header->xh_entries[index];\n\t\ttrace_ocfs2_xattr_bucket_find(OCFS2_I(inode)->ip_blkno,\n\t\t\tname, name_index, name_hash,\n\t\t\t(unsigned long long)bucket_blkno(xs->bucket),\n\t\t\tindex);\n\t} else\n\t\tret = -ENODATA;\n\nout:\n\tocfs2_xattr_bucket_free(search);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_xe_in_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "3733-3786",
    "snippet": "static int ocfs2_find_xe_in_bucket(struct inode *inode,\n\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   int name_index,\n\t\t\t\t   const char *name,\n\t\t\t\t   u32 name_hash,\n\t\t\t\t   u16 *xe_index,\n\t\t\t\t   int *found)\n{\n\tint i, ret = 0, cmp = 1, block_off, new_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tsize_t name_len = strlen(name);\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tchar *xe_name;\n\n\t/*\n\t * We don't use binary search in the bucket because there\n\t * may be multiple entries with the same name hash.\n\t */\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (name_hash > le32_to_cpu(xe->xe_name_hash))\n\t\t\tcontinue;\n\t\telse if (name_hash < le32_to_cpu(xe->xe_name_hash))\n\t\t\tbreak;\n\n\t\tcmp = name_index - ocfs2_xattr_get_type(xe);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - xe->xe_name_len;\n\t\tif (cmp)\n\t\t\tcontinue;\n\n\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\txh,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t&new_offset);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\n\t\txe_name = bucket_block(bucket, block_off) + new_offset;\n\t\tif (!memcmp(name, xe_name, name_len)) {\n\t\t\t*xe_index = i;\n\t\t\t*found = 1;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "xe_name",
            "name_len"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "bucket",
            "block_off"
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_get_name_value",
          "args": [
            "inode->i_sb",
            "xh",
            "i",
            "&block_off",
            "&new_offset"
          ],
          "line": 3765
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_get_name_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4014-4031",
          "snippet": "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_type",
          "args": [
            "xe"
          ],
          "line": 3759
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1153-1156",
          "snippet": "static inline int ocfs2_xattr_get_type(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_TYPE_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_TYPE_MASK\t\t0x7F"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_TYPE_MASK\t\t0x7F\n\nstatic inline int ocfs2_xattr_get_type(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_TYPE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "xe->xe_name_hash"
          ],
          "line": 3756
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_count"
          ],
          "line": 3751
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 3743
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);\n\nstatic int ocfs2_find_xe_in_bucket(struct inode *inode,\n\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   int name_index,\n\t\t\t\t   const char *name,\n\t\t\t\t   u32 name_hash,\n\t\t\t\t   u16 *xe_index,\n\t\t\t\t   int *found)\n{\n\tint i, ret = 0, cmp = 1, block_off, new_offset;\n\tstruct ocfs2_xattr_header *xh = bucket_xh(bucket);\n\tsize_t name_len = strlen(name);\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tchar *xe_name;\n\n\t/*\n\t * We don't use binary search in the bucket because there\n\t * may be multiple entries with the same name hash.\n\t */\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++) {\n\t\txe = &xh->xh_entries[i];\n\n\t\tif (name_hash > le32_to_cpu(xe->xe_name_hash))\n\t\t\tcontinue;\n\t\telse if (name_hash < le32_to_cpu(xe->xe_name_hash))\n\t\t\tbreak;\n\n\t\tcmp = name_index - ocfs2_xattr_get_type(xe);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - xe->xe_name_len;\n\t\tif (cmp)\n\t\t\tcontinue;\n\n\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\txh,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t&new_offset);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\n\t\txe_name = bucket_block(bucket, block_off) + new_offset;\n\t\tif (!memcmp(name, xe_name, name_len)) {\n\t\t\t*xe_index = i;\n\t\t\t*found = 1;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_get_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "3668-3727",
    "snippet": "static int ocfs2_xattr_get_rec(struct inode *inode,\n\t\t\t       u32 name_hash,\n\t\t\t       u64 *p_blkno,\n\t\t\t       u32 *e_cpos,\n\t\t\t       u32 *num_clusters,\n\t\t\t       struct ocfs2_extent_list *el)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tu64 e_blkno = 0;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, name_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= name_hash) {\n\t\t\te_blkno = le64_to_cpu(rec->e_blkno);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*p_blkno = le64_to_cpu(rec->e_blkno);\n\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tif (e_cpos)\n\t\t*e_cpos = le32_to_cpu(rec->e_cpos);\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "eb_bh"
          ],
          "line": 3725
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 3723
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 3721
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->e_blkno"
          ],
          "line": 3720
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in xattr\"",
            "inode->i_ino",
            "le32_to_cpu(rec->e_cpos)",
            "ocfs2_rec_clusters(el, rec)"
          ],
          "line": 3712
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 3715
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_leaf",
          "args": [
            "INODE_CACHE(inode)",
            "el",
            "name_hash",
            "&eb_bh"
          ],
          "line": 3682
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1917-1933",
          "snippet": "int ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 3682
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_get_rec(struct inode *inode,\n\t\t\t       u32 name_hash,\n\t\t\t       u64 *p_blkno,\n\t\t\t       u32 *e_cpos,\n\t\t\t       u32 *num_clusters,\n\t\t\t       struct ocfs2_extent_list *el)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tu64 e_blkno = 0;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, name_hash,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr tree block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= name_hash) {\n\t\t\te_blkno = le64_to_cpu(rec->e_blkno);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!e_blkno) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t*p_blkno = le64_to_cpu(rec->e_blkno);\n\t*num_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tif (e_cpos)\n\t\t*e_cpos = le32_to_cpu(rec->e_cpos);\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "3512-3661",
    "snippet": "int ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Only xbs will be used on indexed trees.  xis doesn't need a\n\t * bucket.\n\t */\n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t/*\n\t * Scan inode and external block to find the same name\n\t * extended attribute and collect search information.\n\t */\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Check whether the value is refcounted and do some preparation. */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tl_inode->i_mutex);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* we need to update inode's ctime field, so add credit for it. */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock(inode, 1);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_free",
          "args": [
            "xbs.bucket"
          ],
          "line": 3658
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "356-363",
          "snippet": "static void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "xbs.xattr_bh"
          ],
          "line": 3657
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 3654
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_try_remove_refcount_tree",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 3650
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_try_remove_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "933-960",
          "snippet": "int ocfs2_try_remove_refcount_tree(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&oi->ip_xattr_sem);\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (oi->ip_clusters)\n\t\tgoto out;\n\n\tif ((oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) && di->i_xattr_loc)\n\t\tgoto out;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL &&\n\t    ocfs2_has_inline_xattr_value_outside(inode, di))\n\t\tgoto out;\n\n\tret = ocfs2_remove_refcount_tree(inode, di_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tup_write(&oi->ip_alloc_sem);\n\tup_write(&oi->ip_xattr_sem);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_try_remove_refcount_tree(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&oi->ip_xattr_sem);\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (oi->ip_clusters)\n\t\tgoto out;\n\n\tif ((oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) && di->i_xattr_loc)\n\t\tgoto out;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL &&\n\t    ocfs2_has_inline_xattr_value_outside(inode, di))\n\t\tgoto out;\n\n\tret = ocfs2_remove_refcount_tree(inode, di_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tup_write(&oi->ip_alloc_sem);\n\tup_write(&oi->ip_xattr_sem);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&OCFS2_I(inode)->ip_xattr_sem"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 3648
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "ref_tree",
            "1"
          ],
          "line": 3647
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "osb",
            "&ctxt.dealloc"
          ],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6472-6513",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "1"
          ],
          "line": 3642
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dealloc_has_cluster",
          "args": [
            "&ctxt.dealloc"
          ],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dealloc_has_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "215-218",
          "snippet": "static inline int ocfs2_dealloc_has_cluster(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\treturn c->c_global_allocator != NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_dealloc_has_cluster(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\treturn c->c_global_allocator != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "ctxt.meta_ac"
          ],
          "line": 3640
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "ctxt.handle"
          ],
          "line": 3634
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "ctxt.handle",
            "inode",
            "0"
          ],
          "line": 3632
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_xattr_set_handle",
          "args": [
            "inode",
            "di",
            "&xi",
            "&xis",
            "&xbs",
            "&ctxt"
          ],
          "line": 3631
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_xattr_set_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3288-3422",
          "snippet": "static int __ocfs2_xattr_set_handle(struct inode *inode,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct ocfs2_xattr_info *xi,\n\t\t\t\t    struct ocfs2_xattr_search *xis,\n\t\t\t\t    struct ocfs2_xattr_search *xbs,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret = 0, credits, old_found;\n\n\tif (!xi->xi_value) {\n\t\t/* Remove existing extended attribute */\n\t\tif (!xis->not_found)\n\t\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\telse if (!xbs->not_found)\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t} else {\n\t\t/* We always try to set extended attribute into inode first*/\n\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\tif (!ret && !xbs->not_found) {\n\t\t\t/*\n\t\t\t * If succeed and that extended attribute existing in\n\t\t\t * external block, then we will remove it.\n\t\t\t */\n\t\t\txi->xi_value = NULL;\n\t\t\txi->xi_value_len = 0;\n\n\t\t\told_found = xis->not_found;\n\t\t\txis->not_found = -ENODATA;\n\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&credits);\n\t\t\txis->not_found = old_found;\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t} else if ((ret == -ENOSPC) && !ctxt->set_abort) {\n\t\t\tif (di->i_xattr_loc && !xbs->xattr_bh) {\n\t\t\t\tret = ocfs2_xattr_block_find(inode,\n\t\t\t\t\t\t\t     xi->xi_name_index,\n\t\t\t\t\t\t\t     xi->xi_name, xbs);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\n\t\t\t\told_found = xis->not_found;\n\t\t\t\txis->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\txis->not_found = old_found;\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * If no space in inode, we will set extended attribute\n\t\t\t * into external block.\n\t\t\t */\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (!xis->not_found) {\n\t\t\t\t/*\n\t\t\t\t * If succeed and that extended attribute\n\t\t\t\t * existing in inode, we will remove it.\n\t\t\t\t */\n\t\t\t\txi->xi_value = NULL;\n\t\t\t\txi->xi_value_len = 0;\n\t\t\t\txbs->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = ocfs2_xattr_ibody_set(inode, xi,\n\t\t\t\t\t\t\t    xis, ctxt);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\t/* Update inode ctime. */\n\t\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t\t      xis->inode_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode->i_ctime = CURRENT_TIME;\n\t\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\t\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\t\tocfs2_journal_dirty(ctxt->handle, xis->inode_bh);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int __ocfs2_xattr_set_handle(struct inode *inode,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct ocfs2_xattr_info *xi,\n\t\t\t\t    struct ocfs2_xattr_search *xis,\n\t\t\t\t    struct ocfs2_xattr_search *xbs,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret = 0, credits, old_found;\n\n\tif (!xi->xi_value) {\n\t\t/* Remove existing extended attribute */\n\t\tif (!xis->not_found)\n\t\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\telse if (!xbs->not_found)\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t} else {\n\t\t/* We always try to set extended attribute into inode first*/\n\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\tif (!ret && !xbs->not_found) {\n\t\t\t/*\n\t\t\t * If succeed and that extended attribute existing in\n\t\t\t * external block, then we will remove it.\n\t\t\t */\n\t\t\txi->xi_value = NULL;\n\t\t\txi->xi_value_len = 0;\n\n\t\t\told_found = xis->not_found;\n\t\t\txis->not_found = -ENODATA;\n\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&credits);\n\t\t\txis->not_found = old_found;\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t} else if ((ret == -ENOSPC) && !ctxt->set_abort) {\n\t\t\tif (di->i_xattr_loc && !xbs->xattr_bh) {\n\t\t\t\tret = ocfs2_xattr_block_find(inode,\n\t\t\t\t\t\t\t     xi->xi_name_index,\n\t\t\t\t\t\t\t     xi->xi_name, xbs);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\n\t\t\t\told_found = xis->not_found;\n\t\t\t\txis->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\txis->not_found = old_found;\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * If no space in inode, we will set extended attribute\n\t\t\t * into external block.\n\t\t\t */\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (!xis->not_found) {\n\t\t\t\t/*\n\t\t\t\t * If succeed and that extended attribute\n\t\t\t\t * existing in inode, we will remove it.\n\t\t\t\t */\n\t\t\t\txi->xi_value = NULL;\n\t\t\t\txi->xi_value_len = 0;\n\t\t\t\txbs->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = ocfs2_xattr_ibody_set(inode, xi,\n\t\t\t\t\t\t\t    xis, ctxt);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\t/* Update inode ctime. */\n\t\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t\t      xis->inode_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode->i_ctime = CURRENT_TIME;\n\t\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\t\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\t\tocfs2_journal_dirty(ctxt->handle, xis->inode_bh);\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ctxt.handle"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctxt.handle"
          ],
          "line": 3625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits + ref_credits"
          ],
          "line": 3624
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_set_ctxt",
          "args": [
            "inode",
            "di",
            "&xi",
            "&xis",
            "&xbs",
            "&ctxt",
            "ref_meta",
            "&credits"
          ],
          "line": 3615
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_set_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3232-3286",
          "snippet": "static int ocfs2_init_xattr_set_ctxt(struct inode *inode,\n\t\t\t\t     struct ocfs2_dinode *di,\n\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t     struct ocfs2_xattr_search *xis,\n\t\t\t\t     struct ocfs2_xattr_search *xbs,\n\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt,\n\t\t\t\t     int extra_meta,\n\t\t\t\t     int *credits)\n{\n\tint clusters_add, meta_add, ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmemset(ctxt, 0, sizeof(struct ocfs2_xattr_set_ctxt));\n\n\tocfs2_init_dealloc_ctxt(&ctxt->dealloc);\n\n\tret = ocfs2_calc_xattr_set_need(inode, di, xi, xis, xbs,\n\t\t\t\t\t&clusters_add, &meta_add, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmeta_add += extra_meta;\n\ttrace_ocfs2_init_xattr_set_ctxt(xi->xi_name, meta_add,\n\t\t\t\t\tclusters_add, *credits);\n\n\tif (meta_add) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, meta_add,\n\t\t\t\t\t\t\t&ctxt->meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_add) {\n\t\tret = ocfs2_reserve_clusters(osb, clusters_add, &ctxt->data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tif (ret) {\n\t\tif (ctxt->meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt->meta_ac);\n\t\t\tctxt->meta_ac = NULL;\n\t\t}\n\n\t\t/*\n\t\t * We cannot have an error and a non null ctxt->data_ac.\n\t\t */\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_init_xattr_set_ctxt(struct inode *inode,\n\t\t\t\t     struct ocfs2_dinode *di,\n\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t     struct ocfs2_xattr_search *xis,\n\t\t\t\t     struct ocfs2_xattr_search *xbs,\n\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt,\n\t\t\t\t     int extra_meta,\n\t\t\t\t     int *credits)\n{\n\tint clusters_add, meta_add, ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmemset(ctxt, 0, sizeof(struct ocfs2_xattr_set_ctxt));\n\n\tocfs2_init_dealloc_ctxt(&ctxt->dealloc);\n\n\tret = ocfs2_calc_xattr_set_need(inode, di, xi, xis, xbs,\n\t\t\t\t\t&clusters_add, &meta_add, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmeta_add += extra_meta;\n\ttrace_ocfs2_init_xattr_set_ctxt(xi->xi_name, meta_add,\n\t\t\t\t\tclusters_add, *credits);\n\n\tif (meta_add) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, meta_add,\n\t\t\t\t\t\t\t&ctxt->meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_add) {\n\t\tret = ocfs2_reserve_clusters(osb, clusters_add, &ctxt->data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tif (ret) {\n\t\tif (ctxt->meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt->meta_ac);\n\t\t\tctxt->meta_ac = NULL;\n\t\t}\n\n\t\t/*\n\t\t * We cannot have an error and a non null ctxt->data_ac.\n\t\t */\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 3608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 3606
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5956-6028",
          "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_needs_flush",
          "args": [
            "osb"
          ],
          "line": 3605
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_needs_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5775-5789",
          "snippet": "int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 3603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_refcount_xattr",
          "args": [
            "inode",
            "di",
            "&xi",
            "&xis",
            "&xbs",
            "&ref_tree",
            "&ref_meta",
            "&ref_credits"
          ],
          "line": 3594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_refcount_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5745-5869",
          "snippet": "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_add,\n\t\t\t\t\tint *credits)\n{\n\tint ret = 0;\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_xattr_entry *xe;\n\tchar *base;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\tint name_offset, name_len;\n\tstruct ocfs2_xattr_value_buf vb;\n\tstruct ocfs2_xattr_bucket *bucket = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_post_refcount refcount;\n\tstruct ocfs2_post_refcount *p = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\n\tif (!xis->not_found) {\n\t\txe = xis->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\tbase = xis->base;\n\t\tvb.vb_bh = xis->inode_bh;\n\t\tvb.vb_access = ocfs2_journal_access_di;\n\t} else {\n\t\tint i, block_off = 0;\n\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\t\txe = xbs->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\ti = xbs->here - xbs->header->xh_entries;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(xbs->bucket),\n\t\t\t\t\t\t\ti, &block_off,\n\t\t\t\t\t\t\t&name_offset);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbase = bucket_block(xbs->bucket, block_off);\n\t\t\tvb.vb_bh = xbs->bucket->bu_bhs[block_off];\n\t\t\tvb.vb_access = ocfs2_journal_access;\n\n\t\t\tif (ocfs2_meta_ecc(osb)) {\n\t\t\t\t/*create parameters for ocfs2_post_refcount. */\n\t\t\t\tbucket = xbs->bucket;\n\t\t\t\trefcount.credits = bucket->bu_blocks;\n\t\t\t\trefcount.para = bucket;\n\t\t\t\trefcount.func =\n\t\t\t\t\tocfs2_xattr_bucket_post_refcount;\n\t\t\t\tp = &refcount;\n\t\t\t}\n\t\t} else {\n\t\t\tbase = xbs->base;\n\t\t\tvb.vb_bh = xbs->xattr_bh;\n\t\t\tvb.vb_access = ocfs2_journal_access_xb;\n\t\t}\n\t}\n\n\tif (ocfs2_xattr_is_local(xe))\n\t\tgoto out;\n\n\tvb.vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(base + name_offset + name_len);\n\n\tret = ocfs2_xattr_get_clusters(inode, 0, &p_cluster,\n\t\t\t\t       &num_clusters, &vb.vb_xv->xr_list,\n\t\t\t\t       &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We just need to check the 1st extent record, since we always\n\t * CoW the whole xattr. So there shouldn't be a xattr with\n\t * some REFCOUNT extent recs after the 1st one.\n\t */\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we are deleting the xattr or the new size will be stored inside,\n\t * cool, leave it there, the xattr truncate process will remove them\n\t * for us(it still needs the refcount tree lock and the meta, credits).\n\t * And the worse case is that every cluster truncate will split the\n\t * refcount tree, and make the original extent become 3. So we will need\n\t * 2 * cluster more extent recs at most.\n\t */\n\tif (!xi->xi_value || xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE) {\n\n\t\tret = ocfs2_refcounted_xattr_delete_need(inode,\n\t\t\t\t\t\t\t &(*ref_tree)->rf_ci,\n\t\t\t\t\t\t\t ref_root_bh, vb.vb_xv,\n\t\t\t\t\t\t\t meta_add, credits);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_refcount_cow_xattr(inode, di, &vb,\n\t\t\t\t       *ref_tree, ref_root_bh, 0,\n\t\t\t\t       le32_to_cpu(vb.vb_xv->xr_clusters), p);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_add,\n\t\t\t\t\tint *credits)\n{\n\tint ret = 0;\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_xattr_entry *xe;\n\tchar *base;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\tint name_offset, name_len;\n\tstruct ocfs2_xattr_value_buf vb;\n\tstruct ocfs2_xattr_bucket *bucket = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_post_refcount refcount;\n\tstruct ocfs2_post_refcount *p = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\n\tif (!xis->not_found) {\n\t\txe = xis->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\tbase = xis->base;\n\t\tvb.vb_bh = xis->inode_bh;\n\t\tvb.vb_access = ocfs2_journal_access_di;\n\t} else {\n\t\tint i, block_off = 0;\n\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\t\txe = xbs->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\ti = xbs->here - xbs->header->xh_entries;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(xbs->bucket),\n\t\t\t\t\t\t\ti, &block_off,\n\t\t\t\t\t\t\t&name_offset);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbase = bucket_block(xbs->bucket, block_off);\n\t\t\tvb.vb_bh = xbs->bucket->bu_bhs[block_off];\n\t\t\tvb.vb_access = ocfs2_journal_access;\n\n\t\t\tif (ocfs2_meta_ecc(osb)) {\n\t\t\t\t/*create parameters for ocfs2_post_refcount. */\n\t\t\t\tbucket = xbs->bucket;\n\t\t\t\trefcount.credits = bucket->bu_blocks;\n\t\t\t\trefcount.para = bucket;\n\t\t\t\trefcount.func =\n\t\t\t\t\tocfs2_xattr_bucket_post_refcount;\n\t\t\t\tp = &refcount;\n\t\t\t}\n\t\t} else {\n\t\t\tbase = xbs->base;\n\t\t\tvb.vb_bh = xbs->xattr_bh;\n\t\t\tvb.vb_access = ocfs2_journal_access_xb;\n\t\t}\n\t}\n\n\tif (ocfs2_xattr_is_local(xe))\n\t\tgoto out;\n\n\tvb.vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(base + name_offset + name_len);\n\n\tret = ocfs2_xattr_get_clusters(inode, 0, &p_cluster,\n\t\t\t\t       &num_clusters, &vb.vb_xv->xr_list,\n\t\t\t\t       &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We just need to check the 1st extent record, since we always\n\t * CoW the whole xattr. So there shouldn't be a xattr with\n\t * some REFCOUNT extent recs after the 1st one.\n\t */\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we are deleting the xattr or the new size will be stored inside,\n\t * cool, leave it there, the xattr truncate process will remove them\n\t * for us(it still needs the refcount tree lock and the meta, credits).\n\t * And the worse case is that every cluster truncate will split the\n\t * refcount tree, and make the original extent become 3. So we will need\n\t * 2 * cluster more extent recs at most.\n\t */\n\tif (!xi->xi_value || xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE) {\n\n\t\tret = ocfs2_refcounted_xattr_delete_need(inode,\n\t\t\t\t\t\t\t &(*ref_tree)->rf_ci,\n\t\t\t\t\t\t\t ref_root_bh, vb.vb_xv,\n\t\t\t\t\t\t\t meta_add, credits);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_refcount_cow_xattr(inode, di, &vb,\n\t\t\t\t       *ref_tree, ref_root_bh, 0,\n\t\t\t\t       le32_to_cpu(vb.vb_xv->xr_clusters), p);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_block_find",
          "args": [
            "inode",
            "name_index",
            "name",
            "&xbs"
          ],
          "line": 3573
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_block_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2798-2843",
          "snippet": "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txs->xattr_bh = blk_bh;\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\txs->header = &xb->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)(blk_bh->b_data) + blk_bh->b_size;\n\t\txs->here = xs->header->xh_entries;\n\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t} else\n\t\tret = ocfs2_xattr_index_block_find(inode, blk_bh,\n\t\t\t\t\t\t   name_index,\n\t\t\t\t\t\t   name, xs);\n\n\tif (ret && ret != -ENODATA) {\n\t\txs->xattr_bh = NULL;\n\t\tgoto cleanup;\n\t}\n\txs->not_found = ret;\n\treturn 0;\ncleanup:\n\tbrelse(blk_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txs->xattr_bh = blk_bh;\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\txs->header = &xb->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)(blk_bh->b_data) + blk_bh->b_size;\n\t\txs->here = xs->header->xh_entries;\n\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t} else\n\t\tret = ocfs2_xattr_index_block_find(inode, blk_bh,\n\t\t\t\t\t\t   name_index,\n\t\t\t\t\t\t   name, xs);\n\n\tif (ret && ret != -ENODATA) {\n\t\txs->xattr_bh = NULL;\n\t\tgoto cleanup;\n\t}\n\txs->not_found = ret;\n\treturn 0;\ncleanup:\n\tbrelse(blk_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_ibody_find",
          "args": [
            "inode",
            "name_index",
            "name",
            "&xis"
          ],
          "line": 3569
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_ibody_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2658-2699",
          "snippet": "static int ocfs2_xattr_ibody_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tint ret;\n\tint has_space = 0;\n\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)\n\t\treturn 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)) {\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\thas_space = ocfs2_xattr_has_space_inline(inode, di);\n\t\tup_read(&oi->ip_alloc_sem);\n\t\tif (!has_space)\n\t\t\treturn 0;\n\t}\n\n\txs->xattr_bh = xs->inode_bh;\n\txs->end = (void *)di + inode->i_sb->s_blocksize;\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - le16_to_cpu(di->i_xattr_inline_size));\n\telse\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - OCFS2_SB(inode->i_sb)->s_xattr_inline_size);\n\txs->base = (void *)xs->header;\n\txs->here = xs->header->xh_entries;\n\n\t/* Find the named attribute. */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t\tif (ret && ret != -ENODATA)\n\t\t\treturn ret;\n\t\txs->not_found = ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_ibody_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tint ret;\n\tint has_space = 0;\n\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)\n\t\treturn 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)) {\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\thas_space = ocfs2_xattr_has_space_inline(inode, di);\n\t\tup_read(&oi->ip_alloc_sem);\n\t\tif (!has_space)\n\t\t\treturn 0;\n\t}\n\n\txs->xattr_bh = xs->inode_bh;\n\txs->end = (void *)di + inode->i_sb->s_blocksize;\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - le16_to_cpu(di->i_xattr_inline_size));\n\telse\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - OCFS2_SB(inode->i_sb)->s_xattr_inline_size);\n\txs->base = (void *)xs->header;\n\txs->here = xs->header->xh_entries;\n\n\t/* Find the named attribute. */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t\tif (ret && ret != -ENODATA)\n\t\t\treturn ret;\n\t\txs->not_found = ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&OCFS2_I(inode)->ip_xattr_sem"
          ],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "1"
          ],
          "line": 3556
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-ENOMEM"
          ],
          "line": 3552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_new",
          "args": [
            "inode"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "330-344",
          "snippet": "static struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_xattr",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "518-523",
          "snippet": "static inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 3530
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nint ocfs2_xattr_set(struct inode *inode,\n\t\t    int name_index,\n\t\t    const char *name,\n\t\t    const void *value,\n\t\t    size_t value_len,\n\t\t    int flags)\n{\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint ret, credits, ref_meta = 0, ref_credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Only xbs will be used on indexed trees.  xis doesn't need a\n\t * bucket.\n\t */\n\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xbs.bucket) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup_nolock;\n\t}\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\t/*\n\t * Scan inode and external block to find the same name\n\t * extended attribute and collect search information.\n\t */\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (xis.not_found && xbs.not_found) {\n\t\tret = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\tret = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Check whether the value is refcounted and do some preparation. */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&\n\t    (!xis.not_found || !xbs.not_found)) {\n\t\tret = ocfs2_prepare_refcount_xattr(inode, di, &xi,\n\t\t\t\t\t\t   &xis, &xbs, &ref_tree,\n\t\t\t\t\t\t   &ref_meta, &ref_credits);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tl_inode->i_mutex);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tret = ocfs2_init_xattr_set_ctxt(inode, di, &xi, &xis,\n\t\t\t\t\t&xbs, &ctxt, ref_meta, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* we need to update inode's ctime field, so add credit for it. */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\tctxt.handle = ocfs2_start_trans(osb, credits + ref_credits);\n\tif (IS_ERR(ctxt.handle)) {\n\t\tret = PTR_ERR(ctxt.handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_free_ac;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\tocfs2_update_inode_fsync_trans(ctxt.handle, inode, 0);\n\n\tocfs2_commit_trans(osb, ctxt.handle);\n\nout_free_ac:\n\tif (ctxt.data_ac)\n\t\tocfs2_free_alloc_context(ctxt.data_ac);\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tif (ocfs2_dealloc_has_cluster(&ctxt.dealloc))\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\ncleanup:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tif (!value && !ret) {\n\t\tret = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_inode_unlock(inode, 1);\ncleanup_nolock:\n\tbrelse(di_bh);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_set_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "3429-3503",
    "snippet": "int ocfs2_xattr_set_handle(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   const void *value,\n\t\t\t   size_t value_len,\n\t\t\t   int flags,\n\t\t\t   struct ocfs2_alloc_context *meta_ac,\n\t\t\t   struct ocfs2_alloc_context *data_ac)\n{\n\tstruct ocfs2_dinode *di;\n\tint ret;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_set_ctxt ctxt = {\n\t\t.handle = handle,\n\t\t.meta_ac = meta_ac,\n\t\t.data_ac = data_ac,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * In extreme situation, may need xattr bucket when\n\t * block size is too small. And we have already reserved\n\t * the credits for bucket in mknod.\n\t */\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE) {\n\t\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\t\tif (!xbs.bucket) {\n\t\t\tmlog_errno(-ENOMEM);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\ncleanup:\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_free",
          "args": [
            "xbs.bucket"
          ],
          "line": 3500
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "356-363",
          "snippet": "static void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "xbs.xattr_bh"
          ],
          "line": 3499
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&OCFS2_I(inode)->ip_xattr_sem"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 3498
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_xattr_set_handle",
          "args": [
            "inode",
            "di",
            "&xi",
            "&xis",
            "&xbs",
            "&ctxt"
          ],
          "line": 3495
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_xattr_set_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3288-3422",
          "snippet": "static int __ocfs2_xattr_set_handle(struct inode *inode,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct ocfs2_xattr_info *xi,\n\t\t\t\t    struct ocfs2_xattr_search *xis,\n\t\t\t\t    struct ocfs2_xattr_search *xbs,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret = 0, credits, old_found;\n\n\tif (!xi->xi_value) {\n\t\t/* Remove existing extended attribute */\n\t\tif (!xis->not_found)\n\t\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\telse if (!xbs->not_found)\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t} else {\n\t\t/* We always try to set extended attribute into inode first*/\n\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\tif (!ret && !xbs->not_found) {\n\t\t\t/*\n\t\t\t * If succeed and that extended attribute existing in\n\t\t\t * external block, then we will remove it.\n\t\t\t */\n\t\t\txi->xi_value = NULL;\n\t\t\txi->xi_value_len = 0;\n\n\t\t\told_found = xis->not_found;\n\t\t\txis->not_found = -ENODATA;\n\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&credits);\n\t\t\txis->not_found = old_found;\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t} else if ((ret == -ENOSPC) && !ctxt->set_abort) {\n\t\t\tif (di->i_xattr_loc && !xbs->xattr_bh) {\n\t\t\t\tret = ocfs2_xattr_block_find(inode,\n\t\t\t\t\t\t\t     xi->xi_name_index,\n\t\t\t\t\t\t\t     xi->xi_name, xbs);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\n\t\t\t\told_found = xis->not_found;\n\t\t\t\txis->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\txis->not_found = old_found;\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * If no space in inode, we will set extended attribute\n\t\t\t * into external block.\n\t\t\t */\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (!xis->not_found) {\n\t\t\t\t/*\n\t\t\t\t * If succeed and that extended attribute\n\t\t\t\t * existing in inode, we will remove it.\n\t\t\t\t */\n\t\t\t\txi->xi_value = NULL;\n\t\t\t\txi->xi_value_len = 0;\n\t\t\t\txbs->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = ocfs2_xattr_ibody_set(inode, xi,\n\t\t\t\t\t\t\t    xis, ctxt);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\t/* Update inode ctime. */\n\t\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t\t      xis->inode_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode->i_ctime = CURRENT_TIME;\n\t\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\t\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\t\tocfs2_journal_dirty(ctxt->handle, xis->inode_bh);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int __ocfs2_xattr_set_handle(struct inode *inode,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct ocfs2_xattr_info *xi,\n\t\t\t\t    struct ocfs2_xattr_search *xis,\n\t\t\t\t    struct ocfs2_xattr_search *xbs,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret = 0, credits, old_found;\n\n\tif (!xi->xi_value) {\n\t\t/* Remove existing extended attribute */\n\t\tif (!xis->not_found)\n\t\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\telse if (!xbs->not_found)\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t} else {\n\t\t/* We always try to set extended attribute into inode first*/\n\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\tif (!ret && !xbs->not_found) {\n\t\t\t/*\n\t\t\t * If succeed and that extended attribute existing in\n\t\t\t * external block, then we will remove it.\n\t\t\t */\n\t\t\txi->xi_value = NULL;\n\t\t\txi->xi_value_len = 0;\n\n\t\t\told_found = xis->not_found;\n\t\t\txis->not_found = -ENODATA;\n\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&credits);\n\t\t\txis->not_found = old_found;\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t} else if ((ret == -ENOSPC) && !ctxt->set_abort) {\n\t\t\tif (di->i_xattr_loc && !xbs->xattr_bh) {\n\t\t\t\tret = ocfs2_xattr_block_find(inode,\n\t\t\t\t\t\t\t     xi->xi_name_index,\n\t\t\t\t\t\t\t     xi->xi_name, xbs);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\n\t\t\t\told_found = xis->not_found;\n\t\t\t\txis->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\txis->not_found = old_found;\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * If no space in inode, we will set extended attribute\n\t\t\t * into external block.\n\t\t\t */\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (!xis->not_found) {\n\t\t\t\t/*\n\t\t\t\t * If succeed and that extended attribute\n\t\t\t\t * existing in inode, we will remove it.\n\t\t\t\t */\n\t\t\t\txi->xi_value = NULL;\n\t\t\t\txi->xi_value_len = 0;\n\t\t\t\txbs->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = ocfs2_xattr_ibody_set(inode, xi,\n\t\t\t\t\t\t\t    xis, ctxt);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\t/* Update inode ctime. */\n\t\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t\t      xis->inode_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode->i_ctime = CURRENT_TIME;\n\t\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\t\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\t\tocfs2_journal_dirty(ctxt->handle, xis->inode_bh);\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_block_find",
          "args": [
            "inode",
            "name_index",
            "name",
            "&xbs"
          ],
          "line": 3490
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_block_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2798-2843",
          "snippet": "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txs->xattr_bh = blk_bh;\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\txs->header = &xb->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)(blk_bh->b_data) + blk_bh->b_size;\n\t\txs->here = xs->header->xh_entries;\n\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t} else\n\t\tret = ocfs2_xattr_index_block_find(inode, blk_bh,\n\t\t\t\t\t\t   name_index,\n\t\t\t\t\t\t   name, xs);\n\n\tif (ret && ret != -ENODATA) {\n\t\txs->xattr_bh = NULL;\n\t\tgoto cleanup;\n\t}\n\txs->not_found = ret;\n\treturn 0;\ncleanup:\n\tbrelse(blk_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txs->xattr_bh = blk_bh;\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\txs->header = &xb->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)(blk_bh->b_data) + blk_bh->b_size;\n\t\txs->here = xs->header->xh_entries;\n\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t} else\n\t\tret = ocfs2_xattr_index_block_find(inode, blk_bh,\n\t\t\t\t\t\t   name_index,\n\t\t\t\t\t\t   name, xs);\n\n\tif (ret && ret != -ENODATA) {\n\t\txs->xattr_bh = NULL;\n\t\tgoto cleanup;\n\t}\n\txs->not_found = ret;\n\treturn 0;\ncleanup:\n\tbrelse(blk_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_ibody_find",
          "args": [
            "inode",
            "name_index",
            "name",
            "&xis"
          ],
          "line": 3486
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_ibody_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2658-2699",
          "snippet": "static int ocfs2_xattr_ibody_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tint ret;\n\tint has_space = 0;\n\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)\n\t\treturn 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)) {\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\thas_space = ocfs2_xattr_has_space_inline(inode, di);\n\t\tup_read(&oi->ip_alloc_sem);\n\t\tif (!has_space)\n\t\t\treturn 0;\n\t}\n\n\txs->xattr_bh = xs->inode_bh;\n\txs->end = (void *)di + inode->i_sb->s_blocksize;\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - le16_to_cpu(di->i_xattr_inline_size));\n\telse\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - OCFS2_SB(inode->i_sb)->s_xattr_inline_size);\n\txs->base = (void *)xs->header;\n\txs->here = xs->header->xh_entries;\n\n\t/* Find the named attribute. */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t\tif (ret && ret != -ENODATA)\n\t\t\treturn ret;\n\t\txs->not_found = ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_ibody_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tint ret;\n\tint has_space = 0;\n\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)\n\t\treturn 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)) {\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\thas_space = ocfs2_xattr_has_space_inline(inode, di);\n\t\tup_read(&oi->ip_alloc_sem);\n\t\tif (!has_space)\n\t\t\treturn 0;\n\t}\n\n\txs->xattr_bh = xs->inode_bh;\n\txs->end = (void *)di + inode->i_sb->s_blocksize;\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - le16_to_cpu(di->i_xattr_inline_size));\n\telse\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - OCFS2_SB(inode->i_sb)->s_xattr_inline_size);\n\txs->base = (void *)xs->header;\n\txs->here = xs->header->xh_entries;\n\n\t/* Find the named attribute. */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t\tif (ret && ret != -ENODATA)\n\t\t\treturn ret;\n\t\txs->not_found = ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&OCFS2_I(inode)->ip_xattr_sem"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-ENOMEM"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_new",
          "args": [
            "inode"
          ],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "330-344",
          "snippet": "static struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_xattr",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 3465
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "518-523",
          "snippet": "static inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nint ocfs2_xattr_set_handle(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   const void *value,\n\t\t\t   size_t value_len,\n\t\t\t   int flags,\n\t\t\t   struct ocfs2_alloc_context *meta_ac,\n\t\t\t   struct ocfs2_alloc_context *data_ac)\n{\n\tstruct ocfs2_dinode *di;\n\tint ret;\n\n\tstruct ocfs2_xattr_info xi = {\n\t\t.xi_name_index = name_index,\n\t\t.xi_name = name,\n\t\t.xi_name_len = strlen(name),\n\t\t.xi_value = value,\n\t\t.xi_value_len = value_len,\n\t};\n\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tstruct ocfs2_xattr_set_ctxt ctxt = {\n\t\t.handle = handle,\n\t\t.meta_ac = meta_ac,\n\t\t.data_ac = data_ac,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * In extreme situation, may need xattr bucket when\n\t * block size is too small. And we have already reserved\n\t * the credits for bucket in mknod.\n\t */\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE) {\n\t\txbs.bucket = ocfs2_xattr_bucket_new(inode);\n\t\tif (!xbs.bucket) {\n\t\t\tmlog_errno(-ENOMEM);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);\n\tif (ret)\n\t\tgoto cleanup;\n\tif (xis.not_found) {\n\t\tret = ocfs2_xattr_block_find(inode, name_index, name, &xbs);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt);\n\ncleanup:\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tbrelse(xbs.xattr_bh);\n\tocfs2_xattr_bucket_free(xbs.bucket);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_xattr_set_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "3288-3422",
    "snippet": "static int __ocfs2_xattr_set_handle(struct inode *inode,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct ocfs2_xattr_info *xi,\n\t\t\t\t    struct ocfs2_xattr_search *xis,\n\t\t\t\t    struct ocfs2_xattr_search *xbs,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret = 0, credits, old_found;\n\n\tif (!xi->xi_value) {\n\t\t/* Remove existing extended attribute */\n\t\tif (!xis->not_found)\n\t\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\telse if (!xbs->not_found)\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t} else {\n\t\t/* We always try to set extended attribute into inode first*/\n\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\tif (!ret && !xbs->not_found) {\n\t\t\t/*\n\t\t\t * If succeed and that extended attribute existing in\n\t\t\t * external block, then we will remove it.\n\t\t\t */\n\t\t\txi->xi_value = NULL;\n\t\t\txi->xi_value_len = 0;\n\n\t\t\told_found = xis->not_found;\n\t\t\txis->not_found = -ENODATA;\n\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&credits);\n\t\t\txis->not_found = old_found;\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t} else if ((ret == -ENOSPC) && !ctxt->set_abort) {\n\t\t\tif (di->i_xattr_loc && !xbs->xattr_bh) {\n\t\t\t\tret = ocfs2_xattr_block_find(inode,\n\t\t\t\t\t\t\t     xi->xi_name_index,\n\t\t\t\t\t\t\t     xi->xi_name, xbs);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\n\t\t\t\told_found = xis->not_found;\n\t\t\t\txis->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\txis->not_found = old_found;\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * If no space in inode, we will set extended attribute\n\t\t\t * into external block.\n\t\t\t */\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (!xis->not_found) {\n\t\t\t\t/*\n\t\t\t\t * If succeed and that extended attribute\n\t\t\t\t * existing in inode, we will remove it.\n\t\t\t\t */\n\t\t\t\txi->xi_value = NULL;\n\t\t\t\txi->xi_value_len = 0;\n\t\t\t\txbs->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = ocfs2_xattr_ibody_set(inode, xi,\n\t\t\t\t\t\t\t    xis, ctxt);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\t/* Update inode ctime. */\n\t\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t\t      xis->inode_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode->i_ctime = CURRENT_TIME;\n\t\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\t\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\t\tocfs2_journal_dirty(ctxt->handle, xis->inode_bh);\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "ctxt->handle",
            "xis->inode_bh"
          ],
          "line": 3418
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_nsec"
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "ctxt->handle",
            "INODE_CACHE(inode)",
            "xis->inode_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 3407
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 3407
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_ibody_set",
          "args": [
            "inode",
            "xi",
            "xis",
            "ctxt"
          ],
          "line": 3399
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_ibody_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2754-2790",
          "snippet": "static int ocfs2_xattr_ibody_set(struct inode *inode,\n\t\t\t\t struct ocfs2_xattr_info *xi,\n\t\t\t\t struct ocfs2_xattr_search *xs,\n\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xa_loc loc;\n\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)\n\t\treturn -ENOSPC;\n\n\tdown_write(&oi->ip_alloc_sem);\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)) {\n\t\tret = ocfs2_xattr_ibody_init(inode, xs->inode_bh, ctxt);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tocfs2_init_dinode_xa_loc(&loc, inode, xs->inode_bh,\n\t\t\t\t xs->not_found ? NULL : xs->here);\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\txs->here = loc.xl_entry;\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_ibody_set(struct inode *inode,\n\t\t\t\t struct ocfs2_xattr_info *xi,\n\t\t\t\t struct ocfs2_xattr_search *xs,\n\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xa_loc loc;\n\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)\n\t\treturn -ENOSPC;\n\n\tdown_write(&oi->ip_alloc_sem);\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)) {\n\t\tret = ocfs2_xattr_ibody_init(inode, xs->inode_bh, ctxt);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tocfs2_init_dinode_xa_loc(&loc, inode, xs->inode_bh,\n\t\t\t\t xs->not_found ? NULL : xs->here);\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\txs->here = loc.xl_entry;\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "ctxt->handle",
            "credits"
          ],
          "line": 3394
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_xattr_set_need",
          "args": [
            "inode",
            "di",
            "xi",
            "xis",
            "xbs",
            "NULL",
            "NULL",
            "&credits"
          ],
          "line": 3381
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_xattr_set_need",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3020-3230",
          "snippet": "static int ocfs2_calc_xattr_set_need(struct inode *inode,\n\t\t\t\t     struct ocfs2_dinode *di,\n\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t     struct ocfs2_xattr_search *xis,\n\t\t\t\t     struct ocfs2_xattr_search *xbs,\n\t\t\t\t     int *clusters_need,\n\t\t\t\t     int *meta_need,\n\t\t\t\t     int *credits_need)\n{\n\tint ret = 0, old_in_xb = 0;\n\tint clusters_add = 0, meta_add = 0, credits = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_xattr_block *xb = NULL;\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tstruct ocfs2_xattr_value_root *xv = NULL;\n\tchar *base = NULL;\n\tint name_offset, name_len = 0;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t    xi->xi_value_len);\n\tu64 value_size;\n\n\t/*\n\t * Calculate the clusters we need to write.\n\t * No matter whether we replace an old one or add a new one,\n\t * we need this for writing.\n\t */\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\tcredits += new_clusters *\n\t\t\t   ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\n\tif (xis->not_found && xbs->not_found) {\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t}\n\n\t\tgoto meta_guess;\n\t}\n\n\tif (!xis->not_found) {\n\t\txe = xis->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\tbase = xis->base;\n\t\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\t} else {\n\t\tint i, block_off = 0;\n\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\t\txe = xbs->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\ti = xbs->here - xbs->header->xh_entries;\n\t\told_in_xb = 1;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(xbs->bucket),\n\t\t\t\t\t\t\ti, &block_off,\n\t\t\t\t\t\t\t&name_offset);\n\t\t\tbase = bucket_block(xbs->bucket, block_off);\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t} else {\n\t\t\tbase = xbs->base;\n\t\t\tcredits += OCFS2_XATTR_BLOCK_UPDATE_CREDITS;\n\t\t}\n\t}\n\n\t/*\n\t * delete a xattr doesn't need metadata and cluster allocation.\n\t * so just calculate the credits and return.\n\t *\n\t * The credits for removing the value tree will be extended\n\t * by ocfs2_remove_extent itself.\n\t */\n\tif (!xi->xi_value) {\n\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\n\t\tgoto out;\n\t}\n\n\t/* do cluster allocation guess first. */\n\tvalue_size = le64_to_cpu(xe->xe_value_size);\n\n\tif (old_in_xb) {\n\t\t/*\n\t\t * In xattr set, we always try to set the xe in inode first,\n\t\t * so if it can be inserted into inode successfully, the old\n\t\t * one will be removed from the xattr block, and this xattr\n\t\t * will be inserted into inode as a new xattr in inode.\n\t\t */\n\t\tif (ocfs2_xattr_can_be_in_inode(inode, xi, xis)) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb) +\n\t\t\t\t    OCFS2_INODE_UPDATE_CREDITS;\n\t\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\t\tcredits += ocfs2_calc_extend_credits(\n\t\t\t\t\t\t\tinode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t/* the new values will be stored outside. */\n\t\tu32 old_clusters = 0;\n\n\t\tif (!ocfs2_xattr_is_local(xe)) {\n\t\t\told_clusters =\tocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t\t\t value_size);\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t     (base + name_offset + name_len);\n\t\t\tvalue_size = OCFS2_XATTR_ROOT_SIZE;\n\t\t} else\n\t\t\txv = &def_xv.xv;\n\n\t\tif (old_clusters >= new_clusters) {\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tmeta_add += ocfs2_extend_meta_needed(&xv->xr_list);\n\t\t\tclusters_add += new_clusters - old_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     &xv->xr_list);\n\t\t\tif (value_size >= OCFS2_XATTR_ROOT_SIZE)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Now the new value will be stored inside. So if the new\n\t\t * value is smaller than the size of value root or the old\n\t\t * value, we don't need any allocation, otherwise we have\n\t\t * to guess metadata allocation.\n\t\t */\n\t\tif ((ocfs2_xattr_is_local(xe) &&\n\t\t     (value_size >= xi->xi_value_len)) ||\n\t\t    (!ocfs2_xattr_is_local(xe) &&\n\t\t     OCFS2_XATTR_ROOT_SIZE >= xi->xi_value_len))\n\t\t\tgoto out;\n\t}\n\nmeta_guess:\n\t/* calculate metadata allocation. */\n\tif (di->i_xattr_loc) {\n\t\tif (!xbs->xattr_bh) {\n\t\t\tret = ocfs2_read_xattr_block(inode,\n\t\t\t\t\t\t     le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t\t\t     &bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\txb = (struct ocfs2_xattr_block *)bh->b_data;\n\t\t} else\n\t\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\n\t\t/*\n\t\t * If there is already an xattr tree, good, we can calculate\n\t\t * like other b-trees. Otherwise we may have the chance of\n\t\t * create a tree, the credit calculation is borrowed from\n\t\t * ocfs2_calc_extend_credits with root_el = NULL. And the\n\t\t * new tree will be cluster based, so no meta is needed.\n\t\t */\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tstruct ocfs2_extent_list *el =\n\t\t\t\t &xb->xb_attrs.xb_root.xt_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else\n\t\t\tcredits += OCFS2_SUBALLOC_ALLOC + 1;\n\n\t\t/*\n\t\t * This cluster will be used either for new bucket or for\n\t\t * new xattr block.\n\t\t * If the cluster size is the same as the bucket size, one\n\t\t * more is needed since we may need to extend the bucket\n\t\t * also.\n\t\t */\n\t\tclusters_add += 1;\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\tif (OCFS2_XATTR_BUCKET_SIZE ==\n\t\t\tOCFS2_SB(inode->i_sb)->s_clustersize) {\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t\tclusters_add += 1;\n\t\t}\n\t} else {\n\t\tcredits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tstruct ocfs2_extent_list *el = &def_xv.xv.xr_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else {\n\t\t\tmeta_add += 1;\n\t\t}\n\t}\nout:\n\tif (clusters_need)\n\t\t*clusters_need = clusters_add;\n\tif (meta_need)\n\t\t*meta_need = meta_add;\n\tif (credits_need)\n\t\t*credits_need = credits;\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80",
            "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
          ],
          "globals_used": [
            "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);",
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_calc_xattr_set_need(struct inode *inode,\n\t\t\t\t     struct ocfs2_dinode *di,\n\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t     struct ocfs2_xattr_search *xis,\n\t\t\t\t     struct ocfs2_xattr_search *xbs,\n\t\t\t\t     int *clusters_need,\n\t\t\t\t     int *meta_need,\n\t\t\t\t     int *credits_need)\n{\n\tint ret = 0, old_in_xb = 0;\n\tint clusters_add = 0, meta_add = 0, credits = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_xattr_block *xb = NULL;\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tstruct ocfs2_xattr_value_root *xv = NULL;\n\tchar *base = NULL;\n\tint name_offset, name_len = 0;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t    xi->xi_value_len);\n\tu64 value_size;\n\n\t/*\n\t * Calculate the clusters we need to write.\n\t * No matter whether we replace an old one or add a new one,\n\t * we need this for writing.\n\t */\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\tcredits += new_clusters *\n\t\t\t   ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\n\tif (xis->not_found && xbs->not_found) {\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t}\n\n\t\tgoto meta_guess;\n\t}\n\n\tif (!xis->not_found) {\n\t\txe = xis->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\tbase = xis->base;\n\t\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\t} else {\n\t\tint i, block_off = 0;\n\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\t\txe = xbs->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\ti = xbs->here - xbs->header->xh_entries;\n\t\told_in_xb = 1;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(xbs->bucket),\n\t\t\t\t\t\t\ti, &block_off,\n\t\t\t\t\t\t\t&name_offset);\n\t\t\tbase = bucket_block(xbs->bucket, block_off);\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t} else {\n\t\t\tbase = xbs->base;\n\t\t\tcredits += OCFS2_XATTR_BLOCK_UPDATE_CREDITS;\n\t\t}\n\t}\n\n\t/*\n\t * delete a xattr doesn't need metadata and cluster allocation.\n\t * so just calculate the credits and return.\n\t *\n\t * The credits for removing the value tree will be extended\n\t * by ocfs2_remove_extent itself.\n\t */\n\tif (!xi->xi_value) {\n\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\n\t\tgoto out;\n\t}\n\n\t/* do cluster allocation guess first. */\n\tvalue_size = le64_to_cpu(xe->xe_value_size);\n\n\tif (old_in_xb) {\n\t\t/*\n\t\t * In xattr set, we always try to set the xe in inode first,\n\t\t * so if it can be inserted into inode successfully, the old\n\t\t * one will be removed from the xattr block, and this xattr\n\t\t * will be inserted into inode as a new xattr in inode.\n\t\t */\n\t\tif (ocfs2_xattr_can_be_in_inode(inode, xi, xis)) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb) +\n\t\t\t\t    OCFS2_INODE_UPDATE_CREDITS;\n\t\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\t\tcredits += ocfs2_calc_extend_credits(\n\t\t\t\t\t\t\tinode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t/* the new values will be stored outside. */\n\t\tu32 old_clusters = 0;\n\n\t\tif (!ocfs2_xattr_is_local(xe)) {\n\t\t\told_clusters =\tocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t\t\t value_size);\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t     (base + name_offset + name_len);\n\t\t\tvalue_size = OCFS2_XATTR_ROOT_SIZE;\n\t\t} else\n\t\t\txv = &def_xv.xv;\n\n\t\tif (old_clusters >= new_clusters) {\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tmeta_add += ocfs2_extend_meta_needed(&xv->xr_list);\n\t\t\tclusters_add += new_clusters - old_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     &xv->xr_list);\n\t\t\tif (value_size >= OCFS2_XATTR_ROOT_SIZE)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Now the new value will be stored inside. So if the new\n\t\t * value is smaller than the size of value root or the old\n\t\t * value, we don't need any allocation, otherwise we have\n\t\t * to guess metadata allocation.\n\t\t */\n\t\tif ((ocfs2_xattr_is_local(xe) &&\n\t\t     (value_size >= xi->xi_value_len)) ||\n\t\t    (!ocfs2_xattr_is_local(xe) &&\n\t\t     OCFS2_XATTR_ROOT_SIZE >= xi->xi_value_len))\n\t\t\tgoto out;\n\t}\n\nmeta_guess:\n\t/* calculate metadata allocation. */\n\tif (di->i_xattr_loc) {\n\t\tif (!xbs->xattr_bh) {\n\t\t\tret = ocfs2_read_xattr_block(inode,\n\t\t\t\t\t\t     le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t\t\t     &bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\txb = (struct ocfs2_xattr_block *)bh->b_data;\n\t\t} else\n\t\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\n\t\t/*\n\t\t * If there is already an xattr tree, good, we can calculate\n\t\t * like other b-trees. Otherwise we may have the chance of\n\t\t * create a tree, the credit calculation is borrowed from\n\t\t * ocfs2_calc_extend_credits with root_el = NULL. And the\n\t\t * new tree will be cluster based, so no meta is needed.\n\t\t */\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tstruct ocfs2_extent_list *el =\n\t\t\t\t &xb->xb_attrs.xb_root.xt_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else\n\t\t\tcredits += OCFS2_SUBALLOC_ALLOC + 1;\n\n\t\t/*\n\t\t * This cluster will be used either for new bucket or for\n\t\t * new xattr block.\n\t\t * If the cluster size is the same as the bucket size, one\n\t\t * more is needed since we may need to extend the bucket\n\t\t * also.\n\t\t */\n\t\tclusters_add += 1;\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\tif (OCFS2_XATTR_BUCKET_SIZE ==\n\t\t\tOCFS2_SB(inode->i_sb)->s_clustersize) {\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t\tclusters_add += 1;\n\t\t}\n\t} else {\n\t\tcredits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tstruct ocfs2_extent_list *el = &def_xv.xv.xr_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else {\n\t\t\tmeta_add += 1;\n\t\t}\n\t}\nout:\n\tif (clusters_need)\n\t\t*clusters_need = clusters_add;\n\tif (meta_need)\n\t\t*meta_need = meta_add;\n\tif (credits_need)\n\t\t*credits_need = credits;\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_block_set",
          "args": [
            "inode",
            "xi",
            "xbs",
            "ctxt"
          ],
          "line": 3370
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_block_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2937-2985",
          "snippet": "static int ocfs2_xattr_block_set(struct inode *inode,\n\t\t\t\t struct ocfs2_xattr_info *xi,\n\t\t\t\t struct ocfs2_xattr_search *xs,\n\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_xattr_block *xblk = NULL;\n\tint ret;\n\tstruct ocfs2_xa_loc loc;\n\n\tif (!xs->xattr_bh) {\n\t\tret = ocfs2_create_xattr_block(inode, xs->inode_bh, ctxt,\n\t\t\t\t\t       0, &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto end;\n\t\t}\n\n\t\txs->xattr_bh = new_bh;\n\t\txblk = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\t\txs->header = &xblk->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)xblk + inode->i_sb->s_blocksize;\n\t\txs->here = xs->header->xh_entries;\n\t} else\n\t\txblk = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\n\tif (!(le16_to_cpu(xblk->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tocfs2_init_xattr_block_xa_loc(&loc, inode, xs->xattr_bh,\n\t\t\t\t\t      xs->not_found ? NULL : xs->here);\n\n\t\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\t\tif (!ret)\n\t\t\txs->here = loc.xl_entry;\n\t\telse if ((ret != -ENOSPC) || ctxt->set_abort)\n\t\t\tgoto end;\n\t\telse {\n\t\t\tret = ocfs2_xattr_create_index_block(inode, xs, ctxt);\n\t\t\tif (ret)\n\t\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (le16_to_cpu(xblk->xb_flags) & OCFS2_XATTR_INDEXED)\n\t\tret = ocfs2_xattr_set_entry_index_block(inode, xi, xs, ctxt);\n\nend:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_block_set(struct inode *inode,\n\t\t\t\t struct ocfs2_xattr_info *xi,\n\t\t\t\t struct ocfs2_xattr_search *xs,\n\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_xattr_block *xblk = NULL;\n\tint ret;\n\tstruct ocfs2_xa_loc loc;\n\n\tif (!xs->xattr_bh) {\n\t\tret = ocfs2_create_xattr_block(inode, xs->inode_bh, ctxt,\n\t\t\t\t\t       0, &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto end;\n\t\t}\n\n\t\txs->xattr_bh = new_bh;\n\t\txblk = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\t\txs->header = &xblk->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)xblk + inode->i_sb->s_blocksize;\n\t\txs->here = xs->header->xh_entries;\n\t} else\n\t\txblk = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\n\tif (!(le16_to_cpu(xblk->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tocfs2_init_xattr_block_xa_loc(&loc, inode, xs->xattr_bh,\n\t\t\t\t\t      xs->not_found ? NULL : xs->here);\n\n\t\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\t\tif (!ret)\n\t\t\txs->here = loc.xl_entry;\n\t\telse if ((ret != -ENOSPC) || ctxt->set_abort)\n\t\t\tgoto end;\n\t\telse {\n\t\t\tret = ocfs2_xattr_create_index_block(inode, xs, ctxt);\n\t\t\tif (ret)\n\t\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (le16_to_cpu(xblk->xb_flags) & OCFS2_XATTR_INDEXED)\n\t\tret = ocfs2_xattr_set_entry_index_block(inode, xi, xs, ctxt);\n\nend:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_block_find",
          "args": [
            "inode",
            "xi->xi_name_index",
            "xi->xi_name",
            "xbs"
          ],
          "line": 3338
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_block_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2798-2843",
          "snippet": "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txs->xattr_bh = blk_bh;\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\txs->header = &xb->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)(blk_bh->b_data) + blk_bh->b_size;\n\t\txs->here = xs->header->xh_entries;\n\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t} else\n\t\tret = ocfs2_xattr_index_block_find(inode, blk_bh,\n\t\t\t\t\t\t   name_index,\n\t\t\t\t\t\t   name, xs);\n\n\tif (ret && ret != -ENODATA) {\n\t\txs->xattr_bh = NULL;\n\t\tgoto cleanup;\n\t}\n\txs->not_found = ret;\n\treturn 0;\ncleanup:\n\tbrelse(blk_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txs->xattr_bh = blk_bh;\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\txs->header = &xb->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)(blk_bh->b_data) + blk_bh->b_size;\n\t\txs->here = xs->header->xh_entries;\n\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t} else\n\t\tret = ocfs2_xattr_index_block_find(inode, blk_bh,\n\t\t\t\t\t\t   name_index,\n\t\t\t\t\t\t   name, xs);\n\n\tif (ret && ret != -ENODATA) {\n\t\txs->xattr_bh = NULL;\n\t\tgoto cleanup;\n\t}\n\txs->not_found = ret;\n\treturn 0;\ncleanup:\n\tbrelse(blk_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int __ocfs2_xattr_set_handle(struct inode *inode,\n\t\t\t\t    struct ocfs2_dinode *di,\n\t\t\t\t    struct ocfs2_xattr_info *xi,\n\t\t\t\t    struct ocfs2_xattr_search *xis,\n\t\t\t\t    struct ocfs2_xattr_search *xbs,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret = 0, credits, old_found;\n\n\tif (!xi->xi_value) {\n\t\t/* Remove existing extended attribute */\n\t\tif (!xis->not_found)\n\t\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\telse if (!xbs->not_found)\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t} else {\n\t\t/* We always try to set extended attribute into inode first*/\n\t\tret = ocfs2_xattr_ibody_set(inode, xi, xis, ctxt);\n\t\tif (!ret && !xbs->not_found) {\n\t\t\t/*\n\t\t\t * If succeed and that extended attribute existing in\n\t\t\t * external block, then we will remove it.\n\t\t\t */\n\t\t\txi->xi_value = NULL;\n\t\t\txi->xi_value_len = 0;\n\n\t\t\told_found = xis->not_found;\n\t\t\txis->not_found = -ENODATA;\n\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&credits);\n\t\t\txis->not_found = old_found;\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t} else if ((ret == -ENOSPC) && !ctxt->set_abort) {\n\t\t\tif (di->i_xattr_loc && !xbs->xattr_bh) {\n\t\t\t\tret = ocfs2_xattr_block_find(inode,\n\t\t\t\t\t\t\t     xi->xi_name_index,\n\t\t\t\t\t\t\t     xi->xi_name, xbs);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\n\t\t\t\told_found = xis->not_found;\n\t\t\t\txis->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\txis->not_found = old_found;\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * If no space in inode, we will set extended attribute\n\t\t\t * into external block.\n\t\t\t */\n\t\t\tret = ocfs2_xattr_block_set(inode, xi, xbs, ctxt);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (!xis->not_found) {\n\t\t\t\t/*\n\t\t\t\t * If succeed and that extended attribute\n\t\t\t\t * existing in inode, we will remove it.\n\t\t\t\t */\n\t\t\t\txi->xi_value = NULL;\n\t\t\t\txi->xi_value_len = 0;\n\t\t\t\txbs->not_found = -ENODATA;\n\t\t\t\tret = ocfs2_calc_xattr_set_need(inode,\n\t\t\t\t\t\t\t\tdi,\n\t\t\t\t\t\t\t\txi,\n\t\t\t\t\t\t\t\txis,\n\t\t\t\t\t\t\t\txbs,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t&credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = ocfs2_extend_trans(ctxt->handle, credits);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = ocfs2_xattr_ibody_set(inode, xi,\n\t\t\t\t\t\t\t    xis, ctxt);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\t/* Update inode ctime. */\n\t\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t\t      xis->inode_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode->i_ctime = CURRENT_TIME;\n\t\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\t\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\t\tocfs2_journal_dirty(ctxt->handle, xis->inode_bh);\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_init_xattr_set_ctxt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "3232-3286",
    "snippet": "static int ocfs2_init_xattr_set_ctxt(struct inode *inode,\n\t\t\t\t     struct ocfs2_dinode *di,\n\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t     struct ocfs2_xattr_search *xis,\n\t\t\t\t     struct ocfs2_xattr_search *xbs,\n\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt,\n\t\t\t\t     int extra_meta,\n\t\t\t\t     int *credits)\n{\n\tint clusters_add, meta_add, ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmemset(ctxt, 0, sizeof(struct ocfs2_xattr_set_ctxt));\n\n\tocfs2_init_dealloc_ctxt(&ctxt->dealloc);\n\n\tret = ocfs2_calc_xattr_set_need(inode, di, xi, xis, xbs,\n\t\t\t\t\t&clusters_add, &meta_add, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmeta_add += extra_meta;\n\ttrace_ocfs2_init_xattr_set_ctxt(xi->xi_name, meta_add,\n\t\t\t\t\tclusters_add, *credits);\n\n\tif (meta_add) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, meta_add,\n\t\t\t\t\t\t\t&ctxt->meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_add) {\n\t\tret = ocfs2_reserve_clusters(osb, clusters_add, &ctxt->data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tif (ret) {\n\t\tif (ctxt->meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt->meta_ac);\n\t\t\tctxt->meta_ac = NULL;\n\t\t}\n\n\t\t/*\n\t\t * We cannot have an error and a non null ctxt->data_ac.\n\t\t */\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "ctxt->meta_ac"
          ],
          "line": 3276
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters",
          "args": [
            "osb",
            "clusters_add",
            "&ctxt->data_ac"
          ],
          "line": 3269
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1228-1234",
          "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "osb",
            "meta_add",
            "&ctxt->meta_ac"
          ],
          "line": 3260
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_init_xattr_set_ctxt",
          "args": [
            "xi->xi_name",
            "meta_add",
            "clusters_add",
            "*credits"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_xattr_set_need",
          "args": [
            "inode",
            "di",
            "xi",
            "xis",
            "xbs",
            "&clusters_add",
            "&meta_add",
            "credits"
          ],
          "line": 3248
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_xattr_set_need",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3020-3230",
          "snippet": "static int ocfs2_calc_xattr_set_need(struct inode *inode,\n\t\t\t\t     struct ocfs2_dinode *di,\n\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t     struct ocfs2_xattr_search *xis,\n\t\t\t\t     struct ocfs2_xattr_search *xbs,\n\t\t\t\t     int *clusters_need,\n\t\t\t\t     int *meta_need,\n\t\t\t\t     int *credits_need)\n{\n\tint ret = 0, old_in_xb = 0;\n\tint clusters_add = 0, meta_add = 0, credits = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_xattr_block *xb = NULL;\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tstruct ocfs2_xattr_value_root *xv = NULL;\n\tchar *base = NULL;\n\tint name_offset, name_len = 0;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t    xi->xi_value_len);\n\tu64 value_size;\n\n\t/*\n\t * Calculate the clusters we need to write.\n\t * No matter whether we replace an old one or add a new one,\n\t * we need this for writing.\n\t */\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\tcredits += new_clusters *\n\t\t\t   ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\n\tif (xis->not_found && xbs->not_found) {\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t}\n\n\t\tgoto meta_guess;\n\t}\n\n\tif (!xis->not_found) {\n\t\txe = xis->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\tbase = xis->base;\n\t\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\t} else {\n\t\tint i, block_off = 0;\n\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\t\txe = xbs->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\ti = xbs->here - xbs->header->xh_entries;\n\t\told_in_xb = 1;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(xbs->bucket),\n\t\t\t\t\t\t\ti, &block_off,\n\t\t\t\t\t\t\t&name_offset);\n\t\t\tbase = bucket_block(xbs->bucket, block_off);\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t} else {\n\t\t\tbase = xbs->base;\n\t\t\tcredits += OCFS2_XATTR_BLOCK_UPDATE_CREDITS;\n\t\t}\n\t}\n\n\t/*\n\t * delete a xattr doesn't need metadata and cluster allocation.\n\t * so just calculate the credits and return.\n\t *\n\t * The credits for removing the value tree will be extended\n\t * by ocfs2_remove_extent itself.\n\t */\n\tif (!xi->xi_value) {\n\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\n\t\tgoto out;\n\t}\n\n\t/* do cluster allocation guess first. */\n\tvalue_size = le64_to_cpu(xe->xe_value_size);\n\n\tif (old_in_xb) {\n\t\t/*\n\t\t * In xattr set, we always try to set the xe in inode first,\n\t\t * so if it can be inserted into inode successfully, the old\n\t\t * one will be removed from the xattr block, and this xattr\n\t\t * will be inserted into inode as a new xattr in inode.\n\t\t */\n\t\tif (ocfs2_xattr_can_be_in_inode(inode, xi, xis)) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb) +\n\t\t\t\t    OCFS2_INODE_UPDATE_CREDITS;\n\t\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\t\tcredits += ocfs2_calc_extend_credits(\n\t\t\t\t\t\t\tinode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t/* the new values will be stored outside. */\n\t\tu32 old_clusters = 0;\n\n\t\tif (!ocfs2_xattr_is_local(xe)) {\n\t\t\told_clusters =\tocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t\t\t value_size);\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t     (base + name_offset + name_len);\n\t\t\tvalue_size = OCFS2_XATTR_ROOT_SIZE;\n\t\t} else\n\t\t\txv = &def_xv.xv;\n\n\t\tif (old_clusters >= new_clusters) {\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tmeta_add += ocfs2_extend_meta_needed(&xv->xr_list);\n\t\t\tclusters_add += new_clusters - old_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     &xv->xr_list);\n\t\t\tif (value_size >= OCFS2_XATTR_ROOT_SIZE)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Now the new value will be stored inside. So if the new\n\t\t * value is smaller than the size of value root or the old\n\t\t * value, we don't need any allocation, otherwise we have\n\t\t * to guess metadata allocation.\n\t\t */\n\t\tif ((ocfs2_xattr_is_local(xe) &&\n\t\t     (value_size >= xi->xi_value_len)) ||\n\t\t    (!ocfs2_xattr_is_local(xe) &&\n\t\t     OCFS2_XATTR_ROOT_SIZE >= xi->xi_value_len))\n\t\t\tgoto out;\n\t}\n\nmeta_guess:\n\t/* calculate metadata allocation. */\n\tif (di->i_xattr_loc) {\n\t\tif (!xbs->xattr_bh) {\n\t\t\tret = ocfs2_read_xattr_block(inode,\n\t\t\t\t\t\t     le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t\t\t     &bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\txb = (struct ocfs2_xattr_block *)bh->b_data;\n\t\t} else\n\t\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\n\t\t/*\n\t\t * If there is already an xattr tree, good, we can calculate\n\t\t * like other b-trees. Otherwise we may have the chance of\n\t\t * create a tree, the credit calculation is borrowed from\n\t\t * ocfs2_calc_extend_credits with root_el = NULL. And the\n\t\t * new tree will be cluster based, so no meta is needed.\n\t\t */\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tstruct ocfs2_extent_list *el =\n\t\t\t\t &xb->xb_attrs.xb_root.xt_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else\n\t\t\tcredits += OCFS2_SUBALLOC_ALLOC + 1;\n\n\t\t/*\n\t\t * This cluster will be used either for new bucket or for\n\t\t * new xattr block.\n\t\t * If the cluster size is the same as the bucket size, one\n\t\t * more is needed since we may need to extend the bucket\n\t\t * also.\n\t\t */\n\t\tclusters_add += 1;\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\tif (OCFS2_XATTR_BUCKET_SIZE ==\n\t\t\tOCFS2_SB(inode->i_sb)->s_clustersize) {\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t\tclusters_add += 1;\n\t\t}\n\t} else {\n\t\tcredits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tstruct ocfs2_extent_list *el = &def_xv.xv.xr_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else {\n\t\t\tmeta_add += 1;\n\t\t}\n\t}\nout:\n\tif (clusters_need)\n\t\t*clusters_need = clusters_add;\n\tif (meta_need)\n\t\t*meta_need = meta_add;\n\tif (credits_need)\n\t\t*credits_need = credits;\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80",
            "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
          ],
          "globals_used": [
            "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);",
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_calc_xattr_set_need(struct inode *inode,\n\t\t\t\t     struct ocfs2_dinode *di,\n\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t     struct ocfs2_xattr_search *xis,\n\t\t\t\t     struct ocfs2_xattr_search *xbs,\n\t\t\t\t     int *clusters_need,\n\t\t\t\t     int *meta_need,\n\t\t\t\t     int *credits_need)\n{\n\tint ret = 0, old_in_xb = 0;\n\tint clusters_add = 0, meta_add = 0, credits = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_xattr_block *xb = NULL;\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tstruct ocfs2_xattr_value_root *xv = NULL;\n\tchar *base = NULL;\n\tint name_offset, name_len = 0;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t    xi->xi_value_len);\n\tu64 value_size;\n\n\t/*\n\t * Calculate the clusters we need to write.\n\t * No matter whether we replace an old one or add a new one,\n\t * we need this for writing.\n\t */\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\tcredits += new_clusters *\n\t\t\t   ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\n\tif (xis->not_found && xbs->not_found) {\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t}\n\n\t\tgoto meta_guess;\n\t}\n\n\tif (!xis->not_found) {\n\t\txe = xis->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\tbase = xis->base;\n\t\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\t} else {\n\t\tint i, block_off = 0;\n\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\t\txe = xbs->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\ti = xbs->here - xbs->header->xh_entries;\n\t\told_in_xb = 1;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(xbs->bucket),\n\t\t\t\t\t\t\ti, &block_off,\n\t\t\t\t\t\t\t&name_offset);\n\t\t\tbase = bucket_block(xbs->bucket, block_off);\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t} else {\n\t\t\tbase = xbs->base;\n\t\t\tcredits += OCFS2_XATTR_BLOCK_UPDATE_CREDITS;\n\t\t}\n\t}\n\n\t/*\n\t * delete a xattr doesn't need metadata and cluster allocation.\n\t * so just calculate the credits and return.\n\t *\n\t * The credits for removing the value tree will be extended\n\t * by ocfs2_remove_extent itself.\n\t */\n\tif (!xi->xi_value) {\n\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\n\t\tgoto out;\n\t}\n\n\t/* do cluster allocation guess first. */\n\tvalue_size = le64_to_cpu(xe->xe_value_size);\n\n\tif (old_in_xb) {\n\t\t/*\n\t\t * In xattr set, we always try to set the xe in inode first,\n\t\t * so if it can be inserted into inode successfully, the old\n\t\t * one will be removed from the xattr block, and this xattr\n\t\t * will be inserted into inode as a new xattr in inode.\n\t\t */\n\t\tif (ocfs2_xattr_can_be_in_inode(inode, xi, xis)) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb) +\n\t\t\t\t    OCFS2_INODE_UPDATE_CREDITS;\n\t\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\t\tcredits += ocfs2_calc_extend_credits(\n\t\t\t\t\t\t\tinode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t/* the new values will be stored outside. */\n\t\tu32 old_clusters = 0;\n\n\t\tif (!ocfs2_xattr_is_local(xe)) {\n\t\t\told_clusters =\tocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t\t\t value_size);\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t     (base + name_offset + name_len);\n\t\t\tvalue_size = OCFS2_XATTR_ROOT_SIZE;\n\t\t} else\n\t\t\txv = &def_xv.xv;\n\n\t\tif (old_clusters >= new_clusters) {\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tmeta_add += ocfs2_extend_meta_needed(&xv->xr_list);\n\t\t\tclusters_add += new_clusters - old_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     &xv->xr_list);\n\t\t\tif (value_size >= OCFS2_XATTR_ROOT_SIZE)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Now the new value will be stored inside. So if the new\n\t\t * value is smaller than the size of value root or the old\n\t\t * value, we don't need any allocation, otherwise we have\n\t\t * to guess metadata allocation.\n\t\t */\n\t\tif ((ocfs2_xattr_is_local(xe) &&\n\t\t     (value_size >= xi->xi_value_len)) ||\n\t\t    (!ocfs2_xattr_is_local(xe) &&\n\t\t     OCFS2_XATTR_ROOT_SIZE >= xi->xi_value_len))\n\t\t\tgoto out;\n\t}\n\nmeta_guess:\n\t/* calculate metadata allocation. */\n\tif (di->i_xattr_loc) {\n\t\tif (!xbs->xattr_bh) {\n\t\t\tret = ocfs2_read_xattr_block(inode,\n\t\t\t\t\t\t     le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t\t\t     &bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\txb = (struct ocfs2_xattr_block *)bh->b_data;\n\t\t} else\n\t\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\n\t\t/*\n\t\t * If there is already an xattr tree, good, we can calculate\n\t\t * like other b-trees. Otherwise we may have the chance of\n\t\t * create a tree, the credit calculation is borrowed from\n\t\t * ocfs2_calc_extend_credits with root_el = NULL. And the\n\t\t * new tree will be cluster based, so no meta is needed.\n\t\t */\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tstruct ocfs2_extent_list *el =\n\t\t\t\t &xb->xb_attrs.xb_root.xt_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else\n\t\t\tcredits += OCFS2_SUBALLOC_ALLOC + 1;\n\n\t\t/*\n\t\t * This cluster will be used either for new bucket or for\n\t\t * new xattr block.\n\t\t * If the cluster size is the same as the bucket size, one\n\t\t * more is needed since we may need to extend the bucket\n\t\t * also.\n\t\t */\n\t\tclusters_add += 1;\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\tif (OCFS2_XATTR_BUCKET_SIZE ==\n\t\t\tOCFS2_SB(inode->i_sb)->s_clustersize) {\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t\tclusters_add += 1;\n\t\t}\n\t} else {\n\t\tcredits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tstruct ocfs2_extent_list *el = &def_xv.xv.xr_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else {\n\t\t\tmeta_add += 1;\n\t\t}\n\t}\nout:\n\tif (clusters_need)\n\t\t*clusters_need = clusters_add;\n\tif (meta_need)\n\t\t*meta_need = meta_add;\n\tif (credits_need)\n\t\t*credits_need = credits;\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&ctxt->dealloc"
          ],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "205-209",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ctxt",
            "0",
            "sizeof(struct ocfs2_xattr_set_ctxt)"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_init_xattr_set_ctxt(struct inode *inode,\n\t\t\t\t     struct ocfs2_dinode *di,\n\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t     struct ocfs2_xattr_search *xis,\n\t\t\t\t     struct ocfs2_xattr_search *xbs,\n\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt,\n\t\t\t\t     int extra_meta,\n\t\t\t\t     int *credits)\n{\n\tint clusters_add, meta_add, ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmemset(ctxt, 0, sizeof(struct ocfs2_xattr_set_ctxt));\n\n\tocfs2_init_dealloc_ctxt(&ctxt->dealloc);\n\n\tret = ocfs2_calc_xattr_set_need(inode, di, xi, xis, xbs,\n\t\t\t\t\t&clusters_add, &meta_add, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tmeta_add += extra_meta;\n\ttrace_ocfs2_init_xattr_set_ctxt(xi->xi_name, meta_add,\n\t\t\t\t\tclusters_add, *credits);\n\n\tif (meta_add) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, meta_add,\n\t\t\t\t\t\t\t&ctxt->meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_add) {\n\t\tret = ocfs2_reserve_clusters(osb, clusters_add, &ctxt->data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tif (ret) {\n\t\tif (ctxt->meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt->meta_ac);\n\t\t\tctxt->meta_ac = NULL;\n\t\t}\n\n\t\t/*\n\t\t * We cannot have an error and a non null ctxt->data_ac.\n\t\t */\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_calc_xattr_set_need",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "3020-3230",
    "snippet": "static int ocfs2_calc_xattr_set_need(struct inode *inode,\n\t\t\t\t     struct ocfs2_dinode *di,\n\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t     struct ocfs2_xattr_search *xis,\n\t\t\t\t     struct ocfs2_xattr_search *xbs,\n\t\t\t\t     int *clusters_need,\n\t\t\t\t     int *meta_need,\n\t\t\t\t     int *credits_need)\n{\n\tint ret = 0, old_in_xb = 0;\n\tint clusters_add = 0, meta_add = 0, credits = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_xattr_block *xb = NULL;\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tstruct ocfs2_xattr_value_root *xv = NULL;\n\tchar *base = NULL;\n\tint name_offset, name_len = 0;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t    xi->xi_value_len);\n\tu64 value_size;\n\n\t/*\n\t * Calculate the clusters we need to write.\n\t * No matter whether we replace an old one or add a new one,\n\t * we need this for writing.\n\t */\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\tcredits += new_clusters *\n\t\t\t   ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\n\tif (xis->not_found && xbs->not_found) {\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t}\n\n\t\tgoto meta_guess;\n\t}\n\n\tif (!xis->not_found) {\n\t\txe = xis->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\tbase = xis->base;\n\t\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\t} else {\n\t\tint i, block_off = 0;\n\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\t\txe = xbs->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\ti = xbs->here - xbs->header->xh_entries;\n\t\told_in_xb = 1;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(xbs->bucket),\n\t\t\t\t\t\t\ti, &block_off,\n\t\t\t\t\t\t\t&name_offset);\n\t\t\tbase = bucket_block(xbs->bucket, block_off);\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t} else {\n\t\t\tbase = xbs->base;\n\t\t\tcredits += OCFS2_XATTR_BLOCK_UPDATE_CREDITS;\n\t\t}\n\t}\n\n\t/*\n\t * delete a xattr doesn't need metadata and cluster allocation.\n\t * so just calculate the credits and return.\n\t *\n\t * The credits for removing the value tree will be extended\n\t * by ocfs2_remove_extent itself.\n\t */\n\tif (!xi->xi_value) {\n\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\n\t\tgoto out;\n\t}\n\n\t/* do cluster allocation guess first. */\n\tvalue_size = le64_to_cpu(xe->xe_value_size);\n\n\tif (old_in_xb) {\n\t\t/*\n\t\t * In xattr set, we always try to set the xe in inode first,\n\t\t * so if it can be inserted into inode successfully, the old\n\t\t * one will be removed from the xattr block, and this xattr\n\t\t * will be inserted into inode as a new xattr in inode.\n\t\t */\n\t\tif (ocfs2_xattr_can_be_in_inode(inode, xi, xis)) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb) +\n\t\t\t\t    OCFS2_INODE_UPDATE_CREDITS;\n\t\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\t\tcredits += ocfs2_calc_extend_credits(\n\t\t\t\t\t\t\tinode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t/* the new values will be stored outside. */\n\t\tu32 old_clusters = 0;\n\n\t\tif (!ocfs2_xattr_is_local(xe)) {\n\t\t\told_clusters =\tocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t\t\t value_size);\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t     (base + name_offset + name_len);\n\t\t\tvalue_size = OCFS2_XATTR_ROOT_SIZE;\n\t\t} else\n\t\t\txv = &def_xv.xv;\n\n\t\tif (old_clusters >= new_clusters) {\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tmeta_add += ocfs2_extend_meta_needed(&xv->xr_list);\n\t\t\tclusters_add += new_clusters - old_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     &xv->xr_list);\n\t\t\tif (value_size >= OCFS2_XATTR_ROOT_SIZE)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Now the new value will be stored inside. So if the new\n\t\t * value is smaller than the size of value root or the old\n\t\t * value, we don't need any allocation, otherwise we have\n\t\t * to guess metadata allocation.\n\t\t */\n\t\tif ((ocfs2_xattr_is_local(xe) &&\n\t\t     (value_size >= xi->xi_value_len)) ||\n\t\t    (!ocfs2_xattr_is_local(xe) &&\n\t\t     OCFS2_XATTR_ROOT_SIZE >= xi->xi_value_len))\n\t\t\tgoto out;\n\t}\n\nmeta_guess:\n\t/* calculate metadata allocation. */\n\tif (di->i_xattr_loc) {\n\t\tif (!xbs->xattr_bh) {\n\t\t\tret = ocfs2_read_xattr_block(inode,\n\t\t\t\t\t\t     le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t\t\t     &bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\txb = (struct ocfs2_xattr_block *)bh->b_data;\n\t\t} else\n\t\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\n\t\t/*\n\t\t * If there is already an xattr tree, good, we can calculate\n\t\t * like other b-trees. Otherwise we may have the chance of\n\t\t * create a tree, the credit calculation is borrowed from\n\t\t * ocfs2_calc_extend_credits with root_el = NULL. And the\n\t\t * new tree will be cluster based, so no meta is needed.\n\t\t */\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tstruct ocfs2_extent_list *el =\n\t\t\t\t &xb->xb_attrs.xb_root.xt_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else\n\t\t\tcredits += OCFS2_SUBALLOC_ALLOC + 1;\n\n\t\t/*\n\t\t * This cluster will be used either for new bucket or for\n\t\t * new xattr block.\n\t\t * If the cluster size is the same as the bucket size, one\n\t\t * more is needed since we may need to extend the bucket\n\t\t * also.\n\t\t */\n\t\tclusters_add += 1;\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\tif (OCFS2_XATTR_BUCKET_SIZE ==\n\t\t\tOCFS2_SB(inode->i_sb)->s_clustersize) {\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t\tclusters_add += 1;\n\t\t}\n\t} else {\n\t\tcredits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tstruct ocfs2_extent_list *el = &def_xv.xv.xr_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else {\n\t\t\tmeta_add += 1;\n\t\t}\n\t}\nout:\n\tif (clusters_need)\n\t\t*clusters_need = clusters_add;\n\tif (meta_need)\n\t\t*meta_need = meta_add;\n\tif (credits_need)\n\t\t*credits_need = credits;\n\tbrelse(bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_INLINE_SIZE\t80",
      "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
    ],
    "globals_used": [
      "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);",
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_extend_credits",
          "args": [
            "inode->i_sb",
            "el"
          ],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_extend_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "531-556",
          "snippet": "static inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_meta_needed",
          "args": [
            "el"
          ],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_meta_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "157-168",
          "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_per_xattr_bucket",
          "args": [
            "inode->i_sb"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_per_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "321-324",
          "snippet": "static inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xb->xb_flags"
          ],
          "line": 3187
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_block",
          "args": [
            "inode",
            "le64_to_cpu(di->i_xattr_loc)",
            "&bh"
          ],
          "line": 3168
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "531-545",
          "snippet": "static int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_xattr_loc"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "xe"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_extent_credits",
          "args": [
            "inode->i_sb"
          ],
          "line": 3140
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_extent_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "412-416",
          "snippet": "static inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS",
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "inode->i_sb",
            "value_size"
          ],
          "line": 3131
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_can_be_in_inode",
          "args": [
            "inode",
            "xi",
            "xis"
          ],
          "line": 3114
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_can_be_in_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2988-3018",
          "snippet": "static int ocfs2_xattr_can_be_in_inode(struct inode *inode,\n\t\t\t\t       struct ocfs2_xattr_info *xi,\n\t\t\t\t       struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *last;\n\tint free, i;\n\tsize_t min_offs = xs->end - xs->base;\n\n\tif (!xs->header)\n\t\treturn 0;\n\n\tlast = xs->header->xh_entries;\n\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tsize_t offs = le16_to_cpu(last->xe_name_offset);\n\t\tif (offs < min_offs)\n\t\t\tmin_offs = offs;\n\t\tlast += 1;\n\t}\n\n\tfree = min_offs - ((void *)last - xs->base) - OCFS2_XATTR_HEADER_GAP;\n\tif (free < 0)\n\t\treturn 0;\n\n\tBUG_ON(!xs->not_found);\n\n\tif (free >= (sizeof(struct ocfs2_xattr_entry) + namevalue_size_xi(xi)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_HEADER_GAP\t4"
          ],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_HEADER_GAP\t4\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_can_be_in_inode(struct inode *inode,\n\t\t\t\t       struct ocfs2_xattr_info *xi,\n\t\t\t\t       struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *last;\n\tint free, i;\n\tsize_t min_offs = xs->end - xs->base;\n\n\tif (!xs->header)\n\t\treturn 0;\n\n\tlast = xs->header->xh_entries;\n\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tsize_t offs = le16_to_cpu(last->xe_name_offset);\n\t\tif (offs < min_offs)\n\t\t\tmin_offs = offs;\n\t\tlast += 1;\n\t}\n\n\tfree = min_offs - ((void *)last - xs->base) - OCFS2_XATTR_HEADER_GAP;\n\tif (free < 0)\n\t\treturn 0;\n\n\tBUG_ON(!xs->not_found);\n\n\tif (free >= (sizeof(struct ocfs2_xattr_entry) + namevalue_size_xi(xi)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "xbs->bucket",
            "block_off"
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_get_name_value",
          "args": [
            "inode->i_sb",
            "bucket_xh(xbs->bucket)",
            "i",
            "&block_off",
            "&name_offset"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_get_name_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4014-4031",
          "snippet": "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "xbs->bucket"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xe->xe_name_len"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xe->xe_name_len"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "1"
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_calc_xattr_set_need(struct inode *inode,\n\t\t\t\t     struct ocfs2_dinode *di,\n\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t     struct ocfs2_xattr_search *xis,\n\t\t\t\t     struct ocfs2_xattr_search *xbs,\n\t\t\t\t     int *clusters_need,\n\t\t\t\t     int *meta_need,\n\t\t\t\t     int *credits_need)\n{\n\tint ret = 0, old_in_xb = 0;\n\tint clusters_add = 0, meta_add = 0, credits = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_xattr_block *xb = NULL;\n\tstruct ocfs2_xattr_entry *xe = NULL;\n\tstruct ocfs2_xattr_value_root *xv = NULL;\n\tchar *base = NULL;\n\tint name_offset, name_len = 0;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t    xi->xi_value_len);\n\tu64 value_size;\n\n\t/*\n\t * Calculate the clusters we need to write.\n\t * No matter whether we replace an old one or add a new one,\n\t * we need this for writing.\n\t */\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\tcredits += new_clusters *\n\t\t\t   ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\n\tif (xis->not_found && xbs->not_found) {\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t}\n\n\t\tgoto meta_guess;\n\t}\n\n\tif (!xis->not_found) {\n\t\txe = xis->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\tbase = xis->base;\n\t\tcredits += OCFS2_INODE_UPDATE_CREDITS;\n\t} else {\n\t\tint i, block_off = 0;\n\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\t\txe = xbs->here;\n\t\tname_offset = le16_to_cpu(xe->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xe->xe_name_len);\n\t\ti = xbs->here - xbs->header->xh_entries;\n\t\told_in_xb = 1;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\tbucket_xh(xbs->bucket),\n\t\t\t\t\t\t\ti, &block_off,\n\t\t\t\t\t\t\t&name_offset);\n\t\t\tbase = bucket_block(xbs->bucket, block_off);\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t} else {\n\t\t\tbase = xbs->base;\n\t\t\tcredits += OCFS2_XATTR_BLOCK_UPDATE_CREDITS;\n\t\t}\n\t}\n\n\t/*\n\t * delete a xattr doesn't need metadata and cluster allocation.\n\t * so just calculate the credits and return.\n\t *\n\t * The credits for removing the value tree will be extended\n\t * by ocfs2_remove_extent itself.\n\t */\n\tif (!xi->xi_value) {\n\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\n\t\tgoto out;\n\t}\n\n\t/* do cluster allocation guess first. */\n\tvalue_size = le64_to_cpu(xe->xe_value_size);\n\n\tif (old_in_xb) {\n\t\t/*\n\t\t * In xattr set, we always try to set the xe in inode first,\n\t\t * so if it can be inserted into inode successfully, the old\n\t\t * one will be removed from the xattr block, and this xattr\n\t\t * will be inserted into inode as a new xattr in inode.\n\t\t */\n\t\tif (ocfs2_xattr_can_be_in_inode(inode, xi, xis)) {\n\t\t\tclusters_add += new_clusters;\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb) +\n\t\t\t\t    OCFS2_INODE_UPDATE_CREDITS;\n\t\t\tif (!ocfs2_xattr_is_local(xe))\n\t\t\t\tcredits += ocfs2_calc_extend_credits(\n\t\t\t\t\t\t\tinode->i_sb,\n\t\t\t\t\t\t\t&def_xv.xv.xr_list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t/* the new values will be stored outside. */\n\t\tu32 old_clusters = 0;\n\n\t\tif (!ocfs2_xattr_is_local(xe)) {\n\t\t\told_clusters =\tocfs2_clusters_for_bytes(inode->i_sb,\n\t\t\t\t\t\t\t\t value_size);\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t     (base + name_offset + name_len);\n\t\t\tvalue_size = OCFS2_XATTR_ROOT_SIZE;\n\t\t} else\n\t\t\txv = &def_xv.xv;\n\n\t\tif (old_clusters >= new_clusters) {\n\t\t\tcredits += ocfs2_remove_extent_credits(inode->i_sb);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tmeta_add += ocfs2_extend_meta_needed(&xv->xr_list);\n\t\t\tclusters_add += new_clusters - old_clusters;\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     &xv->xr_list);\n\t\t\tif (value_size >= OCFS2_XATTR_ROOT_SIZE)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Now the new value will be stored inside. So if the new\n\t\t * value is smaller than the size of value root or the old\n\t\t * value, we don't need any allocation, otherwise we have\n\t\t * to guess metadata allocation.\n\t\t */\n\t\tif ((ocfs2_xattr_is_local(xe) &&\n\t\t     (value_size >= xi->xi_value_len)) ||\n\t\t    (!ocfs2_xattr_is_local(xe) &&\n\t\t     OCFS2_XATTR_ROOT_SIZE >= xi->xi_value_len))\n\t\t\tgoto out;\n\t}\n\nmeta_guess:\n\t/* calculate metadata allocation. */\n\tif (di->i_xattr_loc) {\n\t\tif (!xbs->xattr_bh) {\n\t\t\tret = ocfs2_read_xattr_block(inode,\n\t\t\t\t\t\t     le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t\t\t     &bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\txb = (struct ocfs2_xattr_block *)bh->b_data;\n\t\t} else\n\t\t\txb = (struct ocfs2_xattr_block *)xbs->xattr_bh->b_data;\n\n\t\t/*\n\t\t * If there is already an xattr tree, good, we can calculate\n\t\t * like other b-trees. Otherwise we may have the chance of\n\t\t * create a tree, the credit calculation is borrowed from\n\t\t * ocfs2_calc_extend_credits with root_el = NULL. And the\n\t\t * new tree will be cluster based, so no meta is needed.\n\t\t */\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tstruct ocfs2_extent_list *el =\n\t\t\t\t &xb->xb_attrs.xb_root.xt_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else\n\t\t\tcredits += OCFS2_SUBALLOC_ALLOC + 1;\n\n\t\t/*\n\t\t * This cluster will be used either for new bucket or for\n\t\t * new xattr block.\n\t\t * If the cluster size is the same as the bucket size, one\n\t\t * more is needed since we may need to extend the bucket\n\t\t * also.\n\t\t */\n\t\tclusters_add += 1;\n\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\tif (OCFS2_XATTR_BUCKET_SIZE ==\n\t\t\tOCFS2_SB(inode->i_sb)->s_clustersize) {\n\t\t\tcredits += ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\t\t\tclusters_add += 1;\n\t\t}\n\t} else {\n\t\tcredits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t\tstruct ocfs2_extent_list *el = &def_xv.xv.xr_list;\n\t\t\tmeta_add += ocfs2_extend_meta_needed(el);\n\t\t\tcredits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t     el);\n\t\t} else {\n\t\t\tmeta_add += 1;\n\t\t}\n\t}\nout:\n\tif (clusters_need)\n\t\t*clusters_need = clusters_add;\n\tif (meta_need)\n\t\t*meta_need = meta_add;\n\tif (credits_need)\n\t\t*credits_need = credits;\n\tbrelse(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_can_be_in_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2988-3018",
    "snippet": "static int ocfs2_xattr_can_be_in_inode(struct inode *inode,\n\t\t\t\t       struct ocfs2_xattr_info *xi,\n\t\t\t\t       struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *last;\n\tint free, i;\n\tsize_t min_offs = xs->end - xs->base;\n\n\tif (!xs->header)\n\t\treturn 0;\n\n\tlast = xs->header->xh_entries;\n\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tsize_t offs = le16_to_cpu(last->xe_name_offset);\n\t\tif (offs < min_offs)\n\t\t\tmin_offs = offs;\n\t\tlast += 1;\n\t}\n\n\tfree = min_offs - ((void *)last - xs->base) - OCFS2_XATTR_HEADER_GAP;\n\tif (free < 0)\n\t\treturn 0;\n\n\tBUG_ON(!xs->not_found);\n\n\tif (free >= (sizeof(struct ocfs2_xattr_entry) + namevalue_size_xi(xi)))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_HEADER_GAP\t4"
    ],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "namevalue_size_xi",
          "args": [
            "xi"
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "236-239",
          "snippet": "static int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!xs->not_found"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "last->xe_name_offset"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_HEADER_GAP\t4\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_can_be_in_inode(struct inode *inode,\n\t\t\t\t       struct ocfs2_xattr_info *xi,\n\t\t\t\t       struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *last;\n\tint free, i;\n\tsize_t min_offs = xs->end - xs->base;\n\n\tif (!xs->header)\n\t\treturn 0;\n\n\tlast = xs->header->xh_entries;\n\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tsize_t offs = le16_to_cpu(last->xe_name_offset);\n\t\tif (offs < min_offs)\n\t\t\tmin_offs = offs;\n\t\tlast += 1;\n\t}\n\n\tfree = min_offs - ((void *)last - xs->base) - OCFS2_XATTR_HEADER_GAP;\n\tif (free < 0)\n\t\treturn 0;\n\n\tBUG_ON(!xs->not_found);\n\n\tif (free >= (sizeof(struct ocfs2_xattr_entry) + namevalue_size_xi(xi)))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_xattr_block_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2937-2985",
    "snippet": "static int ocfs2_xattr_block_set(struct inode *inode,\n\t\t\t\t struct ocfs2_xattr_info *xi,\n\t\t\t\t struct ocfs2_xattr_search *xs,\n\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_xattr_block *xblk = NULL;\n\tint ret;\n\tstruct ocfs2_xa_loc loc;\n\n\tif (!xs->xattr_bh) {\n\t\tret = ocfs2_create_xattr_block(inode, xs->inode_bh, ctxt,\n\t\t\t\t\t       0, &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto end;\n\t\t}\n\n\t\txs->xattr_bh = new_bh;\n\t\txblk = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\t\txs->header = &xblk->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)xblk + inode->i_sb->s_blocksize;\n\t\txs->here = xs->header->xh_entries;\n\t} else\n\t\txblk = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\n\tif (!(le16_to_cpu(xblk->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tocfs2_init_xattr_block_xa_loc(&loc, inode, xs->xattr_bh,\n\t\t\t\t\t      xs->not_found ? NULL : xs->here);\n\n\t\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\t\tif (!ret)\n\t\t\txs->here = loc.xl_entry;\n\t\telse if ((ret != -ENOSPC) || ctxt->set_abort)\n\t\t\tgoto end;\n\t\telse {\n\t\t\tret = ocfs2_xattr_create_index_block(inode, xs, ctxt);\n\t\t\tif (ret)\n\t\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (le16_to_cpu(xblk->xb_flags) & OCFS2_XATTR_INDEXED)\n\t\tret = ocfs2_xattr_set_entry_index_block(inode, xi, xs, ctxt);\n\nend:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_set_entry_index_block",
          "args": [
            "inode",
            "xi",
            "xs",
            "ctxt"
          ],
          "line": 2981
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_set_entry_index_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "5577-5641",
          "snippet": "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\n\ttrace_ocfs2_xattr_set_entry_index_block(xi->xi_name);\n\n\tret = ocfs2_xattr_set_entry_bucket(inode, xi, xs, ctxt);\n\tif (!ret)\n\t\tgoto out;\n\tif (ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Ack, need more space.  Let's try to get another bucket! */\n\n\t/*\n\t * We do not allow for overlapping ranges between buckets. And\n\t * the maximum number of collisions we will allow for then is\n\t * one bucket's worth, so check it here whether we need to\n\t * add a new bucket for the insert.\n\t */\n\tret = ocfs2_check_xattr_bucket_collision(inode,\n\t\t\t\t\t\t xs->bucket,\n\t\t\t\t\t\t xi->xi_name);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_add_new_xattr_bucket(inode,\n\t\t\t\t\t xs->xattr_bh,\n\t\t\t\t\t xs->bucket,\n\t\t\t\t\t ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * ocfs2_add_new_xattr_bucket() will have updated\n\t * xs->bucket if it moved, but it will not have updated\n\t * any of the other search fields.  Thus, we drop it and\n\t * re-search.  Everything should be cached, so it'll be\n\t * quick.\n\t */\n\tocfs2_xattr_bucket_relse(xs->bucket);\n\tret = ocfs2_xattr_index_block_find(inode, xs->xattr_bh,\n\t\t\t\t\t   xi->xi_name_index,\n\t\t\t\t\t   xi->xi_name, xs);\n\tif (ret && ret != -ENODATA)\n\t\tgoto out;\n\txs->not_found = ret;\n\n\t/* Ok, we have a new bucket, let's try again */\n\tret = ocfs2_xattr_set_entry_bucket(inode, xi, xs, ctxt);\n\tif (ret && (ret != -ENOSPC))\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\n\ttrace_ocfs2_xattr_set_entry_index_block(xi->xi_name);\n\n\tret = ocfs2_xattr_set_entry_bucket(inode, xi, xs, ctxt);\n\tif (!ret)\n\t\tgoto out;\n\tif (ret != -ENOSPC) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Ack, need more space.  Let's try to get another bucket! */\n\n\t/*\n\t * We do not allow for overlapping ranges between buckets. And\n\t * the maximum number of collisions we will allow for then is\n\t * one bucket's worth, so check it here whether we need to\n\t * add a new bucket for the insert.\n\t */\n\tret = ocfs2_check_xattr_bucket_collision(inode,\n\t\t\t\t\t\t xs->bucket,\n\t\t\t\t\t\t xi->xi_name);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_add_new_xattr_bucket(inode,\n\t\t\t\t\t xs->xattr_bh,\n\t\t\t\t\t xs->bucket,\n\t\t\t\t\t ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * ocfs2_add_new_xattr_bucket() will have updated\n\t * xs->bucket if it moved, but it will not have updated\n\t * any of the other search fields.  Thus, we drop it and\n\t * re-search.  Everything should be cached, so it'll be\n\t * quick.\n\t */\n\tocfs2_xattr_bucket_relse(xs->bucket);\n\tret = ocfs2_xattr_index_block_find(inode, xs->xattr_bh,\n\t\t\t\t\t   xi->xi_name_index,\n\t\t\t\t\t   xi->xi_name, xs);\n\tif (ret && ret != -ENODATA)\n\t\tgoto out;\n\txs->not_found = ret;\n\n\t/* Ok, we have a new bucket, let's try again */\n\tret = ocfs2_xattr_set_entry_bucket(inode, xi, xs, ctxt);\n\tif (ret && (ret != -ENOSPC))\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xblk->xb_flags"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_create_index_block",
          "args": [
            "inode",
            "xs",
            "ctxt"
          ],
          "line": 2974
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_create_index_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4262-4354",
          "snippet": "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 bit_off, len;\n\tu64 blkno;\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *xb_bh = xs->xattr_bh;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xr;\n\tu16 xb_flags = le16_to_cpu(xb->xb_flags);\n\n\ttrace_ocfs2_xattr_create_index_block_begin(\n\t\t\t\t(unsigned long long)xb_bh->b_blocknr);\n\n\tBUG_ON(xb_flags & OCFS2_XATTR_INDEXED);\n\tBUG_ON(!xs->bucket);\n\n\t/*\n\t * XXX:\n\t * We can use this lock for now, and maybe move to a dedicated mutex\n\t * if performance becomes a problem later.\n\t */\n\tdown_write(&oi->ip_alloc_sem);\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), xb_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, ctxt->data_ac,\n\t\t\t\t     1, 1, &bit_off, &len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The bucket may spread in many blocks, and\n\t * we will only touch the 1st block and the last block\n\t * in the whole bucket(one for entry and one for data).\n\t */\n\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\ttrace_ocfs2_xattr_create_index_block((unsigned long long)blkno);\n\n\tret = ocfs2_init_xattr_bucket(xs->bucket, blkno, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, xs->bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_xattr_block_to_bucket(inode, xb_bh, xs->bucket);\n\tocfs2_xattr_bucket_journal_dirty(handle, xs->bucket);\n\n\tocfs2_xattr_update_xattr_search(inode, xs, xb_bh);\n\n\t/* Change from ocfs2_xattr_header to ocfs2_xattr_tree_root */\n\tmemset(&xb->xb_attrs, 0, inode->i_sb->s_blocksize -\n\t       offsetof(struct ocfs2_xattr_block, xb_attrs));\n\n\txr = &xb->xb_attrs.xb_root;\n\txr->xt_clusters = cpu_to_le32(1);\n\txr->xt_last_eb_blk = 0;\n\txr->xt_list.l_tree_depth = 0;\n\txr->xt_list.l_count = cpu_to_le16(ocfs2_xattr_recs_per_xb(inode->i_sb));\n\txr->xt_list.l_next_free_rec = cpu_to_le16(1);\n\n\txr->xt_list.l_recs[0].e_cpos = 0;\n\txr->xt_list.l_recs[0].e_blkno = cpu_to_le64(blkno);\n\txr->xt_list.l_recs[0].e_leaf_clusters = cpu_to_le16(1);\n\n\txb->xb_flags = cpu_to_le16(xb_flags | OCFS2_XATTR_INDEXED);\n\n\tocfs2_journal_dirty(handle, xb_bh);\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 bit_off, len;\n\tu64 blkno;\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *xb_bh = xs->xattr_bh;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)xb_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xr;\n\tu16 xb_flags = le16_to_cpu(xb->xb_flags);\n\n\ttrace_ocfs2_xattr_create_index_block_begin(\n\t\t\t\t(unsigned long long)xb_bh->b_blocknr);\n\n\tBUG_ON(xb_flags & OCFS2_XATTR_INDEXED);\n\tBUG_ON(!xs->bucket);\n\n\t/*\n\t * XXX:\n\t * We can use this lock for now, and maybe move to a dedicated mutex\n\t * if performance becomes a problem later.\n\t */\n\tdown_write(&oi->ip_alloc_sem);\n\n\tret = ocfs2_journal_access_xb(handle, INODE_CACHE(inode), xb_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, ctxt->data_ac,\n\t\t\t\t     1, 1, &bit_off, &len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The bucket may spread in many blocks, and\n\t * we will only touch the 1st block and the last block\n\t * in the whole bucket(one for entry and one for data).\n\t */\n\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\ttrace_ocfs2_xattr_create_index_block((unsigned long long)blkno);\n\n\tret = ocfs2_init_xattr_bucket(xs->bucket, blkno, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_bucket_journal_access(handle, xs->bucket,\n\t\t\t\t\t\tOCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_xattr_block_to_bucket(inode, xb_bh, xs->bucket);\n\tocfs2_xattr_bucket_journal_dirty(handle, xs->bucket);\n\n\tocfs2_xattr_update_xattr_search(inode, xs, xb_bh);\n\n\t/* Change from ocfs2_xattr_header to ocfs2_xattr_tree_root */\n\tmemset(&xb->xb_attrs, 0, inode->i_sb->s_blocksize -\n\t       offsetof(struct ocfs2_xattr_block, xb_attrs));\n\n\txr = &xb->xb_attrs.xb_root;\n\txr->xt_clusters = cpu_to_le32(1);\n\txr->xt_last_eb_blk = 0;\n\txr->xt_list.l_tree_depth = 0;\n\txr->xt_list.l_count = cpu_to_le16(ocfs2_xattr_recs_per_xb(inode->i_sb));\n\txr->xt_list.l_next_free_rec = cpu_to_le16(1);\n\n\txr->xt_list.l_recs[0].e_cpos = 0;\n\txr->xt_list.l_recs[0].e_blkno = cpu_to_le64(blkno);\n\txr->xt_list.l_recs[0].e_leaf_clusters = cpu_to_le16(1);\n\n\txb->xb_flags = cpu_to_le16(xb_flags | OCFS2_XATTR_INDEXED);\n\n\tocfs2_journal_dirty(handle, xb_bh);\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_set",
          "args": [
            "&loc",
            "xi",
            "ctxt"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2207-2250",
          "snippet": "static int ocfs2_xa_set(struct ocfs2_xa_loc *loc,\n\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 name_hash = ocfs2_xattr_name_hash(loc->xl_inode, xi->xi_name,\n\t\t\t\t\t      xi->xi_name_len);\n\n\tret = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * From here on out, everything is going to modify the buffer a\n\t * little.  Errors are going to leave the xattr header in a\n\t * sane state.  Thus, even with errors we dirty the sucker.\n\t */\n\n\t/* Don't worry, we are never called with !xi_value and !xl_entry */\n\tif (!xi->xi_value) {\n\t\tret = ocfs2_xa_remove(loc, ctxt);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_prepare_entry(loc, xi, name_hash, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_store_value(loc, xi, ctxt);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_dirty:\n\tocfs2_xa_journal_dirty(ctxt->handle, loc);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_set(struct ocfs2_xa_loc *loc,\n\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 name_hash = ocfs2_xattr_name_hash(loc->xl_inode, xi->xi_name,\n\t\t\t\t\t      xi->xi_name_len);\n\n\tret = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * From here on out, everything is going to modify the buffer a\n\t * little.  Errors are going to leave the xattr header in a\n\t * sane state.  Thus, even with errors we dirty the sucker.\n\t */\n\n\t/* Don't worry, we are never called with !xi_value and !xl_entry */\n\tif (!xi->xi_value) {\n\t\tret = ocfs2_xa_remove(loc, ctxt);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_prepare_entry(loc, xi, name_hash, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_store_value(loc, xi, ctxt);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_dirty:\n\tocfs2_xa_journal_dirty(ctxt->handle, loc);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_block_xa_loc",
          "args": [
            "&loc",
            "inode",
            "xs->xattr_bh",
            "xs->not_found ? NULL : xs->here"
          ],
          "line": 2965
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_block_xa_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2271-2288",
          "snippet": "static void ocfs2_init_xattr_block_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  struct ocfs2_xattr_entry *entry)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\tBUG_ON(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED);\n\n\tloc->xl_inode = inode;\n\tloc->xl_ops = &ocfs2_xa_block_loc_ops;\n\tloc->xl_storage = bh;\n\tloc->xl_header = &(xb->xb_attrs.xb_header);\n\tloc->xl_entry = entry;\n\tloc->xl_size = bh->b_size - offsetof(struct ocfs2_xattr_block,\n\t\t\t\t\t     xb_attrs.xb_header);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);",
            "static const struct ocfs2_xa_loc_operations ocfs2_xa_block_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_block_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_block_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_block_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_block_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_block_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_block_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_block_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_block_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_block_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_block_fill_value_buf,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\nstatic const struct ocfs2_xa_loc_operations ocfs2_xa_block_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_block_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_block_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_block_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_block_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_block_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_block_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_block_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_block_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_block_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_block_fill_value_buf,\n};\n\nstatic void ocfs2_init_xattr_block_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  struct ocfs2_xattr_entry *entry)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\tBUG_ON(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED);\n\n\tloc->xl_inode = inode;\n\tloc->xl_ops = &ocfs2_xa_block_loc_ops;\n\tloc->xl_storage = bh;\n\tloc->xl_header = &(xb->xb_attrs.xb_header);\n\tloc->xl_entry = entry;\n\tloc->xl_size = bh->b_size - offsetof(struct ocfs2_xattr_block,\n\t\t\t\t\t     xb_attrs.xb_header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_xattr_block",
          "args": [
            "inode",
            "xs->inode_bh",
            "ctxt",
            "0",
            "&new_bh"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2845-2929",
          "snippet": "static int ocfs2_create_xattr_block(struct inode *inode,\n\t\t\t\t    struct buffer_head *inode_bh,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt,\n\t\t\t\t    int indexed,\n\t\t\t\t    struct buffer_head **ret_bh)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_dinode *di =  (struct ocfs2_dinode *)inode_bh->b_data;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_xattr_block *xblk;\n\n\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      inode_bh, OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tret = ocfs2_claim_metadata(ctxt->handle, ctxt->meta_ac, 1,\n\t\t\t\t   &suballoc_loc, &suballoc_bit_start,\n\t\t\t\t   &num_got, &first_blkno);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n\tif (!new_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tret = ocfs2_journal_access_xb(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\t/* Initialize ocfs2_xattr_block */\n\txblk = (struct ocfs2_xattr_block *)new_bh->b_data;\n\tmemset(xblk, 0, inode->i_sb->s_blocksize);\n\tstrcpy((void *)xblk, OCFS2_XATTR_BLOCK_SIGNATURE);\n\txblk->xb_suballoc_slot = cpu_to_le16(ctxt->meta_ac->ac_alloc_slot);\n\txblk->xb_suballoc_loc = cpu_to_le64(suballoc_loc);\n\txblk->xb_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\txblk->xb_fs_generation =\n\t\tcpu_to_le32(OCFS2_SB(inode->i_sb)->fs_generation);\n\txblk->xb_blkno = cpu_to_le64(first_blkno);\n\tif (indexed) {\n\t\tstruct ocfs2_xattr_tree_root *xr = &xblk->xb_attrs.xb_root;\n\t\txr->xt_clusters = cpu_to_le32(1);\n\t\txr->xt_last_eb_blk = 0;\n\t\txr->xt_list.l_tree_depth = 0;\n\t\txr->xt_list.l_count = cpu_to_le16(\n\t\t\t\t\tocfs2_xattr_recs_per_xb(inode->i_sb));\n\t\txr->xt_list.l_next_free_rec = cpu_to_le16(1);\n\t\txblk->xb_flags = cpu_to_le16(OCFS2_XATTR_INDEXED);\n\t}\n\tocfs2_journal_dirty(ctxt->handle, new_bh);\n\n\t/* Add it to the inode */\n\tdi->i_xattr_loc = cpu_to_le64(first_blkno);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tOCFS2_I(inode)->ip_dyn_features |= OCFS2_HAS_XATTR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tocfs2_journal_dirty(ctxt->handle, inode_bh);\n\n\t*ret_bh = new_bh;\n\tnew_bh = NULL;\n\nend:\n\tbrelse(new_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_create_xattr_block(struct inode *inode,\n\t\t\t\t    struct buffer_head *inode_bh,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt,\n\t\t\t\t    int indexed,\n\t\t\t\t    struct buffer_head **ret_bh)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_dinode *di =  (struct ocfs2_dinode *)inode_bh->b_data;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_xattr_block *xblk;\n\n\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      inode_bh, OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tret = ocfs2_claim_metadata(ctxt->handle, ctxt->meta_ac, 1,\n\t\t\t\t   &suballoc_loc, &suballoc_bit_start,\n\t\t\t\t   &num_got, &first_blkno);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n\tif (!new_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tret = ocfs2_journal_access_xb(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\t/* Initialize ocfs2_xattr_block */\n\txblk = (struct ocfs2_xattr_block *)new_bh->b_data;\n\tmemset(xblk, 0, inode->i_sb->s_blocksize);\n\tstrcpy((void *)xblk, OCFS2_XATTR_BLOCK_SIGNATURE);\n\txblk->xb_suballoc_slot = cpu_to_le16(ctxt->meta_ac->ac_alloc_slot);\n\txblk->xb_suballoc_loc = cpu_to_le64(suballoc_loc);\n\txblk->xb_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\txblk->xb_fs_generation =\n\t\tcpu_to_le32(OCFS2_SB(inode->i_sb)->fs_generation);\n\txblk->xb_blkno = cpu_to_le64(first_blkno);\n\tif (indexed) {\n\t\tstruct ocfs2_xattr_tree_root *xr = &xblk->xb_attrs.xb_root;\n\t\txr->xt_clusters = cpu_to_le32(1);\n\t\txr->xt_last_eb_blk = 0;\n\t\txr->xt_list.l_tree_depth = 0;\n\t\txr->xt_list.l_count = cpu_to_le16(\n\t\t\t\t\tocfs2_xattr_recs_per_xb(inode->i_sb));\n\t\txr->xt_list.l_next_free_rec = cpu_to_le16(1);\n\t\txblk->xb_flags = cpu_to_le16(OCFS2_XATTR_INDEXED);\n\t}\n\tocfs2_journal_dirty(ctxt->handle, new_bh);\n\n\t/* Add it to the inode */\n\tdi->i_xattr_loc = cpu_to_le64(first_blkno);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tOCFS2_I(inode)->ip_dyn_features |= OCFS2_HAS_XATTR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tocfs2_journal_dirty(ctxt->handle, inode_bh);\n\n\t*ret_bh = new_bh;\n\tnew_bh = NULL;\n\nend:\n\tbrelse(new_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_block_set(struct inode *inode,\n\t\t\t\t struct ocfs2_xattr_info *xi,\n\t\t\t\t struct ocfs2_xattr_search *xs,\n\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_xattr_block *xblk = NULL;\n\tint ret;\n\tstruct ocfs2_xa_loc loc;\n\n\tif (!xs->xattr_bh) {\n\t\tret = ocfs2_create_xattr_block(inode, xs->inode_bh, ctxt,\n\t\t\t\t\t       0, &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto end;\n\t\t}\n\n\t\txs->xattr_bh = new_bh;\n\t\txblk = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\t\txs->header = &xblk->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)xblk + inode->i_sb->s_blocksize;\n\t\txs->here = xs->header->xh_entries;\n\t} else\n\t\txblk = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\n\tif (!(le16_to_cpu(xblk->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tocfs2_init_xattr_block_xa_loc(&loc, inode, xs->xattr_bh,\n\t\t\t\t\t      xs->not_found ? NULL : xs->here);\n\n\t\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\t\tif (!ret)\n\t\t\txs->here = loc.xl_entry;\n\t\telse if ((ret != -ENOSPC) || ctxt->set_abort)\n\t\t\tgoto end;\n\t\telse {\n\t\t\tret = ocfs2_xattr_create_index_block(inode, xs, ctxt);\n\t\t\tif (ret)\n\t\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (le16_to_cpu(xblk->xb_flags) & OCFS2_XATTR_INDEXED)\n\t\tret = ocfs2_xattr_set_entry_index_block(inode, xi, xs, ctxt);\n\nend:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_create_xattr_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2845-2929",
    "snippet": "static int ocfs2_create_xattr_block(struct inode *inode,\n\t\t\t\t    struct buffer_head *inode_bh,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt,\n\t\t\t\t    int indexed,\n\t\t\t\t    struct buffer_head **ret_bh)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_dinode *di =  (struct ocfs2_dinode *)inode_bh->b_data;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_xattr_block *xblk;\n\n\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      inode_bh, OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tret = ocfs2_claim_metadata(ctxt->handle, ctxt->meta_ac, 1,\n\t\t\t\t   &suballoc_loc, &suballoc_bit_start,\n\t\t\t\t   &num_got, &first_blkno);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n\tif (!new_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tret = ocfs2_journal_access_xb(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\t/* Initialize ocfs2_xattr_block */\n\txblk = (struct ocfs2_xattr_block *)new_bh->b_data;\n\tmemset(xblk, 0, inode->i_sb->s_blocksize);\n\tstrcpy((void *)xblk, OCFS2_XATTR_BLOCK_SIGNATURE);\n\txblk->xb_suballoc_slot = cpu_to_le16(ctxt->meta_ac->ac_alloc_slot);\n\txblk->xb_suballoc_loc = cpu_to_le64(suballoc_loc);\n\txblk->xb_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\txblk->xb_fs_generation =\n\t\tcpu_to_le32(OCFS2_SB(inode->i_sb)->fs_generation);\n\txblk->xb_blkno = cpu_to_le64(first_blkno);\n\tif (indexed) {\n\t\tstruct ocfs2_xattr_tree_root *xr = &xblk->xb_attrs.xb_root;\n\t\txr->xt_clusters = cpu_to_le32(1);\n\t\txr->xt_last_eb_blk = 0;\n\t\txr->xt_list.l_tree_depth = 0;\n\t\txr->xt_list.l_count = cpu_to_le16(\n\t\t\t\t\tocfs2_xattr_recs_per_xb(inode->i_sb));\n\t\txr->xt_list.l_next_free_rec = cpu_to_le16(1);\n\t\txblk->xb_flags = cpu_to_le16(OCFS2_XATTR_INDEXED);\n\t}\n\tocfs2_journal_dirty(ctxt->handle, new_bh);\n\n\t/* Add it to the inode */\n\tdi->i_xattr_loc = cpu_to_le64(first_blkno);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tOCFS2_I(inode)->ip_dyn_features |= OCFS2_HAS_XATTR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tocfs2_journal_dirty(ctxt->handle, inode_bh);\n\n\t*ret_bh = new_bh;\n\tnew_bh = NULL;\n\nend:\n\tbrelse(new_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 2927
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "ctxt->handle",
            "inode_bh"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(inode)->ip_lock"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "OCFS2_I(inode)->ip_dyn_features"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(inode)->ip_lock"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "first_blkno"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "OCFS2_XATTR_INDEXED"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_xattr_recs_per_xb(inode->i_sb)"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_recs_per_xb",
          "args": [
            "inode->i_sb"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_recs_per_xb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1590-1599",
          "snippet": "static inline int ocfs2_xattr_recs_per_xb(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_xattr_block,\n\t\t\t xb_attrs.xb_root.xt_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_xattr_recs_per_xb(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_xattr_block,\n\t\t\t xb_attrs.xb_root.xt_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "first_blkno"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_SB(inode->i_sb)->fs_generation"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "suballoc_bit_start"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "suballoc_loc"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ctxt->meta_ac->ac_alloc_slot"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "(void *)xblk",
            "OCFS2_XATTR_BLOCK_SIGNATURE"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xblk",
            "0",
            "inode->i_sb->s_blocksize"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_xb",
          "args": [
            "ctxt->handle",
            "INODE_CACHE(inode)",
            "new_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_xb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "741-745",
          "snippet": "int ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};\n\nint ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(inode)",
            "new_bh"
          ],
          "line": 2881
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "inode->i_sb",
            "first_blkno"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_metadata",
          "args": [
            "ctxt->handle",
            "ctxt->meta_ac",
            "1",
            "&suballoc_loc",
            "&suballoc_bit_start",
            "&num_got",
            "&first_blkno"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1993-2029",
          "snippet": "int ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "ctxt->handle",
            "INODE_CACHE(inode)",
            "inode_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_create_xattr_block(struct inode *inode,\n\t\t\t\t    struct buffer_head *inode_bh,\n\t\t\t\t    struct ocfs2_xattr_set_ctxt *ctxt,\n\t\t\t\t    int indexed,\n\t\t\t\t    struct buffer_head **ret_bh)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_dinode *di =  (struct ocfs2_dinode *)inode_bh->b_data;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_xattr_block *xblk;\n\n\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      inode_bh, OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tret = ocfs2_claim_metadata(ctxt->handle, ctxt->meta_ac, 1,\n\t\t\t\t   &suballoc_loc, &suballoc_bit_start,\n\t\t\t\t   &num_got, &first_blkno);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n\tif (!new_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), new_bh);\n\n\tret = ocfs2_journal_access_xb(ctxt->handle, INODE_CACHE(inode),\n\t\t\t\t      new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto end;\n\t}\n\n\t/* Initialize ocfs2_xattr_block */\n\txblk = (struct ocfs2_xattr_block *)new_bh->b_data;\n\tmemset(xblk, 0, inode->i_sb->s_blocksize);\n\tstrcpy((void *)xblk, OCFS2_XATTR_BLOCK_SIGNATURE);\n\txblk->xb_suballoc_slot = cpu_to_le16(ctxt->meta_ac->ac_alloc_slot);\n\txblk->xb_suballoc_loc = cpu_to_le64(suballoc_loc);\n\txblk->xb_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\txblk->xb_fs_generation =\n\t\tcpu_to_le32(OCFS2_SB(inode->i_sb)->fs_generation);\n\txblk->xb_blkno = cpu_to_le64(first_blkno);\n\tif (indexed) {\n\t\tstruct ocfs2_xattr_tree_root *xr = &xblk->xb_attrs.xb_root;\n\t\txr->xt_clusters = cpu_to_le32(1);\n\t\txr->xt_last_eb_blk = 0;\n\t\txr->xt_list.l_tree_depth = 0;\n\t\txr->xt_list.l_count = cpu_to_le16(\n\t\t\t\t\tocfs2_xattr_recs_per_xb(inode->i_sb));\n\t\txr->xt_list.l_next_free_rec = cpu_to_le16(1);\n\t\txblk->xb_flags = cpu_to_le16(OCFS2_XATTR_INDEXED);\n\t}\n\tocfs2_journal_dirty(ctxt->handle, new_bh);\n\n\t/* Add it to the inode */\n\tdi->i_xattr_loc = cpu_to_le64(first_blkno);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tOCFS2_I(inode)->ip_dyn_features |= OCFS2_HAS_XATTR_FL;\n\tdi->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tocfs2_journal_dirty(ctxt->handle, inode_bh);\n\n\t*ret_bh = new_bh;\n\tnew_bh = NULL;\n\nend:\n\tbrelse(new_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_block_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2798-2843",
    "snippet": "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txs->xattr_bh = blk_bh;\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\txs->header = &xb->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)(blk_bh->b_data) + blk_bh->b_size;\n\t\txs->here = xs->header->xh_entries;\n\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t} else\n\t\tret = ocfs2_xattr_index_block_find(inode, blk_bh,\n\t\t\t\t\t\t   name_index,\n\t\t\t\t\t\t   name, xs);\n\n\tif (ret && ret != -ENODATA) {\n\t\txs->xattr_bh = NULL;\n\t\tgoto cleanup;\n\t}\n\txs->not_found = ret;\n\treturn 0;\ncleanup:\n\tbrelse(blk_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "blk_bh"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_index_block_find",
          "args": [
            "inode",
            "blk_bh",
            "name_index",
            "name",
            "xs"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_index_block_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "3911-3953",
          "snippet": "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs)\n{\n\tint ret;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)root_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xb_root = &xb->xb_attrs.xb_root;\n\tstruct ocfs2_extent_list *el = &xb_root->xt_list;\n\tu64 p_blkno = 0;\n\tu32 first_hash, num_clusters = 0;\n\tu32 name_hash = ocfs2_xattr_name_hash(inode, name, strlen(name));\n\n\tif (le16_to_cpu(el->l_next_free_rec) == 0)\n\t\treturn -ENODATA;\n\n\ttrace_ocfs2_xattr_index_block_find(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, name_hash,\n\t\t\t\t\t(unsigned long long)root_bh->b_blocknr,\n\t\t\t\t\t-1);\n\n\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno, &first_hash,\n\t\t\t\t  &num_clusters, el);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(p_blkno == 0 || num_clusters == 0 || first_hash > name_hash);\n\n\ttrace_ocfs2_xattr_index_block_find_rec(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, first_hash,\n\t\t\t\t\t(unsigned long long)p_blkno,\n\t\t\t\t\tnum_clusters);\n\n\tret = ocfs2_xattr_bucket_find(inode, name_index, name, name_hash,\n\t\t\t\t      p_blkno, first_hash, num_clusters, xs);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
            "static int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_mv_xattr_buckets(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 src_blk, u64 last_blk, u64 to_blk,\n\t\t\t\t  unsigned int start_bucket,\n\t\t\t\t  u32 *first_hash);\n\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs)\n{\n\tint ret;\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)root_bh->b_data;\n\tstruct ocfs2_xattr_tree_root *xb_root = &xb->xb_attrs.xb_root;\n\tstruct ocfs2_extent_list *el = &xb_root->xt_list;\n\tu64 p_blkno = 0;\n\tu32 first_hash, num_clusters = 0;\n\tu32 name_hash = ocfs2_xattr_name_hash(inode, name, strlen(name));\n\n\tif (le16_to_cpu(el->l_next_free_rec) == 0)\n\t\treturn -ENODATA;\n\n\ttrace_ocfs2_xattr_index_block_find(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, name_hash,\n\t\t\t\t\t(unsigned long long)root_bh->b_blocknr,\n\t\t\t\t\t-1);\n\n\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno, &first_hash,\n\t\t\t\t  &num_clusters, el);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(p_blkno == 0 || num_clusters == 0 || first_hash > name_hash);\n\n\ttrace_ocfs2_xattr_index_block_find_rec(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\tname, name_index, first_hash,\n\t\t\t\t\t(unsigned long long)p_blkno,\n\t\t\t\t\tnum_clusters);\n\n\tret = ocfs2_xattr_bucket_find(inode, name_index, name, name_hash,\n\t\t\t\t      p_blkno, first_hash, num_clusters, xs);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_find_entry",
          "args": [
            "name_index",
            "name",
            "xs"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1061-1089",
          "snippet": "static int ocfs2_xattr_find_entry(int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *entry;\n\tsize_t name_len;\n\tint i, cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(name);\n\tentry = xs->here;\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tcmp = name_index - ocfs2_xattr_get_type(entry);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->xe_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, (xs->base +\n\t\t\t\t     le16_to_cpu(entry->xe_name_offset)),\n\t\t\t\t     name_len);\n\t\tif (cmp == 0)\n\t\t\tbreak;\n\t\tentry += 1;\n\t}\n\txs->here = entry;\n\n\treturn cmp ? -ENODATA : 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_find_entry(int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *entry;\n\tsize_t name_len;\n\tint i, cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(name);\n\tentry = xs->here;\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tcmp = name_index - ocfs2_xattr_get_type(entry);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->xe_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, (xs->base +\n\t\t\t\t     le16_to_cpu(entry->xe_name_offset)),\n\t\t\t\t     name_len);\n\t\tif (cmp == 0)\n\t\t\tbreak;\n\t\tentry += 1;\n\t}\n\txs->here = entry;\n\n\treturn cmp ? -ENODATA : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xb->xb_flags"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_block",
          "args": [
            "inode",
            "le64_to_cpu(di->i_xattr_loc)",
            "&blk_bh"
          ],
          "line": 2811
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "531-545",
          "snippet": "static int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_xattr_loc"
          ],
          "line": 2811
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txs->xattr_bh = blk_bh;\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\txs->header = &xb->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)(blk_bh->b_data) + blk_bh->b_size;\n\t\txs->here = xs->header->xh_entries;\n\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t} else\n\t\tret = ocfs2_xattr_index_block_find(inode, blk_bh,\n\t\t\t\t\t\t   name_index,\n\t\t\t\t\t\t   name, xs);\n\n\tif (ret && ret != -ENODATA) {\n\t\txs->xattr_bh = NULL;\n\t\tgoto cleanup;\n\t}\n\txs->not_found = ret;\n\treturn 0;\ncleanup:\n\tbrelse(blk_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_ibody_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2754-2790",
    "snippet": "static int ocfs2_xattr_ibody_set(struct inode *inode,\n\t\t\t\t struct ocfs2_xattr_info *xi,\n\t\t\t\t struct ocfs2_xattr_search *xs,\n\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xa_loc loc;\n\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)\n\t\treturn -ENOSPC;\n\n\tdown_write(&oi->ip_alloc_sem);\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)) {\n\t\tret = ocfs2_xattr_ibody_init(inode, xs->inode_bh, ctxt);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tocfs2_init_dinode_xa_loc(&loc, inode, xs->inode_bh,\n\t\t\t\t xs->not_found ? NULL : xs->here);\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\txs->here = loc.xl_entry;\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_set",
          "args": [
            "&loc",
            "xi",
            "ctxt"
          ],
          "line": 2778
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2207-2250",
          "snippet": "static int ocfs2_xa_set(struct ocfs2_xa_loc *loc,\n\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 name_hash = ocfs2_xattr_name_hash(loc->xl_inode, xi->xi_name,\n\t\t\t\t\t      xi->xi_name_len);\n\n\tret = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * From here on out, everything is going to modify the buffer a\n\t * little.  Errors are going to leave the xattr header in a\n\t * sane state.  Thus, even with errors we dirty the sucker.\n\t */\n\n\t/* Don't worry, we are never called with !xi_value and !xl_entry */\n\tif (!xi->xi_value) {\n\t\tret = ocfs2_xa_remove(loc, ctxt);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_prepare_entry(loc, xi, name_hash, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_store_value(loc, xi, ctxt);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_dirty:\n\tocfs2_xa_journal_dirty(ctxt->handle, loc);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_set(struct ocfs2_xa_loc *loc,\n\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 name_hash = ocfs2_xattr_name_hash(loc->xl_inode, xi->xi_name,\n\t\t\t\t\t      xi->xi_name_len);\n\n\tret = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * From here on out, everything is going to modify the buffer a\n\t * little.  Errors are going to leave the xattr header in a\n\t * sane state.  Thus, even with errors we dirty the sucker.\n\t */\n\n\t/* Don't worry, we are never called with !xi_value and !xl_entry */\n\tif (!xi->xi_value) {\n\t\tret = ocfs2_xa_remove(loc, ctxt);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_prepare_entry(loc, xi, name_hash, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_store_value(loc, xi, ctxt);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_dirty:\n\tocfs2_xa_journal_dirty(ctxt->handle, loc);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_xa_loc",
          "args": [
            "&loc",
            "inode",
            "xs->inode_bh",
            "xs->not_found ? NULL : xs->here"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_xa_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2252-2269",
          "snippet": "static void ocfs2_init_dinode_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     struct ocfs2_xattr_entry *entry)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_XATTR_FL));\n\n\tloc->xl_inode = inode;\n\tloc->xl_ops = &ocfs2_xa_block_loc_ops;\n\tloc->xl_storage = bh;\n\tloc->xl_entry = entry;\n\tloc->xl_size = le16_to_cpu(di->i_xattr_inline_size);\n\tloc->xl_header =\n\t\t(struct ocfs2_xattr_header *)(bh->b_data + bh->b_size -\n\t\t\t\t\t      loc->xl_size);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);",
            "static const struct ocfs2_xa_loc_operations ocfs2_xa_block_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_block_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_block_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_block_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_block_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_block_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_block_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_block_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_block_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_block_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_block_fill_value_buf,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\nstatic const struct ocfs2_xa_loc_operations ocfs2_xa_block_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_block_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_block_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_block_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_block_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_block_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_block_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_block_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_block_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_block_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_block_fill_value_buf,\n};\n\nstatic void ocfs2_init_dinode_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     struct ocfs2_xattr_entry *entry)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_XATTR_FL));\n\n\tloc->xl_inode = inode;\n\tloc->xl_ops = &ocfs2_xa_block_loc_ops;\n\tloc->xl_storage = bh;\n\tloc->xl_entry = entry;\n\tloc->xl_size = le16_to_cpu(di->i_xattr_inline_size);\n\tloc->xl_header =\n\t\t(struct ocfs2_xattr_header *)(bh->b_data + bh->b_size -\n\t\t\t\t\t      loc->xl_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_ibody_init",
          "args": [
            "inode",
            "xs->inode_bh",
            "ctxt"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_ibody_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2701-2746",
          "snippet": "static int ocfs2_xattr_ibody_init(struct inode *inode,\n\t\t\t\t  struct buffer_head *di_bh,\n\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tunsigned int xattrsize = osb->s_xattr_inline_size;\n\n\tif (!ocfs2_xattr_has_space_inline(inode, di)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Adjust extent record count or inline data size\n\t * to reserve space for extended attribute.\n\t */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\t\tle16_add_cpu(&idata->id_count, -xattrsize);\n\t} else if (!(ocfs2_inode_is_fast_symlink(inode))) {\n\t\tstruct ocfs2_extent_list *el = &di->id2.i_list;\n\t\tle16_add_cpu(&el->l_count, -(xattrsize /\n\t\t\t\t\t     sizeof(struct ocfs2_extent_rec)));\n\t}\n\tdi->i_xattr_inline_size = cpu_to_le16(xattrsize);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_INLINE_XATTR_FL|OCFS2_HAS_XATTR_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_journal_dirty(ctxt->handle, di_bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_ibody_init(struct inode *inode,\n\t\t\t\t  struct buffer_head *di_bh,\n\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tunsigned int xattrsize = osb->s_xattr_inline_size;\n\n\tif (!ocfs2_xattr_has_space_inline(inode, di)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Adjust extent record count or inline data size\n\t * to reserve space for extended attribute.\n\t */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\t\tle16_add_cpu(&idata->id_count, -xattrsize);\n\t} else if (!(ocfs2_inode_is_fast_symlink(inode))) {\n\t\tstruct ocfs2_extent_list *el = &di->id2.i_list;\n\t\tle16_add_cpu(&el->l_count, -(xattrsize /\n\t\t\t\t\t     sizeof(struct ocfs2_extent_rec)));\n\t}\n\tdi->i_xattr_inline_size = cpu_to_le16(xattrsize);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_INLINE_XATTR_FL|OCFS2_HAS_XATTR_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_journal_dirty(ctxt->handle, di_bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 2766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_ibody_set(struct inode *inode,\n\t\t\t\t struct ocfs2_xattr_info *xi,\n\t\t\t\t struct ocfs2_xattr_search *xs,\n\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xa_loc loc;\n\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)\n\t\treturn -ENOSPC;\n\n\tdown_write(&oi->ip_alloc_sem);\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)) {\n\t\tret = ocfs2_xattr_ibody_init(inode, xs->inode_bh, ctxt);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tocfs2_init_dinode_xa_loc(&loc, inode, xs->inode_bh,\n\t\t\t\t xs->not_found ? NULL : xs->here);\n\tret = ocfs2_xa_set(&loc, xi, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\txs->here = loc.xl_entry;\n\nout:\n\tup_write(&oi->ip_alloc_sem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_ibody_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2701-2746",
    "snippet": "static int ocfs2_xattr_ibody_init(struct inode *inode,\n\t\t\t\t  struct buffer_head *di_bh,\n\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tunsigned int xattrsize = osb->s_xattr_inline_size;\n\n\tif (!ocfs2_xattr_has_space_inline(inode, di)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Adjust extent record count or inline data size\n\t * to reserve space for extended attribute.\n\t */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\t\tle16_add_cpu(&idata->id_count, -xattrsize);\n\t} else if (!(ocfs2_inode_is_fast_symlink(inode))) {\n\t\tstruct ocfs2_extent_list *el = &di->id2.i_list;\n\t\tle16_add_cpu(&el->l_count, -(xattrsize /\n\t\t\t\t\t     sizeof(struct ocfs2_extent_rec)));\n\t}\n\tdi->i_xattr_inline_size = cpu_to_le16(xattrsize);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_INLINE_XATTR_FL|OCFS2_HAS_XATTR_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_journal_dirty(ctxt->handle, di_bh);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "ctxt->handle",
            "di_bh"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "oi->ip_dyn_features"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "xattrsize"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&el->l_count",
            "-(xattrsize /\n\t\t\t\t\t     sizeof(struct ocfs2_extent_rec))"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/symlink.h",
          "lines": "35-39",
          "snippet": "static inline int ocfs2_inode_is_fast_symlink(struct inode *inode)\n{\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks == 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_inode_is_fast_symlink(struct inode *inode)\n{\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&idata->id_count",
            "-xattrsize"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "ctxt->handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_has_space_inline",
          "args": [
            "inode",
            "di"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_has_space_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2624-2650",
          "snippet": "static int ocfs2_xattr_has_space_inline(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tunsigned int xattrsize = OCFS2_SB(inode->i_sb)->s_xattr_inline_size;\n\tint free;\n\n\tif (xattrsize < OCFS2_MIN_XATTR_INLINE_SIZE)\n\t\treturn 0;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\t\tfree = le16_to_cpu(idata->id_count) - le64_to_cpu(di->i_size);\n\t} else if (ocfs2_inode_is_fast_symlink(inode)) {\n\t\tfree = ocfs2_fast_symlink_chars(inode->i_sb) -\n\t\t\tle64_to_cpu(di->i_size);\n\t} else {\n\t\tstruct ocfs2_extent_list *el = &di->id2.i_list;\n\t\tfree = (le16_to_cpu(el->l_count) -\n\t\t\tle16_to_cpu(el->l_next_free_rec)) *\n\t\t\tsizeof(struct ocfs2_extent_rec);\n\t}\n\tif (free >= xattrsize)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_has_space_inline(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tunsigned int xattrsize = OCFS2_SB(inode->i_sb)->s_xattr_inline_size;\n\tint free;\n\n\tif (xattrsize < OCFS2_MIN_XATTR_INLINE_SIZE)\n\t\treturn 0;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\t\tfree = le16_to_cpu(idata->id_count) - le64_to_cpu(di->i_size);\n\t} else if (ocfs2_inode_is_fast_symlink(inode)) {\n\t\tfree = ocfs2_fast_symlink_chars(inode->i_sb) -\n\t\t\tle64_to_cpu(di->i_size);\n\t} else {\n\t\tstruct ocfs2_extent_list *el = &di->id2.i_list;\n\t\tfree = (le16_to_cpu(el->l_count) -\n\t\t\tle16_to_cpu(el->l_next_free_rec)) *\n\t\t\tsizeof(struct ocfs2_extent_rec);\n\t}\n\tif (free >= xattrsize)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_ibody_init(struct inode *inode,\n\t\t\t\t  struct buffer_head *di_bh,\n\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tunsigned int xattrsize = osb->s_xattr_inline_size;\n\n\tif (!ocfs2_xattr_has_space_inline(inode, di)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(ctxt->handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Adjust extent record count or inline data size\n\t * to reserve space for extended attribute.\n\t */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\t\tle16_add_cpu(&idata->id_count, -xattrsize);\n\t} else if (!(ocfs2_inode_is_fast_symlink(inode))) {\n\t\tstruct ocfs2_extent_list *el = &di->id2.i_list;\n\t\tle16_add_cpu(&el->l_count, -(xattrsize /\n\t\t\t\t\t     sizeof(struct ocfs2_extent_rec)));\n\t}\n\tdi->i_xattr_inline_size = cpu_to_le16(xattrsize);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_INLINE_XATTR_FL|OCFS2_HAS_XATTR_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_journal_dirty(ctxt->handle, di_bh);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_ibody_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2658-2699",
    "snippet": "static int ocfs2_xattr_ibody_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tint ret;\n\tint has_space = 0;\n\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)\n\t\treturn 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)) {\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\thas_space = ocfs2_xattr_has_space_inline(inode, di);\n\t\tup_read(&oi->ip_alloc_sem);\n\t\tif (!has_space)\n\t\t\treturn 0;\n\t}\n\n\txs->xattr_bh = xs->inode_bh;\n\txs->end = (void *)di + inode->i_sb->s_blocksize;\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - le16_to_cpu(di->i_xattr_inline_size));\n\telse\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - OCFS2_SB(inode->i_sb)->s_xattr_inline_size);\n\txs->base = (void *)xs->header;\n\txs->here = xs->header->xh_entries;\n\n\t/* Find the named attribute. */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t\tif (ret && ret != -ENODATA)\n\t\t\treturn ret;\n\t\txs->not_found = ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_find_entry",
          "args": [
            "name_index",
            "name",
            "xs"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1061-1089",
          "snippet": "static int ocfs2_xattr_find_entry(int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *entry;\n\tsize_t name_len;\n\tint i, cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(name);\n\tentry = xs->here;\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tcmp = name_index - ocfs2_xattr_get_type(entry);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->xe_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, (xs->base +\n\t\t\t\t     le16_to_cpu(entry->xe_name_offset)),\n\t\t\t\t     name_len);\n\t\tif (cmp == 0)\n\t\t\tbreak;\n\t\tentry += 1;\n\t}\n\txs->here = entry;\n\n\treturn cmp ? -ENODATA : 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_find_entry(int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *entry;\n\tsize_t name_len;\n\tint i, cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(name);\n\tentry = xs->here;\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tcmp = name_index - ocfs2_xattr_get_type(entry);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->xe_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, (xs->base +\n\t\t\t\t     le16_to_cpu(entry->xe_name_offset)),\n\t\t\t\t     name_len);\n\t\tif (cmp == 0)\n\t\t\tbreak;\n\t\tentry += 1;\n\t}\n\txs->here = entry;\n\n\treturn cmp ? -ENODATA : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_xattr_inline_size"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_has_space_inline",
          "args": [
            "inode",
            "di"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_has_space_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2624-2650",
          "snippet": "static int ocfs2_xattr_has_space_inline(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tunsigned int xattrsize = OCFS2_SB(inode->i_sb)->s_xattr_inline_size;\n\tint free;\n\n\tif (xattrsize < OCFS2_MIN_XATTR_INLINE_SIZE)\n\t\treturn 0;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\t\tfree = le16_to_cpu(idata->id_count) - le64_to_cpu(di->i_size);\n\t} else if (ocfs2_inode_is_fast_symlink(inode)) {\n\t\tfree = ocfs2_fast_symlink_chars(inode->i_sb) -\n\t\t\tle64_to_cpu(di->i_size);\n\t} else {\n\t\tstruct ocfs2_extent_list *el = &di->id2.i_list;\n\t\tfree = (le16_to_cpu(el->l_count) -\n\t\t\tle16_to_cpu(el->l_next_free_rec)) *\n\t\t\tsizeof(struct ocfs2_extent_rec);\n\t}\n\tif (free >= xattrsize)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_has_space_inline(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tunsigned int xattrsize = OCFS2_SB(inode->i_sb)->s_xattr_inline_size;\n\tint free;\n\n\tif (xattrsize < OCFS2_MIN_XATTR_INLINE_SIZE)\n\t\treturn 0;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\t\tfree = le16_to_cpu(idata->id_count) - le64_to_cpu(di->i_size);\n\t} else if (ocfs2_inode_is_fast_symlink(inode)) {\n\t\tfree = ocfs2_fast_symlink_chars(inode->i_sb) -\n\t\t\tle64_to_cpu(di->i_size);\n\t} else {\n\t\tstruct ocfs2_extent_list *el = &di->id2.i_list;\n\t\tfree = (le16_to_cpu(el->l_count) -\n\t\t\tle16_to_cpu(el->l_next_free_rec)) *\n\t\t\tsizeof(struct ocfs2_extent_rec);\n\t}\n\tif (free >= xattrsize)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2663
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_ibody_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tint ret;\n\tint has_space = 0;\n\n\tif (inode->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE)\n\t\treturn 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)) {\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\thas_space = ocfs2_xattr_has_space_inline(inode, di);\n\t\tup_read(&oi->ip_alloc_sem);\n\t\tif (!has_space)\n\t\t\treturn 0;\n\t}\n\n\txs->xattr_bh = xs->inode_bh;\n\txs->end = (void *)di + inode->i_sb->s_blocksize;\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL)\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - le16_to_cpu(di->i_xattr_inline_size));\n\telse\n\t\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - OCFS2_SB(inode->i_sb)->s_xattr_inline_size);\n\txs->base = (void *)xs->header;\n\txs->here = xs->header->xh_entries;\n\n\t/* Find the named attribute. */\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t\tif (ret && ret != -ENODATA)\n\t\t\treturn ret;\n\t\txs->not_found = ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_xattr_has_space_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2624-2650",
    "snippet": "static int ocfs2_xattr_has_space_inline(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tunsigned int xattrsize = OCFS2_SB(inode->i_sb)->s_xattr_inline_size;\n\tint free;\n\n\tif (xattrsize < OCFS2_MIN_XATTR_INLINE_SIZE)\n\t\treturn 0;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\t\tfree = le16_to_cpu(idata->id_count) - le64_to_cpu(di->i_size);\n\t} else if (ocfs2_inode_is_fast_symlink(inode)) {\n\t\tfree = ocfs2_fast_symlink_chars(inode->i_sb) -\n\t\t\tle64_to_cpu(di->i_size);\n\t} else {\n\t\tstruct ocfs2_extent_list *el = &di->id2.i_list;\n\t\tfree = (le16_to_cpu(el->l_count) -\n\t\t\tle16_to_cpu(el->l_next_free_rec)) *\n\t\t\tsizeof(struct ocfs2_extent_rec);\n\t}\n\tif (free >= xattrsize)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_size"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_fast_symlink_chars",
          "args": [
            "inode->i_sb"
          ],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fast_symlink_chars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1480-1483",
          "snippet": "static inline int ocfs2_fast_symlink_chars(int blocksize)\n{\n\treturn blocksize - offsetof(struct ocfs2_dinode, id2.i_symlink);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_fast_symlink_chars(int blocksize)\n{\n\treturn blocksize - offsetof(struct ocfs2_dinode, id2.i_symlink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/symlink.h",
          "lines": "35-39",
          "snippet": "static inline int ocfs2_inode_is_fast_symlink(struct inode *inode)\n{\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks == 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_inode_is_fast_symlink(struct inode *inode)\n{\n\treturn (S_ISLNK(inode->i_mode) &&\n\t\tinode->i_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_has_space_inline(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tunsigned int xattrsize = OCFS2_SB(inode->i_sb)->s_xattr_inline_size;\n\tint free;\n\n\tif (xattrsize < OCFS2_MIN_XATTR_INLINE_SIZE)\n\t\treturn 0;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\t\tfree = le16_to_cpu(idata->id_count) - le64_to_cpu(di->i_size);\n\t} else if (ocfs2_inode_is_fast_symlink(inode)) {\n\t\tfree = ocfs2_fast_symlink_chars(inode->i_sb) -\n\t\t\tle64_to_cpu(di->i_size);\n\t} else {\n\t\tstruct ocfs2_extent_list *el = &di->id2.i_list;\n\t\tfree = (le16_to_cpu(el->l_count) -\n\t\t\tle16_to_cpu(el->l_next_free_rec)) *\n\t\t\tsizeof(struct ocfs2_extent_rec);\n\t}\n\tif (free >= xattrsize)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_xattr_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2545-2622",
    "snippet": "int ocfs2_xattr_remove(struct inode *inode, struct buffer_head *di_bh)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_caching_info *ref_ci = NULL;\n\thandle_t *handle;\n\tint ret;\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL) {\n\t\tret = ocfs2_lock_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t       le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tref_ci = &ref_tree->rf_ci;\n\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_ibody_remove(inode, di_bh,\n\t\t\t\t\t       ref_ci, ref_root_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (di->i_xattr_loc) {\n\t\tret = ocfs2_xattr_free_block(inode,\n\t\t\t\t\t     le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t\t     ref_ci, ref_root_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans((OCFS2_SB(inode->i_sb)),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdi->i_xattr_loc = 0;\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~(OCFS2_INLINE_XATTR_FL | OCFS2_HAS_XATTR_FL);\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(OCFS2_SB(inode->i_sb), ref_tree, 1);\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_root_bh"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "ref_tree",
            "1"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "handle"
          ],
          "line": 2616
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 2614
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "0"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "oi->ip_dyn_features"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 2608
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "(OCFS2_SB(inode->i_sb))",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_free_block",
          "args": [
            "inode",
            "le64_to_cpu(di->i_xattr_loc)",
            "ref_ci",
            "ref_root_bh"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2465-2538",
          "snippet": "static int ocfs2_xattr_free_block(struct inode *inode,\n\t\t\t\t  u64 block,\n\t\t\t\t  struct ocfs2_caching_info *ref_ci,\n\t\t\t\t  struct buffer_head *ref_root_bh)\n{\n\tstruct inode *xb_alloc_inode;\n\tstruct buffer_head *xb_alloc_bh = NULL;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle;\n\tint ret = 0;\n\tu64 blk, bg_blkno;\n\tu16 bit;\n\n\tret = ocfs2_read_xattr_block(inode, block, &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_block_remove(inode, blk_bh, ref_ci, ref_root_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tblk = le64_to_cpu(xb->xb_blkno);\n\tbit = le16_to_cpu(xb->xb_suballoc_bit);\n\tif (xb->xb_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(xb->xb_suballoc_loc);\n\telse\n\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\txb_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\tle16_to_cpu(xb->xb_suballoc_slot));\n\tif (!xb_alloc_inode) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tmutex_lock(&xb_alloc_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(xb_alloc_inode, &xb_alloc_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_free_suballoc_bits(handle, xb_alloc_inode, xb_alloc_bh,\n\t\t\t\t       bit, bg_blkno, 1);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tocfs2_inode_unlock(xb_alloc_inode, 1);\n\tbrelse(xb_alloc_bh);\nout_mutex:\n\tmutex_unlock(&xb_alloc_inode->i_mutex);\n\tiput(xb_alloc_inode);\nout:\n\tbrelse(blk_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_free_block(struct inode *inode,\n\t\t\t\t  u64 block,\n\t\t\t\t  struct ocfs2_caching_info *ref_ci,\n\t\t\t\t  struct buffer_head *ref_root_bh)\n{\n\tstruct inode *xb_alloc_inode;\n\tstruct buffer_head *xb_alloc_bh = NULL;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle;\n\tint ret = 0;\n\tu64 blk, bg_blkno;\n\tu16 bit;\n\n\tret = ocfs2_read_xattr_block(inode, block, &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_block_remove(inode, blk_bh, ref_ci, ref_root_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tblk = le64_to_cpu(xb->xb_blkno);\n\tbit = le16_to_cpu(xb->xb_suballoc_bit);\n\tif (xb->xb_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(xb->xb_suballoc_loc);\n\telse\n\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\txb_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\tle16_to_cpu(xb->xb_suballoc_slot));\n\tif (!xb_alloc_inode) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tmutex_lock(&xb_alloc_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(xb_alloc_inode, &xb_alloc_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_free_suballoc_bits(handle, xb_alloc_inode, xb_alloc_bh,\n\t\t\t\t       bit, bg_blkno, 1);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tocfs2_inode_unlock(xb_alloc_inode, 1);\n\tbrelse(xb_alloc_bh);\nout_mutex:\n\tmutex_unlock(&xb_alloc_inode->i_mutex);\n\tiput(xb_alloc_inode);\nout:\n\tbrelse(blk_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_xattr_loc"
          ],
          "line": 2584
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_ibody_remove",
          "args": [
            "inode",
            "di_bh",
            "ref_ci",
            "ref_root_bh"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_ibody_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2406-2428",
          "snippet": "static int ocfs2_xattr_ibody_remove(struct inode *inode,\n\t\t\t\t    struct buffer_head *di_bh,\n\t\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t\t    struct buffer_head *ref_root_bh)\n{\n\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_xattr_header *header;\n\tint ret;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = di_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\theader = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tret = ocfs2_remove_value_outside(inode, &vb, header,\n\t\t\t\t\t ref_ci, ref_root_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_ibody_remove(struct inode *inode,\n\t\t\t\t    struct buffer_head *di_bh,\n\t\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t\t    struct buffer_head *ref_root_bh)\n{\n\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_xattr_header *header;\n\tint ret;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = di_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\theader = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tret = ocfs2_remove_value_outside(inode, &vb, header,\n\t\t\t\t\t ref_ci, ref_root_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "le64_to_cpu(di->i_refcount_loc)",
            "1",
            "&ref_tree",
            "&ref_root_bh"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "452-524",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_xattr",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "518-523",
          "snippet": "static inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_xattr_remove(struct inode *inode, struct buffer_head *di_bh)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_caching_info *ref_ci = NULL;\n\thandle_t *handle;\n\tint ret;\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL) {\n\t\tret = ocfs2_lock_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t       le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tref_ci = &ref_tree->rf_ci;\n\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_ibody_remove(inode, di_bh,\n\t\t\t\t\t       ref_ci, ref_root_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (di->i_xattr_loc) {\n\t\tret = ocfs2_xattr_free_block(inode,\n\t\t\t\t\t     le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t\t     ref_ci, ref_root_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans((OCFS2_SB(inode->i_sb)),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdi->i_xattr_loc = 0;\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~(OCFS2_INLINE_XATTR_FL | OCFS2_HAS_XATTR_FL);\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(OCFS2_SB(inode->i_sb), ref_tree, 1);\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_free_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2465-2538",
    "snippet": "static int ocfs2_xattr_free_block(struct inode *inode,\n\t\t\t\t  u64 block,\n\t\t\t\t  struct ocfs2_caching_info *ref_ci,\n\t\t\t\t  struct buffer_head *ref_root_bh)\n{\n\tstruct inode *xb_alloc_inode;\n\tstruct buffer_head *xb_alloc_bh = NULL;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle;\n\tint ret = 0;\n\tu64 blk, bg_blkno;\n\tu16 bit;\n\n\tret = ocfs2_read_xattr_block(inode, block, &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_block_remove(inode, blk_bh, ref_ci, ref_root_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tblk = le64_to_cpu(xb->xb_blkno);\n\tbit = le16_to_cpu(xb->xb_suballoc_bit);\n\tif (xb->xb_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(xb->xb_suballoc_loc);\n\telse\n\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\txb_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\tle16_to_cpu(xb->xb_suballoc_slot));\n\tif (!xb_alloc_inode) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tmutex_lock(&xb_alloc_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(xb_alloc_inode, &xb_alloc_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_free_suballoc_bits(handle, xb_alloc_inode, xb_alloc_bh,\n\t\t\t\t       bit, bg_blkno, 1);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tocfs2_inode_unlock(xb_alloc_inode, 1);\n\tbrelse(xb_alloc_bh);\nout_mutex:\n\tmutex_unlock(&xb_alloc_inode->i_mutex);\n\tiput(xb_alloc_inode);\nout:\n\tbrelse(blk_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "blk_bh"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "xb_alloc_inode"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&xb_alloc_inode->i_mutex"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "xb_alloc_inode",
            "1"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_suballoc_bits",
          "args": [
            "handle",
            "xb_alloc_inode",
            "xb_alloc_bh",
            "bit",
            "bg_blkno",
            "1"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2519-2528",
          "snippet": "int ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_SUBALLOC_FREE"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "xb_alloc_inode",
            "&xb_alloc_bh",
            "1"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&xb_alloc_inode->i_mutex"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "EXTENT_ALLOC_SYSTEM_INODE",
            "le16_to_cpu(xb->xb_suballoc_slot)"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xb->xb_suballoc_slot"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_which_suballoc_group",
          "args": [
            "blk",
            "bit"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_suballoc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "156-161",
          "snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "xb->xb_suballoc_loc"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_block_remove",
          "args": [
            "inode",
            "blk_bh",
            "ref_ci",
            "ref_root_bh"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_block_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2435-2463",
          "snippet": "static int ocfs2_xattr_block_remove(struct inode *inode,\n\t\t\t\t    struct buffer_head *blk_bh,\n\t\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t\t    struct buffer_head *ref_root_bh)\n{\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = blk_bh,\n\t\t.vb_access = ocfs2_journal_access_xb,\n\t};\n\tstruct ocfs2_rm_xattr_bucket_para args = {\n\t\t.ref_ci = ref_ci,\n\t\t.ref_root_bh = ref_root_bh,\n\t};\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &(xb->xb_attrs.xb_header);\n\t\tret = ocfs2_remove_value_outside(inode, &vb, header,\n\t\t\t\t\t\t ref_ci, ref_root_bh);\n\t} else\n\t\tret = ocfs2_iterate_xattr_index_block(inode,\n\t\t\t\t\t\tblk_bh,\n\t\t\t\t\t\tocfs2_rm_xattr_cluster,\n\t\t\t\t\t\t&args);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_remove(struct inode *inode,\n\t\t\t\t    struct buffer_head *blk_bh,\n\t\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t\t    struct buffer_head *ref_root_bh)\n{\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = blk_bh,\n\t\t.vb_access = ocfs2_journal_access_xb,\n\t};\n\tstruct ocfs2_rm_xattr_bucket_para args = {\n\t\t.ref_ci = ref_ci,\n\t\t.ref_root_bh = ref_root_bh,\n\t};\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &(xb->xb_attrs.xb_header);\n\t\tret = ocfs2_remove_value_outside(inode, &vb, header,\n\t\t\t\t\t\t ref_ci, ref_root_bh);\n\t} else\n\t\tret = ocfs2_iterate_xattr_index_block(inode,\n\t\t\t\t\t\tblk_bh,\n\t\t\t\t\t\tocfs2_rm_xattr_cluster,\n\t\t\t\t\t\t&args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_block",
          "args": [
            "inode",
            "block",
            "&blk_bh"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "531-545",
          "snippet": "static int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_free_block(struct inode *inode,\n\t\t\t\t  u64 block,\n\t\t\t\t  struct ocfs2_caching_info *ref_ci,\n\t\t\t\t  struct buffer_head *ref_root_bh)\n{\n\tstruct inode *xb_alloc_inode;\n\tstruct buffer_head *xb_alloc_bh = NULL;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle;\n\tint ret = 0;\n\tu64 blk, bg_blkno;\n\tu16 bit;\n\n\tret = ocfs2_read_xattr_block(inode, block, &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_block_remove(inode, blk_bh, ref_ci, ref_root_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tblk = le64_to_cpu(xb->xb_blkno);\n\tbit = le16_to_cpu(xb->xb_suballoc_bit);\n\tif (xb->xb_suballoc_loc)\n\t\tbg_blkno = le64_to_cpu(xb->xb_suballoc_loc);\n\telse\n\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\txb_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\tle16_to_cpu(xb->xb_suballoc_slot));\n\tif (!xb_alloc_inode) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tmutex_lock(&xb_alloc_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(xb_alloc_inode, &xb_alloc_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_free_suballoc_bits(handle, xb_alloc_inode, xb_alloc_bh,\n\t\t\t\t       bit, bg_blkno, 1);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tocfs2_inode_unlock(xb_alloc_inode, 1);\n\tbrelse(xb_alloc_bh);\nout_mutex:\n\tmutex_unlock(&xb_alloc_inode->i_mutex);\n\tiput(xb_alloc_inode);\nout:\n\tbrelse(blk_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_block_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2435-2463",
    "snippet": "static int ocfs2_xattr_block_remove(struct inode *inode,\n\t\t\t\t    struct buffer_head *blk_bh,\n\t\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t\t    struct buffer_head *ref_root_bh)\n{\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = blk_bh,\n\t\t.vb_access = ocfs2_journal_access_xb,\n\t};\n\tstruct ocfs2_rm_xattr_bucket_para args = {\n\t\t.ref_ci = ref_ci,\n\t\t.ref_root_bh = ref_root_bh,\n\t};\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &(xb->xb_attrs.xb_header);\n\t\tret = ocfs2_remove_value_outside(inode, &vb, header,\n\t\t\t\t\t\t ref_ci, ref_root_bh);\n\t} else\n\t\tret = ocfs2_iterate_xattr_index_block(inode,\n\t\t\t\t\t\tblk_bh,\n\t\t\t\t\t\tocfs2_rm_xattr_cluster,\n\t\t\t\t\t\t&args);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_iterate_xattr_index_block",
          "args": [
            "inode",
            "blk_bh",
            "ocfs2_rm_xattr_cluster",
            "&args"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iterate_xattr_index_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4071-4110",
          "snippet": "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *blk_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_extent_list *el = &xb->xb_attrs.xb_root.xt_list;\n\tint ret = 0;\n\tu32 name_hash = UINT_MAX, e_cpos = 0, num_clusters = 0;\n\tu64 p_blkno = 0;\n\n\tif (!el->l_next_free_rec || !rec_func)\n\t\treturn 0;\n\n\twhile (name_hash > 0) {\n\t\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno,\n\t\t\t\t\t  &e_cpos, &num_clusters, el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rec_func(inode, blk_bh, p_blkno, e_cpos,\n\t\t\t       num_clusters, para);\n\t\tif (ret) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e_cpos == 0)\n\t\t\tbreak;\n\n\t\tname_hash = e_cpos - 1;\n\t}\n\n\treturn ret;\n\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);",
            "static int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);",
            "static int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *root_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para);\nstatic int ocfs2_delete_xattr_in_bucket(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\tvoid *para);\nstatic int ocfs2_rm_xattr_cluster(struct inode *inode,\n\t\t\t\t  struct buffer_head *root_bh,\n\t\t\t\t  u64 blkno,\n\t\t\t\t  u32 cpos,\n\t\t\t\t  u32 len,\n\t\t\t\t  void *para);\n\nstatic int ocfs2_iterate_xattr_index_block(struct inode *inode,\n\t\t\t\t\t   struct buffer_head *blk_bh,\n\t\t\t\t\t   xattr_tree_rec_func *rec_func,\n\t\t\t\t\t   void *para)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t\t(struct ocfs2_xattr_block *)blk_bh->b_data;\n\tstruct ocfs2_extent_list *el = &xb->xb_attrs.xb_root.xt_list;\n\tint ret = 0;\n\tu32 name_hash = UINT_MAX, e_cpos = 0, num_clusters = 0;\n\tu64 p_blkno = 0;\n\n\tif (!el->l_next_free_rec || !rec_func)\n\t\treturn 0;\n\n\twhile (name_hash > 0) {\n\t\tret = ocfs2_xattr_get_rec(inode, name_hash, &p_blkno,\n\t\t\t\t\t  &e_cpos, &num_clusters, el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rec_func(inode, blk_bh, p_blkno, e_cpos,\n\t\t\t       num_clusters, para);\n\t\tif (ret) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e_cpos == 0)\n\t\t\tbreak;\n\n\t\tname_hash = e_cpos - 1;\n\t}\n\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_value_outside",
          "args": [
            "inode",
            "&vb",
            "header",
            "ref_ci",
            "ref_root_bh"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_value_outside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2347-2404",
          "snippet": "static int ocfs2_remove_value_outside(struct inode*inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_xattr_header *header,\n\t\t\t\t      struct ocfs2_caching_info *ref_ci,\n\t\t\t\t      struct buffer_head *ref_root_bh)\n{\n\tint ret = 0, i, ref_credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, };\n\tvoid *val;\n\n\tocfs2_init_dealloc_ctxt(&ctxt.dealloc);\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(entry))\n\t\t\tcontinue;\n\n\t\tval = (void *)header +\n\t\t\tle16_to_cpu(entry->xe_name_offset);\n\t\tvb->vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t\t(val + OCFS2_XATTR_SIZE(entry->xe_name_len));\n\n\t\tret = ocfs2_lock_xattr_remove_allocators(inode, vb->vb_xv,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t &ctxt.meta_ac,\n\t\t\t\t\t\t\t &ref_credits);\n\n\t\tctxt.handle = ocfs2_start_trans(osb, ref_credits +\n\t\t\t\t\tocfs2_remove_extent_credits(osb->sb));\n\t\tif (IS_ERR(ctxt.handle)) {\n\t\t\tret = PTR_ERR(ctxt.handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_value_truncate(inode, vb, 0, &ctxt);\n\n\t\tocfs2_commit_trans(osb, ctxt.handle);\n\t\tif (ctxt.meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\t\t\tctxt.meta_ac = NULL;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_remove_value_outside(struct inode*inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_xattr_header *header,\n\t\t\t\t      struct ocfs2_caching_info *ref_ci,\n\t\t\t\t      struct buffer_head *ref_root_bh)\n{\n\tint ret = 0, i, ref_credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, };\n\tvoid *val;\n\n\tocfs2_init_dealloc_ctxt(&ctxt.dealloc);\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(entry))\n\t\t\tcontinue;\n\n\t\tval = (void *)header +\n\t\t\tle16_to_cpu(entry->xe_name_offset);\n\t\tvb->vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t\t(val + OCFS2_XATTR_SIZE(entry->xe_name_len));\n\n\t\tret = ocfs2_lock_xattr_remove_allocators(inode, vb->vb_xv,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t &ctxt.meta_ac,\n\t\t\t\t\t\t\t &ref_credits);\n\n\t\tctxt.handle = ocfs2_start_trans(osb, ref_credits +\n\t\t\t\t\tocfs2_remove_extent_credits(osb->sb));\n\t\tif (IS_ERR(ctxt.handle)) {\n\t\t\tret = PTR_ERR(ctxt.handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_value_truncate(inode, vb, 0, &ctxt);\n\n\t\tocfs2_commit_trans(osb, ctxt.handle);\n\t\tif (ctxt.meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\t\t\tctxt.meta_ac = NULL;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xb->xb_flags"
          ],
          "line": 2452
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_remove(struct inode *inode,\n\t\t\t\t    struct buffer_head *blk_bh,\n\t\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t\t    struct buffer_head *ref_root_bh)\n{\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = blk_bh,\n\t\t.vb_access = ocfs2_journal_access_xb,\n\t};\n\tstruct ocfs2_rm_xattr_bucket_para args = {\n\t\t.ref_ci = ref_ci,\n\t\t.ref_root_bh = ref_root_bh,\n\t};\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &(xb->xb_attrs.xb_header);\n\t\tret = ocfs2_remove_value_outside(inode, &vb, header,\n\t\t\t\t\t\t ref_ci, ref_root_bh);\n\t} else\n\t\tret = ocfs2_iterate_xattr_index_block(inode,\n\t\t\t\t\t\tblk_bh,\n\t\t\t\t\t\tocfs2_rm_xattr_cluster,\n\t\t\t\t\t\t&args);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_ibody_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2406-2428",
    "snippet": "static int ocfs2_xattr_ibody_remove(struct inode *inode,\n\t\t\t\t    struct buffer_head *di_bh,\n\t\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t\t    struct buffer_head *ref_root_bh)\n{\n\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_xattr_header *header;\n\tint ret;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = di_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\theader = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tret = ocfs2_remove_value_outside(inode, &vb, header,\n\t\t\t\t\t ref_ci, ref_root_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_remove_value_outside",
          "args": [
            "inode",
            "&vb",
            "header",
            "ref_ci",
            "ref_root_bh"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_value_outside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2347-2404",
          "snippet": "static int ocfs2_remove_value_outside(struct inode*inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_xattr_header *header,\n\t\t\t\t      struct ocfs2_caching_info *ref_ci,\n\t\t\t\t      struct buffer_head *ref_root_bh)\n{\n\tint ret = 0, i, ref_credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, };\n\tvoid *val;\n\n\tocfs2_init_dealloc_ctxt(&ctxt.dealloc);\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(entry))\n\t\t\tcontinue;\n\n\t\tval = (void *)header +\n\t\t\tle16_to_cpu(entry->xe_name_offset);\n\t\tvb->vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t\t(val + OCFS2_XATTR_SIZE(entry->xe_name_len));\n\n\t\tret = ocfs2_lock_xattr_remove_allocators(inode, vb->vb_xv,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t &ctxt.meta_ac,\n\t\t\t\t\t\t\t &ref_credits);\n\n\t\tctxt.handle = ocfs2_start_trans(osb, ref_credits +\n\t\t\t\t\tocfs2_remove_extent_credits(osb->sb));\n\t\tif (IS_ERR(ctxt.handle)) {\n\t\t\tret = PTR_ERR(ctxt.handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_value_truncate(inode, vb, 0, &ctxt);\n\n\t\tocfs2_commit_trans(osb, ctxt.handle);\n\t\tif (ctxt.meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\t\t\tctxt.meta_ac = NULL;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_remove_value_outside(struct inode*inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_xattr_header *header,\n\t\t\t\t      struct ocfs2_caching_info *ref_ci,\n\t\t\t\t      struct buffer_head *ref_root_bh)\n{\n\tint ret = 0, i, ref_credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, };\n\tvoid *val;\n\n\tocfs2_init_dealloc_ctxt(&ctxt.dealloc);\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(entry))\n\t\t\tcontinue;\n\n\t\tval = (void *)header +\n\t\t\tle16_to_cpu(entry->xe_name_offset);\n\t\tvb->vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t\t(val + OCFS2_XATTR_SIZE(entry->xe_name_len));\n\n\t\tret = ocfs2_lock_xattr_remove_allocators(inode, vb->vb_xv,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t &ctxt.meta_ac,\n\t\t\t\t\t\t\t &ref_credits);\n\n\t\tctxt.handle = ocfs2_start_trans(osb, ref_credits +\n\t\t\t\t\tocfs2_remove_extent_credits(osb->sb));\n\t\tif (IS_ERR(ctxt.handle)) {\n\t\t\tret = PTR_ERR(ctxt.handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_value_truncate(inode, vb, 0, &ctxt);\n\n\t\tocfs2_commit_trans(osb, ctxt.handle);\n\t\tif (ctxt.meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\t\t\tctxt.meta_ac = NULL;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_xattr_inline_size"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_ibody_remove(struct inode *inode,\n\t\t\t\t    struct buffer_head *di_bh,\n\t\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t\t    struct buffer_head *ref_root_bh)\n{\n\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_xattr_header *header;\n\tint ret;\n\tstruct ocfs2_xattr_value_buf vb = {\n\t\t.vb_bh = di_bh,\n\t\t.vb_access = ocfs2_journal_access_di,\n\t};\n\n\theader = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tret = ocfs2_remove_value_outside(inode, &vb, header,\n\t\t\t\t\t ref_ci, ref_root_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_remove_value_outside",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2347-2404",
    "snippet": "static int ocfs2_remove_value_outside(struct inode*inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_xattr_header *header,\n\t\t\t\t      struct ocfs2_caching_info *ref_ci,\n\t\t\t\t      struct buffer_head *ref_root_bh)\n{\n\tint ret = 0, i, ref_credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, };\n\tvoid *val;\n\n\tocfs2_init_dealloc_ctxt(&ctxt.dealloc);\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(entry))\n\t\t\tcontinue;\n\n\t\tval = (void *)header +\n\t\t\tle16_to_cpu(entry->xe_name_offset);\n\t\tvb->vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t\t(val + OCFS2_XATTR_SIZE(entry->xe_name_len));\n\n\t\tret = ocfs2_lock_xattr_remove_allocators(inode, vb->vb_xv,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t &ctxt.meta_ac,\n\t\t\t\t\t\t\t &ref_credits);\n\n\t\tctxt.handle = ocfs2_start_trans(osb, ref_credits +\n\t\t\t\t\tocfs2_remove_extent_credits(osb->sb));\n\t\tif (IS_ERR(ctxt.handle)) {\n\t\t\tret = PTR_ERR(ctxt.handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_value_truncate(inode, vb, 0, &ctxt);\n\n\t\tocfs2_commit_trans(osb, ctxt.handle);\n\t\tif (ctxt.meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\t\t\tctxt.meta_ac = NULL;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "osb",
            "&ctxt.dealloc"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6472-6513",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "1"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "ctxt.meta_ac"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "ctxt.handle"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_value_truncate",
          "args": [
            "inode",
            "vb",
            "0",
            "&ctxt"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_value_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "869-891",
          "snippet": "static int ocfs2_xattr_value_truncate(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      int len,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb, len);\n\tu32 old_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\n\tif (new_clusters == old_clusters)\n\t\treturn 0;\n\n\tif (new_clusters > old_clusters)\n\t\tret = ocfs2_xattr_extend_allocation(inode,\n\t\t\t\t\t\t    new_clusters - old_clusters,\n\t\t\t\t\t\t    vb, ctxt);\n\telse\n\t\tret = ocfs2_xattr_shrink_size(inode,\n\t\t\t\t\t      old_clusters, new_clusters,\n\t\t\t\t\t      vb, ctxt);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_value_truncate(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      int len,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb, len);\n\tu32 old_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\n\tif (new_clusters == old_clusters)\n\t\treturn 0;\n\n\tif (new_clusters > old_clusters)\n\t\tret = ocfs2_xattr_extend_allocation(inode,\n\t\t\t\t\t\t    new_clusters - old_clusters,\n\t\t\t\t\t\t    vb, ctxt);\n\telse\n\t\tret = ocfs2_xattr_shrink_size(inode,\n\t\t\t\t\t      old_clusters, new_clusters,\n\t\t\t\t\t      vb, ctxt);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ctxt.handle"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctxt.handle"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ref_credits +\n\t\t\t\t\tocfs2_remove_extent_credits(osb->sb)"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_extent_credits",
          "args": [
            "osb->sb"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_extent_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "412-416",
          "snippet": "static inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS",
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_xattr_remove_allocators",
          "args": [
            "inode",
            "vb->vb_xv",
            "ref_ci",
            "ref_root_bh",
            "&ctxt.meta_ac",
            "&ref_credits"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_xattr_remove_allocators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2306-2345",
          "snippet": "static int ocfs2_lock_xattr_remove_allocators(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tint *ref_credits)\n{\n\tint ret, meta_add = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\t*ref_credits = 0;\n\tret = ocfs2_xattr_get_clusters(inode, 0, &p_cluster,\n\t\t\t\t       &num_clusters,\n\t\t\t\t       &xv->xr_list,\n\t\t\t\t       &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\tret = ocfs2_refcounted_xattr_delete_need(inode, ref_ci,\n\t\t\t\t\t\t ref_root_bh, xv,\n\t\t\t\t\t\t &meta_add, ref_credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\tmeta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_lock_xattr_remove_allocators(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tint *ref_credits)\n{\n\tint ret, meta_add = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\t*ref_credits = 0;\n\tret = ocfs2_xattr_get_clusters(inode, 0, &p_cluster,\n\t\t\t\t       &num_clusters,\n\t\t\t\t       &xv->xr_list,\n\t\t\t\t       &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\tret = ocfs2_refcounted_xattr_delete_need(inode, ref_ci,\n\t\t\t\t\t\t ref_root_bh, xv,\n\t\t\t\t\t\t &meta_add, ref_credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\tmeta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "entry->xe_name_len"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->xe_name_offset"
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "entry"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&ctxt.dealloc"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "205-209",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_remove_value_outside(struct inode*inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      struct ocfs2_xattr_header *header,\n\t\t\t\t      struct ocfs2_caching_info *ref_ci,\n\t\t\t\t      struct buffer_head *ref_root_bh)\n{\n\tint ret = 0, i, ref_credits;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, };\n\tvoid *val;\n\n\tocfs2_init_dealloc_ctxt(&ctxt.dealloc);\n\n\tfor (i = 0; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\n\t\tif (ocfs2_xattr_is_local(entry))\n\t\t\tcontinue;\n\n\t\tval = (void *)header +\n\t\t\tle16_to_cpu(entry->xe_name_offset);\n\t\tvb->vb_xv = (struct ocfs2_xattr_value_root *)\n\t\t\t(val + OCFS2_XATTR_SIZE(entry->xe_name_len));\n\n\t\tret = ocfs2_lock_xattr_remove_allocators(inode, vb->vb_xv,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t &ctxt.meta_ac,\n\t\t\t\t\t\t\t &ref_credits);\n\n\t\tctxt.handle = ocfs2_start_trans(osb, ref_credits +\n\t\t\t\t\tocfs2_remove_extent_credits(osb->sb));\n\t\tif (IS_ERR(ctxt.handle)) {\n\t\t\tret = PTR_ERR(ctxt.handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_xattr_value_truncate(inode, vb, 0, &ctxt);\n\n\t\tocfs2_commit_trans(osb, ctxt.handle);\n\t\tif (ctxt.meta_ac) {\n\t\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\t\t\tctxt.meta_ac = NULL;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (ctxt.meta_ac)\n\t\tocfs2_free_alloc_context(ctxt.meta_ac);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &ctxt.dealloc);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_lock_xattr_remove_allocators",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2306-2345",
    "snippet": "static int ocfs2_lock_xattr_remove_allocators(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tint *ref_credits)\n{\n\tint ret, meta_add = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\t*ref_credits = 0;\n\tret = ocfs2_xattr_get_clusters(inode, 0, &p_cluster,\n\t\t\t\t       &num_clusters,\n\t\t\t\t       &xv->xr_list,\n\t\t\t\t       &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\tret = ocfs2_refcounted_xattr_delete_need(inode, ref_ci,\n\t\t\t\t\t\t ref_root_bh, xv,\n\t\t\t\t\t\t &meta_add, ref_credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\tmeta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "meta_add",
            "meta_ac"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcounted_xattr_delete_need",
          "args": [
            "inode",
            "ref_ci",
            "ref_root_bh",
            "xv",
            "&meta_add",
            "ref_credits"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcounted_xattr_delete_need",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3556-3635",
          "snippet": "int ocfs2_refcounted_xattr_delete_need(struct inode *inode,\n\t\t\t\t       struct ocfs2_caching_info *ref_ci,\n\t\t\t\t       struct buffer_head *ref_root_bh,\n\t\t\t\t       struct ocfs2_xattr_value_root *xv,\n\t\t\t\t       int *meta_add, int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0;\n\tu32 p_cluster, num_clusters;\n\tu32 cpos = 0, clusters = le32_to_cpu(xv->xr_clusters);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, &xv->xr_list,\n\t\t\t\t\t       NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcpos += num_clusters;\n\n\t\twhile (num_clusters) {\n\t\t\tret = ocfs2_get_refcount_rec(ref_ci, ref_root_bh,\n\t\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t\t     &rec, &index,\n\t\t\t\t\t\t     &ref_leaf_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!rec.r_refcount);\n\n\t\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\n\t\t\t/*\n\t\t\t * We really don't know whether the other clusters is in\n\t\t\t * this refcount block or not, so just take the worst\n\t\t\t * case that all the clusters are in this block and each\n\t\t\t * one will split a refcount rec, so totally we need\n\t\t\t * clusters * 2 new refcount rec.\n\t\t\t */\n\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) + clusters * 2 >\n\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\tref_blocks++;\n\n\t\t\t*credits += 1;\n\t\t\tbrelse(ref_leaf_bh);\n\t\t\tref_leaf_bh = NULL;\n\n\t\t\tif (num_clusters <= le32_to_cpu(rec.r_clusters))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tnum_clusters -= le32_to_cpu(rec.r_clusters);\n\t\t\tp_cluster += num_clusters;\n\t\t}\n\t}\n\n\t*meta_add += ref_blocks;\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\telse {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ref_ci, ref_root_bh);\n\t\t*credits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_refcounted_xattr_delete_need(struct inode *inode,\n\t\t\t\t       struct ocfs2_caching_info *ref_ci,\n\t\t\t\t       struct buffer_head *ref_root_bh,\n\t\t\t\t       struct ocfs2_xattr_value_root *xv,\n\t\t\t\t       int *meta_add, int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0;\n\tu32 p_cluster, num_clusters;\n\tu32 cpos = 0, clusters = le32_to_cpu(xv->xr_clusters);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, &xv->xr_list,\n\t\t\t\t\t       NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcpos += num_clusters;\n\n\t\twhile (num_clusters) {\n\t\t\tret = ocfs2_get_refcount_rec(ref_ci, ref_root_bh,\n\t\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t\t     &rec, &index,\n\t\t\t\t\t\t     &ref_leaf_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!rec.r_refcount);\n\n\t\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\n\t\t\t/*\n\t\t\t * We really don't know whether the other clusters is in\n\t\t\t * this refcount block or not, so just take the worst\n\t\t\t * case that all the clusters are in this block and each\n\t\t\t * one will split a refcount rec, so totally we need\n\t\t\t * clusters * 2 new refcount rec.\n\t\t\t */\n\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) + clusters * 2 >\n\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\tref_blocks++;\n\n\t\t\t*credits += 1;\n\t\t\tbrelse(ref_leaf_bh);\n\t\t\tref_leaf_bh = NULL;\n\n\t\t\tif (num_clusters <= le32_to_cpu(rec.r_clusters))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tnum_clusters -= le32_to_cpu(rec.r_clusters);\n\t\t\tp_cluster += num_clusters;\n\t\t}\n\t}\n\n\t*meta_add += ref_blocks;\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\telse {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ref_ci, ref_root_bh);\n\t\t*credits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_clusters",
          "args": [
            "inode",
            "0",
            "&p_cluster",
            "&num_clusters",
            "&xv->xr_list",
            "&ext_flags"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "543-606",
          "snippet": "int ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_lock_xattr_remove_allocators(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_xattr_value_root *xv,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tint *ref_credits)\n{\n\tint ret, meta_add = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\t*ref_credits = 0;\n\tret = ocfs2_xattr_get_clusters(inode, 0, &p_cluster,\n\t\t\t\t       &num_clusters,\n\t\t\t\t       &xv->xr_list,\n\t\t\t\t       &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\tret = ocfs2_refcounted_xattr_delete_need(inode, ref_ci,\n\t\t\t\t\t\t ref_root_bh, xv,\n\t\t\t\t\t\t &meta_add, ref_credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\tmeta_add, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_init_xattr_bucket_xa_loc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2290-2300",
    "snippet": "static void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic const struct ocfs2_xa_loc_operations ocfs2_xa_bucket_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_bucket_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_bucket_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_bucket_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_bucket_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_bucket_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_bucket_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_bucket_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_bucket_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_bucket_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_bucket_fill_value_buf,\n};\n\nstatic void ocfs2_init_xattr_bucket_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   struct ocfs2_xattr_entry *entry)\n{\n\tloc->xl_inode = bucket->bu_inode;\n\tloc->xl_ops = &ocfs2_xa_bucket_loc_ops;\n\tloc->xl_storage = bucket;\n\tloc->xl_header = bucket_xh(bucket);\n\tloc->xl_entry = entry;\n\tloc->xl_size = OCFS2_XATTR_BUCKET_SIZE;\n}"
  },
  {
    "function_name": "ocfs2_init_xattr_block_xa_loc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2271-2288",
    "snippet": "static void ocfs2_init_xattr_block_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  struct ocfs2_xattr_entry *entry)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\tBUG_ON(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED);\n\n\tloc->xl_inode = inode;\n\tloc->xl_ops = &ocfs2_xa_block_loc_ops;\n\tloc->xl_storage = bh;\n\tloc->xl_header = &(xb->xb_attrs.xb_header);\n\tloc->xl_entry = entry;\n\tloc->xl_size = bh->b_size - offsetof(struct ocfs2_xattr_block,\n\t\t\t\t\t     xb_attrs.xb_header);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);",
      "static const struct ocfs2_xa_loc_operations ocfs2_xa_block_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_block_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_block_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_block_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_block_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_block_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_block_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_block_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_block_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_block_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_block_fill_value_buf,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xb->xb_flags"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\nstatic const struct ocfs2_xa_loc_operations ocfs2_xa_block_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_block_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_block_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_block_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_block_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_block_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_block_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_block_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_block_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_block_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_block_fill_value_buf,\n};\n\nstatic void ocfs2_init_xattr_block_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  struct ocfs2_xattr_entry *entry)\n{\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\tBUG_ON(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED);\n\n\tloc->xl_inode = inode;\n\tloc->xl_ops = &ocfs2_xa_block_loc_ops;\n\tloc->xl_storage = bh;\n\tloc->xl_header = &(xb->xb_attrs.xb_header);\n\tloc->xl_entry = entry;\n\tloc->xl_size = bh->b_size - offsetof(struct ocfs2_xattr_block,\n\t\t\t\t\t     xb_attrs.xb_header);\n}"
  },
  {
    "function_name": "ocfs2_init_dinode_xa_loc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2252-2269",
    "snippet": "static void ocfs2_init_dinode_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     struct ocfs2_xattr_entry *entry)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_XATTR_FL));\n\n\tloc->xl_inode = inode;\n\tloc->xl_ops = &ocfs2_xa_block_loc_ops;\n\tloc->xl_storage = bh;\n\tloc->xl_entry = entry;\n\tloc->xl_size = le16_to_cpu(di->i_xattr_inline_size);\n\tloc->xl_header =\n\t\t(struct ocfs2_xattr_header *)(bh->b_data + bh->b_size -\n\t\t\t\t\t      loc->xl_size);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);",
      "static const struct ocfs2_xa_loc_operations ocfs2_xa_block_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_block_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_block_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_block_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_block_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_block_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_block_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_block_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_block_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_block_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_block_fill_value_buf,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_xattr_inline_size"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_XATTR_FL)"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\nstatic const struct ocfs2_xa_loc_operations ocfs2_xa_block_loc_ops = {\n\t.xlo_journal_access\t= ocfs2_xa_block_journal_access,\n\t.xlo_journal_dirty\t= ocfs2_xa_block_journal_dirty,\n\t.xlo_offset_pointer\t= ocfs2_xa_block_offset_pointer,\n\t.xlo_check_space\t= ocfs2_xa_block_check_space,\n\t.xlo_can_reuse\t\t= ocfs2_xa_block_can_reuse,\n\t.xlo_get_free_start\t= ocfs2_xa_block_get_free_start,\n\t.xlo_wipe_namevalue\t= ocfs2_xa_block_wipe_namevalue,\n\t.xlo_add_entry\t\t= ocfs2_xa_block_add_entry,\n\t.xlo_add_namevalue\t= ocfs2_xa_block_add_namevalue,\n\t.xlo_fill_value_buf\t= ocfs2_xa_block_fill_value_buf,\n};\n\nstatic void ocfs2_init_dinode_xa_loc(struct ocfs2_xa_loc *loc,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     struct ocfs2_xattr_entry *entry)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_XATTR_FL));\n\n\tloc->xl_inode = inode;\n\tloc->xl_ops = &ocfs2_xa_block_loc_ops;\n\tloc->xl_storage = bh;\n\tloc->xl_entry = entry;\n\tloc->xl_size = le16_to_cpu(di->i_xattr_inline_size);\n\tloc->xl_header =\n\t\t(struct ocfs2_xattr_header *)(bh->b_data + bh->b_size -\n\t\t\t\t\t      loc->xl_size);\n}"
  },
  {
    "function_name": "ocfs2_xa_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2207-2250",
    "snippet": "static int ocfs2_xa_set(struct ocfs2_xa_loc *loc,\n\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 name_hash = ocfs2_xattr_name_hash(loc->xl_inode, xi->xi_name,\n\t\t\t\t\t      xi->xi_name_len);\n\n\tret = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * From here on out, everything is going to modify the buffer a\n\t * little.  Errors are going to leave the xattr header in a\n\t * sane state.  Thus, even with errors we dirty the sucker.\n\t */\n\n\t/* Don't worry, we are never called with !xi_value and !xl_entry */\n\tif (!xi->xi_value) {\n\t\tret = ocfs2_xa_remove(loc, ctxt);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_prepare_entry(loc, xi, name_hash, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_store_value(loc, xi, ctxt);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_dirty:\n\tocfs2_xa_journal_dirty(ctxt->handle, loc);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xa_journal_dirty",
          "args": [
            "ctxt->handle",
            "loc"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1433-1436",
          "snippet": "static void ocfs2_xa_journal_dirty(handle_t *handle, struct ocfs2_xa_loc *loc)\n{\n\tloc->xl_ops->xlo_journal_dirty(handle, loc);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_journal_dirty(handle_t *handle, struct ocfs2_xa_loc *loc)\n{\n\tloc->xl_ops->xlo_journal_dirty(handle, loc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_store_value",
          "args": [
            "loc",
            "xi",
            "ctxt"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_store_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2184-2205",
          "snippet": "static int ocfs2_xa_store_value(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(xi->xi_name_len);\n\tchar *nameval_buf;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc, nameval_offset);\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tocfs2_xa_fill_value_buf(loc, &vb);\n\t\trc = __ocfs2_xattr_set_value_outside(loc->xl_inode,\n\t\t\t\t\t\t     ctxt->handle, &vb,\n\t\t\t\t\t\t     xi->xi_value,\n\t\t\t\t\t\t     xi->xi_value_len);\n\t} else\n\t\tmemcpy(nameval_buf + name_size, xi->xi_value, xi->xi_value_len);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_store_value(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(xi->xi_name_len);\n\tchar *nameval_buf;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc, nameval_offset);\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tocfs2_xa_fill_value_buf(loc, &vb);\n\t\trc = __ocfs2_xattr_set_value_outside(loc->xl_inode,\n\t\t\t\t\t\t     ctxt->handle, &vb,\n\t\t\t\t\t\t     xi->xi_value,\n\t\t\t\t\t\t     xi->xi_value_len);\n\t} else\n\t\tmemcpy(nameval_buf + name_size, xi->xi_value, xi->xi_value_len);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_prepare_entry",
          "args": [
            "loc",
            "xi",
            "name_hash",
            "ctxt"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_prepare_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2108-2177",
          "snippet": "static int ocfs2_xa_prepare_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t  struct ocfs2_xattr_info *xi,\n\t\t\t\t  u32 name_hash,\n\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tunsigned int orig_clusters;\n\t__le64 orig_value_size = 0;\n\n\trc = ocfs2_xa_check_space(loc, xi);\n\tif (rc)\n\t\tgoto out;\n\n\tif (loc->xl_entry) {\n\t\tif (ocfs2_xa_can_reuse_entry(loc, xi)) {\n\t\t\torig_value_size = loc->xl_entry->xe_value_size;\n\t\t\trc = ocfs2_xa_reuse_entry(loc, xi, ctxt);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tgoto alloc_value;\n\t\t}\n\n\t\tif (!ocfs2_xattr_is_local(loc->xl_entry)) {\n\t\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\t\tif (rc) {\n\t\t\t\tmlog_errno(rc);\n\t\t\t\tocfs2_xa_cleanup_value_truncate(loc,\n\t\t\t\t\t\t\t\t\"overwriting\",\n\t\t\t\t\t\t\t\torig_clusters);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tocfs2_xa_wipe_namevalue(loc);\n\t} else\n\t\tocfs2_xa_add_entry(loc, name_hash);\n\n\t/*\n\t * If we get here, we have a blank entry.  Fill it.  We grow our\n\t * name+value pair back from the end.\n\t */\n\tocfs2_xa_add_namevalue(loc, xi);\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\tocfs2_xa_install_value_root(loc);\n\nalloc_value:\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\trc = ocfs2_xa_value_truncate(loc, xi->xi_value_len, ctxt);\n\t\tif (rc < 0) {\n\t\t\tctxt->set_abort = 1;\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"growing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\t/*\n\t\t\t * If we were growing an existing value,\n\t\t\t * ocfs2_xa_cleanup_value_truncate() won't remove\n\t\t\t * the entry. We need to restore the original value\n\t\t\t * size.\n\t\t\t */\n\t\t\tif (loc->xl_entry) {\n\t\t\t\tBUG_ON(!orig_value_size);\n\t\t\t\tloc->xl_entry->xe_value_size = orig_value_size;\n\t\t\t}\n\t\t\tmlog_errno(rc);\n\t\t}\n\t}\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_prepare_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t  struct ocfs2_xattr_info *xi,\n\t\t\t\t  u32 name_hash,\n\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tunsigned int orig_clusters;\n\t__le64 orig_value_size = 0;\n\n\trc = ocfs2_xa_check_space(loc, xi);\n\tif (rc)\n\t\tgoto out;\n\n\tif (loc->xl_entry) {\n\t\tif (ocfs2_xa_can_reuse_entry(loc, xi)) {\n\t\t\torig_value_size = loc->xl_entry->xe_value_size;\n\t\t\trc = ocfs2_xa_reuse_entry(loc, xi, ctxt);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tgoto alloc_value;\n\t\t}\n\n\t\tif (!ocfs2_xattr_is_local(loc->xl_entry)) {\n\t\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\t\tif (rc) {\n\t\t\t\tmlog_errno(rc);\n\t\t\t\tocfs2_xa_cleanup_value_truncate(loc,\n\t\t\t\t\t\t\t\t\"overwriting\",\n\t\t\t\t\t\t\t\torig_clusters);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tocfs2_xa_wipe_namevalue(loc);\n\t} else\n\t\tocfs2_xa_add_entry(loc, name_hash);\n\n\t/*\n\t * If we get here, we have a blank entry.  Fill it.  We grow our\n\t * name+value pair back from the end.\n\t */\n\tocfs2_xa_add_namevalue(loc, xi);\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\tocfs2_xa_install_value_root(loc);\n\nalloc_value:\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\trc = ocfs2_xa_value_truncate(loc, xi->xi_value_len, ctxt);\n\t\tif (rc < 0) {\n\t\t\tctxt->set_abort = 1;\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"growing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\t/*\n\t\t\t * If we were growing an existing value,\n\t\t\t * ocfs2_xa_cleanup_value_truncate() won't remove\n\t\t\t * the entry. We need to restore the original value\n\t\t\t * size.\n\t\t\t */\n\t\t\tif (loc->xl_entry) {\n\t\t\t\tBUG_ON(!orig_value_size);\n\t\t\t\tloc->xl_entry->xe_value_size = orig_value_size;\n\t\t\t}\n\t\t\tmlog_errno(rc);\n\t\t}\n\t}\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_remove",
          "args": [
            "loc",
            "ctxt"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2000-2030",
          "snippet": "static int ocfs2_xa_remove(struct ocfs2_xa_loc *loc,\n\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tunsigned int orig_clusters;\n\n\tif (!ocfs2_xattr_is_local(loc->xl_entry)) {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\t/*\n\t\t\t * Since this is remove, we can return 0 if\n\t\t\t * ocfs2_xa_cleanup_value_truncate() is going to\n\t\t\t * wipe the entry anyway.  So we check the\n\t\t\t * cluster count as well.\n\t\t\t */\n\t\t\tif (orig_clusters != ocfs2_xa_value_clusters(loc))\n\t\t\t\trc = 0;\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"removing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tocfs2_xa_remove_entry(loc);\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_remove(struct ocfs2_xa_loc *loc,\n\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tunsigned int orig_clusters;\n\n\tif (!ocfs2_xattr_is_local(loc->xl_entry)) {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\t/*\n\t\t\t * Since this is remove, we can return 0 if\n\t\t\t * ocfs2_xa_cleanup_value_truncate() is going to\n\t\t\t * wipe the entry anyway.  So we check the\n\t\t\t * cluster count as well.\n\t\t\t */\n\t\t\tif (orig_clusters != ocfs2_xa_value_clusters(loc))\n\t\t\t\trc = 0;\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"removing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tocfs2_xa_remove_entry(loc);\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_journal_access",
          "args": [
            "ctxt->handle",
            "loc",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1427-1431",
          "snippet": "static int ocfs2_xa_journal_access(handle_t *handle, struct ocfs2_xa_loc *loc,\n\t\t\t\t   int type)\n{\n\treturn loc->xl_ops->xlo_journal_access(handle, loc, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_journal_access(handle_t *handle, struct ocfs2_xa_loc *loc,\n\t\t\t\t   int type)\n{\n\treturn loc->xl_ops->xlo_journal_access(handle, loc, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_name_hash",
          "args": [
            "loc->xl_inode",
            "xi->xi_name",
            "xi->xi_name_len"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "557-573",
          "snippet": "static u32 ocfs2_xattr_name_hash(struct inode *inode,\n\t\t\t\t const char *name,\n\t\t\t\t int name_len)\n{\n\t/* Get hash value of uuid from super block */\n\tu32 hash = OCFS2_SB(inode->i_sb)->uuid_hash;\n\tint i;\n\n\t/* hash extended attribute name */\n\tfor (i = 0; i < name_len; i++) {\n\t\thash = (hash << OCFS2_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - OCFS2_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\treturn hash;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic u32 ocfs2_xattr_name_hash(struct inode *inode,\n\t\t\t\t const char *name,\n\t\t\t\t int name_len)\n{\n\t/* Get hash value of uuid from super block */\n\tu32 hash = OCFS2_SB(inode->i_sb)->uuid_hash;\n\tint i;\n\n\t/* hash extended attribute name */\n\tfor (i = 0; i < name_len; i++) {\n\t\thash = (hash << OCFS2_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - OCFS2_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_set(struct ocfs2_xa_loc *loc,\n\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 name_hash = ocfs2_xattr_name_hash(loc->xl_inode, xi->xi_name,\n\t\t\t\t\t      xi->xi_name_len);\n\n\tret = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * From here on out, everything is going to modify the buffer a\n\t * little.  Errors are going to leave the xattr header in a\n\t * sane state.  Thus, even with errors we dirty the sucker.\n\t */\n\n\t/* Don't worry, we are never called with !xi_value and !xl_entry */\n\tif (!xi->xi_value) {\n\t\tret = ocfs2_xa_remove(loc, ctxt);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_prepare_entry(loc, xi, name_hash, ctxt);\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out_dirty;\n\t}\n\n\tret = ocfs2_xa_store_value(loc, xi, ctxt);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_dirty:\n\tocfs2_xa_journal_dirty(ctxt->handle, loc);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xa_store_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2184-2205",
    "snippet": "static int ocfs2_xa_store_value(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(xi->xi_name_len);\n\tchar *nameval_buf;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc, nameval_offset);\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tocfs2_xa_fill_value_buf(loc, &vb);\n\t\trc = __ocfs2_xattr_set_value_outside(loc->xl_inode,\n\t\t\t\t\t\t     ctxt->handle, &vb,\n\t\t\t\t\t\t     xi->xi_value,\n\t\t\t\t\t\t     xi->xi_value_len);\n\t} else\n\t\tmemcpy(nameval_buf + name_size, xi->xi_value, xi->xi_value_len);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_INLINE_SIZE\t80"
    ],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nameval_buf + name_size",
            "xi->xi_value",
            "xi->xi_value_len"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_xattr_set_value_outside",
          "args": [
            "loc->xl_inode",
            "ctxt->handle",
            "&vb",
            "xi->xi_value",
            "xi->xi_value_len"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_xattr_set_value_outside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1332-1405",
          "snippet": "static int __ocfs2_xattr_set_value_outside(struct inode *inode,\n\t\t\t\t\t   handle_t *handle,\n\t\t\t\t\t   struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t\t   const void *value,\n\t\t\t\t\t   int value_len)\n{\n\tint ret = 0, i, cp_len;\n\tu16 blocksize = inode->i_sb->s_blocksize;\n\tu32 p_cluster, num_clusters;\n\tu32 cpos = 0, bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 clusters = ocfs2_clusters_for_bytes(inode->i_sb, value_len);\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tunsigned int ext_flags;\n\tstruct ocfs2_xattr_value_root *xv = vb->vb_xv;\n\n\tBUG_ON(clusters > le32_to_cpu(xv->xr_clusters));\n\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, &xv->xr_list,\n\t\t\t\t\t       &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(ext_flags & OCFS2_EXT_REFCOUNTED);\n\n\t\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\n\t\tfor (i = 0; i < num_clusters * bpc; i++, blkno++) {\n\t\t\tret = ocfs2_read_block(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       &bh, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_journal_access(handle,\n\t\t\t\t\t\t   INODE_CACHE(inode),\n\t\t\t\t\t\t   bh,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcp_len = value_len > blocksize ? blocksize : value_len;\n\t\t\tmemcpy(bh->b_data, value, cp_len);\n\t\t\tvalue_len -= cp_len;\n\t\t\tvalue += cp_len;\n\t\t\tif (cp_len < blocksize)\n\t\t\t\tmemset(bh->b_data + cp_len, 0,\n\t\t\t\t       blocksize - cp_len);\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\n\t\t\t/*\n\t\t\t * XXX: do we need to empty all the following\n\t\t\t * blocks in this cluster?\n\t\t\t */\n\t\t\tif (!value_len)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\nout:\n\tbrelse(bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int __ocfs2_xattr_set_value_outside(struct inode *inode,\n\t\t\t\t\t   handle_t *handle,\n\t\t\t\t\t   struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t\t   const void *value,\n\t\t\t\t\t   int value_len)\n{\n\tint ret = 0, i, cp_len;\n\tu16 blocksize = inode->i_sb->s_blocksize;\n\tu32 p_cluster, num_clusters;\n\tu32 cpos = 0, bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 clusters = ocfs2_clusters_for_bytes(inode->i_sb, value_len);\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tunsigned int ext_flags;\n\tstruct ocfs2_xattr_value_root *xv = vb->vb_xv;\n\n\tBUG_ON(clusters > le32_to_cpu(xv->xr_clusters));\n\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, &xv->xr_list,\n\t\t\t\t\t       &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(ext_flags & OCFS2_EXT_REFCOUNTED);\n\n\t\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\n\t\tfor (i = 0; i < num_clusters * bpc; i++, blkno++) {\n\t\t\tret = ocfs2_read_block(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       &bh, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_journal_access(handle,\n\t\t\t\t\t\t   INODE_CACHE(inode),\n\t\t\t\t\t\t   bh,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcp_len = value_len > blocksize ? blocksize : value_len;\n\t\t\tmemcpy(bh->b_data, value, cp_len);\n\t\t\tvalue_len -= cp_len;\n\t\t\tvalue += cp_len;\n\t\t\tif (cp_len < blocksize)\n\t\t\t\tmemset(bh->b_data + cp_len, 0,\n\t\t\t\t       blocksize - cp_len);\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\n\t\t\t/*\n\t\t\t * XXX: do we need to empty all the following\n\t\t\t * blocks in this cluster?\n\t\t\t */\n\t\t\tif (!value_len)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\nout:\n\tbrelse(bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_fill_value_buf",
          "args": [
            "loc",
            "&vb"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_fill_value_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1510-1526",
          "snippet": "static void ocfs2_xa_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_value_buf *vb)\n{\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\n\t/* Value bufs are for value trees */\n\tBUG_ON(ocfs2_xattr_is_local(loc->xl_entry));\n\tBUG_ON(namevalue_size_xe(loc->xl_entry) !=\n\t       (name_size + OCFS2_XATTR_ROOT_SIZE));\n\n\tloc->xl_ops->xlo_fill_value_buf(loc, vb);\n\tvb->vb_xv =\n\t\t(struct ocfs2_xattr_value_root *)ocfs2_xa_offset_pointer(loc,\n\t\t\t\t\t\t\tnameval_offset +\n\t\t\t\t\t\t\tname_size);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic void ocfs2_xa_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_value_buf *vb)\n{\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\n\t/* Value bufs are for value trees */\n\tBUG_ON(ocfs2_xattr_is_local(loc->xl_entry));\n\tBUG_ON(namevalue_size_xe(loc->xl_entry) !=\n\t       (name_size + OCFS2_XATTR_ROOT_SIZE));\n\n\tloc->xl_ops->xlo_fill_value_buf(loc, vb);\n\tvb->vb_xv =\n\t\t(struct ocfs2_xattr_value_root *)ocfs2_xa_offset_pointer(loc,\n\t\t\t\t\t\t\tnameval_offset +\n\t\t\t\t\t\t\tname_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_offset_pointer",
          "args": [
            "loc",
            "nameval_offset"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_offset_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1439-1443",
          "snippet": "static void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xi->xi_name_len"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "loc->xl_entry->xe_name_offset"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_store_value(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(xi->xi_name_len);\n\tchar *nameval_buf;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc, nameval_offset);\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tocfs2_xa_fill_value_buf(loc, &vb);\n\t\trc = __ocfs2_xattr_set_value_outside(loc->xl_inode,\n\t\t\t\t\t\t     ctxt->handle, &vb,\n\t\t\t\t\t\t     xi->xi_value,\n\t\t\t\t\t\t     xi->xi_value_len);\n\t} else\n\t\tmemcpy(nameval_buf + name_size, xi->xi_value, xi->xi_value_len);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_xa_prepare_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2108-2177",
    "snippet": "static int ocfs2_xa_prepare_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t  struct ocfs2_xattr_info *xi,\n\t\t\t\t  u32 name_hash,\n\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tunsigned int orig_clusters;\n\t__le64 orig_value_size = 0;\n\n\trc = ocfs2_xa_check_space(loc, xi);\n\tif (rc)\n\t\tgoto out;\n\n\tif (loc->xl_entry) {\n\t\tif (ocfs2_xa_can_reuse_entry(loc, xi)) {\n\t\t\torig_value_size = loc->xl_entry->xe_value_size;\n\t\t\trc = ocfs2_xa_reuse_entry(loc, xi, ctxt);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tgoto alloc_value;\n\t\t}\n\n\t\tif (!ocfs2_xattr_is_local(loc->xl_entry)) {\n\t\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\t\tif (rc) {\n\t\t\t\tmlog_errno(rc);\n\t\t\t\tocfs2_xa_cleanup_value_truncate(loc,\n\t\t\t\t\t\t\t\t\"overwriting\",\n\t\t\t\t\t\t\t\torig_clusters);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tocfs2_xa_wipe_namevalue(loc);\n\t} else\n\t\tocfs2_xa_add_entry(loc, name_hash);\n\n\t/*\n\t * If we get here, we have a blank entry.  Fill it.  We grow our\n\t * name+value pair back from the end.\n\t */\n\tocfs2_xa_add_namevalue(loc, xi);\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\tocfs2_xa_install_value_root(loc);\n\nalloc_value:\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\trc = ocfs2_xa_value_truncate(loc, xi->xi_value_len, ctxt);\n\t\tif (rc < 0) {\n\t\t\tctxt->set_abort = 1;\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"growing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\t/*\n\t\t\t * If we were growing an existing value,\n\t\t\t * ocfs2_xa_cleanup_value_truncate() won't remove\n\t\t\t * the entry. We need to restore the original value\n\t\t\t * size.\n\t\t\t */\n\t\t\tif (loc->xl_entry) {\n\t\t\t\tBUG_ON(!orig_value_size);\n\t\t\t\tloc->xl_entry->xe_value_size = orig_value_size;\n\t\t\t}\n\t\t\tmlog_errno(rc);\n\t\t}\n\t}\n\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_INLINE_SIZE\t80"
    ],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!orig_value_size"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_cleanup_value_truncate",
          "args": [
            "loc",
            "\"growing\"",
            "orig_clusters"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_cleanup_value_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1968-1998",
          "snippet": "static void ocfs2_xa_cleanup_value_truncate(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    const char *what,\n\t\t\t\t\t    unsigned int orig_clusters)\n{\n\tunsigned int new_clusters = ocfs2_xa_value_clusters(loc);\n\tchar *nameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\n\tif (new_clusters < orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Partial truncate while %s xattr %.*s.  Leaking \"\n\t\t     \"%u clusters and removing the entry\\n\",\n\t\t     what, loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     orig_clusters - new_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (!orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to allocate an external value for xattr \"\n\t\t     \"%.*s safely.  Leaking %u clusters and removing the \"\n\t\t     \"entry\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (new_clusters > orig_clusters)\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to grow xattr %.*s safely.  %u new clusters \"\n\t\t     \"have been added, but the value will not be \"\n\t\t     \"modified\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_cleanup_value_truncate(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    const char *what,\n\t\t\t\t\t    unsigned int orig_clusters)\n{\n\tunsigned int new_clusters = ocfs2_xa_value_clusters(loc);\n\tchar *nameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\n\tif (new_clusters < orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Partial truncate while %s xattr %.*s.  Leaking \"\n\t\t     \"%u clusters and removing the entry\\n\",\n\t\t     what, loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     orig_clusters - new_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (!orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to allocate an external value for xattr \"\n\t\t     \"%.*s safely.  Leaking %u clusters and removing the \"\n\t\t     \"entry\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (new_clusters > orig_clusters)\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to grow xattr %.*s safely.  %u new clusters \"\n\t\t     \"have been added, but the value will not be \"\n\t\t     \"modified\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_value_truncate",
          "args": [
            "loc",
            "xi->xi_value_len",
            "ctxt"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_value_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1890-1915",
          "snippet": "static int ocfs2_xa_value_truncate(struct ocfs2_xa_loc *loc, u64 bytes,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint trunc_rc, access_rc;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\ttrunc_rc = ocfs2_xattr_value_truncate(loc->xl_inode, &vb, bytes,\n\t\t\t\t\t      ctxt);\n\n\t/*\n\t * The caller of ocfs2_xa_value_truncate() has already called\n\t * ocfs2_xa_journal_access on the loc.  However, The truncate code\n\t * calls ocfs2_extend_trans().  This may commit the previous\n\t * transaction and open a new one.  If this is a bucket, truncate\n\t * could leave only vb->vb_bh set up for journaling.  Meanwhile,\n\t * the caller is expecting to dirty the entire bucket.  So we must\n\t * reset the journal work.  We do this even if truncate has failed,\n\t * as it could have failed after committing the extend.\n\t */\n\taccess_rc = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t/* Errors in truncate take precedence */\n\treturn trunc_rc ? trunc_rc : access_rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_value_truncate(struct ocfs2_xa_loc *loc, u64 bytes,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint trunc_rc, access_rc;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\ttrunc_rc = ocfs2_xattr_value_truncate(loc->xl_inode, &vb, bytes,\n\t\t\t\t\t      ctxt);\n\n\t/*\n\t * The caller of ocfs2_xa_value_truncate() has already called\n\t * ocfs2_xa_journal_access on the loc.  However, The truncate code\n\t * calls ocfs2_extend_trans().  This may commit the previous\n\t * transaction and open a new one.  If this is a bucket, truncate\n\t * could leave only vb->vb_bh set up for journaling.  Meanwhile,\n\t * the caller is expecting to dirty the entire bucket.  So we must\n\t * reset the journal work.  We do this even if truncate has failed,\n\t * as it could have failed after committing the extend.\n\t */\n\taccess_rc = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t/* Errors in truncate take precedence */\n\treturn trunc_rc ? trunc_rc : access_rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_value_clusters",
          "args": [
            "loc"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_value_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1879-1888",
          "snippet": "static unsigned int ocfs2_xa_value_clusters(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tif (ocfs2_xattr_is_local(loc->xl_entry))\n\t\treturn 0;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\treturn le32_to_cpu(vb.vb_xv->xr_clusters);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic unsigned int ocfs2_xa_value_clusters(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tif (ocfs2_xattr_is_local(loc->xl_entry))\n\t\treturn 0;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\treturn le32_to_cpu(vb.vb_xv->xr_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_install_value_root",
          "args": [
            "loc"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_install_value_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2032-2040",
          "snippet": "static void ocfs2_xa_install_value_root(struct ocfs2_xa_loc *loc)\n{\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\tchar *nameval_buf;\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\tmemcpy(nameval_buf + name_size, &def_xv, OCFS2_XATTR_ROOT_SIZE);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
          ],
          "globals_used": [
            "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\n\nstatic void ocfs2_xa_install_value_root(struct ocfs2_xa_loc *loc)\n{\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\tchar *nameval_buf;\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\tmemcpy(nameval_buf + name_size, &def_xv, OCFS2_XATTR_ROOT_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_add_namevalue",
          "args": [
            "loc",
            "xi"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_add_namevalue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1490-1508",
          "snippet": "static void ocfs2_xa_add_namevalue(struct ocfs2_xa_loc *loc,\n\t\t\t\t   struct ocfs2_xattr_info *xi)\n{\n\tint size = namevalue_size_xi(xi);\n\tint nameval_offset;\n\tchar *nameval_buf;\n\n\tloc->xl_ops->xlo_add_namevalue(loc, size);\n\tloc->xl_entry->xe_value_size = cpu_to_le64(xi->xi_value_len);\n\tloc->xl_entry->xe_name_len = xi->xi_name_len;\n\tocfs2_xattr_set_type(loc->xl_entry, xi->xi_name_index);\n\tocfs2_xattr_set_local(loc->xl_entry,\n\t\t\t      xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE);\n\n\tnameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tnameval_buf = ocfs2_xa_offset_pointer(loc, nameval_offset);\n\tmemset(nameval_buf, 0, size);\n\tmemcpy(nameval_buf, xi->xi_name, xi->xi_name_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic void ocfs2_xa_add_namevalue(struct ocfs2_xa_loc *loc,\n\t\t\t\t   struct ocfs2_xattr_info *xi)\n{\n\tint size = namevalue_size_xi(xi);\n\tint nameval_offset;\n\tchar *nameval_buf;\n\n\tloc->xl_ops->xlo_add_namevalue(loc, size);\n\tloc->xl_entry->xe_value_size = cpu_to_le64(xi->xi_value_len);\n\tloc->xl_entry->xe_name_len = xi->xi_name_len;\n\tocfs2_xattr_set_type(loc->xl_entry, xi->xi_name_index);\n\tocfs2_xattr_set_local(loc->xl_entry,\n\t\t\t      xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE);\n\n\tnameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tnameval_buf = ocfs2_xa_offset_pointer(loc, nameval_offset);\n\tmemset(nameval_buf, 0, size);\n\tmemcpy(nameval_buf, xi->xi_name, xi->xi_name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_add_entry",
          "args": [
            "loc",
            "name_hash"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1478-1488",
          "snippet": "static void ocfs2_xa_add_entry(struct ocfs2_xa_loc *loc, u32 name_hash)\n{\n\tloc->xl_ops->xlo_add_entry(loc, name_hash);\n\tloc->xl_entry->xe_name_hash = cpu_to_le32(name_hash);\n\t/*\n\t * We can't leave the new entry's xe_name_offset at zero or\n\t * add_namevalue() will go nuts.  We set it to the size of our\n\t * storage so that it can never be less than any other entry.\n\t */\n\tloc->xl_entry->xe_name_offset = cpu_to_le16(loc->xl_size);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_add_entry(struct ocfs2_xa_loc *loc, u32 name_hash)\n{\n\tloc->xl_ops->xlo_add_entry(loc, name_hash);\n\tloc->xl_entry->xe_name_hash = cpu_to_le32(name_hash);\n\t/*\n\t * We can't leave the new entry's xe_name_offset at zero or\n\t * add_namevalue() will go nuts.  We set it to the size of our\n\t * storage so that it can never be less than any other entry.\n\t */\n\tloc->xl_entry->xe_name_offset = cpu_to_le16(loc->xl_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_wipe_namevalue",
          "args": [
            "loc"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_wipe_namevalue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1450-1453",
          "snippet": "static void ocfs2_xa_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tloc->xl_ops->xlo_wipe_namevalue(loc);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tloc->xl_ops->xlo_wipe_namevalue(loc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "loc->xl_entry"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_reuse_entry",
          "args": [
            "loc",
            "xi",
            "ctxt"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_reuse_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2047-2098",
          "snippet": "static int ocfs2_xa_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tint name_size = OCFS2_XATTR_SIZE(xi->xi_name_len);\n\tunsigned int orig_clusters;\n\tchar *nameval_buf;\n\tint xe_local = ocfs2_xattr_is_local(loc->xl_entry);\n\tint xi_local = xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE;\n\n\tBUG_ON(OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len) !=\n\t       name_size);\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\tif (xe_local) {\n\t\tmemset(nameval_buf + name_size, 0,\n\t\t       namevalue_size_xe(loc->xl_entry) - name_size);\n\t\tif (!xi_local)\n\t\t\tocfs2_xa_install_value_root(loc);\n\t} else {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\tif (xi_local) {\n\t\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\t\tif (rc < 0)\n\t\t\t\tmlog_errno(rc);\n\t\t\telse\n\t\t\t\tmemset(nameval_buf + name_size, 0,\n\t\t\t\t       namevalue_size_xe(loc->xl_entry) -\n\t\t\t\t       name_size);\n\t\t} else if (le64_to_cpu(loc->xl_entry->xe_value_size) >\n\t\t\t   xi->xi_value_len) {\n\t\t\trc = ocfs2_xa_value_truncate(loc, xi->xi_value_len,\n\t\t\t\t\t\t     ctxt);\n\t\t\tif (rc < 0)\n\t\t\t\tmlog_errno(rc);\n\t\t}\n\n\t\tif (rc) {\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"reusing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tloc->xl_entry->xe_value_size = cpu_to_le64(xi->xi_value_len);\n\tocfs2_xattr_set_local(loc->xl_entry, xi_local);\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tint name_size = OCFS2_XATTR_SIZE(xi->xi_name_len);\n\tunsigned int orig_clusters;\n\tchar *nameval_buf;\n\tint xe_local = ocfs2_xattr_is_local(loc->xl_entry);\n\tint xi_local = xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE;\n\n\tBUG_ON(OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len) !=\n\t       name_size);\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\tif (xe_local) {\n\t\tmemset(nameval_buf + name_size, 0,\n\t\t       namevalue_size_xe(loc->xl_entry) - name_size);\n\t\tif (!xi_local)\n\t\t\tocfs2_xa_install_value_root(loc);\n\t} else {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\tif (xi_local) {\n\t\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\t\tif (rc < 0)\n\t\t\t\tmlog_errno(rc);\n\t\t\telse\n\t\t\t\tmemset(nameval_buf + name_size, 0,\n\t\t\t\t       namevalue_size_xe(loc->xl_entry) -\n\t\t\t\t       name_size);\n\t\t} else if (le64_to_cpu(loc->xl_entry->xe_value_size) >\n\t\t\t   xi->xi_value_len) {\n\t\t\trc = ocfs2_xa_value_truncate(loc, xi->xi_value_len,\n\t\t\t\t\t\t     ctxt);\n\t\t\tif (rc < 0)\n\t\t\t\tmlog_errno(rc);\n\t\t}\n\n\t\tif (rc) {\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"reusing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tloc->xl_entry->xe_value_size = cpu_to_le64(xi->xi_value_len);\n\tocfs2_xattr_set_local(loc->xl_entry, xi_local);\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_can_reuse_entry",
          "args": [
            "loc",
            "xi"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_can_reuse_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1465-1469",
          "snippet": "static int ocfs2_xa_can_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_can_reuse(loc, xi);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_can_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_can_reuse(loc, xi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_check_space",
          "args": [
            "loc",
            "xi"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_check_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1472-1476",
          "snippet": "static int ocfs2_xa_check_space(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_check_space(loc, xi);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_check_space(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_check_space(loc, xi);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_prepare_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t  struct ocfs2_xattr_info *xi,\n\t\t\t\t  u32 name_hash,\n\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tunsigned int orig_clusters;\n\t__le64 orig_value_size = 0;\n\n\trc = ocfs2_xa_check_space(loc, xi);\n\tif (rc)\n\t\tgoto out;\n\n\tif (loc->xl_entry) {\n\t\tif (ocfs2_xa_can_reuse_entry(loc, xi)) {\n\t\t\torig_value_size = loc->xl_entry->xe_value_size;\n\t\t\trc = ocfs2_xa_reuse_entry(loc, xi, ctxt);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tgoto alloc_value;\n\t\t}\n\n\t\tif (!ocfs2_xattr_is_local(loc->xl_entry)) {\n\t\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\t\tif (rc) {\n\t\t\t\tmlog_errno(rc);\n\t\t\t\tocfs2_xa_cleanup_value_truncate(loc,\n\t\t\t\t\t\t\t\t\"overwriting\",\n\t\t\t\t\t\t\t\torig_clusters);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tocfs2_xa_wipe_namevalue(loc);\n\t} else\n\t\tocfs2_xa_add_entry(loc, name_hash);\n\n\t/*\n\t * If we get here, we have a blank entry.  Fill it.  We grow our\n\t * name+value pair back from the end.\n\t */\n\tocfs2_xa_add_namevalue(loc, xi);\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\tocfs2_xa_install_value_root(loc);\n\nalloc_value:\n\tif (xi->xi_value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\trc = ocfs2_xa_value_truncate(loc, xi->xi_value_len, ctxt);\n\t\tif (rc < 0) {\n\t\t\tctxt->set_abort = 1;\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"growing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\t/*\n\t\t\t * If we were growing an existing value,\n\t\t\t * ocfs2_xa_cleanup_value_truncate() won't remove\n\t\t\t * the entry. We need to restore the original value\n\t\t\t * size.\n\t\t\t */\n\t\t\tif (loc->xl_entry) {\n\t\t\t\tBUG_ON(!orig_value_size);\n\t\t\t\tloc->xl_entry->xe_value_size = orig_value_size;\n\t\t\t}\n\t\t\tmlog_errno(rc);\n\t\t}\n\t}\n\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_xa_reuse_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2047-2098",
    "snippet": "static int ocfs2_xa_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tint name_size = OCFS2_XATTR_SIZE(xi->xi_name_len);\n\tunsigned int orig_clusters;\n\tchar *nameval_buf;\n\tint xe_local = ocfs2_xattr_is_local(loc->xl_entry);\n\tint xi_local = xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE;\n\n\tBUG_ON(OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len) !=\n\t       name_size);\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\tif (xe_local) {\n\t\tmemset(nameval_buf + name_size, 0,\n\t\t       namevalue_size_xe(loc->xl_entry) - name_size);\n\t\tif (!xi_local)\n\t\t\tocfs2_xa_install_value_root(loc);\n\t} else {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\tif (xi_local) {\n\t\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\t\tif (rc < 0)\n\t\t\t\tmlog_errno(rc);\n\t\t\telse\n\t\t\t\tmemset(nameval_buf + name_size, 0,\n\t\t\t\t       namevalue_size_xe(loc->xl_entry) -\n\t\t\t\t       name_size);\n\t\t} else if (le64_to_cpu(loc->xl_entry->xe_value_size) >\n\t\t\t   xi->xi_value_len) {\n\t\t\trc = ocfs2_xa_value_truncate(loc, xi->xi_value_len,\n\t\t\t\t\t\t     ctxt);\n\t\t\tif (rc < 0)\n\t\t\t\tmlog_errno(rc);\n\t\t}\n\n\t\tif (rc) {\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"reusing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tloc->xl_entry->xe_value_size = cpu_to_le64(xi->xi_value_len);\n\tocfs2_xattr_set_local(loc->xl_entry, xi_local);\n\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_INLINE_SIZE\t80"
    ],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_set_local",
          "args": [
            "loc->xl_entry",
            "xi_local"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_set_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1134-1141",
          "snippet": "static inline void ocfs2_xattr_set_local(struct ocfs2_xattr_entry *xe,\n\t\t\t\t\t int local)\n{\n\tif (local)\n\t\txe->xe_type |= OCFS2_XATTR_ENTRY_LOCAL;\n\telse\n\t\txe->xe_type &= ~OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline void ocfs2_xattr_set_local(struct ocfs2_xattr_entry *xe,\n\t\t\t\t\t int local)\n{\n\tif (local)\n\t\txe->xe_type |= OCFS2_XATTR_ENTRY_LOCAL;\n\telse\n\t\txe->xe_type &= ~OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "xi->xi_value_len"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_cleanup_value_truncate",
          "args": [
            "loc",
            "\"reusing\"",
            "orig_clusters"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_cleanup_value_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1968-1998",
          "snippet": "static void ocfs2_xa_cleanup_value_truncate(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    const char *what,\n\t\t\t\t\t    unsigned int orig_clusters)\n{\n\tunsigned int new_clusters = ocfs2_xa_value_clusters(loc);\n\tchar *nameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\n\tif (new_clusters < orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Partial truncate while %s xattr %.*s.  Leaking \"\n\t\t     \"%u clusters and removing the entry\\n\",\n\t\t     what, loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     orig_clusters - new_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (!orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to allocate an external value for xattr \"\n\t\t     \"%.*s safely.  Leaking %u clusters and removing the \"\n\t\t     \"entry\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (new_clusters > orig_clusters)\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to grow xattr %.*s safely.  %u new clusters \"\n\t\t     \"have been added, but the value will not be \"\n\t\t     \"modified\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_cleanup_value_truncate(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    const char *what,\n\t\t\t\t\t    unsigned int orig_clusters)\n{\n\tunsigned int new_clusters = ocfs2_xa_value_clusters(loc);\n\tchar *nameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\n\tif (new_clusters < orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Partial truncate while %s xattr %.*s.  Leaking \"\n\t\t     \"%u clusters and removing the entry\\n\",\n\t\t     what, loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     orig_clusters - new_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (!orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to allocate an external value for xattr \"\n\t\t     \"%.*s safely.  Leaking %u clusters and removing the \"\n\t\t     \"entry\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (new_clusters > orig_clusters)\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to grow xattr %.*s safely.  %u new clusters \"\n\t\t     \"have been added, but the value will not be \"\n\t\t     \"modified\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_value_truncate",
          "args": [
            "loc",
            "xi->xi_value_len",
            "ctxt"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_value_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1890-1915",
          "snippet": "static int ocfs2_xa_value_truncate(struct ocfs2_xa_loc *loc, u64 bytes,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint trunc_rc, access_rc;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\ttrunc_rc = ocfs2_xattr_value_truncate(loc->xl_inode, &vb, bytes,\n\t\t\t\t\t      ctxt);\n\n\t/*\n\t * The caller of ocfs2_xa_value_truncate() has already called\n\t * ocfs2_xa_journal_access on the loc.  However, The truncate code\n\t * calls ocfs2_extend_trans().  This may commit the previous\n\t * transaction and open a new one.  If this is a bucket, truncate\n\t * could leave only vb->vb_bh set up for journaling.  Meanwhile,\n\t * the caller is expecting to dirty the entire bucket.  So we must\n\t * reset the journal work.  We do this even if truncate has failed,\n\t * as it could have failed after committing the extend.\n\t */\n\taccess_rc = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t/* Errors in truncate take precedence */\n\treturn trunc_rc ? trunc_rc : access_rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_value_truncate(struct ocfs2_xa_loc *loc, u64 bytes,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint trunc_rc, access_rc;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\ttrunc_rc = ocfs2_xattr_value_truncate(loc->xl_inode, &vb, bytes,\n\t\t\t\t\t      ctxt);\n\n\t/*\n\t * The caller of ocfs2_xa_value_truncate() has already called\n\t * ocfs2_xa_journal_access on the loc.  However, The truncate code\n\t * calls ocfs2_extend_trans().  This may commit the previous\n\t * transaction and open a new one.  If this is a bucket, truncate\n\t * could leave only vb->vb_bh set up for journaling.  Meanwhile,\n\t * the caller is expecting to dirty the entire bucket.  So we must\n\t * reset the journal work.  We do this even if truncate has failed,\n\t * as it could have failed after committing the extend.\n\t */\n\taccess_rc = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t/* Errors in truncate take precedence */\n\treturn trunc_rc ? trunc_rc : access_rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "loc->xl_entry->xe_value_size"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "nameval_buf + name_size",
            "0",
            "namevalue_size_xe(loc->xl_entry) -\n\t\t\t\t       name_size"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namevalue_size_xe",
          "args": [
            "loc->xl_entry"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "241-248",
          "snippet": "static int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_value_clusters",
          "args": [
            "loc"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_value_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1879-1888",
          "snippet": "static unsigned int ocfs2_xa_value_clusters(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tif (ocfs2_xattr_is_local(loc->xl_entry))\n\t\treturn 0;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\treturn le32_to_cpu(vb.vb_xv->xr_clusters);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic unsigned int ocfs2_xa_value_clusters(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tif (ocfs2_xattr_is_local(loc->xl_entry))\n\t\treturn 0;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\treturn le32_to_cpu(vb.vb_xv->xr_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_install_value_root",
          "args": [
            "loc"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_install_value_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2032-2040",
          "snippet": "static void ocfs2_xa_install_value_root(struct ocfs2_xa_loc *loc)\n{\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\tchar *nameval_buf;\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\tmemcpy(nameval_buf + name_size, &def_xv, OCFS2_XATTR_ROOT_SIZE);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
          ],
          "globals_used": [
            "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\n\nstatic void ocfs2_xa_install_value_root(struct ocfs2_xa_loc *loc)\n{\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\tchar *nameval_buf;\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\tmemcpy(nameval_buf + name_size, &def_xv, OCFS2_XATTR_ROOT_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "nameval_buf + name_size",
            "0",
            "namevalue_size_xe(loc->xl_entry) - name_size"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_offset_pointer",
          "args": [
            "loc",
            "le16_to_cpu(loc->xl_entry->xe_name_offset)"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_offset_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1439-1443",
          "snippet": "static void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "loc->xl_entry->xe_name_offset"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len) !=\n\t       name_size"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "loc->xl_entry->xe_name_len"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "loc->xl_entry"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xi->xi_name_len"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\tstruct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tint name_size = OCFS2_XATTR_SIZE(xi->xi_name_len);\n\tunsigned int orig_clusters;\n\tchar *nameval_buf;\n\tint xe_local = ocfs2_xattr_is_local(loc->xl_entry);\n\tint xi_local = xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE;\n\n\tBUG_ON(OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len) !=\n\t       name_size);\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\tif (xe_local) {\n\t\tmemset(nameval_buf + name_size, 0,\n\t\t       namevalue_size_xe(loc->xl_entry) - name_size);\n\t\tif (!xi_local)\n\t\t\tocfs2_xa_install_value_root(loc);\n\t} else {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\tif (xi_local) {\n\t\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\t\tif (rc < 0)\n\t\t\t\tmlog_errno(rc);\n\t\t\telse\n\t\t\t\tmemset(nameval_buf + name_size, 0,\n\t\t\t\t       namevalue_size_xe(loc->xl_entry) -\n\t\t\t\t       name_size);\n\t\t} else if (le64_to_cpu(loc->xl_entry->xe_value_size) >\n\t\t\t   xi->xi_value_len) {\n\t\t\trc = ocfs2_xa_value_truncate(loc, xi->xi_value_len,\n\t\t\t\t\t\t     ctxt);\n\t\t\tif (rc < 0)\n\t\t\t\tmlog_errno(rc);\n\t\t}\n\n\t\tif (rc) {\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"reusing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tloc->xl_entry->xe_value_size = cpu_to_le64(xi->xi_value_len);\n\tocfs2_xattr_set_local(loc->xl_entry, xi_local);\n\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_xa_install_value_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2032-2040",
    "snippet": "static void ocfs2_xa_install_value_root(struct ocfs2_xa_loc *loc)\n{\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\tchar *nameval_buf;\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\tmemcpy(nameval_buf + name_size, &def_xv, OCFS2_XATTR_ROOT_SIZE);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
    ],
    "globals_used": [
      "static struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nameval_buf + name_size",
            "&def_xv",
            "OCFS2_XATTR_ROOT_SIZE"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_offset_pointer",
          "args": [
            "loc",
            "le16_to_cpu(loc->xl_entry->xe_name_offset)"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_offset_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1439-1443",
          "snippet": "static void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "loc->xl_entry->xe_name_offset"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "loc->xl_entry->xe_name_len"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic struct ocfs2_xattr_def_value_root def_xv = {\n\t.xv.xr_list.l_count = cpu_to_le16(1),\n};\n\nstatic void ocfs2_xa_install_value_root(struct ocfs2_xa_loc *loc)\n{\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\tchar *nameval_buf;\n\n\tnameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\tmemcpy(nameval_buf + name_size, &def_xv, OCFS2_XATTR_ROOT_SIZE);\n}"
  },
  {
    "function_name": "ocfs2_xa_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "2000-2030",
    "snippet": "static int ocfs2_xa_remove(struct ocfs2_xa_loc *loc,\n\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tunsigned int orig_clusters;\n\n\tif (!ocfs2_xattr_is_local(loc->xl_entry)) {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\t/*\n\t\t\t * Since this is remove, we can return 0 if\n\t\t\t * ocfs2_xa_cleanup_value_truncate() is going to\n\t\t\t * wipe the entry anyway.  So we check the\n\t\t\t * cluster count as well.\n\t\t\t */\n\t\t\tif (orig_clusters != ocfs2_xa_value_clusters(loc))\n\t\t\t\trc = 0;\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"removing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tocfs2_xa_remove_entry(loc);\n\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xa_remove_entry",
          "args": [
            "loc"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_remove_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1917-1942",
          "snippet": "static void ocfs2_xa_remove_entry(struct ocfs2_xa_loc *loc)\n{\n\tint index, count;\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tstruct ocfs2_xattr_entry *entry = loc->xl_entry;\n\n\tocfs2_xa_wipe_namevalue(loc);\n\tloc->xl_entry = NULL;\n\n\tle16_add_cpu(&xh->xh_count, -1);\n\tcount = le16_to_cpu(xh->xh_count);\n\n\t/*\n\t * Only zero out the entry if there are more remaining.  This is\n\t * important for an empty bucket, as it keeps track of the\n\t * bucket's hash value.  It doesn't hurt empty block storage.\n\t */\n\tif (count) {\n\t\tindex = ((char *)entry - (char *)&xh->xh_entries) /\n\t\t\tsizeof(struct ocfs2_xattr_entry);\n\t\tmemmove(&xh->xh_entries[index], &xh->xh_entries[index + 1],\n\t\t\t(count - index) * sizeof(struct ocfs2_xattr_entry));\n\t\tmemset(&xh->xh_entries[count], 0,\n\t\t       sizeof(struct ocfs2_xattr_entry));\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_remove_entry(struct ocfs2_xa_loc *loc)\n{\n\tint index, count;\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tstruct ocfs2_xattr_entry *entry = loc->xl_entry;\n\n\tocfs2_xa_wipe_namevalue(loc);\n\tloc->xl_entry = NULL;\n\n\tle16_add_cpu(&xh->xh_count, -1);\n\tcount = le16_to_cpu(xh->xh_count);\n\n\t/*\n\t * Only zero out the entry if there are more remaining.  This is\n\t * important for an empty bucket, as it keeps track of the\n\t * bucket's hash value.  It doesn't hurt empty block storage.\n\t */\n\tif (count) {\n\t\tindex = ((char *)entry - (char *)&xh->xh_entries) /\n\t\t\tsizeof(struct ocfs2_xattr_entry);\n\t\tmemmove(&xh->xh_entries[index], &xh->xh_entries[index + 1],\n\t\t\t(count - index) * sizeof(struct ocfs2_xattr_entry));\n\t\tmemset(&xh->xh_entries[count], 0,\n\t\t       sizeof(struct ocfs2_xattr_entry));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_cleanup_value_truncate",
          "args": [
            "loc",
            "\"removing\"",
            "orig_clusters"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_cleanup_value_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1968-1998",
          "snippet": "static void ocfs2_xa_cleanup_value_truncate(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    const char *what,\n\t\t\t\t\t    unsigned int orig_clusters)\n{\n\tunsigned int new_clusters = ocfs2_xa_value_clusters(loc);\n\tchar *nameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\n\tif (new_clusters < orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Partial truncate while %s xattr %.*s.  Leaking \"\n\t\t     \"%u clusters and removing the entry\\n\",\n\t\t     what, loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     orig_clusters - new_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (!orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to allocate an external value for xattr \"\n\t\t     \"%.*s safely.  Leaking %u clusters and removing the \"\n\t\t     \"entry\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (new_clusters > orig_clusters)\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to grow xattr %.*s safely.  %u new clusters \"\n\t\t     \"have been added, but the value will not be \"\n\t\t     \"modified\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_cleanup_value_truncate(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    const char *what,\n\t\t\t\t\t    unsigned int orig_clusters)\n{\n\tunsigned int new_clusters = ocfs2_xa_value_clusters(loc);\n\tchar *nameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\n\tif (new_clusters < orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Partial truncate while %s xattr %.*s.  Leaking \"\n\t\t     \"%u clusters and removing the entry\\n\",\n\t\t     what, loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     orig_clusters - new_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (!orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to allocate an external value for xattr \"\n\t\t     \"%.*s safely.  Leaking %u clusters and removing the \"\n\t\t     \"entry\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (new_clusters > orig_clusters)\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to grow xattr %.*s safely.  %u new clusters \"\n\t\t     \"have been added, but the value will not be \"\n\t\t     \"modified\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_value_clusters",
          "args": [
            "loc"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_value_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1879-1888",
          "snippet": "static unsigned int ocfs2_xa_value_clusters(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tif (ocfs2_xattr_is_local(loc->xl_entry))\n\t\treturn 0;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\treturn le32_to_cpu(vb.vb_xv->xr_clusters);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic unsigned int ocfs2_xa_value_clusters(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tif (ocfs2_xattr_is_local(loc->xl_entry))\n\t\treturn 0;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\treturn le32_to_cpu(vb.vb_xv->xr_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_value_truncate",
          "args": [
            "loc",
            "0",
            "ctxt"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_value_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1890-1915",
          "snippet": "static int ocfs2_xa_value_truncate(struct ocfs2_xa_loc *loc, u64 bytes,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint trunc_rc, access_rc;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\ttrunc_rc = ocfs2_xattr_value_truncate(loc->xl_inode, &vb, bytes,\n\t\t\t\t\t      ctxt);\n\n\t/*\n\t * The caller of ocfs2_xa_value_truncate() has already called\n\t * ocfs2_xa_journal_access on the loc.  However, The truncate code\n\t * calls ocfs2_extend_trans().  This may commit the previous\n\t * transaction and open a new one.  If this is a bucket, truncate\n\t * could leave only vb->vb_bh set up for journaling.  Meanwhile,\n\t * the caller is expecting to dirty the entire bucket.  So we must\n\t * reset the journal work.  We do this even if truncate has failed,\n\t * as it could have failed after committing the extend.\n\t */\n\taccess_rc = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t/* Errors in truncate take precedence */\n\treturn trunc_rc ? trunc_rc : access_rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_value_truncate(struct ocfs2_xa_loc *loc, u64 bytes,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint trunc_rc, access_rc;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\ttrunc_rc = ocfs2_xattr_value_truncate(loc->xl_inode, &vb, bytes,\n\t\t\t\t\t      ctxt);\n\n\t/*\n\t * The caller of ocfs2_xa_value_truncate() has already called\n\t * ocfs2_xa_journal_access on the loc.  However, The truncate code\n\t * calls ocfs2_extend_trans().  This may commit the previous\n\t * transaction and open a new one.  If this is a bucket, truncate\n\t * could leave only vb->vb_bh set up for journaling.  Meanwhile,\n\t * the caller is expecting to dirty the entire bucket.  So we must\n\t * reset the journal work.  We do this even if truncate has failed,\n\t * as it could have failed after committing the extend.\n\t */\n\taccess_rc = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t/* Errors in truncate take precedence */\n\treturn trunc_rc ? trunc_rc : access_rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "loc->xl_entry"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_remove(struct ocfs2_xa_loc *loc,\n\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint rc = 0;\n\tunsigned int orig_clusters;\n\n\tif (!ocfs2_xattr_is_local(loc->xl_entry)) {\n\t\torig_clusters = ocfs2_xa_value_clusters(loc);\n\t\trc = ocfs2_xa_value_truncate(loc, 0, ctxt);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\t/*\n\t\t\t * Since this is remove, we can return 0 if\n\t\t\t * ocfs2_xa_cleanup_value_truncate() is going to\n\t\t\t * wipe the entry anyway.  So we check the\n\t\t\t * cluster count as well.\n\t\t\t */\n\t\t\tif (orig_clusters != ocfs2_xa_value_clusters(loc))\n\t\t\t\trc = 0;\n\t\t\tocfs2_xa_cleanup_value_truncate(loc, \"removing\",\n\t\t\t\t\t\t\torig_clusters);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tocfs2_xa_remove_entry(loc);\n\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_xa_cleanup_value_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1968-1998",
    "snippet": "static void ocfs2_xa_cleanup_value_truncate(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    const char *what,\n\t\t\t\t\t    unsigned int orig_clusters)\n{\n\tunsigned int new_clusters = ocfs2_xa_value_clusters(loc);\n\tchar *nameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\n\tif (new_clusters < orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Partial truncate while %s xattr %.*s.  Leaking \"\n\t\t     \"%u clusters and removing the entry\\n\",\n\t\t     what, loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     orig_clusters - new_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (!orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to allocate an external value for xattr \"\n\t\t     \"%.*s safely.  Leaking %u clusters and removing the \"\n\t\t     \"entry\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (new_clusters > orig_clusters)\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to grow xattr %.*s safely.  %u new clusters \"\n\t\t     \"have been added, but the value will not be \"\n\t\t     \"modified\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Unable to grow xattr %.*s safely.  %u new clusters \"\n\t\t     \"have been added, but the value will not be \"\n\t\t     \"modified\\n\"",
            "loc->xl_entry->xe_name_len",
            "nameval_buf",
            "new_clusters - orig_clusters"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_remove_entry",
          "args": [
            "loc"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_remove_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1917-1942",
          "snippet": "static void ocfs2_xa_remove_entry(struct ocfs2_xa_loc *loc)\n{\n\tint index, count;\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tstruct ocfs2_xattr_entry *entry = loc->xl_entry;\n\n\tocfs2_xa_wipe_namevalue(loc);\n\tloc->xl_entry = NULL;\n\n\tle16_add_cpu(&xh->xh_count, -1);\n\tcount = le16_to_cpu(xh->xh_count);\n\n\t/*\n\t * Only zero out the entry if there are more remaining.  This is\n\t * important for an empty bucket, as it keeps track of the\n\t * bucket's hash value.  It doesn't hurt empty block storage.\n\t */\n\tif (count) {\n\t\tindex = ((char *)entry - (char *)&xh->xh_entries) /\n\t\t\tsizeof(struct ocfs2_xattr_entry);\n\t\tmemmove(&xh->xh_entries[index], &xh->xh_entries[index + 1],\n\t\t\t(count - index) * sizeof(struct ocfs2_xattr_entry));\n\t\tmemset(&xh->xh_entries[count], 0,\n\t\t       sizeof(struct ocfs2_xattr_entry));\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_remove_entry(struct ocfs2_xa_loc *loc)\n{\n\tint index, count;\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tstruct ocfs2_xattr_entry *entry = loc->xl_entry;\n\n\tocfs2_xa_wipe_namevalue(loc);\n\tloc->xl_entry = NULL;\n\n\tle16_add_cpu(&xh->xh_count, -1);\n\tcount = le16_to_cpu(xh->xh_count);\n\n\t/*\n\t * Only zero out the entry if there are more remaining.  This is\n\t * important for an empty bucket, as it keeps track of the\n\t * bucket's hash value.  It doesn't hurt empty block storage.\n\t */\n\tif (count) {\n\t\tindex = ((char *)entry - (char *)&xh->xh_entries) /\n\t\t\tsizeof(struct ocfs2_xattr_entry);\n\t\tmemmove(&xh->xh_entries[index], &xh->xh_entries[index + 1],\n\t\t\t(count - index) * sizeof(struct ocfs2_xattr_entry));\n\t\tmemset(&xh->xh_entries[count], 0,\n\t\t       sizeof(struct ocfs2_xattr_entry));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Unable to allocate an external value for xattr \"\n\t\t     \"%.*s safely.  Leaking %u clusters and removing the \"\n\t\t     \"entry\\n\"",
            "loc->xl_entry->xe_name_len",
            "nameval_buf",
            "new_clusters - orig_clusters"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Partial truncate while %s xattr %.*s.  Leaking \"\n\t\t     \"%u clusters and removing the entry\\n\"",
            "what",
            "loc->xl_entry->xe_name_len",
            "nameval_buf",
            "orig_clusters - new_clusters"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_offset_pointer",
          "args": [
            "loc",
            "le16_to_cpu(loc->xl_entry->xe_name_offset)"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_offset_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1439-1443",
          "snippet": "static void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "loc->xl_entry->xe_name_offset"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_value_clusters",
          "args": [
            "loc"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_value_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1879-1888",
          "snippet": "static unsigned int ocfs2_xa_value_clusters(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tif (ocfs2_xattr_is_local(loc->xl_entry))\n\t\treturn 0;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\treturn le32_to_cpu(vb.vb_xv->xr_clusters);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic unsigned int ocfs2_xa_value_clusters(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tif (ocfs2_xattr_is_local(loc->xl_entry))\n\t\treturn 0;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\treturn le32_to_cpu(vb.vb_xv->xr_clusters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_cleanup_value_truncate(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    const char *what,\n\t\t\t\t\t    unsigned int orig_clusters)\n{\n\tunsigned int new_clusters = ocfs2_xa_value_clusters(loc);\n\tchar *nameval_buf = ocfs2_xa_offset_pointer(loc,\n\t\t\t\tle16_to_cpu(loc->xl_entry->xe_name_offset));\n\n\tif (new_clusters < orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Partial truncate while %s xattr %.*s.  Leaking \"\n\t\t     \"%u clusters and removing the entry\\n\",\n\t\t     what, loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     orig_clusters - new_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (!orig_clusters) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to allocate an external value for xattr \"\n\t\t     \"%.*s safely.  Leaking %u clusters and removing the \"\n\t\t     \"entry\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n\t\tocfs2_xa_remove_entry(loc);\n\t} else if (new_clusters > orig_clusters)\n\t\tmlog(ML_ERROR,\n\t\t     \"Unable to grow xattr %.*s safely.  %u new clusters \"\n\t\t     \"have been added, but the value will not be \"\n\t\t     \"modified\\n\",\n\t\t     loc->xl_entry->xe_name_len, nameval_buf,\n\t\t     new_clusters - orig_clusters);\n}"
  },
  {
    "function_name": "ocfs2_xa_remove_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1917-1942",
    "snippet": "static void ocfs2_xa_remove_entry(struct ocfs2_xa_loc *loc)\n{\n\tint index, count;\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tstruct ocfs2_xattr_entry *entry = loc->xl_entry;\n\n\tocfs2_xa_wipe_namevalue(loc);\n\tloc->xl_entry = NULL;\n\n\tle16_add_cpu(&xh->xh_count, -1);\n\tcount = le16_to_cpu(xh->xh_count);\n\n\t/*\n\t * Only zero out the entry if there are more remaining.  This is\n\t * important for an empty bucket, as it keeps track of the\n\t * bucket's hash value.  It doesn't hurt empty block storage.\n\t */\n\tif (count) {\n\t\tindex = ((char *)entry - (char *)&xh->xh_entries) /\n\t\t\tsizeof(struct ocfs2_xattr_entry);\n\t\tmemmove(&xh->xh_entries[index], &xh->xh_entries[index + 1],\n\t\t\t(count - index) * sizeof(struct ocfs2_xattr_entry));\n\t\tmemset(&xh->xh_entries[count], 0,\n\t\t       sizeof(struct ocfs2_xattr_entry));\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&xh->xh_entries[count]",
            "0",
            "sizeof(struct ocfs2_xattr_entry)"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&xh->xh_entries[index]",
            "&xh->xh_entries[index + 1]",
            "(count - index) * sizeof(struct ocfs2_xattr_entry)"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_count"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&xh->xh_count",
            "-1"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_wipe_namevalue",
          "args": [
            "loc"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_wipe_namevalue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1450-1453",
          "snippet": "static void ocfs2_xa_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tloc->xl_ops->xlo_wipe_namevalue(loc);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tloc->xl_ops->xlo_wipe_namevalue(loc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_remove_entry(struct ocfs2_xa_loc *loc)\n{\n\tint index, count;\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tstruct ocfs2_xattr_entry *entry = loc->xl_entry;\n\n\tocfs2_xa_wipe_namevalue(loc);\n\tloc->xl_entry = NULL;\n\n\tle16_add_cpu(&xh->xh_count, -1);\n\tcount = le16_to_cpu(xh->xh_count);\n\n\t/*\n\t * Only zero out the entry if there are more remaining.  This is\n\t * important for an empty bucket, as it keeps track of the\n\t * bucket's hash value.  It doesn't hurt empty block storage.\n\t */\n\tif (count) {\n\t\tindex = ((char *)entry - (char *)&xh->xh_entries) /\n\t\t\tsizeof(struct ocfs2_xattr_entry);\n\t\tmemmove(&xh->xh_entries[index], &xh->xh_entries[index + 1],\n\t\t\t(count - index) * sizeof(struct ocfs2_xattr_entry));\n\t\tmemset(&xh->xh_entries[count], 0,\n\t\t       sizeof(struct ocfs2_xattr_entry));\n\t}\n}"
  },
  {
    "function_name": "ocfs2_xa_value_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1890-1915",
    "snippet": "static int ocfs2_xa_value_truncate(struct ocfs2_xa_loc *loc, u64 bytes,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint trunc_rc, access_rc;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\ttrunc_rc = ocfs2_xattr_value_truncate(loc->xl_inode, &vb, bytes,\n\t\t\t\t\t      ctxt);\n\n\t/*\n\t * The caller of ocfs2_xa_value_truncate() has already called\n\t * ocfs2_xa_journal_access on the loc.  However, The truncate code\n\t * calls ocfs2_extend_trans().  This may commit the previous\n\t * transaction and open a new one.  If this is a bucket, truncate\n\t * could leave only vb->vb_bh set up for journaling.  Meanwhile,\n\t * the caller is expecting to dirty the entire bucket.  So we must\n\t * reset the journal work.  We do this even if truncate has failed,\n\t * as it could have failed after committing the extend.\n\t */\n\taccess_rc = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t/* Errors in truncate take precedence */\n\treturn trunc_rc ? trunc_rc : access_rc;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xa_journal_access",
          "args": [
            "ctxt->handle",
            "loc",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1427-1431",
          "snippet": "static int ocfs2_xa_journal_access(handle_t *handle, struct ocfs2_xa_loc *loc,\n\t\t\t\t   int type)\n{\n\treturn loc->xl_ops->xlo_journal_access(handle, loc, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_journal_access(handle_t *handle, struct ocfs2_xa_loc *loc,\n\t\t\t\t   int type)\n{\n\treturn loc->xl_ops->xlo_journal_access(handle, loc, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_value_truncate",
          "args": [
            "loc->xl_inode",
            "&vb",
            "bytes",
            "ctxt"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_value_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "869-891",
          "snippet": "static int ocfs2_xattr_value_truncate(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      int len,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb, len);\n\tu32 old_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\n\tif (new_clusters == old_clusters)\n\t\treturn 0;\n\n\tif (new_clusters > old_clusters)\n\t\tret = ocfs2_xattr_extend_allocation(inode,\n\t\t\t\t\t\t    new_clusters - old_clusters,\n\t\t\t\t\t\t    vb, ctxt);\n\telse\n\t\tret = ocfs2_xattr_shrink_size(inode,\n\t\t\t\t\t      old_clusters, new_clusters,\n\t\t\t\t\t      vb, ctxt);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_value_truncate(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      int len,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb, len);\n\tu32 old_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\n\tif (new_clusters == old_clusters)\n\t\treturn 0;\n\n\tif (new_clusters > old_clusters)\n\t\tret = ocfs2_xattr_extend_allocation(inode,\n\t\t\t\t\t\t    new_clusters - old_clusters,\n\t\t\t\t\t\t    vb, ctxt);\n\telse\n\t\tret = ocfs2_xattr_shrink_size(inode,\n\t\t\t\t\t      old_clusters, new_clusters,\n\t\t\t\t\t      vb, ctxt);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_fill_value_buf",
          "args": [
            "loc",
            "&vb"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_fill_value_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1510-1526",
          "snippet": "static void ocfs2_xa_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_value_buf *vb)\n{\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\n\t/* Value bufs are for value trees */\n\tBUG_ON(ocfs2_xattr_is_local(loc->xl_entry));\n\tBUG_ON(namevalue_size_xe(loc->xl_entry) !=\n\t       (name_size + OCFS2_XATTR_ROOT_SIZE));\n\n\tloc->xl_ops->xlo_fill_value_buf(loc, vb);\n\tvb->vb_xv =\n\t\t(struct ocfs2_xattr_value_root *)ocfs2_xa_offset_pointer(loc,\n\t\t\t\t\t\t\tnameval_offset +\n\t\t\t\t\t\t\tname_size);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic void ocfs2_xa_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_value_buf *vb)\n{\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\n\t/* Value bufs are for value trees */\n\tBUG_ON(ocfs2_xattr_is_local(loc->xl_entry));\n\tBUG_ON(namevalue_size_xe(loc->xl_entry) !=\n\t       (name_size + OCFS2_XATTR_ROOT_SIZE));\n\n\tloc->xl_ops->xlo_fill_value_buf(loc, vb);\n\tvb->vb_xv =\n\t\t(struct ocfs2_xattr_value_root *)ocfs2_xa_offset_pointer(loc,\n\t\t\t\t\t\t\tnameval_offset +\n\t\t\t\t\t\t\tname_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xa_value_truncate(struct ocfs2_xa_loc *loc, u64 bytes,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint trunc_rc, access_rc;\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\ttrunc_rc = ocfs2_xattr_value_truncate(loc->xl_inode, &vb, bytes,\n\t\t\t\t\t      ctxt);\n\n\t/*\n\t * The caller of ocfs2_xa_value_truncate() has already called\n\t * ocfs2_xa_journal_access on the loc.  However, The truncate code\n\t * calls ocfs2_extend_trans().  This may commit the previous\n\t * transaction and open a new one.  If this is a bucket, truncate\n\t * could leave only vb->vb_bh set up for journaling.  Meanwhile,\n\t * the caller is expecting to dirty the entire bucket.  So we must\n\t * reset the journal work.  We do this even if truncate has failed,\n\t * as it could have failed after committing the extend.\n\t */\n\taccess_rc = ocfs2_xa_journal_access(ctxt->handle, loc,\n\t\t\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t/* Errors in truncate take precedence */\n\treturn trunc_rc ? trunc_rc : access_rc;\n}"
  },
  {
    "function_name": "ocfs2_xa_value_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1879-1888",
    "snippet": "static unsigned int ocfs2_xa_value_clusters(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tif (ocfs2_xattr_is_local(loc->xl_entry))\n\t\treturn 0;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\treturn le32_to_cpu(vb.vb_xv->xr_clusters);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "vb.vb_xv->xr_clusters"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_fill_value_buf",
          "args": [
            "loc",
            "&vb"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_fill_value_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1510-1526",
          "snippet": "static void ocfs2_xa_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_value_buf *vb)\n{\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\n\t/* Value bufs are for value trees */\n\tBUG_ON(ocfs2_xattr_is_local(loc->xl_entry));\n\tBUG_ON(namevalue_size_xe(loc->xl_entry) !=\n\t       (name_size + OCFS2_XATTR_ROOT_SIZE));\n\n\tloc->xl_ops->xlo_fill_value_buf(loc, vb);\n\tvb->vb_xv =\n\t\t(struct ocfs2_xattr_value_root *)ocfs2_xa_offset_pointer(loc,\n\t\t\t\t\t\t\tnameval_offset +\n\t\t\t\t\t\t\tname_size);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic void ocfs2_xa_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_value_buf *vb)\n{\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\n\t/* Value bufs are for value trees */\n\tBUG_ON(ocfs2_xattr_is_local(loc->xl_entry));\n\tBUG_ON(namevalue_size_xe(loc->xl_entry) !=\n\t       (name_size + OCFS2_XATTR_ROOT_SIZE));\n\n\tloc->xl_ops->xlo_fill_value_buf(loc, vb);\n\tvb->vb_xv =\n\t\t(struct ocfs2_xattr_value_root *)ocfs2_xa_offset_pointer(loc,\n\t\t\t\t\t\t\tnameval_offset +\n\t\t\t\t\t\t\tname_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "loc->xl_entry"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic unsigned int ocfs2_xa_value_clusters(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_value_buf vb;\n\n\tif (ocfs2_xattr_is_local(loc->xl_entry))\n\t\treturn 0;\n\n\tocfs2_xa_fill_value_buf(loc, &vb);\n\treturn le32_to_cpu(vb.vb_xv->xr_clusters);\n}"
  },
  {
    "function_name": "ocfs2_xa_bucket_fill_value_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1846-1863",
    "snippet": "static void ocfs2_xa_bucket_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_value_buf *vb)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\tstruct super_block *sb = loc->xl_inode->i_sb;\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint size = namevalue_size_xe(loc->xl_entry);\n\tint block_offset = nameval_offset >> sb->s_blocksize_bits;\n\n\t/* Values are not allowed to straddle block boundaries */\n\tBUG_ON(block_offset !=\n\t       ((nameval_offset + size - 1) >> sb->s_blocksize_bits));\n\t/* We expect the bucket to be filled in */\n\tBUG_ON(!bucket->bu_bhs[block_offset]);\n\n\tvb->vb_access = ocfs2_journal_access;\n\tvb->vb_bh = bucket->bu_bhs[block_offset];\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bucket->bu_bhs[block_offset]"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "block_offset !=\n\t       ((nameval_offset + size - 1) >> sb->s_blocksize_bits)"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namevalue_size_xe",
          "args": [
            "loc->xl_entry"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "241-248",
          "snippet": "static int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "loc->xl_entry->xe_name_offset"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_bucket_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   struct ocfs2_xattr_value_buf *vb)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\tstruct super_block *sb = loc->xl_inode->i_sb;\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint size = namevalue_size_xe(loc->xl_entry);\n\tint block_offset = nameval_offset >> sb->s_blocksize_bits;\n\n\t/* Values are not allowed to straddle block boundaries */\n\tBUG_ON(block_offset !=\n\t       ((nameval_offset + size - 1) >> sb->s_blocksize_bits));\n\t/* We expect the bucket to be filled in */\n\tBUG_ON(!bucket->bu_bhs[block_offset]);\n\n\tvb->vb_access = ocfs2_journal_access;\n\tvb->vb_bh = bucket->bu_bhs[block_offset];\n}"
  },
  {
    "function_name": "ocfs2_xa_bucket_add_namevalue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1831-1844",
    "snippet": "static void ocfs2_xa_bucket_add_namevalue(struct ocfs2_xa_loc *loc, int size)\n{\n\tint free_start = ocfs2_xa_get_free_start(loc);\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tstruct super_block *sb = loc->xl_inode->i_sb;\n\tint nameval_offset;\n\n\tfree_start = ocfs2_bucket_align_free_start(sb, free_start, size);\n\tnameval_offset = free_start - size;\n\tloc->xl_entry->xe_name_offset = cpu_to_le16(nameval_offset);\n\txh->xh_free_start = cpu_to_le16(nameval_offset);\n\tle16_add_cpu(&xh->xh_name_value_len, size);\n\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&xh->xh_name_value_len",
            "size"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "nameval_offset"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "nameval_offset"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_bucket_align_free_start",
          "args": [
            "sb",
            "free_start",
            "size"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bucket_align_free_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1731-1743",
          "snippet": "static int ocfs2_bucket_align_free_start(struct super_block *sb,\n\t\t\t\t\t int free_start, int size)\n{\n\t/*\n\t * We need to make sure that the name+value pair fits within\n\t * one block.\n\t */\n\tif (((free_start - size) >> sb->s_blocksize_bits) !=\n\t    ((free_start - 1) >> sb->s_blocksize_bits))\n\t\tfree_start -= free_start % sb->s_blocksize;\n\n\treturn free_start;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_bucket_align_free_start(struct super_block *sb,\n\t\t\t\t\t int free_start, int size)\n{\n\t/*\n\t * We need to make sure that the name+value pair fits within\n\t * one block.\n\t */\n\tif (((free_start - size) >> sb->s_blocksize_bits) !=\n\t    ((free_start - 1) >> sb->s_blocksize_bits))\n\t\tfree_start -= free_start % sb->s_blocksize;\n\n\treturn free_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_get_free_start",
          "args": [
            "loc"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_get_free_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1459-1462",
          "snippet": "static int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_bucket_add_namevalue(struct ocfs2_xa_loc *loc, int size)\n{\n\tint free_start = ocfs2_xa_get_free_start(loc);\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tstruct super_block *sb = loc->xl_inode->i_sb;\n\tint nameval_offset;\n\n\tfree_start = ocfs2_bucket_align_free_start(sb, free_start, size);\n\tnameval_offset = free_start - size;\n\tloc->xl_entry->xe_name_offset = cpu_to_le16(nameval_offset);\n\txh->xh_free_start = cpu_to_le16(nameval_offset);\n\tle16_add_cpu(&xh->xh_name_value_len, size);\n\n}"
  },
  {
    "function_name": "ocfs2_xa_bucket_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1796-1829",
    "snippet": "static void ocfs2_xa_bucket_add_entry(struct ocfs2_xa_loc *loc, u32 name_hash)\n{\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tint count = le16_to_cpu(xh->xh_count);\n\tint low = 0, high = count - 1, tmp;\n\tstruct ocfs2_xattr_entry *tmp_xe;\n\n\t/*\n\t * We keep buckets sorted by name_hash, so we need to find\n\t * our insert place.\n\t */\n\twhile (low <= high && count) {\n\t\ttmp = (low + high) / 2;\n\t\ttmp_xe = &xh->xh_entries[tmp];\n\n\t\tif (name_hash > le32_to_cpu(tmp_xe->xe_name_hash))\n\t\t\tlow = tmp + 1;\n\t\telse if (name_hash < le32_to_cpu(tmp_xe->xe_name_hash))\n\t\t\thigh = tmp - 1;\n\t\telse {\n\t\t\tlow = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (low != count)\n\t\tmemmove(&xh->xh_entries[low + 1],\n\t\t\t&xh->xh_entries[low],\n\t\t\t((count - low) * sizeof(struct ocfs2_xattr_entry)));\n\n\tle16_add_cpu(&xh->xh_count, 1);\n\tloc->xl_entry = &xh->xh_entries[low];\n\tmemset(loc->xl_entry, 0, sizeof(struct ocfs2_xattr_entry));\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "loc->xl_entry",
            "0",
            "sizeof(struct ocfs2_xattr_entry)"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&xh->xh_count",
            "1"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&xh->xh_entries[low + 1]",
            "&xh->xh_entries[low]",
            "((count - low) * sizeof(struct ocfs2_xattr_entry))"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tmp_xe->xe_name_hash"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_count"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_bucket_add_entry(struct ocfs2_xa_loc *loc, u32 name_hash)\n{\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tint count = le16_to_cpu(xh->xh_count);\n\tint low = 0, high = count - 1, tmp;\n\tstruct ocfs2_xattr_entry *tmp_xe;\n\n\t/*\n\t * We keep buckets sorted by name_hash, so we need to find\n\t * our insert place.\n\t */\n\twhile (low <= high && count) {\n\t\ttmp = (low + high) / 2;\n\t\ttmp_xe = &xh->xh_entries[tmp];\n\n\t\tif (name_hash > le32_to_cpu(tmp_xe->xe_name_hash))\n\t\t\tlow = tmp + 1;\n\t\telse if (name_hash < le32_to_cpu(tmp_xe->xe_name_hash))\n\t\t\thigh = tmp - 1;\n\t\telse {\n\t\t\tlow = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (low != count)\n\t\tmemmove(&xh->xh_entries[low + 1],\n\t\t\t&xh->xh_entries[low],\n\t\t\t((count - low) * sizeof(struct ocfs2_xattr_entry)));\n\n\tle16_add_cpu(&xh->xh_count, 1);\n\tloc->xl_entry = &xh->xh_entries[low];\n\tmemset(loc->xl_entry, 0, sizeof(struct ocfs2_xattr_entry));\n}"
  },
  {
    "function_name": "ocfs2_xa_bucket_wipe_namevalue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1790-1794",
    "snippet": "static void ocfs2_xa_bucket_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tle16_add_cpu(&loc->xl_header->xh_name_value_len,\n\t\t     -namevalue_size_xe(loc->xl_entry));\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&loc->xl_header->xh_name_value_len",
            "-namevalue_size_xe(loc->xl_entry)"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namevalue_size_xe",
          "args": [
            "loc->xl_entry"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "241-248",
          "snippet": "static int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_bucket_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tle16_add_cpu(&loc->xl_header->xh_name_value_len,\n\t\t     -namevalue_size_xe(loc->xl_entry));\n}"
  },
  {
    "function_name": "ocfs2_xa_bucket_check_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1745-1788",
    "snippet": "static int ocfs2_xa_bucket_check_space(struct ocfs2_xa_loc *loc,\n\t\t\t\t       struct ocfs2_xattr_info *xi)\n{\n\tint rc;\n\tint count = le16_to_cpu(loc->xl_header->xh_count);\n\tint free_start = ocfs2_xa_get_free_start(loc);\n\tint needed_space = ocfs2_xi_entry_usage(xi);\n\tint size = namevalue_size_xi(xi);\n\tstruct super_block *sb = loc->xl_inode->i_sb;\n\n\t/*\n\t * Bucket storage does not reclaim name+value pairs it cannot\n\t * reuse.  They live as holes until the bucket fills, and then\n\t * the bucket is defragmented.  However, the bucket can reclaim\n\t * the ocfs2_xattr_entry.\n\t */\n\tif (loc->xl_entry) {\n\t\t/* Don't need space if we're reusing! */\n\t\tif (ocfs2_xa_can_reuse_entry(loc, xi))\n\t\t\tneeded_space = 0;\n\t\telse\n\t\t\tneeded_space -= sizeof(struct ocfs2_xattr_entry);\n\t}\n\tBUG_ON(needed_space < 0);\n\n\tif (free_start < size) {\n\t\tif (needed_space)\n\t\t\treturn -ENOSPC;\n\t} else {\n\t\t/*\n\t\t * First we check if it would fit in the first place.\n\t\t * Below, we align the free start to a block.  This may\n\t\t * slide us below the minimum gap.  By checking unaligned\n\t\t * first, we avoid that error.\n\t\t */\n\t\trc = ocfs2_xa_check_space_helper(needed_space, free_start,\n\t\t\t\t\t\t count);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfree_start = ocfs2_bucket_align_free_start(sb, free_start,\n\t\t\t\t\t\t\t   size);\n\t}\n\treturn ocfs2_xa_check_space_helper(needed_space, free_start, count);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xa_check_space_helper",
          "args": [
            "needed_space",
            "free_start",
            "count"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_check_space_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1407-1425",
          "snippet": "static int ocfs2_xa_check_space_helper(int needed_space, int free_start,\n\t\t\t\t       int num_entries)\n{\n\tint free_space;\n\n\tif (!needed_space)\n\t\treturn 0;\n\n\tfree_space = free_start -\n\t\tsizeof(struct ocfs2_xattr_header) -\n\t\t(num_entries * sizeof(struct ocfs2_xattr_entry)) -\n\t\tOCFS2_XATTR_HEADER_GAP;\n\tif (free_space < 0)\n\t\treturn -EIO;\n\tif (free_space < needed_space)\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_HEADER_GAP\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_HEADER_GAP\t4\n\nstatic int ocfs2_xa_check_space_helper(int needed_space, int free_start,\n\t\t\t\t       int num_entries)\n{\n\tint free_space;\n\n\tif (!needed_space)\n\t\treturn 0;\n\n\tfree_space = free_start -\n\t\tsizeof(struct ocfs2_xattr_header) -\n\t\t(num_entries * sizeof(struct ocfs2_xattr_entry)) -\n\t\tOCFS2_XATTR_HEADER_GAP;\n\tif (free_space < 0)\n\t\treturn -EIO;\n\tif (free_space < needed_space)\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_bucket_align_free_start",
          "args": [
            "sb",
            "free_start",
            "size"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bucket_align_free_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1731-1743",
          "snippet": "static int ocfs2_bucket_align_free_start(struct super_block *sb,\n\t\t\t\t\t int free_start, int size)\n{\n\t/*\n\t * We need to make sure that the name+value pair fits within\n\t * one block.\n\t */\n\tif (((free_start - size) >> sb->s_blocksize_bits) !=\n\t    ((free_start - 1) >> sb->s_blocksize_bits))\n\t\tfree_start -= free_start % sb->s_blocksize;\n\n\treturn free_start;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_bucket_align_free_start(struct super_block *sb,\n\t\t\t\t\t int free_start, int size)\n{\n\t/*\n\t * We need to make sure that the name+value pair fits within\n\t * one block.\n\t */\n\tif (((free_start - size) >> sb->s_blocksize_bits) !=\n\t    ((free_start - 1) >> sb->s_blocksize_bits))\n\t\tfree_start -= free_start % sb->s_blocksize;\n\n\treturn free_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "needed_space < 0"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_can_reuse_entry",
          "args": [
            "loc",
            "xi"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_can_reuse_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1465-1469",
          "snippet": "static int ocfs2_xa_can_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_can_reuse(loc, xi);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_can_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_can_reuse(loc, xi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "namevalue_size_xi",
          "args": [
            "xi"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "236-239",
          "snippet": "static int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xi_entry_usage",
          "args": [
            "xi"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xi_entry_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "581-585",
          "snippet": "static int ocfs2_xi_entry_usage(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size_xi(xi) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xi_entry_usage(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size_xi(xi) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_get_free_start",
          "args": [
            "loc"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_get_free_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1459-1462",
          "snippet": "static int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "loc->xl_header->xh_count"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_bucket_check_space(struct ocfs2_xa_loc *loc,\n\t\t\t\t       struct ocfs2_xattr_info *xi)\n{\n\tint rc;\n\tint count = le16_to_cpu(loc->xl_header->xh_count);\n\tint free_start = ocfs2_xa_get_free_start(loc);\n\tint needed_space = ocfs2_xi_entry_usage(xi);\n\tint size = namevalue_size_xi(xi);\n\tstruct super_block *sb = loc->xl_inode->i_sb;\n\n\t/*\n\t * Bucket storage does not reclaim name+value pairs it cannot\n\t * reuse.  They live as holes until the bucket fills, and then\n\t * the bucket is defragmented.  However, the bucket can reclaim\n\t * the ocfs2_xattr_entry.\n\t */\n\tif (loc->xl_entry) {\n\t\t/* Don't need space if we're reusing! */\n\t\tif (ocfs2_xa_can_reuse_entry(loc, xi))\n\t\t\tneeded_space = 0;\n\t\telse\n\t\t\tneeded_space -= sizeof(struct ocfs2_xattr_entry);\n\t}\n\tBUG_ON(needed_space < 0);\n\n\tif (free_start < size) {\n\t\tif (needed_space)\n\t\t\treturn -ENOSPC;\n\t} else {\n\t\t/*\n\t\t * First we check if it would fit in the first place.\n\t\t * Below, we align the free start to a block.  This may\n\t\t * slide us below the minimum gap.  By checking unaligned\n\t\t * first, we avoid that error.\n\t\t */\n\t\trc = ocfs2_xa_check_space_helper(needed_space, free_start,\n\t\t\t\t\t\t count);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfree_start = ocfs2_bucket_align_free_start(sb, free_start,\n\t\t\t\t\t\t\t   size);\n\t}\n\treturn ocfs2_xa_check_space_helper(needed_space, free_start, count);\n}"
  },
  {
    "function_name": "ocfs2_bucket_align_free_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1731-1743",
    "snippet": "static int ocfs2_bucket_align_free_start(struct super_block *sb,\n\t\t\t\t\t int free_start, int size)\n{\n\t/*\n\t * We need to make sure that the name+value pair fits within\n\t * one block.\n\t */\n\tif (((free_start - size) >> sb->s_blocksize_bits) !=\n\t    ((free_start - 1) >> sb->s_blocksize_bits))\n\t\tfree_start -= free_start % sb->s_blocksize;\n\n\treturn free_start;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_bucket_align_free_start(struct super_block *sb,\n\t\t\t\t\t int free_start, int size)\n{\n\t/*\n\t * We need to make sure that the name+value pair fits within\n\t * one block.\n\t */\n\tif (((free_start - size) >> sb->s_blocksize_bits) !=\n\t    ((free_start - 1) >> sb->s_blocksize_bits))\n\t\tfree_start -= free_start % sb->s_blocksize;\n\n\treturn free_start;\n}"
  },
  {
    "function_name": "ocfs2_xa_bucket_get_free_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1725-1729",
    "snippet": "static int ocfs2_xa_bucket_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\treturn le16_to_cpu(bucket_xh(bucket)->xh_free_start);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bucket_xh(bucket)->xh_free_start"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_bucket_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\treturn le16_to_cpu(bucket_xh(bucket)->xh_free_start);\n}"
  },
  {
    "function_name": "ocfs2_xa_bucket_can_reuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1718-1723",
    "snippet": "static int ocfs2_xa_bucket_can_reuse(struct ocfs2_xa_loc *loc,\n\t\t\t\t     struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size_xe(loc->xl_entry) >=\n\t\tnamevalue_size_xi(xi);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "namevalue_size_xi",
          "args": [
            "xi"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "236-239",
          "snippet": "static int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "namevalue_size_xe",
          "args": [
            "loc->xl_entry"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "241-248",
          "snippet": "static int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_bucket_can_reuse(struct ocfs2_xa_loc *loc,\n\t\t\t\t     struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size_xe(loc->xl_entry) >=\n\t\tnamevalue_size_xi(xi);\n}"
  },
  {
    "function_name": "ocfs2_xa_bucket_offset_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1705-1716",
    "snippet": "static void *ocfs2_xa_bucket_offset_pointer(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    int offset)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\tint block, block_offset;\n\n\t/* The header is at the front of the bucket */\n\tblock = offset >> loc->xl_inode->i_sb->s_blocksize_bits;\n\tblock_offset = offset % loc->xl_inode->i_sb->s_blocksize;\n\n\treturn bucket_block(bucket, block) + block_offset;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "bucket",
            "block"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void *ocfs2_xa_bucket_offset_pointer(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    int offset)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\tint block, block_offset;\n\n\t/* The header is at the front of the bucket */\n\tblock = offset >> loc->xl_inode->i_sb->s_blocksize_bits;\n\tblock_offset = offset % loc->xl_inode->i_sb->s_blocksize;\n\n\treturn bucket_block(bucket, block) + block_offset;\n}"
  },
  {
    "function_name": "ocfs2_xa_bucket_journal_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1697-1703",
    "snippet": "static void ocfs2_xa_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t  struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\n\tocfs2_xattr_bucket_journal_dirty(handle, bucket);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_dirty",
          "args": [
            "handle",
            "bucket"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "447-460",
          "snippet": "static void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t  struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\n\tocfs2_xattr_bucket_journal_dirty(handle, bucket);\n}"
  },
  {
    "function_name": "ocfs2_xa_bucket_journal_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1689-1695",
    "snippet": "static int ocfs2_xa_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t  struct ocfs2_xa_loc *loc, int type)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\n\treturn ocfs2_xattr_bucket_journal_access(handle, bucket, type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_journal_access",
          "args": [
            "handle",
            "bucket",
            "type"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "428-445",
          "snippet": "static int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t  struct ocfs2_xa_loc *loc, int type)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\n\treturn ocfs2_xattr_bucket_journal_access(handle, bucket, type);\n}"
  },
  {
    "function_name": "ocfs2_xa_block_fill_value_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1658-1670",
    "snippet": "static void ocfs2_xa_block_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t  struct ocfs2_xattr_value_buf *vb)\n{\n\tstruct buffer_head *bh = loc->xl_storage;\n\n\tif (loc->xl_size == (bh->b_size -\n\t\t\t     offsetof(struct ocfs2_xattr_block,\n\t\t\t\t      xb_attrs.xb_header)))\n\t\tvb->vb_access = ocfs2_journal_access_xb;\n\telse\n\t\tvb->vb_access = ocfs2_journal_access_di;\n\tvb->vb_bh = bh;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic void ocfs2_xa_block_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t  struct ocfs2_xattr_value_buf *vb)\n{\n\tstruct buffer_head *bh = loc->xl_storage;\n\n\tif (loc->xl_size == (bh->b_size -\n\t\t\t     offsetof(struct ocfs2_xattr_block,\n\t\t\t\t      xb_attrs.xb_header)))\n\t\tvb->vb_access = ocfs2_journal_access_xb;\n\telse\n\t\tvb->vb_access = ocfs2_journal_access_di;\n\tvb->vb_bh = bh;\n}"
  },
  {
    "function_name": "ocfs2_xa_block_add_namevalue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1651-1656",
    "snippet": "static void ocfs2_xa_block_add_namevalue(struct ocfs2_xa_loc *loc, int size)\n{\n\tint free_start = ocfs2_xa_get_free_start(loc);\n\n\tloc->xl_entry->xe_name_offset = cpu_to_le16(free_start - size);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "free_start - size"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_get_free_start",
          "args": [
            "loc"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_get_free_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1459-1462",
          "snippet": "static int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_block_add_namevalue(struct ocfs2_xa_loc *loc, int size)\n{\n\tint free_start = ocfs2_xa_get_free_start(loc);\n\n\tloc->xl_entry->xe_name_offset = cpu_to_le16(free_start - size);\n}"
  },
  {
    "function_name": "ocfs2_xa_block_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1643-1649",
    "snippet": "static void ocfs2_xa_block_add_entry(struct ocfs2_xa_loc *loc, u32 name_hash)\n{\n\tint count = le16_to_cpu(loc->xl_header->xh_count);\n\tloc->xl_entry = &(loc->xl_header->xh_entries[count]);\n\tle16_add_cpu(&loc->xl_header->xh_count, 1);\n\tmemset(loc->xl_entry, 0, sizeof(struct ocfs2_xattr_entry));\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "loc->xl_entry",
            "0",
            "sizeof(struct ocfs2_xattr_entry)"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&loc->xl_header->xh_count",
            "1"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "loc->xl_header->xh_count"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_block_add_entry(struct ocfs2_xa_loc *loc, u32 name_hash)\n{\n\tint count = le16_to_cpu(loc->xl_header->xh_count);\n\tloc->xl_entry = &(loc->xl_header->xh_entries[count]);\n\tle16_add_cpu(&loc->xl_header->xh_count, 1);\n\tmemset(loc->xl_entry, 0, sizeof(struct ocfs2_xattr_entry));\n}"
  },
  {
    "function_name": "ocfs2_xa_block_wipe_namevalue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1611-1641",
    "snippet": "static void ocfs2_xa_block_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tint i, offset;\n\tint namevalue_offset, first_namevalue_offset, namevalue_size;\n\tstruct ocfs2_xattr_entry *entry = loc->xl_entry;\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tint count = le16_to_cpu(xh->xh_count);\n\n\tnamevalue_offset = le16_to_cpu(entry->xe_name_offset);\n\tnamevalue_size = namevalue_size_xe(entry);\n\tfirst_namevalue_offset = ocfs2_xa_get_free_start(loc);\n\n\t/* Shift the name+value pairs */\n\tmemmove((char *)xh + first_namevalue_offset + namevalue_size,\n\t\t(char *)xh + first_namevalue_offset,\n\t\tnamevalue_offset - first_namevalue_offset);\n\tmemset((char *)xh + first_namevalue_offset, 0, namevalue_size);\n\n\t/* Now tell xh->xh_entries about it */\n\tfor (i = 0; i < count; i++) {\n\t\toffset = le16_to_cpu(xh->xh_entries[i].xe_name_offset);\n\t\tif (offset <= namevalue_offset)\n\t\t\tle16_add_cpu(&xh->xh_entries[i].xe_name_offset,\n\t\t\t\t     namevalue_size);\n\t}\n\n\t/*\n\t * Note that we don't update xh_free_start or xh_name_value_len\n\t * because they're not used in block-stored xattrs.\n\t */\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&xh->xh_entries[i].xe_name_offset",
            "namevalue_size"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_entries[i].xe_name_offset"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)xh + first_namevalue_offset",
            "0",
            "namevalue_size"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(char *)xh + first_namevalue_offset + namevalue_size",
            "(char *)xh + first_namevalue_offset",
            "namevalue_offset - first_namevalue_offset"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_get_free_start",
          "args": [
            "loc"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_get_free_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1459-1462",
          "snippet": "static int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "namevalue_size_xe",
          "args": [
            "entry"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "241-248",
          "snippet": "static int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_block_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tint i, offset;\n\tint namevalue_offset, first_namevalue_offset, namevalue_size;\n\tstruct ocfs2_xattr_entry *entry = loc->xl_entry;\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tint count = le16_to_cpu(xh->xh_count);\n\n\tnamevalue_offset = le16_to_cpu(entry->xe_name_offset);\n\tnamevalue_size = namevalue_size_xe(entry);\n\tfirst_namevalue_offset = ocfs2_xa_get_free_start(loc);\n\n\t/* Shift the name+value pairs */\n\tmemmove((char *)xh + first_namevalue_offset + namevalue_size,\n\t\t(char *)xh + first_namevalue_offset,\n\t\tnamevalue_offset - first_namevalue_offset);\n\tmemset((char *)xh + first_namevalue_offset, 0, namevalue_size);\n\n\t/* Now tell xh->xh_entries about it */\n\tfor (i = 0; i < count; i++) {\n\t\toffset = le16_to_cpu(xh->xh_entries[i].xe_name_offset);\n\t\tif (offset <= namevalue_offset)\n\t\t\tle16_add_cpu(&xh->xh_entries[i].xe_name_offset,\n\t\t\t\t     namevalue_size);\n\t}\n\n\t/*\n\t * Note that we don't update xh_free_start or xh_name_value_len\n\t * because they're not used in block-stored xattrs.\n\t */\n}"
  },
  {
    "function_name": "ocfs2_xa_block_check_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1583-1605",
    "snippet": "static int ocfs2_xa_block_check_space(struct ocfs2_xa_loc *loc,\n\t\t\t\t      struct ocfs2_xattr_info *xi)\n{\n\tint count = le16_to_cpu(loc->xl_header->xh_count);\n\tint free_start = ocfs2_xa_get_free_start(loc);\n\tint needed_space = ocfs2_xi_entry_usage(xi);\n\n\t/*\n\t * Block storage will reclaim the original entry before inserting\n\t * the new value, so we only need the difference.  If the new\n\t * entry is smaller than the old one, we don't need anything.\n\t */\n\tif (loc->xl_entry) {\n\t\t/* Don't need space if we're reusing! */\n\t\tif (ocfs2_xa_can_reuse_entry(loc, xi))\n\t\t\tneeded_space = 0;\n\t\telse\n\t\t\tneeded_space -= ocfs2_xe_entry_usage(loc->xl_entry);\n\t}\n\tif (needed_space < 0)\n\t\tneeded_space = 0;\n\treturn ocfs2_xa_check_space_helper(needed_space, free_start, count);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xa_check_space_helper",
          "args": [
            "needed_space",
            "free_start",
            "count"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_check_space_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1407-1425",
          "snippet": "static int ocfs2_xa_check_space_helper(int needed_space, int free_start,\n\t\t\t\t       int num_entries)\n{\n\tint free_space;\n\n\tif (!needed_space)\n\t\treturn 0;\n\n\tfree_space = free_start -\n\t\tsizeof(struct ocfs2_xattr_header) -\n\t\t(num_entries * sizeof(struct ocfs2_xattr_entry)) -\n\t\tOCFS2_XATTR_HEADER_GAP;\n\tif (free_space < 0)\n\t\treturn -EIO;\n\tif (free_space < needed_space)\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_HEADER_GAP\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_HEADER_GAP\t4\n\nstatic int ocfs2_xa_check_space_helper(int needed_space, int free_start,\n\t\t\t\t       int num_entries)\n{\n\tint free_space;\n\n\tif (!needed_space)\n\t\treturn 0;\n\n\tfree_space = free_start -\n\t\tsizeof(struct ocfs2_xattr_header) -\n\t\t(num_entries * sizeof(struct ocfs2_xattr_entry)) -\n\t\tOCFS2_XATTR_HEADER_GAP;\n\tif (free_space < 0)\n\t\treturn -EIO;\n\tif (free_space < needed_space)\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xe_entry_usage",
          "args": [
            "loc->xl_entry"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xe_entry_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "587-591",
          "snippet": "static int ocfs2_xe_entry_usage(struct ocfs2_xattr_entry *xe)\n{\n\treturn namevalue_size_xe(xe) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xe_entry_usage(struct ocfs2_xattr_entry *xe)\n{\n\treturn namevalue_size_xe(xe) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_can_reuse_entry",
          "args": [
            "loc",
            "xi"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_can_reuse_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1465-1469",
          "snippet": "static int ocfs2_xa_can_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_can_reuse(loc, xi);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_can_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_can_reuse(loc, xi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xi_entry_usage",
          "args": [
            "xi"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xi_entry_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "581-585",
          "snippet": "static int ocfs2_xi_entry_usage(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size_xi(xi) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xi_entry_usage(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size_xi(xi) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_get_free_start",
          "args": [
            "loc"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_get_free_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1459-1462",
          "snippet": "static int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "loc->xl_header->xh_count"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_block_check_space(struct ocfs2_xa_loc *loc,\n\t\t\t\t      struct ocfs2_xattr_info *xi)\n{\n\tint count = le16_to_cpu(loc->xl_header->xh_count);\n\tint free_start = ocfs2_xa_get_free_start(loc);\n\tint needed_space = ocfs2_xi_entry_usage(xi);\n\n\t/*\n\t * Block storage will reclaim the original entry before inserting\n\t * the new value, so we only need the difference.  If the new\n\t * entry is smaller than the old one, we don't need anything.\n\t */\n\tif (loc->xl_entry) {\n\t\t/* Don't need space if we're reusing! */\n\t\tif (ocfs2_xa_can_reuse_entry(loc, xi))\n\t\t\tneeded_space = 0;\n\t\telse\n\t\t\tneeded_space -= ocfs2_xe_entry_usage(loc->xl_entry);\n\t}\n\tif (needed_space < 0)\n\t\tneeded_space = 0;\n\treturn ocfs2_xa_check_space_helper(needed_space, free_start, count);\n}"
  },
  {
    "function_name": "ocfs2_xa_block_get_free_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1568-1581",
    "snippet": "static int ocfs2_xa_block_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tint i, count = le16_to_cpu(xh->xh_count);\n\tint offset, free_start = loc->xl_size;\n\n\tfor (i = 0; i < count; i++) {\n\t\toffset = le16_to_cpu(xh->xh_entries[i].xe_name_offset);\n\t\tif (offset < free_start)\n\t\t\tfree_start = offset;\n\t}\n\n\treturn free_start;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_entries[i].xe_name_offset"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_block_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\tstruct ocfs2_xattr_header *xh = loc->xl_header;\n\tint i, count = le16_to_cpu(xh->xh_count);\n\tint offset, free_start = loc->xl_size;\n\n\tfor (i = 0; i < count; i++) {\n\t\toffset = le16_to_cpu(xh->xh_entries[i].xe_name_offset);\n\t\tif (offset < free_start)\n\t\t\tfree_start = offset;\n\t}\n\n\treturn free_start;\n}"
  },
  {
    "function_name": "ocfs2_xa_block_can_reuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1557-1566",
    "snippet": "static int ocfs2_xa_block_can_reuse(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_info *xi)\n{\n\t/*\n\t * Block storage is strict.  If the sizes aren't exact, we will\n\t * remove the old one and reinsert the new.\n\t */\n\treturn namevalue_size_xe(loc->xl_entry) ==\n\t\tnamevalue_size_xi(xi);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "namevalue_size_xi",
          "args": [
            "xi"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "236-239",
          "snippet": "static int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "namevalue_size_xe",
          "args": [
            "loc->xl_entry"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "241-248",
          "snippet": "static int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_block_can_reuse(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_info *xi)\n{\n\t/*\n\t * Block storage is strict.  If the sizes aren't exact, we will\n\t * remove the old one and reinsert the new.\n\t */\n\treturn namevalue_size_xe(loc->xl_entry) ==\n\t\tnamevalue_size_xi(xi);\n}"
  },
  {
    "function_name": "ocfs2_xa_block_offset_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1551-1555",
    "snippet": "static void *ocfs2_xa_block_offset_pointer(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   int offset)\n{\n\treturn (char *)loc->xl_header + offset;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void *ocfs2_xa_block_offset_pointer(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t   int offset)\n{\n\treturn (char *)loc->xl_header + offset;\n}"
  },
  {
    "function_name": "ocfs2_xa_block_journal_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1543-1549",
    "snippet": "static void ocfs2_xa_block_journal_dirty(handle_t *handle,\n\t\t\t\t\t struct ocfs2_xa_loc *loc)\n{\n\tstruct buffer_head *bh = loc->xl_storage;\n\n\tocfs2_journal_dirty(handle, bh);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic void ocfs2_xa_block_journal_dirty(handle_t *handle,\n\t\t\t\t\t struct ocfs2_xa_loc *loc)\n{\n\tstruct buffer_head *bh = loc->xl_storage;\n\n\tocfs2_journal_dirty(handle, bh);\n}"
  },
  {
    "function_name": "ocfs2_xa_block_journal_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1528-1541",
    "snippet": "static int ocfs2_xa_block_journal_access(handle_t *handle,\n\t\t\t\t\t struct ocfs2_xa_loc *loc, int type)\n{\n\tstruct buffer_head *bh = loc->xl_storage;\n\tocfs2_journal_access_func access;\n\n\tif (loc->xl_size == (bh->b_size -\n\t\t\t     offsetof(struct ocfs2_xattr_block,\n\t\t\t\t      xb_attrs.xb_header)))\n\t\taccess = ocfs2_journal_access_xb;\n\telse\n\t\taccess = ocfs2_journal_access_di;\n\treturn access(handle, INODE_CACHE(loc->xl_inode), bh, type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "access",
          "args": [
            "handle",
            "INODE_CACHE(loc->xl_inode)",
            "bh",
            "type"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "726-741",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "loc->xl_inode"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_xa_block_journal_access(handle_t *handle,\n\t\t\t\t\t struct ocfs2_xa_loc *loc, int type)\n{\n\tstruct buffer_head *bh = loc->xl_storage;\n\tocfs2_journal_access_func access;\n\n\tif (loc->xl_size == (bh->b_size -\n\t\t\t     offsetof(struct ocfs2_xattr_block,\n\t\t\t\t      xb_attrs.xb_header)))\n\t\taccess = ocfs2_journal_access_xb;\n\telse\n\t\taccess = ocfs2_journal_access_di;\n\treturn access(handle, INODE_CACHE(loc->xl_inode), bh, type);\n}"
  },
  {
    "function_name": "ocfs2_xa_fill_value_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1510-1526",
    "snippet": "static void ocfs2_xa_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_value_buf *vb)\n{\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\n\t/* Value bufs are for value trees */\n\tBUG_ON(ocfs2_xattr_is_local(loc->xl_entry));\n\tBUG_ON(namevalue_size_xe(loc->xl_entry) !=\n\t       (name_size + OCFS2_XATTR_ROOT_SIZE));\n\n\tloc->xl_ops->xlo_fill_value_buf(loc, vb);\n\tvb->vb_xv =\n\t\t(struct ocfs2_xattr_value_root *)ocfs2_xa_offset_pointer(loc,\n\t\t\t\t\t\t\tnameval_offset +\n\t\t\t\t\t\t\tname_size);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xa_offset_pointer",
          "args": [
            "loc",
            "nameval_offset +\n\t\t\t\t\t\t\tname_size"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_offset_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1439-1443",
          "snippet": "static void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "loc->xl_ops->xlo_fill_value_buf",
          "args": [
            "loc",
            "vb"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "namevalue_size_xe(loc->xl_entry) !=\n\t       (name_size + OCFS2_XATTR_ROOT_SIZE)"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namevalue_size_xe",
          "args": [
            "loc->xl_entry"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "241-248",
          "snippet": "static int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ocfs2_xattr_is_local(loc->xl_entry)"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "loc->xl_entry"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "loc->xl_entry->xe_name_len"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "loc->xl_entry->xe_name_offset"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic void ocfs2_xa_fill_value_buf(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_value_buf *vb)\n{\n\tint nameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tint name_size = OCFS2_XATTR_SIZE(loc->xl_entry->xe_name_len);\n\n\t/* Value bufs are for value trees */\n\tBUG_ON(ocfs2_xattr_is_local(loc->xl_entry));\n\tBUG_ON(namevalue_size_xe(loc->xl_entry) !=\n\t       (name_size + OCFS2_XATTR_ROOT_SIZE));\n\n\tloc->xl_ops->xlo_fill_value_buf(loc, vb);\n\tvb->vb_xv =\n\t\t(struct ocfs2_xattr_value_root *)ocfs2_xa_offset_pointer(loc,\n\t\t\t\t\t\t\tnameval_offset +\n\t\t\t\t\t\t\tname_size);\n}"
  },
  {
    "function_name": "ocfs2_xa_add_namevalue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1490-1508",
    "snippet": "static void ocfs2_xa_add_namevalue(struct ocfs2_xa_loc *loc,\n\t\t\t\t   struct ocfs2_xattr_info *xi)\n{\n\tint size = namevalue_size_xi(xi);\n\tint nameval_offset;\n\tchar *nameval_buf;\n\n\tloc->xl_ops->xlo_add_namevalue(loc, size);\n\tloc->xl_entry->xe_value_size = cpu_to_le64(xi->xi_value_len);\n\tloc->xl_entry->xe_name_len = xi->xi_name_len;\n\tocfs2_xattr_set_type(loc->xl_entry, xi->xi_name_index);\n\tocfs2_xattr_set_local(loc->xl_entry,\n\t\t\t      xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE);\n\n\tnameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tnameval_buf = ocfs2_xa_offset_pointer(loc, nameval_offset);\n\tmemset(nameval_buf, 0, size);\n\tmemcpy(nameval_buf, xi->xi_name, xi->xi_name_len);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_INLINE_SIZE\t80"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nameval_buf",
            "xi->xi_name",
            "xi->xi_name_len"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "nameval_buf",
            "0",
            "size"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xa_offset_pointer",
          "args": [
            "loc",
            "nameval_offset"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_offset_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1439-1443",
          "snippet": "static void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "loc->xl_entry->xe_name_offset"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_set_local",
          "args": [
            "loc->xl_entry",
            "xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_set_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1134-1141",
          "snippet": "static inline void ocfs2_xattr_set_local(struct ocfs2_xattr_entry *xe,\n\t\t\t\t\t int local)\n{\n\tif (local)\n\t\txe->xe_type |= OCFS2_XATTR_ENTRY_LOCAL;\n\telse\n\t\txe->xe_type &= ~OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline void ocfs2_xattr_set_local(struct ocfs2_xattr_entry *xe,\n\t\t\t\t\t int local)\n{\n\tif (local)\n\t\txe->xe_type |= OCFS2_XATTR_ENTRY_LOCAL;\n\telse\n\t\txe->xe_type &= ~OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_set_type",
          "args": [
            "loc->xl_entry",
            "xi->xi_name_index"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1148-1151",
          "snippet": "static inline void ocfs2_xattr_set_type(struct ocfs2_xattr_entry *xe, int type)\n{\n\txe->xe_type |= type & OCFS2_XATTR_TYPE_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_TYPE_MASK\t\t0x7F"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_TYPE_MASK\t\t0x7F\n\nstatic inline void ocfs2_xattr_set_type(struct ocfs2_xattr_entry *xe, int type)\n{\n\txe->xe_type |= type & OCFS2_XATTR_TYPE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "xi->xi_value_len"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loc->xl_ops->xlo_add_namevalue",
          "args": [
            "loc",
            "size"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namevalue_size_xi",
          "args": [
            "xi"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "236-239",
          "snippet": "static int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic void ocfs2_xa_add_namevalue(struct ocfs2_xa_loc *loc,\n\t\t\t\t   struct ocfs2_xattr_info *xi)\n{\n\tint size = namevalue_size_xi(xi);\n\tint nameval_offset;\n\tchar *nameval_buf;\n\n\tloc->xl_ops->xlo_add_namevalue(loc, size);\n\tloc->xl_entry->xe_value_size = cpu_to_le64(xi->xi_value_len);\n\tloc->xl_entry->xe_name_len = xi->xi_name_len;\n\tocfs2_xattr_set_type(loc->xl_entry, xi->xi_name_index);\n\tocfs2_xattr_set_local(loc->xl_entry,\n\t\t\t      xi->xi_value_len <= OCFS2_XATTR_INLINE_SIZE);\n\n\tnameval_offset = le16_to_cpu(loc->xl_entry->xe_name_offset);\n\tnameval_buf = ocfs2_xa_offset_pointer(loc, nameval_offset);\n\tmemset(nameval_buf, 0, size);\n\tmemcpy(nameval_buf, xi->xi_name, xi->xi_name_len);\n}"
  },
  {
    "function_name": "ocfs2_xa_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1478-1488",
    "snippet": "static void ocfs2_xa_add_entry(struct ocfs2_xa_loc *loc, u32 name_hash)\n{\n\tloc->xl_ops->xlo_add_entry(loc, name_hash);\n\tloc->xl_entry->xe_name_hash = cpu_to_le32(name_hash);\n\t/*\n\t * We can't leave the new entry's xe_name_offset at zero or\n\t * add_namevalue() will go nuts.  We set it to the size of our\n\t * storage so that it can never be less than any other entry.\n\t */\n\tloc->xl_entry->xe_name_offset = cpu_to_le16(loc->xl_size);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "loc->xl_size"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "name_hash"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loc->xl_ops->xlo_add_entry",
          "args": [
            "loc",
            "name_hash"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_add_entry(struct ocfs2_xa_loc *loc, u32 name_hash)\n{\n\tloc->xl_ops->xlo_add_entry(loc, name_hash);\n\tloc->xl_entry->xe_name_hash = cpu_to_le32(name_hash);\n\t/*\n\t * We can't leave the new entry's xe_name_offset at zero or\n\t * add_namevalue() will go nuts.  We set it to the size of our\n\t * storage so that it can never be less than any other entry.\n\t */\n\tloc->xl_entry->xe_name_offset = cpu_to_le16(loc->xl_size);\n}"
  },
  {
    "function_name": "ocfs2_xa_check_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1472-1476",
    "snippet": "static int ocfs2_xa_check_space(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_check_space(loc, xi);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loc->xl_ops->xlo_check_space",
          "args": [
            "loc",
            "xi"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_check_space(struct ocfs2_xa_loc *loc,\n\t\t\t\tstruct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_check_space(loc, xi);\n}"
  },
  {
    "function_name": "ocfs2_xa_can_reuse_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1465-1469",
    "snippet": "static int ocfs2_xa_can_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_can_reuse(loc, xi);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loc->xl_ops->xlo_can_reuse",
          "args": [
            "loc",
            "xi"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_can_reuse_entry(struct ocfs2_xa_loc *loc,\n\t\t\t\t    struct ocfs2_xattr_info *xi)\n{\n\treturn loc->xl_ops->xlo_can_reuse(loc, xi);\n}"
  },
  {
    "function_name": "ocfs2_xa_get_free_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1459-1462",
    "snippet": "static int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loc->xl_ops->xlo_get_free_start",
          "args": [
            "loc"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_get_free_start(struct ocfs2_xa_loc *loc)\n{\n\treturn loc->xl_ops->xlo_get_free_start(loc);\n}"
  },
  {
    "function_name": "ocfs2_xa_wipe_namevalue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1450-1453",
    "snippet": "static void ocfs2_xa_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tloc->xl_ops->xlo_wipe_namevalue(loc);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loc->xl_ops->xlo_wipe_namevalue",
          "args": [
            "loc"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_wipe_namevalue(struct ocfs2_xa_loc *loc)\n{\n\tloc->xl_ops->xlo_wipe_namevalue(loc);\n}"
  },
  {
    "function_name": "ocfs2_xa_offset_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1439-1443",
    "snippet": "static void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loc->xl_ops->xlo_offset_pointer",
          "args": [
            "loc",
            "offset"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset >= loc->xl_size"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void *ocfs2_xa_offset_pointer(struct ocfs2_xa_loc *loc, int offset)\n{\n\tBUG_ON(offset >= loc->xl_size);\n\treturn loc->xl_ops->xlo_offset_pointer(loc, offset);\n}"
  },
  {
    "function_name": "ocfs2_xa_journal_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1433-1436",
    "snippet": "static void ocfs2_xa_journal_dirty(handle_t *handle, struct ocfs2_xa_loc *loc)\n{\n\tloc->xl_ops->xlo_journal_dirty(handle, loc);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loc->xl_ops->xlo_journal_dirty",
          "args": [
            "handle",
            "loc"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xa_journal_dirty(handle_t *handle, struct ocfs2_xa_loc *loc)\n{\n\tloc->xl_ops->xlo_journal_dirty(handle, loc);\n}"
  },
  {
    "function_name": "ocfs2_xa_journal_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1427-1431",
    "snippet": "static int ocfs2_xa_journal_access(handle_t *handle, struct ocfs2_xa_loc *loc,\n\t\t\t\t   int type)\n{\n\treturn loc->xl_ops->xlo_journal_access(handle, loc, type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loc->xl_ops->xlo_journal_access",
          "args": [
            "handle",
            "loc",
            "type"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xa_journal_access(handle_t *handle, struct ocfs2_xa_loc *loc,\n\t\t\t\t   int type)\n{\n\treturn loc->xl_ops->xlo_journal_access(handle, loc, type);\n}"
  },
  {
    "function_name": "ocfs2_xa_check_space_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1407-1425",
    "snippet": "static int ocfs2_xa_check_space_helper(int needed_space, int free_start,\n\t\t\t\t       int num_entries)\n{\n\tint free_space;\n\n\tif (!needed_space)\n\t\treturn 0;\n\n\tfree_space = free_start -\n\t\tsizeof(struct ocfs2_xattr_header) -\n\t\t(num_entries * sizeof(struct ocfs2_xattr_entry)) -\n\t\tOCFS2_XATTR_HEADER_GAP;\n\tif (free_space < 0)\n\t\treturn -EIO;\n\tif (free_space < needed_space)\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_HEADER_GAP\t4"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_HEADER_GAP\t4\n\nstatic int ocfs2_xa_check_space_helper(int needed_space, int free_start,\n\t\t\t\t       int num_entries)\n{\n\tint free_space;\n\n\tif (!needed_space)\n\t\treturn 0;\n\n\tfree_space = free_start -\n\t\tsizeof(struct ocfs2_xattr_header) -\n\t\t(num_entries * sizeof(struct ocfs2_xattr_entry)) -\n\t\tOCFS2_XATTR_HEADER_GAP;\n\tif (free_space < 0)\n\t\treturn -EIO;\n\tif (free_space < needed_space)\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ocfs2_xattr_set_value_outside",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1332-1405",
    "snippet": "static int __ocfs2_xattr_set_value_outside(struct inode *inode,\n\t\t\t\t\t   handle_t *handle,\n\t\t\t\t\t   struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t\t   const void *value,\n\t\t\t\t\t   int value_len)\n{\n\tint ret = 0, i, cp_len;\n\tu16 blocksize = inode->i_sb->s_blocksize;\n\tu32 p_cluster, num_clusters;\n\tu32 cpos = 0, bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 clusters = ocfs2_clusters_for_bytes(inode->i_sb, value_len);\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tunsigned int ext_flags;\n\tstruct ocfs2_xattr_value_root *xv = vb->vb_xv;\n\n\tBUG_ON(clusters > le32_to_cpu(xv->xr_clusters));\n\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, &xv->xr_list,\n\t\t\t\t\t       &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(ext_flags & OCFS2_EXT_REFCOUNTED);\n\n\t\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\n\t\tfor (i = 0; i < num_clusters * bpc; i++, blkno++) {\n\t\t\tret = ocfs2_read_block(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       &bh, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_journal_access(handle,\n\t\t\t\t\t\t   INODE_CACHE(inode),\n\t\t\t\t\t\t   bh,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcp_len = value_len > blocksize ? blocksize : value_len;\n\t\t\tmemcpy(bh->b_data, value, cp_len);\n\t\t\tvalue_len -= cp_len;\n\t\t\tvalue += cp_len;\n\t\t\tif (cp_len < blocksize)\n\t\t\t\tmemset(bh->b_data + cp_len, 0,\n\t\t\t\t       blocksize - cp_len);\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\n\t\t\t/*\n\t\t\t * XXX: do we need to empty all the following\n\t\t\t * blocks in this cluster?\n\t\t\t */\n\t\t\tif (!value_len)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\nout:\n\tbrelse(bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data + cp_len",
            "0",
            "blocksize - cp_len"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data",
            "value",
            "cp_len"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "765-769",
          "snippet": "int ocfs2_journal_access(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, NULL, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, NULL, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_block",
          "args": [
            "INODE_CACHE(inode)",
            "blkno",
            "&bh",
            "NULL"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "p_cluster"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ext_flags & OCFS2_EXT_REFCOUNTED"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&p_cluster",
            "&num_clusters",
            "&xv->xr_list",
            "&ext_flags"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "543-606",
          "snippet": "int ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "clusters > le32_to_cpu(xv->xr_clusters)"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "xv->xr_clusters"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "inode->i_sb",
            "value_len"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int __ocfs2_xattr_set_value_outside(struct inode *inode,\n\t\t\t\t\t   handle_t *handle,\n\t\t\t\t\t   struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t\t   const void *value,\n\t\t\t\t\t   int value_len)\n{\n\tint ret = 0, i, cp_len;\n\tu16 blocksize = inode->i_sb->s_blocksize;\n\tu32 p_cluster, num_clusters;\n\tu32 cpos = 0, bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 clusters = ocfs2_clusters_for_bytes(inode->i_sb, value_len);\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tunsigned int ext_flags;\n\tstruct ocfs2_xattr_value_root *xv = vb->vb_xv;\n\n\tBUG_ON(clusters > le32_to_cpu(xv->xr_clusters));\n\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, &xv->xr_list,\n\t\t\t\t\t       &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUG_ON(ext_flags & OCFS2_EXT_REFCOUNTED);\n\n\t\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\n\t\tfor (i = 0; i < num_clusters * bpc; i++, blkno++) {\n\t\t\tret = ocfs2_read_block(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       &bh, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_journal_access(handle,\n\t\t\t\t\t\t   INODE_CACHE(inode),\n\t\t\t\t\t\t   bh,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcp_len = value_len > blocksize ? blocksize : value_len;\n\t\t\tmemcpy(bh->b_data, value, cp_len);\n\t\t\tvalue_len -= cp_len;\n\t\t\tvalue += cp_len;\n\t\t\tif (cp_len < blocksize)\n\t\t\t\tmemset(bh->b_data + cp_len, 0,\n\t\t\t\t       blocksize - cp_len);\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\n\t\t\t/*\n\t\t\t * XXX: do we need to empty all the following\n\t\t\t * blocks in this cluster?\n\t\t\t */\n\t\t\tif (!value_len)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\nout:\n\tbrelse(bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1306-1330",
    "snippet": "static int ocfs2_xattr_get(struct inode *inode,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\tdown_read(&OCFS2_I(inode)->ip_xattr_sem);\n\tret = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t     name, buffer, buffer_size);\n\tup_read(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock(inode, 0);\n\n\tbrelse(di_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "0"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&OCFS2_I(inode)->ip_xattr_sem"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_nolock",
          "args": [
            "inode",
            "di_bh",
            "name_index",
            "name",
            "buffer",
            "buffer_size"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1266-1299",
          "snippet": "int ocfs2_xattr_get_nolock(struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t    buffer_size, &xis);\n\tif (ret == -ENODATA && di->i_xattr_loc)\n\t\tret = ocfs2_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t    buffer_size, &xbs);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nint ocfs2_xattr_get_nolock(struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t    buffer_size, &xis);\n\tif (ret == -ENODATA && di->i_xattr_loc)\n\t\tret = ocfs2_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t    buffer_size, &xbs);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&OCFS2_I(inode)->ip_xattr_sem"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "0"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_get(struct inode *inode,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\tdown_read(&OCFS2_I(inode)->ip_xattr_sem);\n\tret = ocfs2_xattr_get_nolock(inode, di_bh, name_index,\n\t\t\t\t     name, buffer, buffer_size);\n\tup_read(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock(inode, 0);\n\n\tbrelse(di_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_get_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1266-1299",
    "snippet": "int ocfs2_xattr_get_nolock(struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t    buffer_size, &xis);\n\tif (ret == -ENODATA && di->i_xattr_loc)\n\t\tret = ocfs2_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t    buffer_size, &xbs);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_block_get",
          "args": [
            "inode",
            "name_index",
            "name",
            "buffer",
            "buffer_size",
            "&xbs"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_block_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1193-1264",
          "snippet": "static int ocfs2_xattr_block_get(struct inode *inode,\n\t\t\t\t int name_index,\n\t\t\t\t const char *name,\n\t\t\t\t void *buffer,\n\t\t\t\t size_t buffer_size,\n\t\t\t\t struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_xattr_value_root *xv;\n\tsize_t size;\n\tint ret = -ENODATA, name_offset, name_len, i;\n\tint uninitialized_var(block_off);\n\n\txs->bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xs->bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\tret = ocfs2_xattr_block_find(inode, name_index, name, xs);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\tif (xs->not_found) {\n\t\tret = -ENODATA;\n\t\tgoto cleanup;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\tsize = le64_to_cpu(xs->here->xe_value_size);\n\tif (buffer) {\n\t\tret = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\n\t\tname_offset = le16_to_cpu(xs->here->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xs->here->xe_name_len);\n\t\ti = xs->here - xs->header->xh_entries;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\t\tbucket_xh(xs->bucket),\n\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t\t&name_offset);\n\t\t\txs->base = bucket_block(xs->bucket, block_off);\n\t\t}\n\t\tif (ocfs2_xattr_is_local(xs->here)) {\n\t\t\tmemcpy(buffer, (void *)xs->base +\n\t\t\t       name_offset + name_len, size);\n\t\t} else {\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(xs->base + name_offset + name_len);\n\t\t\tret = ocfs2_xattr_get_value_outside(inode, xv,\n\t\t\t\t\t\t\t    buffer, size);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\tret = size;\ncleanup:\n\tocfs2_xattr_bucket_free(xs->bucket);\n\n\tbrelse(xs->xattr_bh);\n\txs->xattr_bh = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_block_get(struct inode *inode,\n\t\t\t\t int name_index,\n\t\t\t\t const char *name,\n\t\t\t\t void *buffer,\n\t\t\t\t size_t buffer_size,\n\t\t\t\t struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_xattr_value_root *xv;\n\tsize_t size;\n\tint ret = -ENODATA, name_offset, name_len, i;\n\tint uninitialized_var(block_off);\n\n\txs->bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xs->bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\tret = ocfs2_xattr_block_find(inode, name_index, name, xs);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\tif (xs->not_found) {\n\t\tret = -ENODATA;\n\t\tgoto cleanup;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\tsize = le64_to_cpu(xs->here->xe_value_size);\n\tif (buffer) {\n\t\tret = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\n\t\tname_offset = le16_to_cpu(xs->here->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xs->here->xe_name_len);\n\t\ti = xs->here - xs->header->xh_entries;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\t\tbucket_xh(xs->bucket),\n\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t\t&name_offset);\n\t\t\txs->base = bucket_block(xs->bucket, block_off);\n\t\t}\n\t\tif (ocfs2_xattr_is_local(xs->here)) {\n\t\t\tmemcpy(buffer, (void *)xs->base +\n\t\t\t       name_offset + name_len, size);\n\t\t} else {\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(xs->base + name_offset + name_len);\n\t\t\tret = ocfs2_xattr_get_value_outside(inode, xv,\n\t\t\t\t\t\t\t    buffer, size);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\tret = size;\ncleanup:\n\tocfs2_xattr_bucket_free(xs->bucket);\n\n\tbrelse(xs->xattr_bh);\n\txs->xattr_bh = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_ibody_get",
          "args": [
            "inode",
            "name_index",
            "name",
            "buffer",
            "buffer_size",
            "&xis"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_ibody_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1143-1191",
          "snippet": "static int ocfs2_xattr_ibody_get(struct inode *inode,\n\t\t\t\t int name_index,\n\t\t\t\t const char *name,\n\t\t\t\t void *buffer,\n\t\t\t\t size_t buffer_size,\n\t\t\t\t struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct ocfs2_xattr_value_root *xv;\n\tsize_t size;\n\tint ret = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txs->end = (void *)di + inode->i_sb->s_blocksize;\n\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - le16_to_cpu(di->i_xattr_inline_size));\n\txs->base = (void *)xs->header;\n\txs->here = xs->header->xh_entries;\n\n\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\tif (ret)\n\t\treturn ret;\n\tsize = le64_to_cpu(xs->here->xe_value_size);\n\tif (buffer) {\n\t\tif (size > buffer_size)\n\t\t\treturn -ERANGE;\n\t\tif (ocfs2_xattr_is_local(xs->here)) {\n\t\t\tmemcpy(buffer, (void *)xs->base +\n\t\t\t       le16_to_cpu(xs->here->xe_name_offset) +\n\t\t\t       OCFS2_XATTR_SIZE(xs->here->xe_name_len), size);\n\t\t} else {\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(xs->base + le16_to_cpu(\n\t\t\t\t xs->here->xe_name_offset) +\n\t\t\t\tOCFS2_XATTR_SIZE(xs->here->xe_name_len));\n\t\t\tret = ocfs2_xattr_get_value_outside(inode, xv,\n\t\t\t\t\t\t\t    buffer, size);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_ibody_get(struct inode *inode,\n\t\t\t\t int name_index,\n\t\t\t\t const char *name,\n\t\t\t\t void *buffer,\n\t\t\t\t size_t buffer_size,\n\t\t\t\t struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct ocfs2_xattr_value_root *xv;\n\tsize_t size;\n\tint ret = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txs->end = (void *)di + inode->i_sb->s_blocksize;\n\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - le16_to_cpu(di->i_xattr_inline_size));\n\txs->base = (void *)xs->header;\n\txs->here = xs->header->xh_entries;\n\n\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\tif (ret)\n\t\treturn ret;\n\tsize = le64_to_cpu(xs->here->xe_value_size);\n\tif (buffer) {\n\t\tif (size > buffer_size)\n\t\t\treturn -ERANGE;\n\t\tif (ocfs2_xattr_is_local(xs->here)) {\n\t\t\tmemcpy(buffer, (void *)xs->base +\n\t\t\t       le16_to_cpu(xs->here->xe_name_offset) +\n\t\t\t       OCFS2_XATTR_SIZE(xs->here->xe_name_len), size);\n\t\t} else {\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(xs->base + le16_to_cpu(\n\t\t\t\t xs->here->xe_name_offset) +\n\t\t\t\tOCFS2_XATTR_SIZE(xs->here->xe_name_len));\n\t\t\tret = ocfs2_xattr_get_value_outside(inode, xv,\n\t\t\t\t\t\t\t    buffer, size);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_xattr",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "518-523",
          "snippet": "static inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nint ocfs2_xattr_get_nolock(struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t    buffer_size, &xis);\n\tif (ret == -ENODATA && di->i_xattr_loc)\n\t\tret = ocfs2_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t    buffer_size, &xbs);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_block_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1193-1264",
    "snippet": "static int ocfs2_xattr_block_get(struct inode *inode,\n\t\t\t\t int name_index,\n\t\t\t\t const char *name,\n\t\t\t\t void *buffer,\n\t\t\t\t size_t buffer_size,\n\t\t\t\t struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_xattr_value_root *xv;\n\tsize_t size;\n\tint ret = -ENODATA, name_offset, name_len, i;\n\tint uninitialized_var(block_off);\n\n\txs->bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xs->bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\tret = ocfs2_xattr_block_find(inode, name_index, name, xs);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\tif (xs->not_found) {\n\t\tret = -ENODATA;\n\t\tgoto cleanup;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\tsize = le64_to_cpu(xs->here->xe_value_size);\n\tif (buffer) {\n\t\tret = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\n\t\tname_offset = le16_to_cpu(xs->here->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xs->here->xe_name_len);\n\t\ti = xs->here - xs->header->xh_entries;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\t\tbucket_xh(xs->bucket),\n\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t\t&name_offset);\n\t\t\txs->base = bucket_block(xs->bucket, block_off);\n\t\t}\n\t\tif (ocfs2_xattr_is_local(xs->here)) {\n\t\t\tmemcpy(buffer, (void *)xs->base +\n\t\t\t       name_offset + name_len, size);\n\t\t} else {\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(xs->base + name_offset + name_len);\n\t\t\tret = ocfs2_xattr_get_value_outside(inode, xv,\n\t\t\t\t\t\t\t    buffer, size);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\tret = size;\ncleanup:\n\tocfs2_xattr_bucket_free(xs->bucket);\n\n\tbrelse(xs->xattr_bh);\n\txs->xattr_bh = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "xs->xattr_bh"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_free",
          "args": [
            "xs->bucket"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "356-363",
          "snippet": "static void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_value_outside",
          "args": [
            "inode",
            "xv",
            "buffer",
            "size"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_value_outside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1091-1141",
          "snippet": "static int ocfs2_xattr_get_value_outside(struct inode *inode,\n\t\t\t\t\t struct ocfs2_xattr_value_root *xv,\n\t\t\t\t\t void *buffer,\n\t\t\t\t\t size_t len)\n{\n\tu32 cpos, p_cluster, num_clusters, bpc, clusters;\n\tu64 blkno;\n\tint i, ret = 0;\n\tsize_t cplen, blocksize;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = &xv->xr_list;\n\tclusters = le32_to_cpu(xv->xr_clusters);\n\tbpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\t/* Copy ocfs2_xattr_value */\n\t\tfor (i = 0; i < num_clusters * bpc; i++, blkno++) {\n\t\t\tret = ocfs2_read_block(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       &bh, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcplen = len >= blocksize ? blocksize : len;\n\t\t\tmemcpy(buffer, bh->b_data, cplen);\n\t\t\tlen -= cplen;\n\t\t\tbuffer += cplen;\n\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_xattr_get_value_outside(struct inode *inode,\n\t\t\t\t\t struct ocfs2_xattr_value_root *xv,\n\t\t\t\t\t void *buffer,\n\t\t\t\t\t size_t len)\n{\n\tu32 cpos, p_cluster, num_clusters, bpc, clusters;\n\tu64 blkno;\n\tint i, ret = 0;\n\tsize_t cplen, blocksize;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = &xv->xr_list;\n\tclusters = le32_to_cpu(xv->xr_clusters);\n\tbpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\t/* Copy ocfs2_xattr_value */\n\t\tfor (i = 0; i < num_clusters * bpc; i++, blkno++) {\n\t\t\tret = ocfs2_read_block(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       &bh, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcplen = len >= blocksize ? blocksize : len;\n\t\t\tmemcpy(buffer, bh->b_data, cplen);\n\t\t\tlen -= cplen;\n\t\t\tbuffer += cplen;\n\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "(void *)xs->base +\n\t\t\t       name_offset + name_len",
            "size"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "xs->here"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "xs->bucket",
            "block_off"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_get_name_value",
          "args": [
            "inode->i_sb",
            "bucket_xh(xs->bucket)",
            "i",
            "&block_off",
            "&name_offset"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_get_name_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4014-4031",
          "snippet": "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset);\n\nstatic int ocfs2_xattr_bucket_get_name_value(struct super_block *sb,\n\t\t\t\t\t     struct ocfs2_xattr_header *xh,\n\t\t\t\t\t     int index,\n\t\t\t\t\t     int *block_off,\n\t\t\t\t\t     int *new_offset)\n{\n\tu16 name_offset;\n\n\tif (index < 0 || index >= le16_to_cpu(xh->xh_count))\n\t\treturn -EINVAL;\n\n\tname_offset = le16_to_cpu(xh->xh_entries[index].xe_name_offset);\n\n\t*block_off = name_offset >> sb->s_blocksize_bits;\n\t*new_offset = name_offset % sb->s_blocksize;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "xs->bucket"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xb->xb_flags"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xs->here->xe_name_len"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "xs->here->xe_value_size"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_block_find",
          "args": [
            "inode",
            "name_index",
            "name",
            "xs"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_block_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "2798-2843",
          "snippet": "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txs->xattr_bh = blk_bh;\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\txs->header = &xb->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)(blk_bh->b_data) + blk_bh->b_size;\n\t\txs->here = xs->header->xh_entries;\n\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t} else\n\t\tret = ocfs2_xattr_index_block_find(inode, blk_bh,\n\t\t\t\t\t\t   name_index,\n\t\t\t\t\t\t   name, xs);\n\n\tif (ret && ret != -ENODATA) {\n\t\txs->xattr_bh = NULL;\n\t\tgoto cleanup;\n\t}\n\txs->not_found = ret;\n\treturn 0;\ncleanup:\n\tbrelse(blk_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txs->xattr_bh = blk_bh;\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\txs->header = &xb->xb_attrs.xb_header;\n\t\txs->base = (void *)xs->header;\n\t\txs->end = (void *)(blk_bh->b_data) + blk_bh->b_size;\n\t\txs->here = xs->header->xh_entries;\n\n\t\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\t} else\n\t\tret = ocfs2_xattr_index_block_find(inode, blk_bh,\n\t\t\t\t\t\t   name_index,\n\t\t\t\t\t\t   name, xs);\n\n\tif (ret && ret != -ENODATA) {\n\t\txs->xattr_bh = NULL;\n\t\tgoto cleanup;\n\t}\n\txs->not_found = ret;\n\treturn 0;\ncleanup:\n\tbrelse(blk_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_new",
          "args": [
            "inode"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "330-344",
          "snippet": "static struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_block_get(struct inode *inode,\n\t\t\t\t int name_index,\n\t\t\t\t const char *name,\n\t\t\t\t void *buffer,\n\t\t\t\t size_t buffer_size,\n\t\t\t\t struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_block *xb;\n\tstruct ocfs2_xattr_value_root *xv;\n\tsize_t size;\n\tint ret = -ENODATA, name_offset, name_len, i;\n\tint uninitialized_var(block_off);\n\n\txs->bucket = ocfs2_xattr_bucket_new(inode);\n\tif (!xs->bucket) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\tret = ocfs2_xattr_block_find(inode, name_index, name, xs);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto cleanup;\n\t}\n\n\tif (xs->not_found) {\n\t\tret = -ENODATA;\n\t\tgoto cleanup;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)xs->xattr_bh->b_data;\n\tsize = le64_to_cpu(xs->here->xe_value_size);\n\tif (buffer) {\n\t\tret = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\n\t\tname_offset = le16_to_cpu(xs->here->xe_name_offset);\n\t\tname_len = OCFS2_XATTR_SIZE(xs->here->xe_name_len);\n\t\ti = xs->here - xs->header->xh_entries;\n\n\t\tif (le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED) {\n\t\t\tret = ocfs2_xattr_bucket_get_name_value(inode->i_sb,\n\t\t\t\t\t\t\t\tbucket_xh(xs->bucket),\n\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\t&block_off,\n\t\t\t\t\t\t\t\t&name_offset);\n\t\t\txs->base = bucket_block(xs->bucket, block_off);\n\t\t}\n\t\tif (ocfs2_xattr_is_local(xs->here)) {\n\t\t\tmemcpy(buffer, (void *)xs->base +\n\t\t\t       name_offset + name_len, size);\n\t\t} else {\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(xs->base + name_offset + name_len);\n\t\t\tret = ocfs2_xattr_get_value_outside(inode, xv,\n\t\t\t\t\t\t\t    buffer, size);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\tret = size;\ncleanup:\n\tocfs2_xattr_bucket_free(xs->bucket);\n\n\tbrelse(xs->xattr_bh);\n\txs->xattr_bh = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_ibody_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1143-1191",
    "snippet": "static int ocfs2_xattr_ibody_get(struct inode *inode,\n\t\t\t\t int name_index,\n\t\t\t\t const char *name,\n\t\t\t\t void *buffer,\n\t\t\t\t size_t buffer_size,\n\t\t\t\t struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct ocfs2_xattr_value_root *xv;\n\tsize_t size;\n\tint ret = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txs->end = (void *)di + inode->i_sb->s_blocksize;\n\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - le16_to_cpu(di->i_xattr_inline_size));\n\txs->base = (void *)xs->header;\n\txs->here = xs->header->xh_entries;\n\n\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\tif (ret)\n\t\treturn ret;\n\tsize = le64_to_cpu(xs->here->xe_value_size);\n\tif (buffer) {\n\t\tif (size > buffer_size)\n\t\t\treturn -ERANGE;\n\t\tif (ocfs2_xattr_is_local(xs->here)) {\n\t\t\tmemcpy(buffer, (void *)xs->base +\n\t\t\t       le16_to_cpu(xs->here->xe_name_offset) +\n\t\t\t       OCFS2_XATTR_SIZE(xs->here->xe_name_len), size);\n\t\t} else {\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(xs->base + le16_to_cpu(\n\t\t\t\t xs->here->xe_name_offset) +\n\t\t\t\tOCFS2_XATTR_SIZE(xs->here->xe_name_len));\n\t\t\tret = ocfs2_xattr_get_value_outside(inode, xv,\n\t\t\t\t\t\t\t    buffer, size);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn size;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_value_outside",
          "args": [
            "inode",
            "xv",
            "buffer",
            "size"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_value_outside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1091-1141",
          "snippet": "static int ocfs2_xattr_get_value_outside(struct inode *inode,\n\t\t\t\t\t struct ocfs2_xattr_value_root *xv,\n\t\t\t\t\t void *buffer,\n\t\t\t\t\t size_t len)\n{\n\tu32 cpos, p_cluster, num_clusters, bpc, clusters;\n\tu64 blkno;\n\tint i, ret = 0;\n\tsize_t cplen, blocksize;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = &xv->xr_list;\n\tclusters = le32_to_cpu(xv->xr_clusters);\n\tbpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\t/* Copy ocfs2_xattr_value */\n\t\tfor (i = 0; i < num_clusters * bpc; i++, blkno++) {\n\t\t\tret = ocfs2_read_block(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       &bh, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcplen = len >= blocksize ? blocksize : len;\n\t\t\tmemcpy(buffer, bh->b_data, cplen);\n\t\t\tlen -= cplen;\n\t\t\tbuffer += cplen;\n\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_xattr_get_value_outside(struct inode *inode,\n\t\t\t\t\t struct ocfs2_xattr_value_root *xv,\n\t\t\t\t\t void *buffer,\n\t\t\t\t\t size_t len)\n{\n\tu32 cpos, p_cluster, num_clusters, bpc, clusters;\n\tu64 blkno;\n\tint i, ret = 0;\n\tsize_t cplen, blocksize;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = &xv->xr_list;\n\tclusters = le32_to_cpu(xv->xr_clusters);\n\tbpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\t/* Copy ocfs2_xattr_value */\n\t\tfor (i = 0; i < num_clusters * bpc; i++, blkno++) {\n\t\t\tret = ocfs2_read_block(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       &bh, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcplen = len >= blocksize ? blocksize : len;\n\t\t\tmemcpy(buffer, bh->b_data, cplen);\n\t\t\tlen -= cplen;\n\t\t\tbuffer += cplen;\n\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xs->here->xe_name_len"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xs->here->xe_name_offset"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "(void *)xs->base +\n\t\t\t       le16_to_cpu(xs->here->xe_name_offset) +\n\t\t\t       OCFS2_XATTR_SIZE(xs->here->xe_name_len)",
            "size"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "xs->here->xe_name_len"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "xs->here"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "xs->here->xe_value_size"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_find_entry",
          "args": [
            "name_index",
            "name",
            "xs"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1061-1089",
          "snippet": "static int ocfs2_xattr_find_entry(int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *entry;\n\tsize_t name_len;\n\tint i, cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(name);\n\tentry = xs->here;\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tcmp = name_index - ocfs2_xattr_get_type(entry);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->xe_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, (xs->base +\n\t\t\t\t     le16_to_cpu(entry->xe_name_offset)),\n\t\t\t\t     name_len);\n\t\tif (cmp == 0)\n\t\t\tbreak;\n\t\tentry += 1;\n\t}\n\txs->here = entry;\n\n\treturn cmp ? -ENODATA : 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
            "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_find_entry(int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *entry;\n\tsize_t name_len;\n\tint i, cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(name);\n\tentry = xs->here;\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tcmp = name_index - ocfs2_xattr_get_type(entry);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->xe_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, (xs->base +\n\t\t\t\t     le16_to_cpu(entry->xe_name_offset)),\n\t\t\t\t     name_len);\n\t\tif (cmp == 0)\n\t\t\tbreak;\n\t\tentry += 1;\n\t}\n\txs->here = entry;\n\n\treturn cmp ? -ENODATA : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_ibody_get(struct inode *inode,\n\t\t\t\t int name_index,\n\t\t\t\t const char *name,\n\t\t\t\t void *buffer,\n\t\t\t\t size_t buffer_size,\n\t\t\t\t struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)xs->inode_bh->b_data;\n\tstruct ocfs2_xattr_value_root *xv;\n\tsize_t size;\n\tint ret = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txs->end = (void *)di + inode->i_sb->s_blocksize;\n\txs->header = (struct ocfs2_xattr_header *)\n\t\t\t(xs->end - le16_to_cpu(di->i_xattr_inline_size));\n\txs->base = (void *)xs->header;\n\txs->here = xs->header->xh_entries;\n\n\tret = ocfs2_xattr_find_entry(name_index, name, xs);\n\tif (ret)\n\t\treturn ret;\n\tsize = le64_to_cpu(xs->here->xe_value_size);\n\tif (buffer) {\n\t\tif (size > buffer_size)\n\t\t\treturn -ERANGE;\n\t\tif (ocfs2_xattr_is_local(xs->here)) {\n\t\t\tmemcpy(buffer, (void *)xs->base +\n\t\t\t       le16_to_cpu(xs->here->xe_name_offset) +\n\t\t\t       OCFS2_XATTR_SIZE(xs->here->xe_name_len), size);\n\t\t} else {\n\t\t\txv = (struct ocfs2_xattr_value_root *)\n\t\t\t\t(xs->base + le16_to_cpu(\n\t\t\t\t xs->here->xe_name_offset) +\n\t\t\t\tOCFS2_XATTR_SIZE(xs->here->xe_name_len));\n\t\t\tret = ocfs2_xattr_get_value_outside(inode, xv,\n\t\t\t\t\t\t\t    buffer, size);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn size;\n}"
  },
  {
    "function_name": "ocfs2_xattr_get_value_outside",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1091-1141",
    "snippet": "static int ocfs2_xattr_get_value_outside(struct inode *inode,\n\t\t\t\t\t struct ocfs2_xattr_value_root *xv,\n\t\t\t\t\t void *buffer,\n\t\t\t\t\t size_t len)\n{\n\tu32 cpos, p_cluster, num_clusters, bpc, clusters;\n\tu64 blkno;\n\tint i, ret = 0;\n\tsize_t cplen, blocksize;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = &xv->xr_list;\n\tclusters = le32_to_cpu(xv->xr_clusters);\n\tbpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\t/* Copy ocfs2_xattr_value */\n\t\tfor (i = 0; i < num_clusters * bpc; i++, blkno++) {\n\t\t\tret = ocfs2_read_block(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       &bh, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcplen = len >= blocksize ? blocksize : len;\n\t\t\tmemcpy(buffer, bh->b_data, cplen);\n\t\t\tlen -= cplen;\n\t\t\tbuffer += cplen;\n\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "bh->b_data",
            "cplen"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_block",
          "args": [
            "INODE_CACHE(inode)",
            "blkno",
            "&bh",
            "NULL"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "p_cluster"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&p_cluster",
            "&num_clusters",
            "el",
            "NULL"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "543-606",
          "snippet": "int ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "xv->xr_clusters"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_xattr_get_value_outside(struct inode *inode,\n\t\t\t\t\t struct ocfs2_xattr_value_root *xv,\n\t\t\t\t\t void *buffer,\n\t\t\t\t\t size_t len)\n{\n\tu32 cpos, p_cluster, num_clusters, bpc, clusters;\n\tu64 blkno;\n\tint i, ret = 0;\n\tsize_t cplen, blocksize;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = &xv->xr_list;\n\tclusters = le32_to_cpu(xv->xr_clusters);\n\tbpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, el, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tblkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\t/* Copy ocfs2_xattr_value */\n\t\tfor (i = 0; i < num_clusters * bpc; i++, blkno++) {\n\t\t\tret = ocfs2_read_block(INODE_CACHE(inode), blkno,\n\t\t\t\t\t       &bh, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcplen = len >= blocksize ? blocksize : len;\n\t\t\tmemcpy(buffer, bh->b_data, cplen);\n\t\t\tlen -= cplen;\n\t\t\tbuffer += cplen;\n\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1061-1089",
    "snippet": "static int ocfs2_xattr_find_entry(int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *entry;\n\tsize_t name_len;\n\tint i, cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(name);\n\tentry = xs->here;\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tcmp = name_index - ocfs2_xattr_get_type(entry);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->xe_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, (xs->base +\n\t\t\t\t     le16_to_cpu(entry->xe_name_offset)),\n\t\t\t\t     name_len);\n\t\tif (cmp == 0)\n\t\t\tbreak;\n\t\tentry += 1;\n\t}\n\txs->here = entry;\n\n\treturn cmp ? -ENODATA : 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);",
      "static int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "(xs->base +\n\t\t\t\t     le16_to_cpu(entry->xe_name_offset))",
            "name_len"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->xe_name_offset"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_type",
          "args": [
            "entry"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1153-1156",
          "snippet": "static inline int ocfs2_xattr_get_type(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_TYPE_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_TYPE_MASK\t\t0x7F"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_TYPE_MASK\t\t0x7F\n\nstatic inline int ocfs2_xattr_get_type(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_TYPE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_block_find(struct inode *inode,\n\t\t\t\t  int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs);\nstatic int ocfs2_xattr_index_block_find(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *root_bh,\n\t\t\t\t\tint name_index,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tstruct ocfs2_xattr_search *xs);\n\nstatic int ocfs2_xattr_find_entry(int name_index,\n\t\t\t\t  const char *name,\n\t\t\t\t  struct ocfs2_xattr_search *xs)\n{\n\tstruct ocfs2_xattr_entry *entry;\n\tsize_t name_len;\n\tint i, cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(name);\n\tentry = xs->here;\n\tfor (i = 0; i < le16_to_cpu(xs->header->xh_count); i++) {\n\t\tcmp = name_index - ocfs2_xattr_get_type(entry);\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->xe_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, (xs->base +\n\t\t\t\t     le16_to_cpu(entry->xe_name_offset)),\n\t\t\t\t     name_len);\n\t\tif (cmp == 0)\n\t\t\tbreak;\n\t\tentry += 1;\n\t}\n\txs->here = entry;\n\n\treturn cmp ? -ENODATA : 0;\n}"
  },
  {
    "function_name": "ocfs2_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "1016-1059",
    "snippet": "ssize_t ocfs2_listxattr(struct dentry *dentry,\n\t\t\tchar *buffer,\n\t\t\tsize_t size)\n{\n\tint ret = 0, i_ret = 0, b_ret = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(dentry->d_inode);\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(dentry->d_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn ret;\n\n\tret = ocfs2_inode_lock(dentry->d_inode, &di_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_read(&oi->ip_xattr_sem);\n\ti_ret = ocfs2_xattr_ibody_list(dentry->d_inode, di, buffer, size);\n\tif (i_ret < 0)\n\t\tb_ret = 0;\n\telse {\n\t\tif (buffer) {\n\t\t\tbuffer += i_ret;\n\t\t\tsize -= i_ret;\n\t\t}\n\t\tb_ret = ocfs2_xattr_block_list(dentry->d_inode, di,\n\t\t\t\t\t       buffer, size);\n\t\tif (b_ret < 0)\n\t\t\ti_ret = 0;\n\t}\n\tup_read(&oi->ip_xattr_sem);\n\tocfs2_inode_unlock(dentry->d_inode, 0);\n\n\tbrelse(di_bh);\n\n\treturn i_ret + b_ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "dentry->d_inode",
            "0"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&oi->ip_xattr_sem"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_block_list",
          "args": [
            "dentry->d_inode",
            "di",
            "buffer",
            "size"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_block_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "983-1014",
          "snippet": "static int ocfs2_xattr_block_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di,\n\t\t\t\t  char *buffer,\n\t\t\t\t  size_t buffer_size)\n{\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &xb->xb_attrs.xb_header;\n\t\tret = ocfs2_xattr_list_entries(inode, header,\n\t\t\t\t\t       buffer, buffer_size);\n\t} else\n\t\tret = ocfs2_xattr_tree_list_index_block(inode, blk_bh,\n\t\t\t\t\t\t   buffer, buffer_size);\n\n\tbrelse(blk_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_block_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di,\n\t\t\t\t  char *buffer,\n\t\t\t\t  size_t buffer_size)\n{\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &xb->xb_attrs.xb_header;\n\t\tret = ocfs2_xattr_list_entries(inode, header,\n\t\t\t\t\t       buffer, buffer_size);\n\t} else\n\t\tret = ocfs2_xattr_tree_list_index_block(inode, blk_bh,\n\t\t\t\t\t\t   buffer, buffer_size);\n\n\tbrelse(blk_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_ibody_list",
          "args": [
            "dentry->d_inode",
            "di",
            "buffer",
            "size"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_ibody_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "962-981",
          "snippet": "static int ocfs2_xattr_ibody_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di,\n\t\t\t\t  char *buffer,\n\t\t\t\t  size_t buffer_size)\n{\n\tstruct ocfs2_xattr_header *header = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tint ret = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn ret;\n\n\theader = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tret = ocfs2_xattr_list_entries(inode, header, buffer, buffer_size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_ibody_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di,\n\t\t\t\t  char *buffer,\n\t\t\t\t  size_t buffer_size)\n{\n\tstruct ocfs2_xattr_header *header = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tint ret = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn ret;\n\n\theader = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tret = ocfs2_xattr_list_entries(inode, header, buffer, buffer_size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&oi->ip_xattr_sem"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "dentry->d_inode",
            "&di_bh",
            "0"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_xattr",
          "args": [
            "OCFS2_SB(dentry->d_sb)"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "518-523",
          "snippet": "static inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_xattr(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nssize_t ocfs2_listxattr(struct dentry *dentry,\n\t\t\tchar *buffer,\n\t\t\tsize_t size)\n{\n\tint ret = 0, i_ret = 0, b_ret = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(dentry->d_inode);\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(dentry->d_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn ret;\n\n\tret = ocfs2_inode_lock(dentry->d_inode, &di_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_read(&oi->ip_xattr_sem);\n\ti_ret = ocfs2_xattr_ibody_list(dentry->d_inode, di, buffer, size);\n\tif (i_ret < 0)\n\t\tb_ret = 0;\n\telse {\n\t\tif (buffer) {\n\t\t\tbuffer += i_ret;\n\t\t\tsize -= i_ret;\n\t\t}\n\t\tb_ret = ocfs2_xattr_block_list(dentry->d_inode, di,\n\t\t\t\t\t       buffer, size);\n\t\tif (b_ret < 0)\n\t\t\ti_ret = 0;\n\t}\n\tup_read(&oi->ip_xattr_sem);\n\tocfs2_inode_unlock(dentry->d_inode, 0);\n\n\tbrelse(di_bh);\n\n\treturn i_ret + b_ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_block_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "983-1014",
    "snippet": "static int ocfs2_xattr_block_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di,\n\t\t\t\t  char *buffer,\n\t\t\t\t  size_t buffer_size)\n{\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &xb->xb_attrs.xb_header;\n\t\tret = ocfs2_xattr_list_entries(inode, header,\n\t\t\t\t\t       buffer, buffer_size);\n\t} else\n\t\tret = ocfs2_xattr_tree_list_index_block(inode, blk_bh,\n\t\t\t\t\t\t   buffer, buffer_size);\n\n\tbrelse(blk_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "blk_bh"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_tree_list_index_block",
          "args": [
            "inode",
            "blk_bh",
            "buffer",
            "buffer_size"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_tree_list_index_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "4120-4142",
          "snippet": "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\t     struct buffer_head *blk_bh,\n\t\t\t\t\t     char *buffer,\n\t\t\t\t\t     size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_xattr_tree_list xl = {\n\t\t.buffer = buffer,\n\t\t.buffer_size = buffer_size,\n\t\t.result = 0,\n\t};\n\n\tret = ocfs2_iterate_xattr_index_block(inode, blk_bh,\n\t\t\t\t\t      ocfs2_list_xattr_tree_rec, &xl);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = xl.result;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\t     struct buffer_head *blk_bh,\n\t\t\t\t\t     char *buffer,\n\t\t\t\t\t     size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_xattr_tree_list xl = {\n\t\t.buffer = buffer,\n\t\t.buffer_size = buffer_size,\n\t\t.result = 0,\n\t};\n\n\tret = ocfs2_iterate_xattr_index_block(inode, blk_bh,\n\t\t\t\t\t      ocfs2_list_xattr_tree_rec, &xl);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = xl.result;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_list_entries",
          "args": [
            "inode",
            "header",
            "buffer",
            "buffer_size"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_list_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "917-943",
          "snippet": "static int ocfs2_xattr_list_entries(struct inode *inode,\n\t\t\t\t    struct ocfs2_xattr_header *header,\n\t\t\t\t    char *buffer, size_t buffer_size)\n{\n\tsize_t result = 0;\n\tint i, type, ret;\n\tconst char *prefix, *name;\n\n\tfor (i = 0 ; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\t\ttype = ocfs2_xattr_get_type(entry);\n\t\tprefix = ocfs2_xattr_prefix(type);\n\n\t\tif (prefix) {\n\t\t\tname = (const char *)header +\n\t\t\t\tle16_to_cpu(entry->xe_name_offset);\n\n\t\t\tret = ocfs2_xattr_list_entry(buffer, buffer_size,\n\t\t\t\t\t\t     &result, prefix, name,\n\t\t\t\t\t\t     entry->xe_name_len);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_list_entries(struct inode *inode,\n\t\t\t\t    struct ocfs2_xattr_header *header,\n\t\t\t\t    char *buffer, size_t buffer_size)\n{\n\tsize_t result = 0;\n\tint i, type, ret;\n\tconst char *prefix, *name;\n\n\tfor (i = 0 ; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\t\ttype = ocfs2_xattr_get_type(entry);\n\t\tprefix = ocfs2_xattr_prefix(type);\n\n\t\tif (prefix) {\n\t\t\tname = (const char *)header +\n\t\t\t\tle16_to_cpu(entry->xe_name_offset);\n\n\t\t\tret = ocfs2_xattr_list_entry(buffer, buffer_size,\n\t\t\t\t\t\t     &result, prefix, name,\n\t\t\t\t\t\t     entry->xe_name_len);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xb->xb_flags"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_xattr_block",
          "args": [
            "inode",
            "le64_to_cpu(di->i_xattr_loc)",
            "&blk_bh"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "531-545",
          "snippet": "static int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_xattr_loc"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_block_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di,\n\t\t\t\t  char *buffer,\n\t\t\t\t  size_t buffer_size)\n{\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_xattr_block *xb;\n\tint ret = 0;\n\n\tif (!di->i_xattr_loc)\n\t\treturn ret;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\txb = (struct ocfs2_xattr_block *)blk_bh->b_data;\n\tif (!(le16_to_cpu(xb->xb_flags) & OCFS2_XATTR_INDEXED)) {\n\t\tstruct ocfs2_xattr_header *header = &xb->xb_attrs.xb_header;\n\t\tret = ocfs2_xattr_list_entries(inode, header,\n\t\t\t\t\t       buffer, buffer_size);\n\t} else\n\t\tret = ocfs2_xattr_tree_list_index_block(inode, blk_bh,\n\t\t\t\t\t\t   buffer, buffer_size);\n\n\tbrelse(blk_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_ibody_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "962-981",
    "snippet": "static int ocfs2_xattr_ibody_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di,\n\t\t\t\t  char *buffer,\n\t\t\t\t  size_t buffer_size)\n{\n\tstruct ocfs2_xattr_header *header = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tint ret = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn ret;\n\n\theader = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tret = ocfs2_xattr_list_entries(inode, header, buffer, buffer_size);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_list_entries",
          "args": [
            "inode",
            "header",
            "buffer",
            "buffer_size"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_list_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "917-943",
          "snippet": "static int ocfs2_xattr_list_entries(struct inode *inode,\n\t\t\t\t    struct ocfs2_xattr_header *header,\n\t\t\t\t    char *buffer, size_t buffer_size)\n{\n\tsize_t result = 0;\n\tint i, type, ret;\n\tconst char *prefix, *name;\n\n\tfor (i = 0 ; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\t\ttype = ocfs2_xattr_get_type(entry);\n\t\tprefix = ocfs2_xattr_prefix(type);\n\n\t\tif (prefix) {\n\t\t\tname = (const char *)header +\n\t\t\t\tle16_to_cpu(entry->xe_name_offset);\n\n\t\t\tret = ocfs2_xattr_list_entry(buffer, buffer_size,\n\t\t\t\t\t\t     &result, prefix, name,\n\t\t\t\t\t\t     entry->xe_name_len);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_list_entries(struct inode *inode,\n\t\t\t\t    struct ocfs2_xattr_header *header,\n\t\t\t\t    char *buffer, size_t buffer_size)\n{\n\tsize_t result = 0;\n\tint i, type, ret;\n\tconst char *prefix, *name;\n\n\tfor (i = 0 ; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\t\ttype = ocfs2_xattr_get_type(entry);\n\t\tprefix = ocfs2_xattr_prefix(type);\n\n\t\tif (prefix) {\n\t\t\tname = (const char *)header +\n\t\t\t\tle16_to_cpu(entry->xe_name_offset);\n\n\t\t\tret = ocfs2_xattr_list_entry(buffer, buffer_size,\n\t\t\t\t\t\t     &result, prefix, name,\n\t\t\t\t\t\t     entry->xe_name_len);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_xattr_inline_size"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_ibody_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di,\n\t\t\t\t  char *buffer,\n\t\t\t\t  size_t buffer_size)\n{\n\tstruct ocfs2_xattr_header *header = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tint ret = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn ret;\n\n\theader = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tret = ocfs2_xattr_list_entries(inode, header, buffer, buffer_size);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_has_inline_xattr_value_outside",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "945-960",
    "snippet": "int ocfs2_has_inline_xattr_value_outside(struct inode *inode,\n\t\t\t\t\t struct ocfs2_dinode *di)\n{\n\tstruct ocfs2_xattr_header *xh;\n\tint i;\n\n\txh = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++)\n\t\tif (!ocfs2_xattr_is_local(&xh->xh_entries[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "&xh->xh_entries[i]"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "xh->xh_count"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_has_inline_xattr_value_outside(struct inode *inode,\n\t\t\t\t\t struct ocfs2_dinode *di)\n{\n\tstruct ocfs2_xattr_header *xh;\n\tint i;\n\n\txh = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++)\n\t\tif (!ocfs2_xattr_is_local(&xh->xh_entries[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_xattr_list_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "917-943",
    "snippet": "static int ocfs2_xattr_list_entries(struct inode *inode,\n\t\t\t\t    struct ocfs2_xattr_header *header,\n\t\t\t\t    char *buffer, size_t buffer_size)\n{\n\tsize_t result = 0;\n\tint i, type, ret;\n\tconst char *prefix, *name;\n\n\tfor (i = 0 ; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\t\ttype = ocfs2_xattr_get_type(entry);\n\t\tprefix = ocfs2_xattr_prefix(type);\n\n\t\tif (prefix) {\n\t\t\tname = (const char *)header +\n\t\t\t\tle16_to_cpu(entry->xe_name_offset);\n\n\t\t\tret = ocfs2_xattr_list_entry(buffer, buffer_size,\n\t\t\t\t\t\t     &result, prefix, name,\n\t\t\t\t\t\t     entry->xe_name_len);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_list_entry",
          "args": [
            "buffer",
            "buffer_size",
            "&result",
            "prefix",
            "name",
            "entry->xe_name_len"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_list_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "893-915",
          "snippet": "static int ocfs2_xattr_list_entry(char *buffer, size_t size,\n\t\t\t\t  size_t *result, const char *prefix,\n\t\t\t\t  const char *name, int name_len)\n{\n\tchar *p = buffer + *result;\n\tint prefix_len = strlen(prefix);\n\tint total_len = prefix_len + name_len + 1;\n\n\t*result += total_len;\n\n\t/* we are just looking for how big our buffer needs to be */\n\tif (!size)\n\t\treturn 0;\n\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tmemcpy(p, prefix, prefix_len);\n\tmemcpy(p + prefix_len, name, name_len);\n\tp[prefix_len + name_len] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_list_entry(char *buffer, size_t size,\n\t\t\t\t  size_t *result, const char *prefix,\n\t\t\t\t  const char *name, int name_len)\n{\n\tchar *p = buffer + *result;\n\tint prefix_len = strlen(prefix);\n\tint total_len = prefix_len + name_len + 1;\n\n\t*result += total_len;\n\n\t/* we are just looking for how big our buffer needs to be */\n\tif (!size)\n\t\treturn 0;\n\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tmemcpy(p, prefix, prefix_len);\n\tmemcpy(p + prefix_len, name, name_len);\n\tp[prefix_len + name_len] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->xe_name_offset"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_prefix",
          "args": [
            "type"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "547-555",
          "snippet": "static inline const char *ocfs2_xattr_prefix(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < OCFS2_XATTR_MAX)\n\t\thandler = ocfs2_xattr_handler_map[name_index];\n\n\treturn handler ? handler->prefix : NULL;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xattr_handler *ocfs2_xattr_handler_map[OCFS2_XATTR_MAX] = {\n\t[OCFS2_XATTR_INDEX_USER]\t= &ocfs2_xattr_user_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS]\n\t\t\t\t\t= &posix_acl_access_xattr_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT]\n\t\t\t\t\t= &posix_acl_default_xattr_handler,\n\t[OCFS2_XATTR_INDEX_TRUSTED]\t= &ocfs2_xattr_trusted_handler,\n\t[OCFS2_XATTR_INDEX_SECURITY]\t= &ocfs2_xattr_security_handler,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic const struct xattr_handler *ocfs2_xattr_handler_map[OCFS2_XATTR_MAX] = {\n\t[OCFS2_XATTR_INDEX_USER]\t= &ocfs2_xattr_user_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS]\n\t\t\t\t\t= &posix_acl_access_xattr_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT]\n\t\t\t\t\t= &posix_acl_default_xattr_handler,\n\t[OCFS2_XATTR_INDEX_TRUSTED]\t= &ocfs2_xattr_trusted_handler,\n\t[OCFS2_XATTR_INDEX_SECURITY]\t= &ocfs2_xattr_security_handler,\n};\n\nstatic inline const char *ocfs2_xattr_prefix(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < OCFS2_XATTR_MAX)\n\t\thandler = ocfs2_xattr_handler_map[name_index];\n\n\treturn handler ? handler->prefix : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_type",
          "args": [
            "entry"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1153-1156",
          "snippet": "static inline int ocfs2_xattr_get_type(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_TYPE_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_TYPE_MASK\t\t0x7F"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_TYPE_MASK\t\t0x7F\n\nstatic inline int ocfs2_xattr_get_type(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_TYPE_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nstatic int ocfs2_xattr_list_entries(struct inode *inode,\n\t\t\t\t    struct ocfs2_xattr_header *header,\n\t\t\t\t    char *buffer, size_t buffer_size)\n{\n\tsize_t result = 0;\n\tint i, type, ret;\n\tconst char *prefix, *name;\n\n\tfor (i = 0 ; i < le16_to_cpu(header->xh_count); i++) {\n\t\tstruct ocfs2_xattr_entry *entry = &header->xh_entries[i];\n\t\ttype = ocfs2_xattr_get_type(entry);\n\t\tprefix = ocfs2_xattr_prefix(type);\n\n\t\tif (prefix) {\n\t\t\tname = (const char *)header +\n\t\t\t\tle16_to_cpu(entry->xe_name_offset);\n\n\t\t\tret = ocfs2_xattr_list_entry(buffer, buffer_size,\n\t\t\t\t\t\t     &result, prefix, name,\n\t\t\t\t\t\t     entry->xe_name_len);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "ocfs2_xattr_list_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "893-915",
    "snippet": "static int ocfs2_xattr_list_entry(char *buffer, size_t size,\n\t\t\t\t  size_t *result, const char *prefix,\n\t\t\t\t  const char *name, int name_len)\n{\n\tchar *p = buffer + *result;\n\tint prefix_len = strlen(prefix);\n\tint total_len = prefix_len + name_len + 1;\n\n\t*result += total_len;\n\n\t/* we are just looking for how big our buffer needs to be */\n\tif (!size)\n\t\treturn 0;\n\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tmemcpy(p, prefix, prefix_len);\n\tmemcpy(p + prefix_len, name, name_len);\n\tp[prefix_len + name_len] = '\\0';\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p + prefix_len",
            "name",
            "name_len"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "prefix",
            "prefix_len"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_list_entry(char *buffer, size_t size,\n\t\t\t\t  size_t *result, const char *prefix,\n\t\t\t\t  const char *name, int name_len)\n{\n\tchar *p = buffer + *result;\n\tint prefix_len = strlen(prefix);\n\tint total_len = prefix_len + name_len + 1;\n\n\t*result += total_len;\n\n\t/* we are just looking for how big our buffer needs to be */\n\tif (!size)\n\t\treturn 0;\n\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tmemcpy(p, prefix, prefix_len);\n\tmemcpy(p + prefix_len, name, name_len);\n\tp[prefix_len + name_len] = '\\0';\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_xattr_value_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "869-891",
    "snippet": "static int ocfs2_xattr_value_truncate(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      int len,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb, len);\n\tu32 old_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\n\tif (new_clusters == old_clusters)\n\t\treturn 0;\n\n\tif (new_clusters > old_clusters)\n\t\tret = ocfs2_xattr_extend_allocation(inode,\n\t\t\t\t\t\t    new_clusters - old_clusters,\n\t\t\t\t\t\t    vb, ctxt);\n\telse\n\t\tret = ocfs2_xattr_shrink_size(inode,\n\t\t\t\t\t      old_clusters, new_clusters,\n\t\t\t\t\t      vb, ctxt);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_shrink_size",
          "args": [
            "inode",
            "old_clusters",
            "new_clusters",
            "vb",
            "ctxt"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_shrink_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "822-867",
          "snippet": "static int ocfs2_xattr_shrink_size(struct inode *inode,\n\t\t\t\t   u32 old_clusters,\n\t\t\t\t   u32 new_clusters,\n\t\t\t\t   struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret = 0;\n\tunsigned int ext_flags;\n\tu32 trunc_len, cpos, phys_cpos, alloc_size;\n\tu64 block;\n\n\tif (old_clusters <= new_clusters)\n\t\treturn 0;\n\n\tcpos = new_clusters;\n\ttrunc_len = old_clusters - new_clusters;\n\twhile (trunc_len) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &phys_cpos,\n\t\t\t\t\t       &alloc_size,\n\t\t\t\t\t       &vb->vb_xv->xr_list, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (alloc_size > trunc_len)\n\t\t\talloc_size = trunc_len;\n\n\t\tret = __ocfs2_remove_xattr_range(inode, vb, cpos,\n\t\t\t\t\t\t phys_cpos, alloc_size,\n\t\t\t\t\t\t ext_flags, ctxt);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tblock = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\t\tocfs2_remove_xattr_clusters_from_cache(INODE_CACHE(inode),\n\t\t\t\t\t\t       block, alloc_size);\n\t\tcpos += alloc_size;\n\t\ttrunc_len -= alloc_size;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_shrink_size(struct inode *inode,\n\t\t\t\t   u32 old_clusters,\n\t\t\t\t   u32 new_clusters,\n\t\t\t\t   struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret = 0;\n\tunsigned int ext_flags;\n\tu32 trunc_len, cpos, phys_cpos, alloc_size;\n\tu64 block;\n\n\tif (old_clusters <= new_clusters)\n\t\treturn 0;\n\n\tcpos = new_clusters;\n\ttrunc_len = old_clusters - new_clusters;\n\twhile (trunc_len) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &phys_cpos,\n\t\t\t\t\t       &alloc_size,\n\t\t\t\t\t       &vb->vb_xv->xr_list, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (alloc_size > trunc_len)\n\t\t\talloc_size = trunc_len;\n\n\t\tret = __ocfs2_remove_xattr_range(inode, vb, cpos,\n\t\t\t\t\t\t phys_cpos, alloc_size,\n\t\t\t\t\t\t ext_flags, ctxt);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tblock = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\t\tocfs2_remove_xattr_clusters_from_cache(INODE_CACHE(inode),\n\t\t\t\t\t\t       block, alloc_size);\n\t\tcpos += alloc_size;\n\t\ttrunc_len -= alloc_size;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_extend_allocation",
          "args": [
            "inode",
            "new_clusters - old_clusters",
            "vb",
            "ctxt"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_extend_allocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "713-775",
          "snippet": "static int ocfs2_xattr_extend_allocation(struct inode *inode,\n\t\t\t\t\t u32 clusters_to_add,\n\t\t\t\t\t struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint status = 0, credits;\n\thandle_t *handle = ctxt->handle;\n\tenum ocfs2_alloc_restarted why;\n\tu32 prev_clusters, logical_start = le32_to_cpu(vb->vb_xv->xr_clusters);\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\twhile (clusters_to_add) {\n\t\ttrace_ocfs2_xattr_extend_allocation(clusters_to_add);\n\n\t\tstatus = vb->vb_access(handle, INODE_CACHE(inode), vb->vb_bh,\n\t\t\t\t       OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\t\tstatus = ocfs2_add_clusters_in_btree(handle,\n\t\t\t\t\t\t     &et,\n\t\t\t\t\t\t     &logical_start,\n\t\t\t\t\t\t     clusters_to_add,\n\t\t\t\t\t\t     0,\n\t\t\t\t\t\t     ctxt->data_ac,\n\t\t\t\t\t\t     ctxt->meta_ac,\n\t\t\t\t\t\t     &why);\n\t\tif ((status < 0) && (status != -EAGAIN)) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_journal_dirty(handle, vb->vb_bh);\n\n\t\tclusters_to_add -= le32_to_cpu(vb->vb_xv->xr_clusters) -\n\t\t\t\t\t prev_clusters;\n\n\t\tif (why != RESTART_NONE && clusters_to_add) {\n\t\t\t/*\n\t\t\t * We can only fail in case the alloc file doesn't give\n\t\t\t * up enough clusters.\n\t\t\t */\n\t\t\tBUG_ON(why == RESTART_META);\n\n\t\t\tcredits = ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t    &vb->vb_xv->xr_list);\n\t\t\tstatus = ocfs2_extend_trans(handle, credits);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_xattr_extend_allocation(struct inode *inode,\n\t\t\t\t\t u32 clusters_to_add,\n\t\t\t\t\t struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint status = 0, credits;\n\thandle_t *handle = ctxt->handle;\n\tenum ocfs2_alloc_restarted why;\n\tu32 prev_clusters, logical_start = le32_to_cpu(vb->vb_xv->xr_clusters);\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\twhile (clusters_to_add) {\n\t\ttrace_ocfs2_xattr_extend_allocation(clusters_to_add);\n\n\t\tstatus = vb->vb_access(handle, INODE_CACHE(inode), vb->vb_bh,\n\t\t\t\t       OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\t\tstatus = ocfs2_add_clusters_in_btree(handle,\n\t\t\t\t\t\t     &et,\n\t\t\t\t\t\t     &logical_start,\n\t\t\t\t\t\t     clusters_to_add,\n\t\t\t\t\t\t     0,\n\t\t\t\t\t\t     ctxt->data_ac,\n\t\t\t\t\t\t     ctxt->meta_ac,\n\t\t\t\t\t\t     &why);\n\t\tif ((status < 0) && (status != -EAGAIN)) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_journal_dirty(handle, vb->vb_bh);\n\n\t\tclusters_to_add -= le32_to_cpu(vb->vb_xv->xr_clusters) -\n\t\t\t\t\t prev_clusters;\n\n\t\tif (why != RESTART_NONE && clusters_to_add) {\n\t\t\t/*\n\t\t\t * We can only fail in case the alloc file doesn't give\n\t\t\t * up enough clusters.\n\t\t\t */\n\t\t\tBUG_ON(why == RESTART_META);\n\n\t\t\tcredits = ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t    &vb->vb_xv->xr_list);\n\t\t\tstatus = ocfs2_extend_trans(handle, credits);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "vb->vb_xv->xr_clusters"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "inode->i_sb",
            "len"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_value_truncate(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      int len,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu32 new_clusters = ocfs2_clusters_for_bytes(inode->i_sb, len);\n\tu32 old_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\n\tif (new_clusters == old_clusters)\n\t\treturn 0;\n\n\tif (new_clusters > old_clusters)\n\t\tret = ocfs2_xattr_extend_allocation(inode,\n\t\t\t\t\t\t    new_clusters - old_clusters,\n\t\t\t\t\t\t    vb, ctxt);\n\telse\n\t\tret = ocfs2_xattr_shrink_size(inode,\n\t\t\t\t\t      old_clusters, new_clusters,\n\t\t\t\t\t      vb, ctxt);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_shrink_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "822-867",
    "snippet": "static int ocfs2_xattr_shrink_size(struct inode *inode,\n\t\t\t\t   u32 old_clusters,\n\t\t\t\t   u32 new_clusters,\n\t\t\t\t   struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret = 0;\n\tunsigned int ext_flags;\n\tu32 trunc_len, cpos, phys_cpos, alloc_size;\n\tu64 block;\n\n\tif (old_clusters <= new_clusters)\n\t\treturn 0;\n\n\tcpos = new_clusters;\n\ttrunc_len = old_clusters - new_clusters;\n\twhile (trunc_len) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &phys_cpos,\n\t\t\t\t\t       &alloc_size,\n\t\t\t\t\t       &vb->vb_xv->xr_list, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (alloc_size > trunc_len)\n\t\t\talloc_size = trunc_len;\n\n\t\tret = __ocfs2_remove_xattr_range(inode, vb, cpos,\n\t\t\t\t\t\t phys_cpos, alloc_size,\n\t\t\t\t\t\t ext_flags, ctxt);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tblock = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\t\tocfs2_remove_xattr_clusters_from_cache(INODE_CACHE(inode),\n\t\t\t\t\t\t       block, alloc_size);\n\t\tcpos += alloc_size;\n\t\ttrunc_len -= alloc_size;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_remove_xattr_clusters_from_cache",
          "args": [
            "INODE_CACHE(inode)",
            "block",
            "alloc_size"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_xattr_clusters_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "612-621",
          "snippet": "void ocfs2_remove_xattr_clusters_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t\t\t    sector_t block,\n\t\t\t\t\t    u32 c_len)\n{\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tunsigned int i, b_len = ocfs2_clusters_to_blocks(sb, 1) * c_len;\n\n\tfor (i = 0; i < b_len; i++, block++)\n\t\tocfs2_remove_block_from_cache(ci, block);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_remove_xattr_clusters_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t\t\t    sector_t block,\n\t\t\t\t\t    u32 c_len)\n{\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tunsigned int i, b_len = ocfs2_clusters_to_blocks(sb, 1) * c_len;\n\n\tfor (i = 0; i < b_len; i++, block++)\n\t\tocfs2_remove_block_from_cache(ci, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "phys_cpos"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_remove_xattr_range",
          "args": [
            "inode",
            "vb",
            "cpos",
            "phys_cpos",
            "alloc_size",
            "ext_flags",
            "ctxt"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_remove_xattr_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "777-820",
          "snippet": "static int __ocfs2_remove_xattr_range(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      u32 cpos, u32 phys_cpos, u32 len,\n\t\t\t\t      unsigned int ext_flags,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\tret = vb->vb_access(handle, INODE_CACHE(inode), vb->vb_bh,\n\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_remove_extent(handle, &et, cpos, len, ctxt->meta_ac,\n\t\t\t\t  &ctxt->dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle32_add_cpu(&vb->vb_xv->xr_clusters, -len);\n\tocfs2_journal_dirty(handle, vb->vb_bh);\n\n\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, ctxt->meta_ac, &ctxt->dealloc, 1);\n\telse\n\t\tret = ocfs2_cache_cluster_dealloc(&ctxt->dealloc,\n\t\t\t\t\t\t  phys_blkno, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
            "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int __ocfs2_remove_xattr_range(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      u32 cpos, u32 phys_cpos, u32 len,\n\t\t\t\t      unsigned int ext_flags,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\tret = vb->vb_access(handle, INODE_CACHE(inode), vb->vb_bh,\n\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_remove_extent(handle, &et, cpos, len, ctxt->meta_ac,\n\t\t\t\t  &ctxt->dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle32_add_cpu(&vb->vb_xv->xr_clusters, -len);\n\tocfs2_journal_dirty(handle, vb->vb_bh);\n\n\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, ctxt->meta_ac, &ctxt->dealloc, 1);\n\telse\n\t\tret = ocfs2_cache_cluster_dealloc(&ctxt->dealloc,\n\t\t\t\t\t\t  phys_blkno, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&phys_cpos",
            "&alloc_size",
            "&vb->vb_xv->xr_list",
            "&ext_flags"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "543-606",
          "snippet": "int ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int ocfs2_xattr_shrink_size(struct inode *inode,\n\t\t\t\t   u32 old_clusters,\n\t\t\t\t   u32 new_clusters,\n\t\t\t\t   struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t   struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret = 0;\n\tunsigned int ext_flags;\n\tu32 trunc_len, cpos, phys_cpos, alloc_size;\n\tu64 block;\n\n\tif (old_clusters <= new_clusters)\n\t\treturn 0;\n\n\tcpos = new_clusters;\n\ttrunc_len = old_clusters - new_clusters;\n\twhile (trunc_len) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &phys_cpos,\n\t\t\t\t\t       &alloc_size,\n\t\t\t\t\t       &vb->vb_xv->xr_list, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (alloc_size > trunc_len)\n\t\t\talloc_size = trunc_len;\n\n\t\tret = __ocfs2_remove_xattr_range(inode, vb, cpos,\n\t\t\t\t\t\t phys_cpos, alloc_size,\n\t\t\t\t\t\t ext_flags, ctxt);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tblock = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\t\tocfs2_remove_xattr_clusters_from_cache(INODE_CACHE(inode),\n\t\t\t\t\t\t       block, alloc_size);\n\t\tcpos += alloc_size;\n\t\ttrunc_len -= alloc_size;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_remove_xattr_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "777-820",
    "snippet": "static int __ocfs2_remove_xattr_range(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      u32 cpos, u32 phys_cpos, u32 len,\n\t\t\t\t      unsigned int ext_flags,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\tret = vb->vb_access(handle, INODE_CACHE(inode), vb->vb_bh,\n\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_remove_extent(handle, &et, cpos, len, ctxt->meta_ac,\n\t\t\t\t  &ctxt->dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle32_add_cpu(&vb->vb_xv->xr_clusters, -len);\n\tocfs2_journal_dirty(handle, vb->vb_bh);\n\n\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, ctxt->meta_ac, &ctxt->dealloc, 1);\n\telse\n\t\tret = ocfs2_cache_cluster_dealloc(&ctxt->dealloc,\n\t\t\t\t\t\t  phys_blkno, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cache_cluster_dealloc",
          "args": [
            "&ctxt->dealloc",
            "phys_blkno",
            "len"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cache_cluster_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6397-6418",
          "snippet": "int ocfs2_cache_cluster_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\tu64 blkno, unsigned int bit)\n{\n\tint ret = 0;\n\tstruct ocfs2_cached_block_free *item;\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\ttrace_ocfs2_cache_cluster_dealloc((unsigned long long)blkno, bit);\n\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = ctxt->c_global_allocator;\n\n\tctxt->c_global_allocator = item;\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_cache_cluster_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\tu64 blkno, unsigned int bit)\n{\n\tint ret = 0;\n\tstruct ocfs2_cached_block_free *item;\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\ttrace_ocfs2_cache_cluster_dealloc((unsigned long long)blkno, bit);\n\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = ctxt->c_global_allocator;\n\n\tctxt->c_global_allocator = item;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_decrease_refcount",
          "args": [
            "inode",
            "handle",
            "ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t\t phys_blkno)",
            "len",
            "ctxt->meta_ac",
            "&ctxt->dealloc",
            "1"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_decrease_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2300-2340",
          "snippet": "int ocfs2_decrease_refcount(struct inode *inode,\n\t\t\t    handle_t *handle, u32 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    int delete)\n{\n\tint ret;\n\tu64 ref_blkno;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_block(inode, &ref_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_decrease_refcount(handle, &tree->rf_ci, ref_root_bh,\n\t\t\t\t\tcpos, len, meta_ac, dealloc, delete);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_decrease_refcount(struct inode *inode,\n\t\t\t    handle_t *handle, u32 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    int delete)\n{\n\tint ret;\n\tu64 ref_blkno;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_block(inode, &ref_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_decrease_refcount(handle, &tree->rf_ci, ref_root_bh,\n\t\t\t\t\tcpos, len, meta_ac, dealloc, delete);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "phys_blkno"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "vb->vb_bh"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&vb->vb_xv->xr_clusters",
            "-len"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_extent",
          "args": [
            "handle",
            "&et",
            "cpos",
            "len",
            "ctxt->meta_ac",
            "&ctxt->dealloc"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5470-5607",
          "snippet": "int ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record.\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u\"\n\t\t\t\t    \"trunc len %u, existing record is (%u,%u)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record.\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u\"\n\t\t\t\t    \"trunc len %u, existing record is (%u,%u)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vb->vb_access",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "vb->vb_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_value_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "vb"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_value_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "474-480",
          "snippet": "void ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};\n\nvoid ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "phys_cpos"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\n\nstatic int __ocfs2_remove_xattr_range(struct inode *inode,\n\t\t\t\t      struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t      u32 cpos, u32 phys_cpos, u32 len,\n\t\t\t\t      unsigned int ext_flags,\n\t\t\t\t      struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint ret;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\thandle_t *handle = ctxt->handle;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\tret = vb->vb_access(handle, INODE_CACHE(inode), vb->vb_bh,\n\t\t\t    OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_remove_extent(handle, &et, cpos, len, ctxt->meta_ac,\n\t\t\t\t  &ctxt->dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle32_add_cpu(&vb->vb_xv->xr_clusters, -len);\n\tocfs2_journal_dirty(handle, vb->vb_bh);\n\n\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, ctxt->meta_ac, &ctxt->dealloc, 1);\n\telse\n\t\tret = ocfs2_cache_cluster_dealloc(&ctxt->dealloc,\n\t\t\t\t\t\t  phys_blkno, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_extend_allocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "713-775",
    "snippet": "static int ocfs2_xattr_extend_allocation(struct inode *inode,\n\t\t\t\t\t u32 clusters_to_add,\n\t\t\t\t\t struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint status = 0, credits;\n\thandle_t *handle = ctxt->handle;\n\tenum ocfs2_alloc_restarted why;\n\tu32 prev_clusters, logical_start = le32_to_cpu(vb->vb_xv->xr_clusters);\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\twhile (clusters_to_add) {\n\t\ttrace_ocfs2_xattr_extend_allocation(clusters_to_add);\n\n\t\tstatus = vb->vb_access(handle, INODE_CACHE(inode), vb->vb_bh,\n\t\t\t\t       OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\t\tstatus = ocfs2_add_clusters_in_btree(handle,\n\t\t\t\t\t\t     &et,\n\t\t\t\t\t\t     &logical_start,\n\t\t\t\t\t\t     clusters_to_add,\n\t\t\t\t\t\t     0,\n\t\t\t\t\t\t     ctxt->data_ac,\n\t\t\t\t\t\t     ctxt->meta_ac,\n\t\t\t\t\t\t     &why);\n\t\tif ((status < 0) && (status != -EAGAIN)) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_journal_dirty(handle, vb->vb_bh);\n\n\t\tclusters_to_add -= le32_to_cpu(vb->vb_xv->xr_clusters) -\n\t\t\t\t\t prev_clusters;\n\n\t\tif (why != RESTART_NONE && clusters_to_add) {\n\t\t\t/*\n\t\t\t * We can only fail in case the alloc file doesn't give\n\t\t\t * up enough clusters.\n\t\t\t */\n\t\t\tBUG_ON(why == RESTART_META);\n\n\t\t\tcredits = ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t    &vb->vb_xv->xr_list);\n\t\t\tstatus = ocfs2_extend_trans(handle, credits);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);",
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "credits"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_extend_credits",
          "args": [
            "inode->i_sb",
            "&vb->vb_xv->xr_list"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_extend_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "531-556",
          "snippet": "static inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "why == RESTART_META"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "vb->vb_xv->xr_clusters"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "vb->vb_bh"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_clusters_in_btree",
          "args": [
            "handle",
            "&et",
            "&logical_start",
            "clusters_to_add",
            "0",
            "ctxt->data_ac",
            "ctxt->meta_ac",
            "&why"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_clusters_in_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4735-4845",
          "snippet": "int ocfs2_add_clusters_in_btree(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tu32 *logical_offset,\n\t\t\t\tu32 clusters_to_add,\n\t\t\t\tint mark_unwritten,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tenum ocfs2_alloc_restarted *reason_ret)\n{\n\tint status = 0, err = 0;\n\tint need_free = 0;\n\tint free_extents;\n\tenum ocfs2_alloc_restarted reason = RESTART_NONE;\n\tu32 bit_off, num_bits;\n\tu64 block;\n\tu8 flags = 0;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\tBUG_ON(!clusters_to_add);\n\n\tif (mark_unwritten)\n\t\tflags = OCFS2_EXT_UNWRITTEN;\n\n\tfree_extents = ocfs2_num_free_extents(osb, et);\n\tif (free_extents < 0) {\n\t\tstatus = free_extents;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* there are two cases which could cause us to EAGAIN in the\n\t * we-need-more-metadata case:\n\t * 1) we haven't reserved *any*\n\t * 2) we are so fragmented, we've needed to add metadata too\n\t *    many times. */\n\tif (!free_extents && !meta_ac) {\n\t\terr = -1;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t} else if ((!free_extents)\n\t\t   && (ocfs2_alloc_context_bits_left(meta_ac)\n\t\t       < ocfs2_extend_meta_needed(et->et_root_el))) {\n\t\terr = -2;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t}\n\n\tstatus = __ocfs2_claim_clusters(handle, data_ac, 1,\n\t\t\t\t\tclusters_to_add, &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\t/* reserve our write early -- insert_extent may update the tree root */\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_clusters_in_btree(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t     bit_off, num_bits);\n\tstatus = ocfs2_insert_extent(handle, et, *logical_offset, block,\n\t\t\t\t     num_bits, flags, meta_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tclusters_to_add -= num_bits;\n\t*logical_offset += num_bits;\n\n\tif (clusters_to_add) {\n\t\terr = clusters_to_add;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_TRANS;\n\t}\n\nbail:\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num_bits);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum_bits);\n\t}\n\nleave:\n\tif (reason_ret)\n\t\t*reason_ret = reason;\n\ttrace_ocfs2_add_clusters_in_btree_ret(status, reason, err);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_add_clusters_in_btree(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tu32 *logical_offset,\n\t\t\t\tu32 clusters_to_add,\n\t\t\t\tint mark_unwritten,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tenum ocfs2_alloc_restarted *reason_ret)\n{\n\tint status = 0, err = 0;\n\tint need_free = 0;\n\tint free_extents;\n\tenum ocfs2_alloc_restarted reason = RESTART_NONE;\n\tu32 bit_off, num_bits;\n\tu64 block;\n\tu8 flags = 0;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\tBUG_ON(!clusters_to_add);\n\n\tif (mark_unwritten)\n\t\tflags = OCFS2_EXT_UNWRITTEN;\n\n\tfree_extents = ocfs2_num_free_extents(osb, et);\n\tif (free_extents < 0) {\n\t\tstatus = free_extents;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* there are two cases which could cause us to EAGAIN in the\n\t * we-need-more-metadata case:\n\t * 1) we haven't reserved *any*\n\t * 2) we are so fragmented, we've needed to add metadata too\n\t *    many times. */\n\tif (!free_extents && !meta_ac) {\n\t\terr = -1;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t} else if ((!free_extents)\n\t\t   && (ocfs2_alloc_context_bits_left(meta_ac)\n\t\t       < ocfs2_extend_meta_needed(et->et_root_el))) {\n\t\terr = -2;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t}\n\n\tstatus = __ocfs2_claim_clusters(handle, data_ac, 1,\n\t\t\t\t\tclusters_to_add, &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\t/* reserve our write early -- insert_extent may update the tree root */\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_clusters_in_btree(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t     bit_off, num_bits);\n\tstatus = ocfs2_insert_extent(handle, et, *logical_offset, block,\n\t\t\t\t     num_bits, flags, meta_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tclusters_to_add -= num_bits;\n\t*logical_offset += num_bits;\n\n\tif (clusters_to_add) {\n\t\terr = clusters_to_add;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_TRANS;\n\t}\n\nbail:\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num_bits);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum_bits);\n\t}\n\nleave:\n\tif (reason_ret)\n\t\t*reason_ret = reason;\n\ttrace_ocfs2_add_clusters_in_btree_ret(status, reason, err);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vb->vb_access",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "vb->vb_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_xattr_extend_allocation",
          "args": [
            "clusters_to_add"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_value_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "vb"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_value_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "474-480",
          "snippet": "void ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};\n\nvoid ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_create_index_block(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_xattr_search *xs,\n\t\t\t\t\t  struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_xattr_set_entry_index_block(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_xattr_info *xi,\n\t\t\t\t\t     struct ocfs2_xattr_search *xs,\n\t\t\t\t\t     struct ocfs2_xattr_set_ctxt *ctxt);\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nstatic int ocfs2_xattr_extend_allocation(struct inode *inode,\n\t\t\t\t\t u32 clusters_to_add,\n\t\t\t\t\t struct ocfs2_xattr_value_buf *vb,\n\t\t\t\t\t struct ocfs2_xattr_set_ctxt *ctxt)\n{\n\tint status = 0, credits;\n\thandle_t *handle = ctxt->handle;\n\tenum ocfs2_alloc_restarted why;\n\tu32 prev_clusters, logical_start = le32_to_cpu(vb->vb_xv->xr_clusters);\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_xattr_value_extent_tree(&et, INODE_CACHE(inode), vb);\n\n\twhile (clusters_to_add) {\n\t\ttrace_ocfs2_xattr_extend_allocation(clusters_to_add);\n\n\t\tstatus = vb->vb_access(handle, INODE_CACHE(inode), vb->vb_bh,\n\t\t\t\t       OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_clusters = le32_to_cpu(vb->vb_xv->xr_clusters);\n\t\tstatus = ocfs2_add_clusters_in_btree(handle,\n\t\t\t\t\t\t     &et,\n\t\t\t\t\t\t     &logical_start,\n\t\t\t\t\t\t     clusters_to_add,\n\t\t\t\t\t\t     0,\n\t\t\t\t\t\t     ctxt->data_ac,\n\t\t\t\t\t\t     ctxt->meta_ac,\n\t\t\t\t\t\t     &why);\n\t\tif ((status < 0) && (status != -EAGAIN)) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_journal_dirty(handle, vb->vb_bh);\n\n\t\tclusters_to_add -= le32_to_cpu(vb->vb_xv->xr_clusters) -\n\t\t\t\t\t prev_clusters;\n\n\t\tif (why != RESTART_NONE && clusters_to_add) {\n\t\t\t/*\n\t\t\t * We can only fail in case the alloc file doesn't give\n\t\t\t * up enough clusters.\n\t\t\t */\n\t\t\tBUG_ON(why == RESTART_META);\n\n\t\t\tcredits = ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t\t    &vb->vb_xv->xr_list);\n\t\t\tstatus = ocfs2_extend_trans(handle, credits);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_calc_xattr_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "631-711",
    "snippet": "int ocfs2_calc_xattr_init(struct inode *dir,\n\t\t\t  struct buffer_head *dir_bh,\n\t\t\t  umode_t mode,\n\t\t\t  struct ocfs2_security_xattr_info *si,\n\t\t\t  int *want_clusters,\n\t\t\t  int *xattr_credits,\n\t\t\t  int *want_meta)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tint s_size = 0, a_size = 0, acl_len = 0, new_clusters;\n\n\tif (si->enable)\n\t\ts_size = ocfs2_xattr_entry_real_size(strlen(si->name),\n\t\t\t\t\t\t     si->value_len);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) {\n\t\tacl_len = ocfs2_xattr_get_nolock(dir, dir_bh,\n\t\t\t\t\tOCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT,\n\t\t\t\t\t\"\", NULL, 0);\n\t\tif (acl_len > 0) {\n\t\t\ta_size = ocfs2_xattr_entry_real_size(0, acl_len);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\ta_size <<= 1;\n\t\t} else if (acl_len != 0 && acl_len != -ENODATA) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!(s_size + a_size))\n\t\treturn ret;\n\n\t/*\n\t * The max space of security xattr taken inline is\n\t * 256(name) + 80(value) + 16(entry) = 352 bytes,\n\t * The max space of acl xattr taken inline is\n\t * 80(value) + 16(entry) * 2(if directory) = 192 bytes,\n\t * when blocksize = 512, may reserve one more cluser for\n\t * xattr bucket, otherwise reserve one metadata block\n\t * for them is ok.\n\t * If this is a new directory with inline data,\n\t * we choose to reserve the entire inline area for\n\t * directory contents and force an external xattr block.\n\t */\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE ||\n\t    (S_ISDIR(mode) && ocfs2_supports_inline_data(osb)) ||\n\t    (s_size + a_size) > OCFS2_XATTR_FREE_IN_IBODY) {\n\t\t*want_meta = *want_meta + 1;\n\t\t*xattr_credits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t}\n\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE &&\n\t    (s_size + a_size) > OCFS2_XATTR_FREE_IN_BLOCK(dir)) {\n\t\t*want_clusters += 1;\n\t\t*xattr_credits += ocfs2_blocks_per_xattr_bucket(dir->i_sb);\n\t}\n\n\t/*\n\t * reserve credits and clusters for xattrs which has large value\n\t * and have to be set outside\n\t */\n\tif (si->enable && si->value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tnew_clusters = ocfs2_clusters_for_bytes(dir->i_sb,\n\t\t\t\t\t\t\tsi->value_len);\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    acl_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t/* for directory, it has DEFAULT and ACCESS two types of acls */\n\t\tnew_clusters = (S_ISDIR(mode) ? 2 : 1) *\n\t\t\t\tocfs2_clusters_for_bytes(dir->i_sb, acl_len);\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_FREE_IN_IBODY\t(OCFS2_MIN_XATTR_INLINE_SIZE \\\n\t\t\t\t\t - sizeof(struct ocfs2_xattr_header) \\\n\t\t\t\t\t - OCFS2_XATTR_HEADER_GAP)",
      "#define OCFS2_XATTR_INLINE_SIZE\t80"
    ],
    "globals_used": [
      "static int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "dir->i_sb",
            "new_clusters"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "dir->i_sb",
            "acl_len"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_per_xattr_bucket",
          "args": [
            "dir->i_sb"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_per_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "321-324",
          "snippet": "static inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_FREE_IN_BLOCK",
          "args": [
            "dir"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_inline_data",
          "args": [
            "osb"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "511-516",
          "snippet": "static inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_entry_real_size",
          "args": [
            "0",
            "acl_len"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_entry_real_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "575-579",
          "snippet": "static int ocfs2_xattr_entry_real_size(int name_len, size_t value_len)\n{\n\treturn namevalue_size(name_len, value_len) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_entry_real_size(int name_len, size_t value_len)\n{\n\treturn namevalue_size(name_len, value_len) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_nolock",
          "args": [
            "dir",
            "dir_bh",
            "OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT",
            "\"\"",
            "NULL",
            "0"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1266-1299",
          "snippet": "int ocfs2_xattr_get_nolock(struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t    buffer_size, &xis);\n\tif (ret == -ENODATA && di->i_xattr_loc)\n\t\tret = ocfs2_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t    buffer_size, &xbs);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_tree_list_index_block(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *blk_bh,\n\t\t\t\t\tchar *buffer,\n\t\t\t\t\tsize_t buffer_size);\n\nint ocfs2_xattr_get_nolock(struct inode *inode,\n\t\t\t   struct buffer_head *di_bh,\n\t\t\t   int name_index,\n\t\t\t   const char *name,\n\t\t\t   void *buffer,\n\t\t\t   size_t buffer_size)\n{\n\tint ret;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_xattr_search xis = {\n\t\t.not_found = -ENODATA,\n\t};\n\tstruct ocfs2_xattr_search xbs = {\n\t\t.not_found = -ENODATA,\n\t};\n\n\tif (!ocfs2_supports_xattr(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))\n\t\treturn -ENODATA;\n\n\txis.inode_bh = xbs.inode_bh = di_bh;\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tret = ocfs2_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t    buffer_size, &xis);\n\tif (ret == -ENODATA && di->i_xattr_loc)\n\t\tret = ocfs2_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t    buffer_size, &xbs);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "si->name"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_FREE_IN_IBODY\t(OCFS2_MIN_XATTR_INLINE_SIZE \\\n\t\t\t\t\t - sizeof(struct ocfs2_xattr_header) \\\n\t\t\t\t\t - OCFS2_XATTR_HEADER_GAP)\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int ocfs2_prepare_refcount_xattr(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_xattr_info *xi,\n\t\t\t\t\tstruct ocfs2_xattr_search *xis,\n\t\t\t\t\tstruct ocfs2_xattr_search *xbs,\n\t\t\t\t\tstruct ocfs2_refcount_tree **ref_tree,\n\t\t\t\t\tint *meta_need,\n\t\t\t\t\tint *credits);\n\nint ocfs2_calc_xattr_init(struct inode *dir,\n\t\t\t  struct buffer_head *dir_bh,\n\t\t\t  umode_t mode,\n\t\t\t  struct ocfs2_security_xattr_info *si,\n\t\t\t  int *want_clusters,\n\t\t\t  int *xattr_credits,\n\t\t\t  int *want_meta)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tint s_size = 0, a_size = 0, acl_len = 0, new_clusters;\n\n\tif (si->enable)\n\t\ts_size = ocfs2_xattr_entry_real_size(strlen(si->name),\n\t\t\t\t\t\t     si->value_len);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) {\n\t\tacl_len = ocfs2_xattr_get_nolock(dir, dir_bh,\n\t\t\t\t\tOCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT,\n\t\t\t\t\t\"\", NULL, 0);\n\t\tif (acl_len > 0) {\n\t\t\ta_size = ocfs2_xattr_entry_real_size(0, acl_len);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\ta_size <<= 1;\n\t\t} else if (acl_len != 0 && acl_len != -ENODATA) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!(s_size + a_size))\n\t\treturn ret;\n\n\t/*\n\t * The max space of security xattr taken inline is\n\t * 256(name) + 80(value) + 16(entry) = 352 bytes,\n\t * The max space of acl xattr taken inline is\n\t * 80(value) + 16(entry) * 2(if directory) = 192 bytes,\n\t * when blocksize = 512, may reserve one more cluser for\n\t * xattr bucket, otherwise reserve one metadata block\n\t * for them is ok.\n\t * If this is a new directory with inline data,\n\t * we choose to reserve the entire inline area for\n\t * directory contents and force an external xattr block.\n\t */\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE ||\n\t    (S_ISDIR(mode) && ocfs2_supports_inline_data(osb)) ||\n\t    (s_size + a_size) > OCFS2_XATTR_FREE_IN_IBODY) {\n\t\t*want_meta = *want_meta + 1;\n\t\t*xattr_credits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t}\n\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE &&\n\t    (s_size + a_size) > OCFS2_XATTR_FREE_IN_BLOCK(dir)) {\n\t\t*want_clusters += 1;\n\t\t*xattr_credits += ocfs2_blocks_per_xattr_bucket(dir->i_sb);\n\t}\n\n\t/*\n\t * reserve credits and clusters for xattrs which has large value\n\t * and have to be set outside\n\t */\n\tif (si->enable && si->value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tnew_clusters = ocfs2_clusters_for_bytes(dir->i_sb,\n\t\t\t\t\t\t\tsi->value_len);\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\tif (osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    acl_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\t/* for directory, it has DEFAULT and ACCESS two types of acls */\n\t\tnew_clusters = (S_ISDIR(mode) ? 2 : 1) *\n\t\t\t\tocfs2_clusters_for_bytes(dir->i_sb, acl_len);\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_calc_security_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "593-629",
    "snippet": "int ocfs2_calc_security_init(struct inode *dir,\n\t\t\t     struct ocfs2_security_xattr_info *si,\n\t\t\t     int *want_clusters,\n\t\t\t     int *xattr_credits,\n\t\t\t     struct ocfs2_alloc_context **xattr_ac)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tint s_size = ocfs2_xattr_entry_real_size(strlen(si->name),\n\t\t\t\t\t\t si->value_len);\n\n\t/*\n\t * The max space of security xattr taken inline is\n\t * 256(name) + 80(value) + 16(entry) = 352 bytes,\n\t * So reserve one metadata block for it is ok.\n\t */\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE ||\n\t    s_size > OCFS2_XATTR_FREE_IN_IBODY) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, xattr_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*xattr_credits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t}\n\n\t/* reserve clusters for xattr value which will be set in B tree*/\n\tif (si->value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tint new_clusters = ocfs2_clusters_for_bytes(dir->i_sb,\n\t\t\t\t\t\t\t    si->value_len);\n\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_FREE_IN_IBODY\t(OCFS2_MIN_XATTR_INLINE_SIZE \\\n\t\t\t\t\t - sizeof(struct ocfs2_xattr_header) \\\n\t\t\t\t\t - OCFS2_XATTR_HEADER_GAP)",
      "#define OCFS2_XATTR_INLINE_SIZE\t80"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "dir->i_sb",
            "new_clusters"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "dir->i_sb",
            "si->value_len"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "osb",
            "1",
            "xattr_ac"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_entry_real_size",
          "args": [
            "strlen(si->name)",
            "si->value_len"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_entry_real_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "575-579",
          "snippet": "static int ocfs2_xattr_entry_real_size(int name_len, size_t value_len)\n{\n\treturn namevalue_size(name_len, value_len) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_entry_real_size(int name_len, size_t value_len)\n{\n\treturn namevalue_size(name_len, value_len) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "si->name"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_FREE_IN_IBODY\t(OCFS2_MIN_XATTR_INLINE_SIZE \\\n\t\t\t\t\t - sizeof(struct ocfs2_xattr_header) \\\n\t\t\t\t\t - OCFS2_XATTR_HEADER_GAP)\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nint ocfs2_calc_security_init(struct inode *dir,\n\t\t\t     struct ocfs2_security_xattr_info *si,\n\t\t\t     int *want_clusters,\n\t\t\t     int *xattr_credits,\n\t\t\t     struct ocfs2_alloc_context **xattr_ac)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tint s_size = ocfs2_xattr_entry_real_size(strlen(si->name),\n\t\t\t\t\t\t si->value_len);\n\n\t/*\n\t * The max space of security xattr taken inline is\n\t * 256(name) + 80(value) + 16(entry) = 352 bytes,\n\t * So reserve one metadata block for it is ok.\n\t */\n\tif (dir->i_sb->s_blocksize == OCFS2_MIN_BLOCKSIZE ||\n\t    s_size > OCFS2_XATTR_FREE_IN_IBODY) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, xattr_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*xattr_credits += OCFS2_XATTR_BLOCK_CREATE_CREDITS;\n\t}\n\n\t/* reserve clusters for xattr value which will be set in B tree*/\n\tif (si->value_len > OCFS2_XATTR_INLINE_SIZE) {\n\t\tint new_clusters = ocfs2_clusters_for_bytes(dir->i_sb,\n\t\t\t\t\t\t\t    si->value_len);\n\n\t\t*xattr_credits += ocfs2_clusters_to_blocks(dir->i_sb,\n\t\t\t\t\t\t\t   new_clusters);\n\t\t*want_clusters += new_clusters;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xe_entry_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "587-591",
    "snippet": "static int ocfs2_xe_entry_usage(struct ocfs2_xattr_entry *xe)\n{\n\treturn namevalue_size_xe(xe) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "namevalue_size_xe",
          "args": [
            "xe"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "241-248",
          "snippet": "static int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xe_entry_usage(struct ocfs2_xattr_entry *xe)\n{\n\treturn namevalue_size_xe(xe) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}"
  },
  {
    "function_name": "ocfs2_xi_entry_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "581-585",
    "snippet": "static int ocfs2_xi_entry_usage(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size_xi(xi) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "namevalue_size_xi",
          "args": [
            "xi"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size_xi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "236-239",
          "snippet": "static int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xi_entry_usage(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size_xi(xi) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}"
  },
  {
    "function_name": "ocfs2_xattr_entry_real_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "575-579",
    "snippet": "static int ocfs2_xattr_entry_real_size(int name_len, size_t value_len)\n{\n\treturn namevalue_size(name_len, value_len) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "namevalue_size",
          "args": [
            "name_len",
            "value_len"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "228-234",
          "snippet": "static int namevalue_size(int name_len, uint64_t value_len)\n{\n\tif (value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_ROOT_SIZE;\n\telse\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_SIZE(value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80",
            "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic int namevalue_size(int name_len, uint64_t value_len)\n{\n\tif (value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_ROOT_SIZE;\n\telse\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_SIZE(value_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_entry_real_size(int name_len, size_t value_len)\n{\n\treturn namevalue_size(name_len, value_len) +\n\t\tsizeof(struct ocfs2_xattr_entry);\n}"
  },
  {
    "function_name": "ocfs2_xattr_name_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "557-573",
    "snippet": "static u32 ocfs2_xattr_name_hash(struct inode *inode,\n\t\t\t\t const char *name,\n\t\t\t\t int name_len)\n{\n\t/* Get hash value of uuid from super block */\n\tu32 hash = OCFS2_SB(inode->i_sb)->uuid_hash;\n\tint i;\n\n\t/* hash extended attribute name */\n\tfor (i = 0; i < name_len; i++) {\n\t\thash = (hash << OCFS2_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - OCFS2_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\treturn hash;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic u32 ocfs2_xattr_name_hash(struct inode *inode,\n\t\t\t\t const char *name,\n\t\t\t\t int name_len)\n{\n\t/* Get hash value of uuid from super block */\n\tu32 hash = OCFS2_SB(inode->i_sb)->uuid_hash;\n\tint i;\n\n\t/* hash extended attribute name */\n\tfor (i = 0; i < name_len; i++) {\n\t\thash = (hash << OCFS2_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - OCFS2_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\treturn hash;\n}"
  },
  {
    "function_name": "ocfs2_xattr_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "547-555",
    "snippet": "static inline const char *ocfs2_xattr_prefix(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < OCFS2_XATTR_MAX)\n\t\thandler = ocfs2_xattr_handler_map[name_index];\n\n\treturn handler ? handler->prefix : NULL;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct xattr_handler *ocfs2_xattr_handler_map[OCFS2_XATTR_MAX] = {\n\t[OCFS2_XATTR_INDEX_USER]\t= &ocfs2_xattr_user_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS]\n\t\t\t\t\t= &posix_acl_access_xattr_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT]\n\t\t\t\t\t= &posix_acl_default_xattr_handler,\n\t[OCFS2_XATTR_INDEX_TRUSTED]\t= &ocfs2_xattr_trusted_handler,\n\t[OCFS2_XATTR_INDEX_SECURITY]\t= &ocfs2_xattr_security_handler,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic const struct xattr_handler *ocfs2_xattr_handler_map[OCFS2_XATTR_MAX] = {\n\t[OCFS2_XATTR_INDEX_USER]\t= &ocfs2_xattr_user_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS]\n\t\t\t\t\t= &posix_acl_access_xattr_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT]\n\t\t\t\t\t= &posix_acl_default_xattr_handler,\n\t[OCFS2_XATTR_INDEX_TRUSTED]\t= &ocfs2_xattr_trusted_handler,\n\t[OCFS2_XATTR_INDEX_SECURITY]\t= &ocfs2_xattr_security_handler,\n};\n\nstatic inline const char *ocfs2_xattr_prefix(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < OCFS2_XATTR_MAX)\n\t\thandler = ocfs2_xattr_handler_map[name_index];\n\n\treturn handler ? handler->prefix : NULL;\n}"
  },
  {
    "function_name": "ocfs2_read_xattr_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "531-545",
    "snippet": "static int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_read_block",
          "args": [
            "INODE_CACHE(inode)",
            "xb_blkno",
            "&tmp",
            "ocfs2_validate_xattr_block"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_read_xattr_block(struct inode *inode, u64 xb_blkno,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), xb_blkno, &tmp,\n\t\t\t      ocfs2_validate_xattr_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_validate_xattr_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "477-529",
    "snippet": "static int ocfs2_validate_xattr_block(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_xattr_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &xb->xb_check);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Errors after here are fatal\n\t */\n\n\tif (!OCFS2_IS_VALID_XATTR_BLOCK(xb)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has bad \"\n\t\t\t    \"signature %.*s\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    xb->xb_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(xb->xb_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an \"\n\t\t\t    \"invalid xb_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(xb->xb_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(xb->xb_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an invalid \"\n\t\t\t    \"xb_fs_generation of #%u\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(xb->xb_fs_generation));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Extended attribute block #%llu has an invalid \"\n\t\t\t    \"xb_fs_generation of #%u\"",
            "(unsigned long long)bh->b_blocknr",
            "le32_to_cpu(xb->xb_fs_generation)"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "xb->xb_fs_generation"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "xb->xb_blkno"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_XATTR_BLOCK",
          "args": [
            "xb"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_meta_ecc",
          "args": [
            "sb",
            "bh->b_data",
            "&xb->xb_check"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "613-624",
          "snippet": "int ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_validate_xattr_block",
          "args": [
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_get_xattr_tree_value_root(struct super_block *sb,\n\t\t\t\t\t   struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t   int offset,\n\t\t\t\t\t   struct ocfs2_xattr_value_root **xv,\n\t\t\t\t\t   struct buffer_head **bh);\n\nstatic int ocfs2_validate_xattr_block(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_xattr_block *xb =\n\t\t(struct ocfs2_xattr_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_xattr_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &xb->xb_check);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * Errors after here are fatal\n\t */\n\n\tif (!OCFS2_IS_VALID_XATTR_BLOCK(xb)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has bad \"\n\t\t\t    \"signature %.*s\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    xb->xb_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(xb->xb_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an \"\n\t\t\t    \"invalid xb_blkno of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(xb->xb_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(xb->xb_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Extended attribute block #%llu has an invalid \"\n\t\t\t    \"xb_fs_generation of #%u\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(xb->xb_fs_generation));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_xattr_bucket_copy_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "462-475",
    "snippet": "static void ocfs2_xattr_bucket_copy_data(struct ocfs2_xattr_bucket *dest,\n\t\t\t\t\t struct ocfs2_xattr_bucket *src)\n{\n\tint i;\n\tint blocksize = src->bu_inode->i_sb->s_blocksize;\n\n\tBUG_ON(dest->bu_blocks != src->bu_blocks);\n\tBUG_ON(dest->bu_inode != src->bu_inode);\n\n\tfor (i = 0; i < src->bu_blocks; i++) {\n\t\tmemcpy(bucket_block(dest, i), bucket_block(src, i),\n\t\t       blocksize);\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bucket_block(dest, i)",
            "bucket_block(src, i)",
            "blocksize"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "src",
            "i"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_block",
          "args": [
            "dest",
            "i"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dest->bu_inode != src->bu_inode"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dest->bu_blocks != src->bu_blocks"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_copy_data(struct ocfs2_xattr_bucket *dest,\n\t\t\t\t\t struct ocfs2_xattr_bucket *src)\n{\n\tint i;\n\tint blocksize = src->bu_inode->i_sb->s_blocksize;\n\n\tBUG_ON(dest->bu_blocks != src->bu_blocks);\n\tBUG_ON(dest->bu_inode != src->bu_inode);\n\n\tfor (i = 0; i < src->bu_blocks; i++) {\n\t\tmemcpy(bucket_block(dest, i), bucket_block(src, i),\n\t\t       blocksize);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_xattr_bucket_journal_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "447-460",
    "snippet": "static void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bucket->bu_bhs[i]"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "bucket->bu_inode->i_sb"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_compute_meta_ecc_bhs",
          "args": [
            "bucket->bu_inode->i_sb",
            "bucket->bu_bhs",
            "bucket->bu_blocks",
            "&bucket_xh(bucket)->xh_check"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_compute_meta_ecc_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "626-632",
          "snippet": "void ocfs2_compute_meta_ecc_bhs(struct super_block *sb,\n\t\t\t\tstruct buffer_head **bhs, int nr,\n\t\t\t\tstruct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute_bhs(bhs, nr, bc);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_compute_meta_ecc_bhs(struct super_block *sb,\n\t\t\t\tstruct buffer_head **bhs, int nr,\n\t\t\t\tstruct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute_bhs(bhs, nr, bc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "bucket->bu_inode->i_sb"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_journal_dirty(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\tocfs2_compute_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t   bucket->bu_bhs, bucket->bu_blocks,\n\t\t\t\t   &bucket_xh(bucket)->xh_check);\n\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\n\tfor (i = 0; i < bucket->bu_blocks; i++)\n\t\tocfs2_journal_dirty(handle, bucket->bu_bhs[i]);\n}"
  },
  {
    "function_name": "ocfs2_xattr_bucket_journal_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "428-445",
    "snippet": "static int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access",
          "args": [
            "handle",
            "INODE_CACHE(bucket->bu_inode)",
            "bucket->bu_bhs[i]",
            "type"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "765-769",
          "snippet": "int ocfs2_journal_access(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, NULL, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, NULL, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "bucket->bu_inode"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_xattr_bucket_journal_access(handle_t *handle,\n\t\t\t\t\t     struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t\t     int type)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\trc = ocfs2_journal_access(handle,\n\t\t\t\t\t  INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t  bucket->bu_bhs[i], type);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_read_xattr_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "404-426",
    "snippet": "static int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_relse",
          "args": [
            "bucket"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "346-354",
          "snippet": "static void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "bucket->bu_inode->i_sb"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_meta_ecc_bhs",
          "args": [
            "bucket->bu_inode->i_sb",
            "bucket->bu_bhs",
            "bucket->bu_blocks",
            "&bucket_xh(bucket)->xh_check"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_meta_ecc_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "634-646",
          "snippet": "int ocfs2_validate_meta_ecc_bhs(struct super_block *sb,\n\t\t\t\tstruct buffer_head **bhs, int nr,\n\t\t\t\tstruct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate_bhs(bhs, nr, bc,\n\t\t\t\t\t\t    &osb->osb_ecc_stats);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc_bhs(struct super_block *sb,\n\t\t\t\tstruct buffer_head **bhs, int nr,\n\t\t\t\tstruct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate_bhs(bhs, nr, bc,\n\t\t\t\t\t\t    &osb->osb_ecc_stats);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_xh",
          "args": [
            "bucket"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "bucket->bu_inode->i_sb"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks",
          "args": [
            "INODE_CACHE(bucket->bu_inode)",
            "xb_blkno",
            "bucket->bu_blocks",
            "bucket->bu_bhs",
            "0",
            "NULL"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "176-366",
          "snippet": "int ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "bucket->bu_inode"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_read_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno)\n{\n\tint rc;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(bucket->bu_inode), xb_blkno,\n\t\t\t       bucket->bu_blocks, bucket->bu_bhs, 0,\n\t\t\t       NULL);\n\tif (!rc) {\n\t\tspin_lock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\trc = ocfs2_validate_meta_ecc_bhs(bucket->bu_inode->i_sb,\n\t\t\t\t\t\t bucket->bu_bhs,\n\t\t\t\t\t\t bucket->bu_blocks,\n\t\t\t\t\t\t &bucket_xh(bucket)->xh_check);\n\t\tspin_unlock(&OCFS2_SB(bucket->bu_inode->i_sb)->osb_xattr_lock);\n\t\tif (rc)\n\t\t\tmlog_errno(rc);\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_init_xattr_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "371-401",
    "snippet": "static int ocfs2_init_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno, int new)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbucket->bu_bhs[i] = sb_getblk(bucket->bu_inode->i_sb,\n\t\t\t\t\t      xb_blkno + i);\n\t\tif (!bucket->bu_bhs[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ocfs2_buffer_uptodate(INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t   bucket->bu_bhs[i])) {\n\t\t\tif (new)\n\t\t\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t\t\t      bucket->bu_bhs[i]);\n\t\t\telse {\n\t\t\t\tset_buffer_uptodate(bucket->bu_bhs[i]);\n\t\t\t\tocfs2_set_buffer_uptodate(INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t\t\t  bucket->bu_bhs[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_relse",
          "args": [
            "bucket"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "346-354",
          "snippet": "static void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_buffer_uptodate",
          "args": [
            "INODE_CACHE(bucket->bu_inode)",
            "bucket->bu_bhs[i]"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "483-516",
          "snippet": "void ocfs2_set_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t       struct buffer_head *bh)\n{\n\tint expand;\n\n\t/* The block may very well exist in our cache already, so avoid\n\t * doing any more work in that case. */\n\tif (ocfs2_buffer_cached(ci, bh))\n\t\treturn;\n\n\ttrace_ocfs2_set_buffer_uptodate_begin(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr);\n\n\t/* No need to recheck under spinlock - insertion is guarded by\n\t * co_io_lock() */\n\tocfs2_metadata_cache_lock(ci);\n\tif (ocfs2_insert_can_use_array(ci)) {\n\t\t/* Fast case - it's an array and there's a free\n\t\t * spot. */\n\t\tocfs2_append_cache_array(ci, bh->b_blocknr);\n\t\tocfs2_metadata_cache_unlock(ci);\n\t\treturn;\n\t}\n\n\texpand = 0;\n\tif (ci->ci_flags & OCFS2_CACHE_FL_INLINE) {\n\t\t/* We need to bump things up to a tree. */\n\t\texpand = 1;\n\t}\n\tocfs2_metadata_cache_unlock(ci);\n\n\t__ocfs2_set_buffer_uptodate(ci, bh->b_blocknr, expand);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t       struct buffer_head *bh)\n{\n\tint expand;\n\n\t/* The block may very well exist in our cache already, so avoid\n\t * doing any more work in that case. */\n\tif (ocfs2_buffer_cached(ci, bh))\n\t\treturn;\n\n\ttrace_ocfs2_set_buffer_uptodate_begin(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr);\n\n\t/* No need to recheck under spinlock - insertion is guarded by\n\t * co_io_lock() */\n\tocfs2_metadata_cache_lock(ci);\n\tif (ocfs2_insert_can_use_array(ci)) {\n\t\t/* Fast case - it's an array and there's a free\n\t\t * spot. */\n\t\tocfs2_append_cache_array(ci, bh->b_blocknr);\n\t\tocfs2_metadata_cache_unlock(ci);\n\t\treturn;\n\t}\n\n\texpand = 0;\n\tif (ci->ci_flags & OCFS2_CACHE_FL_INLINE) {\n\t\t/* We need to bump things up to a tree. */\n\t\texpand = 1;\n\t}\n\tocfs2_metadata_cache_unlock(ci);\n\n\t__ocfs2_set_buffer_uptodate(ci, bh->b_blocknr, expand);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "bucket->bu_inode"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bucket->bu_bhs[i]"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(bucket->bu_inode)",
            "bucket->bu_bhs[i]"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_buffer_uptodate",
          "args": [
            "INODE_CACHE(bucket->bu_inode)",
            "bucket->bu_bhs[i]"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "273-290",
          "snippet": "int ocfs2_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t  struct buffer_head *bh)\n{\n\t/* Doesn't matter if the bh is in our cache or not -- if it's\n\t * not marked uptodate then we know it can't have correct\n\t * data. */\n\tif (!buffer_uptodate(bh))\n\t\treturn 0;\n\n\t/* OCFS2 does not allow multiple nodes to be changing the same\n\t * block at the same time. */\n\tif (buffer_jbd(bh))\n\t\treturn 1;\n\n\t/* Ok, locally the buffer is marked as up to date, now search\n\t * our cache to see if we can trust that. */\n\treturn ocfs2_buffer_cached(ci, bh);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t  struct buffer_head *bh)\n{\n\t/* Doesn't matter if the bh is in our cache or not -- if it's\n\t * not marked uptodate then we know it can't have correct\n\t * data. */\n\tif (!buffer_uptodate(bh))\n\t\treturn 0;\n\n\t/* OCFS2 does not allow multiple nodes to be changing the same\n\t * block at the same time. */\n\tif (buffer_jbd(bh))\n\t\treturn 1;\n\n\t/* Ok, locally the buffer is marked as up to date, now search\n\t * our cache to see if we can trust that. */\n\treturn ocfs2_buffer_cached(ci, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "bucket->bu_inode->i_sb",
            "xb_blkno + i"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_init_xattr_bucket(struct ocfs2_xattr_bucket *bucket,\n\t\t\t\t   u64 xb_blkno, int new)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbucket->bu_bhs[i] = sb_getblk(bucket->bu_inode->i_sb,\n\t\t\t\t\t      xb_blkno + i);\n\t\tif (!bucket->bu_bhs[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ocfs2_buffer_uptodate(INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t   bucket->bu_bhs[i])) {\n\t\t\tif (new)\n\t\t\t\tocfs2_set_new_buffer_uptodate(INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t\t\t      bucket->bu_bhs[i]);\n\t\t\telse {\n\t\t\t\tset_buffer_uptodate(bucket->bu_bhs[i]);\n\t\t\t\tocfs2_set_buffer_uptodate(INODE_CACHE(bucket->bu_inode),\n\t\t\t\t\t\t\t  bucket->bu_bhs[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rc)\n\t\tocfs2_xattr_bucket_relse(bucket);\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_xattr_bucket_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "356-363",
    "snippet": "static void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bucket"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_bucket_relse",
          "args": [
            "bucket"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_bucket_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "346-354",
          "snippet": "static void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_free(struct ocfs2_xattr_bucket *bucket)\n{\n\tif (bucket) {\n\t\tocfs2_xattr_bucket_relse(bucket);\n\t\tbucket->bu_inode = NULL;\n\t\tkfree(bucket);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_xattr_bucket_relse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "346-354",
    "snippet": "static void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bucket->bu_bhs[i]"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_xattr_bucket_relse(struct ocfs2_xattr_bucket *bucket)\n{\n\tint i;\n\n\tfor (i = 0; i < bucket->bu_blocks; i++) {\n\t\tbrelse(bucket->bu_bhs[i]);\n\t\tbucket->bu_bhs[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_xattr_bucket_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "330-344",
    "snippet": "static struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_xattr_bucket)",
            "GFP_NOFS"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_per_xattr_bucket",
          "args": [
            "inode->i_sb"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_per_xattr_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "321-324",
          "snippet": "static inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic struct ocfs2_xattr_bucket *ocfs2_xattr_bucket_new(struct inode *inode)\n{\n\tstruct ocfs2_xattr_bucket *bucket;\n\tint blks = ocfs2_blocks_per_xattr_bucket(inode->i_sb);\n\n\tBUG_ON(blks > OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET);\n\n\tbucket = kzalloc(sizeof(struct ocfs2_xattr_bucket), GFP_NOFS);\n\tif (bucket) {\n\t\tbucket->bu_inode = inode;\n\t\tbucket->bu_blocks = blks;\n\t}\n\n\treturn bucket;\n}"
  },
  {
    "function_name": "ocfs2_blocks_per_xattr_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "321-324",
    "snippet": "static inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)\n{\n\treturn OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);\n}"
  },
  {
    "function_name": "ocfs2_xattr_buckets_per_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "316-319",
    "snippet": "static inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)\n{\n\treturn (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;\n}"
  },
  {
    "function_name": "namevalue_size_xe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "241-248",
    "snippet": "static int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_INLINE_SIZE\t80"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "namevalue_size",
          "args": [
            "xe->xe_name_len",
            "value_len"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "228-234",
          "snippet": "static int namevalue_size(int name_len, uint64_t value_len)\n{\n\tif (value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_ROOT_SIZE;\n\telse\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_SIZE(value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80",
            "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic int namevalue_size(int name_len, uint64_t value_len)\n{\n\tif (value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_ROOT_SIZE;\n\telse\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_SIZE(value_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_is_local",
          "args": [
            "xe"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_is_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1143-1146",
          "snippet": "static inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_XATTR_ENTRY_LOCAL\t\t0x80\n\nstatic inline int ocfs2_xattr_is_local(struct ocfs2_xattr_entry *xe)\n{\n\treturn xe->xe_type & OCFS2_XATTR_ENTRY_LOCAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "xe->xe_value_size"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n\nstatic int namevalue_size_xe(struct ocfs2_xattr_entry *xe)\n{\n\tu64 value_len = le64_to_cpu(xe->xe_value_size);\n\n\tBUG_ON((value_len > OCFS2_XATTR_INLINE_SIZE) &&\n\t       ocfs2_xattr_is_local(xe));\n\treturn namevalue_size(xe->xe_name_len, value_len);\n}"
  },
  {
    "function_name": "namevalue_size_xi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "236-239",
    "snippet": "static int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "namevalue_size",
          "args": [
            "xi->xi_name_len",
            "xi->xi_value_len"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "namevalue_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "228-234",
          "snippet": "static int namevalue_size(int name_len, uint64_t value_len)\n{\n\tif (value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_ROOT_SIZE;\n\telse\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_SIZE(value_len);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define OCFS2_XATTR_INLINE_SIZE\t80",
            "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic int namevalue_size(int name_len, uint64_t value_len)\n{\n\tif (value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_ROOT_SIZE;\n\telse\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_SIZE(value_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int namevalue_size_xi(struct ocfs2_xattr_info *xi)\n{\n\treturn namevalue_size(xi->xi_name_len, xi->xi_value_len);\n}"
  },
  {
    "function_name": "namevalue_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
    "lines": "228-234",
    "snippet": "static int namevalue_size(int name_len, uint64_t value_len)\n{\n\tif (value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_ROOT_SIZE;\n\telse\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_SIZE(value_len);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"acl.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"symlink.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/sort.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_XATTR_INLINE_SIZE\t80",
      "#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "value_len"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "name_len"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_XATTR_SIZE",
          "args": [
            "name_len"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_XATTR_INLINE_SIZE\t80\n#define OCFS2_XATTR_ROOT_SIZE\t(sizeof(struct ocfs2_xattr_def_value_root))\n\nstatic int namevalue_size(int name_len, uint64_t value_len)\n{\n\tif (value_len > OCFS2_XATTR_INLINE_SIZE)\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_ROOT_SIZE;\n\telse\n\t\treturn OCFS2_XATTR_SIZE(name_len) + OCFS2_XATTR_SIZE(value_len);\n}"
  }
]