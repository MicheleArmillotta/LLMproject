[
  {
    "function_name": "ext4_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
    "lines": "625-688",
    "snippet": "long ext4_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\t/* These are just misnamed, they actually get/put from/to user an int */\n\tswitch (cmd) {\n\tcase EXT4_IOC32_GETFLAGS:\n\t\tcmd = EXT4_IOC_GETFLAGS;\n\t\tbreak;\n\tcase EXT4_IOC32_SETFLAGS:\n\t\tcmd = EXT4_IOC_SETFLAGS;\n\t\tbreak;\n\tcase EXT4_IOC32_GETVERSION:\n\t\tcmd = EXT4_IOC_GETVERSION;\n\t\tbreak;\n\tcase EXT4_IOC32_SETVERSION:\n\t\tcmd = EXT4_IOC_SETVERSION;\n\t\tbreak;\n\tcase EXT4_IOC32_GROUP_EXTEND:\n\t\tcmd = EXT4_IOC_GROUP_EXTEND;\n\t\tbreak;\n\tcase EXT4_IOC32_GETVERSION_OLD:\n\t\tcmd = EXT4_IOC_GETVERSION_OLD;\n\t\tbreak;\n\tcase EXT4_IOC32_SETVERSION_OLD:\n\t\tcmd = EXT4_IOC_SETVERSION_OLD;\n\t\tbreak;\n\tcase EXT4_IOC32_GETRSVSZ:\n\t\tcmd = EXT4_IOC_GETRSVSZ;\n\t\tbreak;\n\tcase EXT4_IOC32_SETRSVSZ:\n\t\tcmd = EXT4_IOC_SETRSVSZ;\n\t\tbreak;\n\tcase EXT4_IOC32_GROUP_ADD: {\n\t\tstruct compat_ext4_new_group_input __user *uinput;\n\t\tstruct ext4_new_group_input input;\n\t\tmm_segment_t old_fs;\n\t\tint err;\n\n\t\tuinput = compat_ptr(arg);\n\t\terr = get_user(input.group, &uinput->group);\n\t\terr |= get_user(input.block_bitmap, &uinput->block_bitmap);\n\t\terr |= get_user(input.inode_bitmap, &uinput->inode_bitmap);\n\t\terr |= get_user(input.inode_table, &uinput->inode_table);\n\t\terr |= get_user(input.blocks_count, &uinput->blocks_count);\n\t\terr |= get_user(input.reserved_blocks,\n\t\t\t\t&uinput->reserved_blocks);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t\told_fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = ext4_ioctl(file, EXT4_IOC_GROUP_ADD,\n\t\t\t\t (unsigned long) &input);\n\t\tset_fs(old_fs);\n\t\treturn err;\n\t}\n\tcase EXT4_IOC_MOVE_EXT:\n\tcase FITRIM:\n\tcase EXT4_IOC_RESIZE_FS:\n\tcase EXT4_IOC_PRECACHE_EXTENTS:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn ext4_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/capability.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_ioctl",
          "args": [
            "file",
            "cmd",
            "(unsigned long) compat_ptr(arg)"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
          "lines": "199-622",
          "snippet": "long ext4_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int flags;\n\n\text4_debug(\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT4_IOC_GETFLAGS:\n\t\text4_get_inode_flags(ei);\n\t\tflags = ei->i_flags & EXT4_FL_USER_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase EXT4_IOC_SETFLAGS: {\n\t\thandle_t *handle = NULL;\n\t\tint err, migrate = 0;\n\t\tstruct ext4_iloc iloc;\n\t\tunsigned int oldflags, mask, i;\n\t\tunsigned int jflag;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tflags = ext4_mask_flags(inode->i_mode, flags);\n\n\t\terr = -EPERM;\n\t\tmutex_lock(&inode->i_mutex);\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\tif (IS_NOQUOTA(inode))\n\t\t\tgoto flags_out;\n\n\t\toldflags = ei->i_flags;\n\n\t\t/* The JOURNAL_DATA flag is modifiable only by root */\n\t\tjflag = flags & EXT4_JOURNAL_DATA_FL;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t *\n\t\t * This test looks nicer. Thanks to Pauline Middelink\n\t\t */\n\t\tif ((flags ^ oldflags) & (EXT4_APPEND_FL | EXT4_IMMUTABLE_FL)) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\n\t\t/*\n\t\t * The JOURNAL_DATA flag can only be changed by\n\t\t * the relevant capability.\n\t\t */\n\t\tif ((jflag ^ oldflags) & (EXT4_JOURNAL_DATA_FL)) {\n\t\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\t\tif ((flags ^ oldflags) & EXT4_EXTENTS_FL)\n\t\t\tmigrate = 1;\n\n\t\tif (flags & EXT4_EOFBLOCKS_FL) {\n\t\t\t/* we don't support adding EOFBLOCKS flag */\n\t\t\tif (!(oldflags & EXT4_EOFBLOCKS_FL)) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto flags_out;\n\t\t\t}\n\t\t} else if (oldflags & EXT4_EOFBLOCKS_FL)\n\t\t\text4_truncate(inode);\n\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto flags_out;\n\t\t}\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err)\n\t\t\tgoto flags_err;\n\n\t\tfor (i = 0, mask = 1; i < 32; i++, mask <<= 1) {\n\t\t\tif (!(mask & EXT4_FL_USER_MODIFIABLE))\n\t\t\t\tcontinue;\n\t\t\tif (mask & flags)\n\t\t\t\text4_set_inode_flag(inode, i);\n\t\t\telse\n\t\t\t\text4_clear_inode_flag(inode, i);\n\t\t}\n\n\t\text4_set_inode_flags(inode);\n\t\tinode->i_ctime = ext4_current_time(inode);\n\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nflags_err:\n\t\text4_journal_stop(handle);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\n\t\tif ((jflag ^ oldflags) & (EXT4_JOURNAL_DATA_FL))\n\t\t\terr = ext4_change_inode_journal_flag(inode, jflag);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\t\tif (migrate) {\n\t\t\tif (flags & EXT4_EXTENTS_FL)\n\t\t\t\terr = ext4_ext_migrate(inode);\n\t\t\telse\n\t\t\t\terr = ext4_ind_migrate(inode);\n\t\t}\n\nflags_out:\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT4_IOC_GETVERSION:\n\tcase EXT4_IOC_GETVERSION_OLD:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT4_IOC_SETVERSION:\n\tcase EXT4_IOC_SETVERSION_OLD: {\n\t\thandle_t *handle;\n\t\tstruct ext4_iloc iloc;\n\t\t__u32 generation;\n\t\tint err;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (ext4_has_metadata_csum(inode->i_sb)) {\n\t\t\text4_warning(sb, \"Setting inode version is not \"\n\t\t\t\t     \"supported with metadata_csum enabled.\");\n\t\t\treturn -ENOTTY;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock_out;\n\t\t}\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err == 0) {\n\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\tinode->i_generation = generation;\n\t\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\t}\n\t\text4_journal_stop(handle);\n\nunlock_out:\n\t\tmutex_unlock(&inode->i_mutex);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT4_IOC_GROUP_EXTEND: {\n\t\text4_fsblk_t n_blocks_count;\n\t\tint err, err2=0;\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (get_user(n_blocks_count, (__u32 __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_extend_out;\n\t\t}\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online resizing not supported with bigalloc\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto group_extend_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto group_extend_out;\n\n\t\terr = ext4_group_extend(sb, EXT4_SB(sb)->s_es, n_blocks_count);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\ngroup_extend_out:\n\t\text4_resize_end(sb);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_MOVE_EXT: {\n\t\tstruct move_extent me;\n\t\tstruct fd donor;\n\t\tint err;\n\n\t\tif (!(filp->f_mode & FMODE_READ) ||\n\t\t    !(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\n\t\tif (copy_from_user(&me,\n\t\t\t(struct move_extent __user *)arg, sizeof(me)))\n\t\t\treturn -EFAULT;\n\t\tme.moved_len = 0;\n\n\t\tdonor = fdget(me.donor_fd);\n\t\tif (!donor.file)\n\t\t\treturn -EBADF;\n\n\t\tif (!(donor.file->f_mode & FMODE_WRITE)) {\n\t\t\terr = -EBADF;\n\t\t\tgoto mext_out;\n\t\t}\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online defrag not supported with bigalloc\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto mext_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto mext_out;\n\n\t\terr = ext4_move_extents(filp, donor.file, me.orig_start,\n\t\t\t\t\tme.donor_start, me.len, &me.moved_len);\n\t\tmnt_drop_write_file(filp);\n\n\t\tif (copy_to_user((struct move_extent __user *)arg,\n\t\t\t\t &me, sizeof(me)))\n\t\t\terr = -EFAULT;\nmext_out:\n\t\tfdput(donor);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_GROUP_ADD: {\n\t\tstruct ext4_new_group_data input;\n\t\tint err, err2=0;\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (copy_from_user(&input, (struct ext4_new_group_input __user *)arg,\n\t\t\t\tsizeof(input))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_add_out;\n\t\t}\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online resizing not supported with bigalloc\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto group_add_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto group_add_out;\n\n\t\terr = ext4_group_add(sb, &input);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\n\t\tif (!err && ext4_has_group_desc_csum(sb) &&\n\t\t    test_opt(sb, INIT_INODE_TABLE))\n\t\t\terr = ext4_register_li_request(sb, input.group);\ngroup_add_out:\n\t\text4_resize_end(sb);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_MIGRATE:\n\t{\n\t\tint err;\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * inode_mutex prevent write and truncate on the file.\n\t\t * Read still goes through. We take i_data_sem in\n\t\t * ext4_ext_swap_inode_data before we switch the\n\t\t * inode format to prevent read.\n\t\t */\n\t\tmutex_lock(&(inode->i_mutex));\n\t\terr = ext4_ext_migrate(inode);\n\t\tmutex_unlock(&(inode->i_mutex));\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_ALLOC_DA_BLKS:\n\t{\n\t\tint err;\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = ext4_alloc_da_blocks(inode);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_SWAP_BOOT:\n\t{\n\t\tint err;\n\t\tif (!(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = swap_inode_boot_loader(sb, inode);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_RESIZE_FS: {\n\t\text4_fsblk_t n_blocks_count;\n\t\tint err = 0, err2 = 0;\n\t\text4_group_t o_group = EXT4_SB(sb)->s_groups_count;\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online resizing not (yet) supported with bigalloc\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (copy_from_user(&n_blocks_count, (__u64 __user *)arg,\n\t\t\t\t   sizeof(__u64))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto resizefs_out;\n\n\t\terr = ext4_resize_fs(sb, n_blocks_count);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\n\t\tif (!err && (o_group > EXT4_SB(sb)->s_groups_count) &&\n\t\t    ext4_has_group_desc_csum(sb) &&\n\t\t    test_opt(sb, INIT_INODE_TABLE))\n\t\t\terr = ext4_register_li_request(sb, o_group);\n\nresizefs_out:\n\t\text4_resize_end(sb);\n\t\treturn err;\n\t}\n\n\tcase FITRIM:\n\t{\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!blk_queue_discard(q))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max((unsigned int)range.minlen,\n\t\t\t\t   q->limits.discard_granularity);\n\t\tret = ext4_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase EXT4_IOC_PRECACHE_EXTENTS:\n\t\treturn ext4_ext_precache(inode);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/capability.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nlong ext4_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int flags;\n\n\text4_debug(\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT4_IOC_GETFLAGS:\n\t\text4_get_inode_flags(ei);\n\t\tflags = ei->i_flags & EXT4_FL_USER_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase EXT4_IOC_SETFLAGS: {\n\t\thandle_t *handle = NULL;\n\t\tint err, migrate = 0;\n\t\tstruct ext4_iloc iloc;\n\t\tunsigned int oldflags, mask, i;\n\t\tunsigned int jflag;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tflags = ext4_mask_flags(inode->i_mode, flags);\n\n\t\terr = -EPERM;\n\t\tmutex_lock(&inode->i_mutex);\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\tif (IS_NOQUOTA(inode))\n\t\t\tgoto flags_out;\n\n\t\toldflags = ei->i_flags;\n\n\t\t/* The JOURNAL_DATA flag is modifiable only by root */\n\t\tjflag = flags & EXT4_JOURNAL_DATA_FL;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t *\n\t\t * This test looks nicer. Thanks to Pauline Middelink\n\t\t */\n\t\tif ((flags ^ oldflags) & (EXT4_APPEND_FL | EXT4_IMMUTABLE_FL)) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\n\t\t/*\n\t\t * The JOURNAL_DATA flag can only be changed by\n\t\t * the relevant capability.\n\t\t */\n\t\tif ((jflag ^ oldflags) & (EXT4_JOURNAL_DATA_FL)) {\n\t\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\t\tif ((flags ^ oldflags) & EXT4_EXTENTS_FL)\n\t\t\tmigrate = 1;\n\n\t\tif (flags & EXT4_EOFBLOCKS_FL) {\n\t\t\t/* we don't support adding EOFBLOCKS flag */\n\t\t\tif (!(oldflags & EXT4_EOFBLOCKS_FL)) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto flags_out;\n\t\t\t}\n\t\t} else if (oldflags & EXT4_EOFBLOCKS_FL)\n\t\t\text4_truncate(inode);\n\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto flags_out;\n\t\t}\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err)\n\t\t\tgoto flags_err;\n\n\t\tfor (i = 0, mask = 1; i < 32; i++, mask <<= 1) {\n\t\t\tif (!(mask & EXT4_FL_USER_MODIFIABLE))\n\t\t\t\tcontinue;\n\t\t\tif (mask & flags)\n\t\t\t\text4_set_inode_flag(inode, i);\n\t\t\telse\n\t\t\t\text4_clear_inode_flag(inode, i);\n\t\t}\n\n\t\text4_set_inode_flags(inode);\n\t\tinode->i_ctime = ext4_current_time(inode);\n\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nflags_err:\n\t\text4_journal_stop(handle);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\n\t\tif ((jflag ^ oldflags) & (EXT4_JOURNAL_DATA_FL))\n\t\t\terr = ext4_change_inode_journal_flag(inode, jflag);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\t\tif (migrate) {\n\t\t\tif (flags & EXT4_EXTENTS_FL)\n\t\t\t\terr = ext4_ext_migrate(inode);\n\t\t\telse\n\t\t\t\terr = ext4_ind_migrate(inode);\n\t\t}\n\nflags_out:\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT4_IOC_GETVERSION:\n\tcase EXT4_IOC_GETVERSION_OLD:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT4_IOC_SETVERSION:\n\tcase EXT4_IOC_SETVERSION_OLD: {\n\t\thandle_t *handle;\n\t\tstruct ext4_iloc iloc;\n\t\t__u32 generation;\n\t\tint err;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (ext4_has_metadata_csum(inode->i_sb)) {\n\t\t\text4_warning(sb, \"Setting inode version is not \"\n\t\t\t\t     \"supported with metadata_csum enabled.\");\n\t\t\treturn -ENOTTY;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock_out;\n\t\t}\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err == 0) {\n\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\tinode->i_generation = generation;\n\t\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\t}\n\t\text4_journal_stop(handle);\n\nunlock_out:\n\t\tmutex_unlock(&inode->i_mutex);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT4_IOC_GROUP_EXTEND: {\n\t\text4_fsblk_t n_blocks_count;\n\t\tint err, err2=0;\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (get_user(n_blocks_count, (__u32 __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_extend_out;\n\t\t}\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online resizing not supported with bigalloc\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto group_extend_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto group_extend_out;\n\n\t\terr = ext4_group_extend(sb, EXT4_SB(sb)->s_es, n_blocks_count);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\ngroup_extend_out:\n\t\text4_resize_end(sb);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_MOVE_EXT: {\n\t\tstruct move_extent me;\n\t\tstruct fd donor;\n\t\tint err;\n\n\t\tif (!(filp->f_mode & FMODE_READ) ||\n\t\t    !(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\n\t\tif (copy_from_user(&me,\n\t\t\t(struct move_extent __user *)arg, sizeof(me)))\n\t\t\treturn -EFAULT;\n\t\tme.moved_len = 0;\n\n\t\tdonor = fdget(me.donor_fd);\n\t\tif (!donor.file)\n\t\t\treturn -EBADF;\n\n\t\tif (!(donor.file->f_mode & FMODE_WRITE)) {\n\t\t\terr = -EBADF;\n\t\t\tgoto mext_out;\n\t\t}\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online defrag not supported with bigalloc\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto mext_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto mext_out;\n\n\t\terr = ext4_move_extents(filp, donor.file, me.orig_start,\n\t\t\t\t\tme.donor_start, me.len, &me.moved_len);\n\t\tmnt_drop_write_file(filp);\n\n\t\tif (copy_to_user((struct move_extent __user *)arg,\n\t\t\t\t &me, sizeof(me)))\n\t\t\terr = -EFAULT;\nmext_out:\n\t\tfdput(donor);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_GROUP_ADD: {\n\t\tstruct ext4_new_group_data input;\n\t\tint err, err2=0;\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (copy_from_user(&input, (struct ext4_new_group_input __user *)arg,\n\t\t\t\tsizeof(input))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_add_out;\n\t\t}\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online resizing not supported with bigalloc\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto group_add_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto group_add_out;\n\n\t\terr = ext4_group_add(sb, &input);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\n\t\tif (!err && ext4_has_group_desc_csum(sb) &&\n\t\t    test_opt(sb, INIT_INODE_TABLE))\n\t\t\terr = ext4_register_li_request(sb, input.group);\ngroup_add_out:\n\t\text4_resize_end(sb);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_MIGRATE:\n\t{\n\t\tint err;\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * inode_mutex prevent write and truncate on the file.\n\t\t * Read still goes through. We take i_data_sem in\n\t\t * ext4_ext_swap_inode_data before we switch the\n\t\t * inode format to prevent read.\n\t\t */\n\t\tmutex_lock(&(inode->i_mutex));\n\t\terr = ext4_ext_migrate(inode);\n\t\tmutex_unlock(&(inode->i_mutex));\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_ALLOC_DA_BLKS:\n\t{\n\t\tint err;\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = ext4_alloc_da_blocks(inode);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_SWAP_BOOT:\n\t{\n\t\tint err;\n\t\tif (!(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = swap_inode_boot_loader(sb, inode);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_RESIZE_FS: {\n\t\text4_fsblk_t n_blocks_count;\n\t\tint err = 0, err2 = 0;\n\t\text4_group_t o_group = EXT4_SB(sb)->s_groups_count;\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online resizing not (yet) supported with bigalloc\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (copy_from_user(&n_blocks_count, (__u64 __user *)arg,\n\t\t\t\t   sizeof(__u64))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto resizefs_out;\n\n\t\terr = ext4_resize_fs(sb, n_blocks_count);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\n\t\tif (!err && (o_group > EXT4_SB(sb)->s_groups_count) &&\n\t\t    ext4_has_group_desc_csum(sb) &&\n\t\t    test_opt(sb, INIT_INODE_TABLE))\n\t\t\terr = ext4_register_li_request(sb, o_group);\n\nresizefs_out:\n\t\text4_resize_end(sb);\n\t\treturn err;\n\t}\n\n\tcase FITRIM:\n\t{\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!blk_queue_discard(q))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max((unsigned int)range.minlen,\n\t\t\t\t   q->limits.discard_granularity);\n\t\tret = ext4_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase EXT4_IOC_PRECACHE_EXTENTS:\n\t\treturn ext4_ext_precache(inode);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "KERNEL_DS"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "input.reserved_blocks",
            "&uinput->reserved_blocks"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nlong ext4_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\t/* These are just misnamed, they actually get/put from/to user an int */\n\tswitch (cmd) {\n\tcase EXT4_IOC32_GETFLAGS:\n\t\tcmd = EXT4_IOC_GETFLAGS;\n\t\tbreak;\n\tcase EXT4_IOC32_SETFLAGS:\n\t\tcmd = EXT4_IOC_SETFLAGS;\n\t\tbreak;\n\tcase EXT4_IOC32_GETVERSION:\n\t\tcmd = EXT4_IOC_GETVERSION;\n\t\tbreak;\n\tcase EXT4_IOC32_SETVERSION:\n\t\tcmd = EXT4_IOC_SETVERSION;\n\t\tbreak;\n\tcase EXT4_IOC32_GROUP_EXTEND:\n\t\tcmd = EXT4_IOC_GROUP_EXTEND;\n\t\tbreak;\n\tcase EXT4_IOC32_GETVERSION_OLD:\n\t\tcmd = EXT4_IOC_GETVERSION_OLD;\n\t\tbreak;\n\tcase EXT4_IOC32_SETVERSION_OLD:\n\t\tcmd = EXT4_IOC_SETVERSION_OLD;\n\t\tbreak;\n\tcase EXT4_IOC32_GETRSVSZ:\n\t\tcmd = EXT4_IOC_GETRSVSZ;\n\t\tbreak;\n\tcase EXT4_IOC32_SETRSVSZ:\n\t\tcmd = EXT4_IOC_SETRSVSZ;\n\t\tbreak;\n\tcase EXT4_IOC32_GROUP_ADD: {\n\t\tstruct compat_ext4_new_group_input __user *uinput;\n\t\tstruct ext4_new_group_input input;\n\t\tmm_segment_t old_fs;\n\t\tint err;\n\n\t\tuinput = compat_ptr(arg);\n\t\terr = get_user(input.group, &uinput->group);\n\t\terr |= get_user(input.block_bitmap, &uinput->block_bitmap);\n\t\terr |= get_user(input.inode_bitmap, &uinput->inode_bitmap);\n\t\terr |= get_user(input.inode_table, &uinput->inode_table);\n\t\terr |= get_user(input.blocks_count, &uinput->blocks_count);\n\t\terr |= get_user(input.reserved_blocks,\n\t\t\t\t&uinput->reserved_blocks);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t\told_fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = ext4_ioctl(file, EXT4_IOC_GROUP_ADD,\n\t\t\t\t (unsigned long) &input);\n\t\tset_fs(old_fs);\n\t\treturn err;\n\t}\n\tcase EXT4_IOC_MOVE_EXT:\n\tcase FITRIM:\n\tcase EXT4_IOC_RESIZE_FS:\n\tcase EXT4_IOC_PRECACHE_EXTENTS:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn ext4_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}"
  },
  {
    "function_name": "ext4_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
    "lines": "199-622",
    "snippet": "long ext4_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int flags;\n\n\text4_debug(\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT4_IOC_GETFLAGS:\n\t\text4_get_inode_flags(ei);\n\t\tflags = ei->i_flags & EXT4_FL_USER_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase EXT4_IOC_SETFLAGS: {\n\t\thandle_t *handle = NULL;\n\t\tint err, migrate = 0;\n\t\tstruct ext4_iloc iloc;\n\t\tunsigned int oldflags, mask, i;\n\t\tunsigned int jflag;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tflags = ext4_mask_flags(inode->i_mode, flags);\n\n\t\terr = -EPERM;\n\t\tmutex_lock(&inode->i_mutex);\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\tif (IS_NOQUOTA(inode))\n\t\t\tgoto flags_out;\n\n\t\toldflags = ei->i_flags;\n\n\t\t/* The JOURNAL_DATA flag is modifiable only by root */\n\t\tjflag = flags & EXT4_JOURNAL_DATA_FL;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t *\n\t\t * This test looks nicer. Thanks to Pauline Middelink\n\t\t */\n\t\tif ((flags ^ oldflags) & (EXT4_APPEND_FL | EXT4_IMMUTABLE_FL)) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\n\t\t/*\n\t\t * The JOURNAL_DATA flag can only be changed by\n\t\t * the relevant capability.\n\t\t */\n\t\tif ((jflag ^ oldflags) & (EXT4_JOURNAL_DATA_FL)) {\n\t\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\t\tif ((flags ^ oldflags) & EXT4_EXTENTS_FL)\n\t\t\tmigrate = 1;\n\n\t\tif (flags & EXT4_EOFBLOCKS_FL) {\n\t\t\t/* we don't support adding EOFBLOCKS flag */\n\t\t\tif (!(oldflags & EXT4_EOFBLOCKS_FL)) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto flags_out;\n\t\t\t}\n\t\t} else if (oldflags & EXT4_EOFBLOCKS_FL)\n\t\t\text4_truncate(inode);\n\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto flags_out;\n\t\t}\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err)\n\t\t\tgoto flags_err;\n\n\t\tfor (i = 0, mask = 1; i < 32; i++, mask <<= 1) {\n\t\t\tif (!(mask & EXT4_FL_USER_MODIFIABLE))\n\t\t\t\tcontinue;\n\t\t\tif (mask & flags)\n\t\t\t\text4_set_inode_flag(inode, i);\n\t\t\telse\n\t\t\t\text4_clear_inode_flag(inode, i);\n\t\t}\n\n\t\text4_set_inode_flags(inode);\n\t\tinode->i_ctime = ext4_current_time(inode);\n\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nflags_err:\n\t\text4_journal_stop(handle);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\n\t\tif ((jflag ^ oldflags) & (EXT4_JOURNAL_DATA_FL))\n\t\t\terr = ext4_change_inode_journal_flag(inode, jflag);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\t\tif (migrate) {\n\t\t\tif (flags & EXT4_EXTENTS_FL)\n\t\t\t\terr = ext4_ext_migrate(inode);\n\t\t\telse\n\t\t\t\terr = ext4_ind_migrate(inode);\n\t\t}\n\nflags_out:\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT4_IOC_GETVERSION:\n\tcase EXT4_IOC_GETVERSION_OLD:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT4_IOC_SETVERSION:\n\tcase EXT4_IOC_SETVERSION_OLD: {\n\t\thandle_t *handle;\n\t\tstruct ext4_iloc iloc;\n\t\t__u32 generation;\n\t\tint err;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (ext4_has_metadata_csum(inode->i_sb)) {\n\t\t\text4_warning(sb, \"Setting inode version is not \"\n\t\t\t\t     \"supported with metadata_csum enabled.\");\n\t\t\treturn -ENOTTY;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock_out;\n\t\t}\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err == 0) {\n\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\tinode->i_generation = generation;\n\t\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\t}\n\t\text4_journal_stop(handle);\n\nunlock_out:\n\t\tmutex_unlock(&inode->i_mutex);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT4_IOC_GROUP_EXTEND: {\n\t\text4_fsblk_t n_blocks_count;\n\t\tint err, err2=0;\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (get_user(n_blocks_count, (__u32 __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_extend_out;\n\t\t}\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online resizing not supported with bigalloc\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto group_extend_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto group_extend_out;\n\n\t\terr = ext4_group_extend(sb, EXT4_SB(sb)->s_es, n_blocks_count);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\ngroup_extend_out:\n\t\text4_resize_end(sb);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_MOVE_EXT: {\n\t\tstruct move_extent me;\n\t\tstruct fd donor;\n\t\tint err;\n\n\t\tif (!(filp->f_mode & FMODE_READ) ||\n\t\t    !(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\n\t\tif (copy_from_user(&me,\n\t\t\t(struct move_extent __user *)arg, sizeof(me)))\n\t\t\treturn -EFAULT;\n\t\tme.moved_len = 0;\n\n\t\tdonor = fdget(me.donor_fd);\n\t\tif (!donor.file)\n\t\t\treturn -EBADF;\n\n\t\tif (!(donor.file->f_mode & FMODE_WRITE)) {\n\t\t\terr = -EBADF;\n\t\t\tgoto mext_out;\n\t\t}\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online defrag not supported with bigalloc\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto mext_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto mext_out;\n\n\t\terr = ext4_move_extents(filp, donor.file, me.orig_start,\n\t\t\t\t\tme.donor_start, me.len, &me.moved_len);\n\t\tmnt_drop_write_file(filp);\n\n\t\tif (copy_to_user((struct move_extent __user *)arg,\n\t\t\t\t &me, sizeof(me)))\n\t\t\terr = -EFAULT;\nmext_out:\n\t\tfdput(donor);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_GROUP_ADD: {\n\t\tstruct ext4_new_group_data input;\n\t\tint err, err2=0;\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (copy_from_user(&input, (struct ext4_new_group_input __user *)arg,\n\t\t\t\tsizeof(input))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_add_out;\n\t\t}\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online resizing not supported with bigalloc\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto group_add_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto group_add_out;\n\n\t\terr = ext4_group_add(sb, &input);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\n\t\tif (!err && ext4_has_group_desc_csum(sb) &&\n\t\t    test_opt(sb, INIT_INODE_TABLE))\n\t\t\terr = ext4_register_li_request(sb, input.group);\ngroup_add_out:\n\t\text4_resize_end(sb);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_MIGRATE:\n\t{\n\t\tint err;\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * inode_mutex prevent write and truncate on the file.\n\t\t * Read still goes through. We take i_data_sem in\n\t\t * ext4_ext_swap_inode_data before we switch the\n\t\t * inode format to prevent read.\n\t\t */\n\t\tmutex_lock(&(inode->i_mutex));\n\t\terr = ext4_ext_migrate(inode);\n\t\tmutex_unlock(&(inode->i_mutex));\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_ALLOC_DA_BLKS:\n\t{\n\t\tint err;\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = ext4_alloc_da_blocks(inode);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_SWAP_BOOT:\n\t{\n\t\tint err;\n\t\tif (!(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = swap_inode_boot_loader(sb, inode);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_RESIZE_FS: {\n\t\text4_fsblk_t n_blocks_count;\n\t\tint err = 0, err2 = 0;\n\t\text4_group_t o_group = EXT4_SB(sb)->s_groups_count;\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online resizing not (yet) supported with bigalloc\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (copy_from_user(&n_blocks_count, (__u64 __user *)arg,\n\t\t\t\t   sizeof(__u64))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto resizefs_out;\n\n\t\terr = ext4_resize_fs(sb, n_blocks_count);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\n\t\tif (!err && (o_group > EXT4_SB(sb)->s_groups_count) &&\n\t\t    ext4_has_group_desc_csum(sb) &&\n\t\t    test_opt(sb, INIT_INODE_TABLE))\n\t\t\terr = ext4_register_li_request(sb, o_group);\n\nresizefs_out:\n\t\text4_resize_end(sb);\n\t\treturn err;\n\t}\n\n\tcase FITRIM:\n\t{\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!blk_queue_discard(q))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max((unsigned int)range.minlen,\n\t\t\t\t   q->limits.discard_granularity);\n\t\tret = ext4_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase EXT4_IOC_PRECACHE_EXTENTS:\n\t\treturn ext4_ext_precache(inode);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/capability.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_ext_precache",
          "args": [
            "inode"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_precache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "564-623",
          "snippet": "int ext4_ext_precache(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_ext_path *path = NULL;\n\tstruct buffer_head *bh;\n\tint i = 0, depth, ret = 0;\n\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\treturn 0;\t/* not an extent-mapped inode */\n\n\tdown_read(&ei->i_data_sem);\n\tdepth = ext_depth(inode);\n\n\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 1),\n\t\t       GFP_NOFS);\n\tif (path == NULL) {\n\t\tup_read(&ei->i_data_sem);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Don't cache anything if there are no external extent blocks */\n\tif (depth == 0)\n\t\tgoto out;\n\tpath[0].p_hdr = ext_inode_hdr(inode);\n\tret = ext4_ext_check(inode, path[0].p_hdr, depth, 0);\n\tif (ret)\n\t\tgoto out;\n\tpath[0].p_idx = EXT_FIRST_INDEX(path[0].p_hdr);\n\twhile (i >= 0) {\n\t\t/*\n\t\t * If this is a leaf block or we've reached the end of\n\t\t * the index block, go up\n\t\t */\n\t\tif ((i == depth) ||\n\t\t    path[i].p_idx > EXT_LAST_INDEX(path[i].p_hdr)) {\n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tbh = read_extent_tree_block(inode,\n\t\t\t\t\t    ext4_idx_pblock(path[i].p_idx++),\n\t\t\t\t\t    depth - i - 1,\n\t\t\t\t\t    EXT4_EX_FORCE_CACHE);\n\t\tif (IS_ERR(bh)) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tpath[i].p_bh = bh;\n\t\tpath[i].p_hdr = ext_block_hdr(bh);\n\t\tpath[i].p_idx = EXT_FIRST_INDEX(path[i].p_hdr);\n\t}\n\text4_set_inode_state(inode, EXT4_STATE_EXT_PRECACHED);\nout:\n\tup_read(&ei->i_data_sem);\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_ext_precache(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_ext_path *path = NULL;\n\tstruct buffer_head *bh;\n\tint i = 0, depth, ret = 0;\n\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\treturn 0;\t/* not an extent-mapped inode */\n\n\tdown_read(&ei->i_data_sem);\n\tdepth = ext_depth(inode);\n\n\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 1),\n\t\t       GFP_NOFS);\n\tif (path == NULL) {\n\t\tup_read(&ei->i_data_sem);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Don't cache anything if there are no external extent blocks */\n\tif (depth == 0)\n\t\tgoto out;\n\tpath[0].p_hdr = ext_inode_hdr(inode);\n\tret = ext4_ext_check(inode, path[0].p_hdr, depth, 0);\n\tif (ret)\n\t\tgoto out;\n\tpath[0].p_idx = EXT_FIRST_INDEX(path[0].p_hdr);\n\twhile (i >= 0) {\n\t\t/*\n\t\t * If this is a leaf block or we've reached the end of\n\t\t * the index block, go up\n\t\t */\n\t\tif ((i == depth) ||\n\t\t    path[i].p_idx > EXT_LAST_INDEX(path[i].p_hdr)) {\n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tbh = read_extent_tree_block(inode,\n\t\t\t\t\t    ext4_idx_pblock(path[i].p_idx++),\n\t\t\t\t\t    depth - i - 1,\n\t\t\t\t\t    EXT4_EX_FORCE_CACHE);\n\t\tif (IS_ERR(bh)) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tpath[i].p_bh = bh;\n\t\tpath[i].p_hdr = ext_block_hdr(bh);\n\t\tpath[i].p_idx = EXT_FIRST_INDEX(path[i].p_hdr);\n\t}\n\text4_set_inode_state(inode, EXT4_STATE_EXT_PRECACHED);\nout:\n\tup_read(&ei->i_data_sem);\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(struct fstrim_range __user *)arg",
            "&range",
            "sizeof(range)"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_trim_fs",
          "args": [
            "sb",
            "&range"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_trim_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "5161-5238",
          "snippet": "int ext4_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tstruct ext4_group_info *grp;\n\text4_group_t group, first_group, last_group;\n\text4_grpblk_t cnt = 0, first_cluster, last_cluster;\n\tuint64_t start, end, minlen, trimmed = 0;\n\text4_fsblk_t first_data_blk =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n\text4_fsblk_t max_blks = ext4_blocks_count(EXT4_SB(sb)->s_es);\n\tint ret = 0;\n\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = EXT4_NUM_B2C(EXT4_SB(sb),\n\t\t\t      range->minlen >> sb->s_blocksize_bits);\n\n\tif (minlen > EXT4_CLUSTERS_PER_GROUP(sb) ||\n\t    start >= max_blks ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\tif (end >= max_blks)\n\t\tend = max_blks - 1;\n\tif (end <= first_data_blk)\n\t\tgoto out;\n\tif (start < first_data_blk)\n\t\tstart = first_data_blk;\n\n\t/* Determine first and last group to examine based on start and end */\n\text4_get_group_no_and_offset(sb, (ext4_fsblk_t) start,\n\t\t\t\t     &first_group, &first_cluster);\n\text4_get_group_no_and_offset(sb, (ext4_fsblk_t) end,\n\t\t\t\t     &last_group, &last_cluster);\n\n\t/* end now represents the last cluster to discard in this group */\n\tend = EXT4_CLUSTERS_PER_GROUP(sb) - 1;\n\n\tfor (group = first_group; group <= last_group; group++) {\n\t\tgrp = ext4_get_group_info(sb, group);\n\t\t/* We only do this if the grp has never been initialized */\n\t\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t\tret = ext4_mb_init_group(sb, group);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For all the groups except the last one, last cluster will\n\t\t * always be EXT4_CLUSTERS_PER_GROUP(sb)-1, so we only need to\n\t\t * change it for the last group, note that last_cluster is\n\t\t * already computed earlier by ext4_get_group_no_and_offset()\n\t\t */\n\t\tif (group == last_group)\n\t\t\tend = last_cluster;\n\n\t\tif (grp->bb_free >= minlen) {\n\t\t\tcnt = ext4_trim_all_free(sb, group, first_cluster,\n\t\t\t\t\t\tend, minlen);\n\t\t\tif (cnt < 0) {\n\t\t\t\tret = cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttrimmed += cnt;\n\t\t}\n\n\t\t/*\n\t\t * For every group except the first one, we are sure\n\t\t * that the first cluster to discard will be cluster #0.\n\t\t */\n\t\tfirst_cluster = 0;\n\t}\n\n\tif (!ret)\n\t\tatomic_set(&EXT4_SB(sb)->s_last_trim_minblks, minlen);\n\nout:\n\trange->len = EXT4_C2B(EXT4_SB(sb), trimmed) << sb->s_blocksize_bits;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nint ext4_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tstruct ext4_group_info *grp;\n\text4_group_t group, first_group, last_group;\n\text4_grpblk_t cnt = 0, first_cluster, last_cluster;\n\tuint64_t start, end, minlen, trimmed = 0;\n\text4_fsblk_t first_data_blk =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n\text4_fsblk_t max_blks = ext4_blocks_count(EXT4_SB(sb)->s_es);\n\tint ret = 0;\n\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = EXT4_NUM_B2C(EXT4_SB(sb),\n\t\t\t      range->minlen >> sb->s_blocksize_bits);\n\n\tif (minlen > EXT4_CLUSTERS_PER_GROUP(sb) ||\n\t    start >= max_blks ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\tif (end >= max_blks)\n\t\tend = max_blks - 1;\n\tif (end <= first_data_blk)\n\t\tgoto out;\n\tif (start < first_data_blk)\n\t\tstart = first_data_blk;\n\n\t/* Determine first and last group to examine based on start and end */\n\text4_get_group_no_and_offset(sb, (ext4_fsblk_t) start,\n\t\t\t\t     &first_group, &first_cluster);\n\text4_get_group_no_and_offset(sb, (ext4_fsblk_t) end,\n\t\t\t\t     &last_group, &last_cluster);\n\n\t/* end now represents the last cluster to discard in this group */\n\tend = EXT4_CLUSTERS_PER_GROUP(sb) - 1;\n\n\tfor (group = first_group; group <= last_group; group++) {\n\t\tgrp = ext4_get_group_info(sb, group);\n\t\t/* We only do this if the grp has never been initialized */\n\t\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t\tret = ext4_mb_init_group(sb, group);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For all the groups except the last one, last cluster will\n\t\t * always be EXT4_CLUSTERS_PER_GROUP(sb)-1, so we only need to\n\t\t * change it for the last group, note that last_cluster is\n\t\t * already computed earlier by ext4_get_group_no_and_offset()\n\t\t */\n\t\tif (group == last_group)\n\t\t\tend = last_cluster;\n\n\t\tif (grp->bb_free >= minlen) {\n\t\t\tcnt = ext4_trim_all_free(sb, group, first_cluster,\n\t\t\t\t\t\tend, minlen);\n\t\t\tif (cnt < 0) {\n\t\t\t\tret = cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttrimmed += cnt;\n\t\t}\n\n\t\t/*\n\t\t * For every group except the first one, we are sure\n\t\t * that the first cluster to discard will be cluster #0.\n\t\t */\n\t\tfirst_cluster = 0;\n\t}\n\n\tif (!ret)\n\t\tatomic_set(&EXT4_SB(sb)->s_last_trim_minblks, minlen);\n\nout:\n\trange->len = EXT4_C2B(EXT4_SB(sb), trimmed) << sb->s_blocksize_bits;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(unsigned int)range.minlen",
            "q->limits.discard_granularity"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_maxslots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ioctl.c",
          "lines": "182-199",
          "snippet": "static int ocfs2_info_handle_maxslots(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_maxslots oim;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oim, req))\n\t\treturn -EFAULT;\n\n\toim.im_max_slots = osb->max_slots;\n\n\to2info_set_request_filled(&oim.im_req);\n\n\tif (o2info_to_user(oim, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_maxslots(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_maxslots oim;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oim, req))\n\t\treturn -EFAULT;\n\n\toim.im_max_slots = osb->max_slots;\n\n\to2info_set_request_filled(&oim.im_req);\n\n\tif (o2info_to_user(oim, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&range",
            "(struct fstrim_range __user *)arg",
            "sizeof(range)"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "sb->s_bdev"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_resize_end",
          "args": [
            "sb"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_resize_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "54-58",
          "snippet": "void ext4_resize_end(struct super_block *sb)\n{\n\tclear_bit_unlock(EXT4_RESIZING, &EXT4_SB(sb)->s_resize_flags);\n\tsmp_mb__after_atomic();\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid ext4_resize_end(struct super_block *sb)\n{\n\tclear_bit_unlock(EXT4_RESIZING, &EXT4_SB(sb)->s_resize_flags);\n\tsmp_mb__after_atomic();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_register_li_request",
          "args": [
            "sb",
            "o_group"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_register_li_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3137-3194",
          "snippet": "int ext4_register_li_request(struct super_block *sb,\n\t\t\t     ext4_group_t first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr = NULL;\n\text4_group_t ngroups = EXT4_SB(sb)->s_groups_count;\n\tint ret = 0;\n\n\tmutex_lock(&ext4_li_mtx);\n\tif (sbi->s_li_request != NULL) {\n\t\t/*\n\t\t * Reset timeout so it can be computed again, because\n\t\t * s_li_wait_mult might have changed.\n\t\t */\n\t\tsbi->s_li_request->lr_timeout = 0;\n\t\tgoto out;\n\t}\n\n\tif (first_not_zeroed == ngroups ||\n\t    (sb->s_flags & MS_RDONLY) ||\n\t    !test_opt(sb, INIT_INODE_TABLE))\n\t\tgoto out;\n\n\telr = ext4_li_request_new(sb, first_not_zeroed);\n\tif (!elr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (NULL == ext4_li_info) {\n\t\tret = ext4_li_info_new();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_add(&elr->lr_request, &ext4_li_info->li_request_list);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\n\tsbi->s_li_request = elr;\n\t/*\n\t * set elr to NULL here since it has been inserted to\n\t * the request_list and the removal and free of it is\n\t * handled by ext4_clear_request_list from now on.\n\t */\n\telr = NULL;\n\n\tif (!(ext4_li_info->li_state & EXT4_LAZYINIT_RUNNING)) {\n\t\tret = ext4_run_lazyinit_thread();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ext4_li_mtx);\n\tif (ret)\n\t\tkfree(elr);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ext4_lazy_init *ext4_li_info;",
            "static struct mutex ext4_li_mtx;",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static void ext4_clear_request_list(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic struct mutex ext4_li_mtx;\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic void ext4_clear_request_list(void);\n\nint ext4_register_li_request(struct super_block *sb,\n\t\t\t     ext4_group_t first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr = NULL;\n\text4_group_t ngroups = EXT4_SB(sb)->s_groups_count;\n\tint ret = 0;\n\n\tmutex_lock(&ext4_li_mtx);\n\tif (sbi->s_li_request != NULL) {\n\t\t/*\n\t\t * Reset timeout so it can be computed again, because\n\t\t * s_li_wait_mult might have changed.\n\t\t */\n\t\tsbi->s_li_request->lr_timeout = 0;\n\t\tgoto out;\n\t}\n\n\tif (first_not_zeroed == ngroups ||\n\t    (sb->s_flags & MS_RDONLY) ||\n\t    !test_opt(sb, INIT_INODE_TABLE))\n\t\tgoto out;\n\n\telr = ext4_li_request_new(sb, first_not_zeroed);\n\tif (!elr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (NULL == ext4_li_info) {\n\t\tret = ext4_li_info_new();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_add(&elr->lr_request, &ext4_li_info->li_request_list);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\n\tsbi->s_li_request = elr;\n\t/*\n\t * set elr to NULL here since it has been inserted to\n\t * the request_list and the removal and free of it is\n\t * handled by ext4_clear_request_list from now on.\n\t */\n\telr = NULL;\n\n\tif (!(ext4_li_info->li_state & EXT4_LAZYINIT_RUNNING)) {\n\t\tret = ext4_run_lazyinit_thread();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ext4_li_mtx);\n\tif (ret)\n\t\tkfree(elr);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "INIT_INODE_TABLE"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_group_desc_csum",
          "args": [
            "sb"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_unlock_updates",
          "args": [
            "EXT4_SB(sb)->s_journal"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "744-753",
          "snippet": "void jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_flush",
          "args": [
            "EXT4_SB(sb)->s_journal"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1914-1970",
          "snippet": "int jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_lock_updates",
          "args": [
            "EXT4_SB(sb)->s_journal"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "689-734",
          "snippet": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_resize_fs",
          "args": [
            "sb",
            "n_blocks_count"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_resize_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1866-2021",
          "snippet": "int ext4_resize_fs(struct super_block *sb, ext4_fsblk_t n_blocks_count)\n{\n\tstruct ext4_new_flex_group_data *flex_gd = NULL;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *bh;\n\tstruct inode *resize_inode = NULL;\n\text4_grpblk_t add, offset;\n\tunsigned long n_desc_blocks;\n\tunsigned long o_desc_blocks;\n\text4_group_t o_group;\n\text4_group_t n_group;\n\text4_fsblk_t o_blocks_count;\n\text4_fsblk_t n_blocks_count_retry = 0;\n\tunsigned long last_update_time = 0;\n\tint err = 0, flexbg_size = 1 << sbi->s_log_groups_per_flex;\n\tint meta_bg;\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, n_blocks_count - 1);\n\tif (!bh) {\n\t\text4_warning(sb, \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\nretry:\n\to_blocks_count = ext4_blocks_count(es);\n\n\text4_msg(sb, KERN_INFO, \"resizing filesystem from %llu \"\n\t\t \"to %llu blocks\", o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\t/* On-line shrinking not supported */\n\t\text4_warning(sb, \"can't shrink FS - resize aborted\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count == o_blocks_count)\n\t\t/* Nothing need to do */\n\t\treturn 0;\n\n\tn_group = ext4_get_group_number(sb, n_blocks_count - 1);\n\tif (n_group > (0xFFFFFFFFUL / EXT4_INODES_PER_GROUP(sb))) {\n\t\text4_warning(sb, \"resize would cause inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\text4_get_group_no_and_offset(sb, o_blocks_count - 1, &o_group, &offset);\n\n\tn_desc_blocks = num_desc_blocks(sb, n_group + 1);\n\to_desc_blocks = num_desc_blocks(sb, sbi->s_groups_count);\n\n\tmeta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_RESIZE_INODE)) {\n\t\tif (meta_bg) {\n\t\t\text4_error(sb, \"resize_inode and meta_bg enabled \"\n\t\t\t\t   \"simultaneously\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (n_desc_blocks > o_desc_blocks +\n\t\t    le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\tn_blocks_count_retry = n_blocks_count;\n\t\t\tn_desc_blocks = o_desc_blocks +\n\t\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks);\n\t\t\tn_group = n_desc_blocks * EXT4_DESC_PER_BLOCK(sb);\n\t\t\tn_blocks_count = n_group * EXT4_BLOCKS_PER_GROUP(sb);\n\t\t\tn_group--; /* set to last group number */\n\t\t}\n\n\t\tif (!resize_inode)\n\t\t\tresize_inode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(resize_inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(resize_inode);\n\t\t}\n\t}\n\n\tif ((!resize_inode && !meta_bg) || n_blocks_count == o_blocks_count) {\n\t\terr = ext4_convert_meta_bg(sb, resize_inode);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (resize_inode) {\n\t\t\tiput(resize_inode);\n\t\t\tresize_inode = NULL;\n\t\t}\n\t\tif (n_blocks_count_retry) {\n\t\t\tn_blocks_count = n_blocks_count_retry;\n\t\t\tn_blocks_count_retry = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/* extend the last group */\n\tif (n_group == o_group)\n\t\tadd = n_blocks_count - o_blocks_count;\n\telse\n\t\tadd = EXT4_BLOCKS_PER_GROUP(sb) - (offset + 1);\n\tif (add > 0) {\n\t\terr = ext4_group_extend_no_check(sb, o_blocks_count, add);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (ext4_blocks_count(es) == n_blocks_count)\n\t\tgoto out;\n\n\terr = ext4_alloc_flex_bg_array(sb, n_group + 1);\n\tif (err)\n\t\treturn err;\n\n\terr = ext4_mb_alloc_groupinfo(sb, n_group + 1);\n\tif (err)\n\t\tgoto out;\n\n\tflex_gd = alloc_flex_gd(flexbg_size);\n\tif (flex_gd == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Add flex groups. Note that a regular group is a\n\t * flex group with 1 group.\n\t */\n\twhile (ext4_setup_next_flex_gd(sb, flex_gd, n_blocks_count,\n\t\t\t\t\t      flexbg_size)) {\n\t\tif (jiffies - last_update_time > HZ * 10) {\n\t\t\tif (last_update_time)\n\t\t\t\text4_msg(sb, KERN_INFO,\n\t\t\t\t\t \"resized to %llu blocks\",\n\t\t\t\t\t ext4_blocks_count(es));\n\t\t\tlast_update_time = jiffies;\n\t\t}\n\t\tif (ext4_alloc_group_tables(sb, flex_gd, flexbg_size) != 0)\n\t\t\tbreak;\n\t\terr = ext4_flex_group_add(sb, resize_inode, flex_gd);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\n\tif (!err && n_blocks_count_retry) {\n\t\tn_blocks_count = n_blocks_count_retry;\n\t\tn_blocks_count_retry = 0;\n\t\tfree_flex_gd(flex_gd);\n\t\tflex_gd = NULL;\n\t\tgoto retry;\n\t}\n\nout:\n\tif (flex_gd)\n\t\tfree_flex_gd(flex_gd);\n\tif (resize_inode != NULL)\n\t\tiput(resize_inode);\n\text4_msg(sb, KERN_INFO, \"resized filesystem to %llu\", n_blocks_count);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nint ext4_resize_fs(struct super_block *sb, ext4_fsblk_t n_blocks_count)\n{\n\tstruct ext4_new_flex_group_data *flex_gd = NULL;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *bh;\n\tstruct inode *resize_inode = NULL;\n\text4_grpblk_t add, offset;\n\tunsigned long n_desc_blocks;\n\tunsigned long o_desc_blocks;\n\text4_group_t o_group;\n\text4_group_t n_group;\n\text4_fsblk_t o_blocks_count;\n\text4_fsblk_t n_blocks_count_retry = 0;\n\tunsigned long last_update_time = 0;\n\tint err = 0, flexbg_size = 1 << sbi->s_log_groups_per_flex;\n\tint meta_bg;\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, n_blocks_count - 1);\n\tif (!bh) {\n\t\text4_warning(sb, \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\nretry:\n\to_blocks_count = ext4_blocks_count(es);\n\n\text4_msg(sb, KERN_INFO, \"resizing filesystem from %llu \"\n\t\t \"to %llu blocks\", o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\t/* On-line shrinking not supported */\n\t\text4_warning(sb, \"can't shrink FS - resize aborted\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count == o_blocks_count)\n\t\t/* Nothing need to do */\n\t\treturn 0;\n\n\tn_group = ext4_get_group_number(sb, n_blocks_count - 1);\n\tif (n_group > (0xFFFFFFFFUL / EXT4_INODES_PER_GROUP(sb))) {\n\t\text4_warning(sb, \"resize would cause inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\text4_get_group_no_and_offset(sb, o_blocks_count - 1, &o_group, &offset);\n\n\tn_desc_blocks = num_desc_blocks(sb, n_group + 1);\n\to_desc_blocks = num_desc_blocks(sb, sbi->s_groups_count);\n\n\tmeta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_RESIZE_INODE)) {\n\t\tif (meta_bg) {\n\t\t\text4_error(sb, \"resize_inode and meta_bg enabled \"\n\t\t\t\t   \"simultaneously\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (n_desc_blocks > o_desc_blocks +\n\t\t    le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\tn_blocks_count_retry = n_blocks_count;\n\t\t\tn_desc_blocks = o_desc_blocks +\n\t\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks);\n\t\t\tn_group = n_desc_blocks * EXT4_DESC_PER_BLOCK(sb);\n\t\t\tn_blocks_count = n_group * EXT4_BLOCKS_PER_GROUP(sb);\n\t\t\tn_group--; /* set to last group number */\n\t\t}\n\n\t\tif (!resize_inode)\n\t\t\tresize_inode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(resize_inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(resize_inode);\n\t\t}\n\t}\n\n\tif ((!resize_inode && !meta_bg) || n_blocks_count == o_blocks_count) {\n\t\terr = ext4_convert_meta_bg(sb, resize_inode);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (resize_inode) {\n\t\t\tiput(resize_inode);\n\t\t\tresize_inode = NULL;\n\t\t}\n\t\tif (n_blocks_count_retry) {\n\t\t\tn_blocks_count = n_blocks_count_retry;\n\t\t\tn_blocks_count_retry = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/* extend the last group */\n\tif (n_group == o_group)\n\t\tadd = n_blocks_count - o_blocks_count;\n\telse\n\t\tadd = EXT4_BLOCKS_PER_GROUP(sb) - (offset + 1);\n\tif (add > 0) {\n\t\terr = ext4_group_extend_no_check(sb, o_blocks_count, add);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (ext4_blocks_count(es) == n_blocks_count)\n\t\tgoto out;\n\n\terr = ext4_alloc_flex_bg_array(sb, n_group + 1);\n\tif (err)\n\t\treturn err;\n\n\terr = ext4_mb_alloc_groupinfo(sb, n_group + 1);\n\tif (err)\n\t\tgoto out;\n\n\tflex_gd = alloc_flex_gd(flexbg_size);\n\tif (flex_gd == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Add flex groups. Note that a regular group is a\n\t * flex group with 1 group.\n\t */\n\twhile (ext4_setup_next_flex_gd(sb, flex_gd, n_blocks_count,\n\t\t\t\t\t      flexbg_size)) {\n\t\tif (jiffies - last_update_time > HZ * 10) {\n\t\t\tif (last_update_time)\n\t\t\t\text4_msg(sb, KERN_INFO,\n\t\t\t\t\t \"resized to %llu blocks\",\n\t\t\t\t\t ext4_blocks_count(es));\n\t\t\tlast_update_time = jiffies;\n\t\t}\n\t\tif (ext4_alloc_group_tables(sb, flex_gd, flexbg_size) != 0)\n\t\t\tbreak;\n\t\terr = ext4_flex_group_add(sb, resize_inode, flex_gd);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\n\tif (!err && n_blocks_count_retry) {\n\t\tn_blocks_count = n_blocks_count_retry;\n\t\tn_blocks_count_retry = 0;\n\t\tfree_flex_gd(flex_gd);\n\t\tflex_gd = NULL;\n\t\tgoto retry;\n\t}\n\nout:\n\tif (flex_gd)\n\t\tfree_flex_gd(flex_gd);\n\tif (resize_inode != NULL)\n\t\tiput(resize_inode);\n\text4_msg(sb, KERN_INFO, \"resized filesystem to %llu\", n_blocks_count);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_resize_begin",
          "args": [
            "sb"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_resize_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "19-52",
          "snippet": "int ext4_resize_begin(struct super_block *sb)\n{\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\t/*\n\t * If we are not using the primary superblock/GDT copy don't resize,\n         * because the user tools have no way of handling this.  Probably a\n         * bad time to do it anyways.\n         */\n\tif (EXT4_SB(sb)->s_sbh->b_blocknr !=\n\t    le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) {\n\t\text4_warning(sb, \"won't resize using backup superblock at %llu\",\n\t\t\t(unsigned long long)EXT4_SB(sb)->s_sbh->b_blocknr);\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We are not allowed to do online-resizing on a filesystem mounted\n\t * with error, because it can destroy the filesystem easily.\n\t */\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\text4_warning(sb, \"There are errors in the filesystem, \"\n\t\t\t     \"so online resizing is not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (test_and_set_bit_lock(EXT4_RESIZING, &EXT4_SB(sb)->s_resize_flags))\n\t\tret = -EBUSY;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nint ext4_resize_begin(struct super_block *sb)\n{\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\t/*\n\t * If we are not using the primary superblock/GDT copy don't resize,\n         * because the user tools have no way of handling this.  Probably a\n         * bad time to do it anyways.\n         */\n\tif (EXT4_SB(sb)->s_sbh->b_blocknr !=\n\t    le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) {\n\t\text4_warning(sb, \"won't resize using backup superblock at %llu\",\n\t\t\t(unsigned long long)EXT4_SB(sb)->s_sbh->b_blocknr);\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We are not allowed to do online-resizing on a filesystem mounted\n\t * with error, because it can destroy the filesystem easily.\n\t */\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\text4_warning(sb, \"There are errors in the filesystem, \"\n\t\t\t     \"so online resizing is not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (test_and_set_bit_lock(EXT4_RESIZING, &EXT4_SB(sb)->s_resize_flags))\n\t\tret = -EBUSY;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"Online resizing not (yet) supported with bigalloc\""
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_BIGALLOC"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_inode_boot_loader",
          "args": [
            "sb",
            "inode"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "swap_inode_boot_loader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
          "lines": "96-197",
          "snippet": "static long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\tfilemap_flush(inode->i_mapping);\n\tfilemap_flush(inode_bl->i_mapping);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\text4_inode_block_unlocked_dio(inode_bl);\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (inode_bl->i_nlink == 0) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_bl->i_version = 1;\n\t\ti_size_write(inode_bl, 0);\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);\n\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tinode_bl->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\text4_discard_preallocations(inode);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\text4_warning(inode->i_sb,\n\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t} else {\n\t\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\t\tif (err < 0) {\n\t\t\text4_warning(inode_bl->i_sb,\n\t\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\t\tinode_bl->i_ino, err);\n\t\t\t/* Revert all changes: */\n\t\t\tswap_inode_data(inode, inode_bl);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\njournal_err_out:\n\text4_inode_resume_unlocked_dio(inode);\n\text4_inode_resume_unlocked_dio(inode_bl);\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/capability.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\tfilemap_flush(inode->i_mapping);\n\tfilemap_flush(inode_bl->i_mapping);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\text4_inode_block_unlocked_dio(inode_bl);\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (inode_bl->i_nlink == 0) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_bl->i_version = 1;\n\t\ti_size_write(inode_bl, 0);\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);\n\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tinode_bl->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\text4_discard_preallocations(inode);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\text4_warning(inode->i_sb,\n\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t} else {\n\t\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\t\tif (err < 0) {\n\t\t\text4_warning(inode_bl->i_sb,\n\t\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\t\tinode_bl->i_ino, err);\n\t\t\t/* Revert all changes: */\n\t\t\tswap_inode_data(inode, inode_bl);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\njournal_err_out:\n\text4_inode_resume_unlocked_dio(inode);\n\text4_inode_resume_unlocked_dio(inode_bl);\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_alloc_da_blocks",
          "args": [
            "inode"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_alloc_da_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2704-2743",
          "snippet": "int ext4_alloc_da_blocks(struct inode *inode)\n{\n\ttrace_ext4_alloc_da_blocks(inode);\n\n\tif (!EXT4_I(inode)->i_reserved_data_blocks)\n\t\treturn 0;\n\n\t/*\n\t * We do something simple for now.  The filemap_flush() will\n\t * also start triggering a write of the data blocks, which is\n\t * not strictly speaking necessary (and for users of\n\t * laptop_mode, not even desirable).  However, to do otherwise\n\t * would require replicating code paths in:\n\t *\n\t * ext4_writepages() ->\n\t *    write_cache_pages() ---> (via passed in callback function)\n\t *        __mpage_da_writepage() -->\n\t *           mpage_add_bh_to_extent()\n\t *           mpage_da_map_blocks()\n\t *\n\t * The problem is that write_cache_pages(), located in\n\t * mm/page-writeback.c, marks pages clean in preparation for\n\t * doing I/O, which is not desirable if we're not planning on\n\t * doing I/O at all.\n\t *\n\t * We could call write_cache_pages(), and then redirty all of\n\t * the pages by calling redirty_page_for_writepage() but that\n\t * would be ugly in the extreme.  So instead we would need to\n\t * replicate parts of the code in the above functions,\n\t * simplifying them because we wouldn't actually intend to\n\t * write out the pages, but rather only collect contiguous\n\t * logical block extents, call the multi-block allocator, and\n\t * then update the buffer heads with the block allocations.\n\t *\n\t * For now, though, we'll cheat by calling filemap_flush(),\n\t * which will map the blocks, and start the I/O, but not\n\t * actually wait for the I/O to complete.\n\t */\n\treturn filemap_flush(inode->i_mapping);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_alloc_da_blocks(struct inode *inode)\n{\n\ttrace_ext4_alloc_da_blocks(inode);\n\n\tif (!EXT4_I(inode)->i_reserved_data_blocks)\n\t\treturn 0;\n\n\t/*\n\t * We do something simple for now.  The filemap_flush() will\n\t * also start triggering a write of the data blocks, which is\n\t * not strictly speaking necessary (and for users of\n\t * laptop_mode, not even desirable).  However, to do otherwise\n\t * would require replicating code paths in:\n\t *\n\t * ext4_writepages() ->\n\t *    write_cache_pages() ---> (via passed in callback function)\n\t *        __mpage_da_writepage() -->\n\t *           mpage_add_bh_to_extent()\n\t *           mpage_da_map_blocks()\n\t *\n\t * The problem is that write_cache_pages(), located in\n\t * mm/page-writeback.c, marks pages clean in preparation for\n\t * doing I/O, which is not desirable if we're not planning on\n\t * doing I/O at all.\n\t *\n\t * We could call write_cache_pages(), and then redirty all of\n\t * the pages by calling redirty_page_for_writepage() but that\n\t * would be ugly in the extreme.  So instead we would need to\n\t * replicate parts of the code in the above functions,\n\t * simplifying them because we wouldn't actually intend to\n\t * write out the pages, but rather only collect contiguous\n\t * logical block extents, call the multi-block allocator, and\n\t * then update the buffer heads with the block allocations.\n\t *\n\t * For now, though, we'll cheat by calling filemap_flush(),\n\t * which will map the blocks, and start the I/O, but not\n\t * actually wait for the I/O to complete.\n\t */\n\treturn filemap_flush(inode->i_mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&(inode->i_mutex)"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ext_migrate",
          "args": [
            "inode"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "435-611",
          "snippet": "int ext4_ext_migrate(struct inode *inode)\n{\n\thandle_t *handle;\n\tint retval = 0, i;\n\t__le32 *i_data;\n\tstruct ext4_inode_info *ei;\n\tstruct inode *tmp_inode = NULL;\n\tstruct migrate_struct lb;\n\tunsigned long max_entries;\n\t__u32 goal;\n\tuid_t owner[2];\n\n\t/*\n\t * If the filesystem does not support extents, or the inode\n\t * already is extent-based, error out.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_INCOMPAT_EXTENTS) ||\n\t    (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn -EINVAL;\n\n\tif (S_ISLNK(inode->i_mode) && inode->i_blocks == 0)\n\t\t/*\n\t\t * don't migrate fast symlink\n\t\t */\n\t\treturn retval;\n\n\t/*\n\t * Worst case we can touch the allocation bitmaps, a bgd\n\t * block, and a block to link in the orphan list.  We do need\n\t * need to worry about credits for modifying the quota inode.\n\t */\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE,\n\t\t4 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb));\n\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\treturn retval;\n\t}\n\tgoal = (((inode->i_ino - 1) / EXT4_INODES_PER_GROUP(inode->i_sb)) *\n\t\tEXT4_INODES_PER_GROUP(inode->i_sb)) + 1;\n\towner[0] = i_uid_read(inode);\n\towner[1] = i_gid_read(inode);\n\ttmp_inode = ext4_new_inode(handle, inode->i_sb->s_root->d_inode,\n\t\t\t\t   S_IFREG, NULL, goal, owner);\n\tif (IS_ERR(tmp_inode)) {\n\t\tretval = PTR_ERR(tmp_inode);\n\t\text4_journal_stop(handle);\n\t\treturn retval;\n\t}\n\ti_size_write(tmp_inode, i_size_read(inode));\n\t/*\n\t * Set the i_nlink to zero so it will be deleted later\n\t * when we drop inode reference.\n\t */\n\tclear_nlink(tmp_inode);\n\n\text4_ext_tree_init(handle, tmp_inode);\n\text4_orphan_add(handle, tmp_inode);\n\text4_journal_stop(handle);\n\n\t/*\n\t * start with one credit accounted for\n\t * superblock modification.\n\t *\n\t * For the tmp_inode we already have committed the\n\t * transaction that created the inode. Later as and\n\t * when we add extents we extent the journal\n\t */\n\t/*\n\t * Even though we take i_mutex we can still cause block\n\t * allocation via mmap write to holes. If we have allocated\n\t * new blocks we fail migrate.  New block allocation will\n\t * clear EXT4_STATE_EXT_MIGRATE flag.  The flag is updated\n\t * with i_data_sem held to prevent racing with block\n\t * allocation.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\text4_set_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);\n\tif (IS_ERR(handle)) {\n\t\t/*\n\t\t * It is impossible to update on-disk structures without\n\t\t * a handle, so just rollback in-core changes and live other\n\t\t * work to orphan_list_cleanup()\n\t\t */\n\t\text4_orphan_del(NULL, tmp_inode);\n\t\tretval = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tei = EXT4_I(inode);\n\ti_data = ei->i_data;\n\tmemset(&lb, 0, sizeof(lb));\n\n\t/* 32 bit block address 4 bytes */\n\tmax_entries = inode->i_sb->s_blocksize >> 2;\n\tfor (i = 0; i < EXT4_NDIR_BLOCKS; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_extent_range(handle, tmp_inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t} else\n\t\t\tlb.curr_block++;\n\t}\n\tif (i_data[EXT4_IND_BLOCK]) {\n\t\tretval = update_ind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_IND_BLOCK]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t} else\n\t\tlb.curr_block += max_entries;\n\tif (i_data[EXT4_DIND_BLOCK]) {\n\t\tretval = update_dind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_DIND_BLOCK]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t} else\n\t\tlb.curr_block += max_entries * max_entries;\n\tif (i_data[EXT4_TIND_BLOCK]) {\n\t\tretval = update_tind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_TIND_BLOCK]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t}\n\t/*\n\t * Build the last extent\n\t */\n\tretval = finish_range(handle, tmp_inode, &lb);\nerr_out:\n\tif (retval)\n\t\t/*\n\t\t * Failure case delete the extent information with the\n\t\t * tmp_inode\n\t\t */\n\t\tfree_ext_block(handle, tmp_inode);\n\telse {\n\t\tretval = ext4_ext_swap_inode_data(handle, inode, tmp_inode);\n\t\tif (retval)\n\t\t\t/*\n\t\t\t * if we fail to swap inode data free the extent\n\t\t\t * details of the tmp inode\n\t\t\t */\n\t\t\tfree_ext_block(handle, tmp_inode);\n\t}\n\n\t/* We mark the tmp_inode dirty via ext4_ext_tree_init. */\n\tif (ext4_journal_extend(handle, 1) != 0)\n\t\text4_journal_restart(handle, 1);\n\n\t/*\n\t * Mark the tmp_inode as of size zero\n\t */\n\ti_size_write(tmp_inode, 0);\n\n\t/*\n\t * set the  i_blocks count to zero\n\t * so that the ext4_evict_inode() does the\n\t * right job\n\t *\n\t * We don't need to take the i_lock because\n\t * the inode is not visible to user space.\n\t */\n\ttmp_inode->i_blocks = 0;\n\n\t/* Reset the extent details */\n\text4_ext_tree_init(handle, tmp_inode);\n\text4_journal_stop(handle);\nout:\n\tunlock_new_inode(tmp_inode);\n\tiput(tmp_inode);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nint ext4_ext_migrate(struct inode *inode)\n{\n\thandle_t *handle;\n\tint retval = 0, i;\n\t__le32 *i_data;\n\tstruct ext4_inode_info *ei;\n\tstruct inode *tmp_inode = NULL;\n\tstruct migrate_struct lb;\n\tunsigned long max_entries;\n\t__u32 goal;\n\tuid_t owner[2];\n\n\t/*\n\t * If the filesystem does not support extents, or the inode\n\t * already is extent-based, error out.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_INCOMPAT_EXTENTS) ||\n\t    (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn -EINVAL;\n\n\tif (S_ISLNK(inode->i_mode) && inode->i_blocks == 0)\n\t\t/*\n\t\t * don't migrate fast symlink\n\t\t */\n\t\treturn retval;\n\n\t/*\n\t * Worst case we can touch the allocation bitmaps, a bgd\n\t * block, and a block to link in the orphan list.  We do need\n\t * need to worry about credits for modifying the quota inode.\n\t */\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE,\n\t\t4 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb));\n\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\treturn retval;\n\t}\n\tgoal = (((inode->i_ino - 1) / EXT4_INODES_PER_GROUP(inode->i_sb)) *\n\t\tEXT4_INODES_PER_GROUP(inode->i_sb)) + 1;\n\towner[0] = i_uid_read(inode);\n\towner[1] = i_gid_read(inode);\n\ttmp_inode = ext4_new_inode(handle, inode->i_sb->s_root->d_inode,\n\t\t\t\t   S_IFREG, NULL, goal, owner);\n\tif (IS_ERR(tmp_inode)) {\n\t\tretval = PTR_ERR(tmp_inode);\n\t\text4_journal_stop(handle);\n\t\treturn retval;\n\t}\n\ti_size_write(tmp_inode, i_size_read(inode));\n\t/*\n\t * Set the i_nlink to zero so it will be deleted later\n\t * when we drop inode reference.\n\t */\n\tclear_nlink(tmp_inode);\n\n\text4_ext_tree_init(handle, tmp_inode);\n\text4_orphan_add(handle, tmp_inode);\n\text4_journal_stop(handle);\n\n\t/*\n\t * start with one credit accounted for\n\t * superblock modification.\n\t *\n\t * For the tmp_inode we already have committed the\n\t * transaction that created the inode. Later as and\n\t * when we add extents we extent the journal\n\t */\n\t/*\n\t * Even though we take i_mutex we can still cause block\n\t * allocation via mmap write to holes. If we have allocated\n\t * new blocks we fail migrate.  New block allocation will\n\t * clear EXT4_STATE_EXT_MIGRATE flag.  The flag is updated\n\t * with i_data_sem held to prevent racing with block\n\t * allocation.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\text4_set_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);\n\tif (IS_ERR(handle)) {\n\t\t/*\n\t\t * It is impossible to update on-disk structures without\n\t\t * a handle, so just rollback in-core changes and live other\n\t\t * work to orphan_list_cleanup()\n\t\t */\n\t\text4_orphan_del(NULL, tmp_inode);\n\t\tretval = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tei = EXT4_I(inode);\n\ti_data = ei->i_data;\n\tmemset(&lb, 0, sizeof(lb));\n\n\t/* 32 bit block address 4 bytes */\n\tmax_entries = inode->i_sb->s_blocksize >> 2;\n\tfor (i = 0; i < EXT4_NDIR_BLOCKS; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_extent_range(handle, tmp_inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t} else\n\t\t\tlb.curr_block++;\n\t}\n\tif (i_data[EXT4_IND_BLOCK]) {\n\t\tretval = update_ind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_IND_BLOCK]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t} else\n\t\tlb.curr_block += max_entries;\n\tif (i_data[EXT4_DIND_BLOCK]) {\n\t\tretval = update_dind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_DIND_BLOCK]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t} else\n\t\tlb.curr_block += max_entries * max_entries;\n\tif (i_data[EXT4_TIND_BLOCK]) {\n\t\tretval = update_tind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_TIND_BLOCK]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t}\n\t/*\n\t * Build the last extent\n\t */\n\tretval = finish_range(handle, tmp_inode, &lb);\nerr_out:\n\tif (retval)\n\t\t/*\n\t\t * Failure case delete the extent information with the\n\t\t * tmp_inode\n\t\t */\n\t\tfree_ext_block(handle, tmp_inode);\n\telse {\n\t\tretval = ext4_ext_swap_inode_data(handle, inode, tmp_inode);\n\t\tif (retval)\n\t\t\t/*\n\t\t\t * if we fail to swap inode data free the extent\n\t\t\t * details of the tmp inode\n\t\t\t */\n\t\t\tfree_ext_block(handle, tmp_inode);\n\t}\n\n\t/* We mark the tmp_inode dirty via ext4_ext_tree_init. */\n\tif (ext4_journal_extend(handle, 1) != 0)\n\t\text4_journal_restart(handle, 1);\n\n\t/*\n\t * Mark the tmp_inode as of size zero\n\t */\n\ti_size_write(tmp_inode, 0);\n\n\t/*\n\t * set the  i_blocks count to zero\n\t * so that the ext4_evict_inode() does the\n\t * right job\n\t *\n\t * We don't need to take the i_lock because\n\t * the inode is not visible to user space.\n\t */\n\ttmp_inode->i_blocks = 0;\n\n\t/* Reset the extent details */\n\text4_ext_tree_init(handle, tmp_inode);\n\text4_journal_stop(handle);\nout:\n\tunlock_new_inode(tmp_inode);\n\tiput(tmp_inode);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&(inode->i_mutex)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "INIT_INODE_TABLE"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_group_desc_csum",
          "args": [
            "sb"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_add",
          "args": [
            "sb",
            "&input"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1571-1638",
          "snippet": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off;\n\tint err;\n\t__u16 bg_flags = 0;\n\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_alloc_flex_bg_array(sb, input->group + 1);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_mb_alloc_groupinfo(sb, input->group + 1);\n\tif (err)\n\t\tgoto out;\n\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nint ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off;\n\tint err;\n\t__u16 bg_flags = 0;\n\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_alloc_flex_bg_array(sb, input->group + 1);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_mb_alloc_groupinfo(sb, input->group + 1);\n\tif (err)\n\t\tgoto out;\n\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_BIGALLOC"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "donor"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(struct move_extent __user *)arg",
            "&me",
            "sizeof(me)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_move_extents",
          "args": [
            "filp",
            "donor.file",
            "me.orig_start",
            "me.donor_start",
            "me.len",
            "&me.moved_len"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_move_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "543-684",
          "snippet": "int\next4_move_extents(struct file *o_filp, struct file *d_filp, __u64 orig_blk,\n\t\t  __u64 donor_blk, __u64 len, __u64 *moved_len)\n{\n\tstruct inode *orig_inode = file_inode(o_filp);\n\tstruct inode *donor_inode = file_inode(d_filp);\n\tstruct ext4_ext_path *path = NULL;\n\tint blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;\n\text4_lblk_t o_end, o_start = orig_blk;\n\text4_lblk_t d_start = donor_blk;\n\tint ret;\n\n\tif (orig_inode->i_sb != donor_inode->i_sb) {\n\t\text4_debug(\"ext4 move extent: The argument files \"\n\t\t\t\"should be in same FS [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t/* orig and donor should be different inodes */\n\tif (orig_inode == donor_inode) {\n\t\text4_debug(\"ext4 move extent: The argument files should not \"\n\t\t\t\"be same inode [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Regular file check */\n\tif (!S_ISREG(orig_inode->i_mode) || !S_ISREG(donor_inode->i_mode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should be \"\n\t\t\t\"regular file [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\t/* TODO: This is non obvious task to swap blocks for inodes with full\n\t   jornaling enabled */\n\tif (ext4_should_journal_data(orig_inode) ||\n\t    ext4_should_journal_data(donor_inode)) {\n\t\treturn -EINVAL;\n\t}\n\t/* Protect orig and donor inodes against a truncate */\n\tlock_two_nondirectories(orig_inode, donor_inode);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(orig_inode);\n\text4_inode_block_unlocked_dio(donor_inode);\n\tinode_dio_wait(orig_inode);\n\tinode_dio_wait(donor_inode);\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t/* Check the filesystem environment whether move_extent can be done */\n\tret = mext_check_arguments(orig_inode, donor_inode, orig_blk,\n\t\t\t\t    donor_blk, &len);\n\tif (ret)\n\t\tgoto out;\n\to_end = o_start + len;\n\n\twhile (o_start < o_end) {\n\t\tstruct ext4_extent *ex;\n\t\text4_lblk_t cur_blk, next_blk;\n\t\tpgoff_t orig_page_index, donor_page_index;\n\t\tint offset_in_page;\n\t\tint unwritten, cur_len;\n\n\t\tret = get_ext_path(orig_inode, o_start, &path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tex = path[path->p_depth].p_ext;\n\t\tnext_blk = ext4_ext_next_allocated_block(path);\n\t\tcur_blk = le32_to_cpu(ex->ee_block);\n\t\tcur_len = ext4_ext_get_actual_len(ex);\n\t\t/* Check hole before the start pos */\n\t\tif (cur_blk + cur_len - 1 < o_start) {\n\t\t\tif (next_blk == EXT_MAX_BLOCKS) {\n\t\t\t\to_start = o_end;\n\t\t\t\tret = -ENODATA;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\td_start += next_blk - o_start;\n\t\t\to_start = next_blk;\n\t\t\tcontinue;\n\t\t/* Check hole after the start pos */\n\t\t} else if (cur_blk > o_start) {\n\t\t\t/* Skip hole */\n\t\t\td_start += cur_blk - o_start;\n\t\t\to_start = cur_blk;\n\t\t\t/* Extent inside requested range ?*/\n\t\t\tif (cur_blk >= o_end)\n\t\t\t\tgoto out;\n\t\t} else { /* in_range(o_start, o_blk, o_len) */\n\t\t\tcur_len += cur_blk - o_start;\n\t\t}\n\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\tif (o_end - o_start < cur_len)\n\t\t\tcur_len = o_end - o_start;\n\n\t\torig_page_index = o_start >> (PAGE_CACHE_SHIFT -\n\t\t\t\t\t       orig_inode->i_blkbits);\n\t\tdonor_page_index = d_start >> (PAGE_CACHE_SHIFT -\n\t\t\t\t\t       donor_inode->i_blkbits);\n\t\toffset_in_page = o_start % blocks_per_page;\n\t\tif (cur_len > blocks_per_page- offset_in_page)\n\t\t\tcur_len = blocks_per_page - offset_in_page;\n\t\t/*\n\t\t * Up semaphore to avoid following problems:\n\t\t * a. transaction deadlock among ext4_journal_start,\n\t\t *    ->write_begin via pagefault, and jbd2_journal_commit\n\t\t * b. racing with ->readpage, ->write_begin, and ext4_get_block\n\t\t *    in move_extent_per_page\n\t\t */\n\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\t/* Swap original branches with new branches */\n\t\tmove_extent_per_page(o_filp, donor_inode,\n\t\t\t\t     orig_page_index, donor_page_index,\n\t\t\t\t     offset_in_page, cur_len,\n\t\t\t\t     unwritten, &ret);\n\t\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\to_start += cur_len;\n\t\td_start += cur_len;\n\t}\n\t*moved_len = o_start - orig_blk;\n\tif (*moved_len > len)\n\t\t*moved_len = len;\n\nout:\n\tif (*moved_len) {\n\t\text4_discard_preallocations(orig_inode);\n\t\text4_discard_preallocations(donor_inode);\n\t}\n\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\text4_inode_resume_unlocked_dio(orig_inode);\n\text4_inode_resume_unlocked_dio(donor_inode);\n\tunlock_two_nondirectories(orig_inode, donor_inode);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nint\next4_move_extents(struct file *o_filp, struct file *d_filp, __u64 orig_blk,\n\t\t  __u64 donor_blk, __u64 len, __u64 *moved_len)\n{\n\tstruct inode *orig_inode = file_inode(o_filp);\n\tstruct inode *donor_inode = file_inode(d_filp);\n\tstruct ext4_ext_path *path = NULL;\n\tint blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;\n\text4_lblk_t o_end, o_start = orig_blk;\n\text4_lblk_t d_start = donor_blk;\n\tint ret;\n\n\tif (orig_inode->i_sb != donor_inode->i_sb) {\n\t\text4_debug(\"ext4 move extent: The argument files \"\n\t\t\t\"should be in same FS [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t/* orig and donor should be different inodes */\n\tif (orig_inode == donor_inode) {\n\t\text4_debug(\"ext4 move extent: The argument files should not \"\n\t\t\t\"be same inode [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Regular file check */\n\tif (!S_ISREG(orig_inode->i_mode) || !S_ISREG(donor_inode->i_mode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should be \"\n\t\t\t\"regular file [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\t/* TODO: This is non obvious task to swap blocks for inodes with full\n\t   jornaling enabled */\n\tif (ext4_should_journal_data(orig_inode) ||\n\t    ext4_should_journal_data(donor_inode)) {\n\t\treturn -EINVAL;\n\t}\n\t/* Protect orig and donor inodes against a truncate */\n\tlock_two_nondirectories(orig_inode, donor_inode);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(orig_inode);\n\text4_inode_block_unlocked_dio(donor_inode);\n\tinode_dio_wait(orig_inode);\n\tinode_dio_wait(donor_inode);\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t/* Check the filesystem environment whether move_extent can be done */\n\tret = mext_check_arguments(orig_inode, donor_inode, orig_blk,\n\t\t\t\t    donor_blk, &len);\n\tif (ret)\n\t\tgoto out;\n\to_end = o_start + len;\n\n\twhile (o_start < o_end) {\n\t\tstruct ext4_extent *ex;\n\t\text4_lblk_t cur_blk, next_blk;\n\t\tpgoff_t orig_page_index, donor_page_index;\n\t\tint offset_in_page;\n\t\tint unwritten, cur_len;\n\n\t\tret = get_ext_path(orig_inode, o_start, &path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tex = path[path->p_depth].p_ext;\n\t\tnext_blk = ext4_ext_next_allocated_block(path);\n\t\tcur_blk = le32_to_cpu(ex->ee_block);\n\t\tcur_len = ext4_ext_get_actual_len(ex);\n\t\t/* Check hole before the start pos */\n\t\tif (cur_blk + cur_len - 1 < o_start) {\n\t\t\tif (next_blk == EXT_MAX_BLOCKS) {\n\t\t\t\to_start = o_end;\n\t\t\t\tret = -ENODATA;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\td_start += next_blk - o_start;\n\t\t\to_start = next_blk;\n\t\t\tcontinue;\n\t\t/* Check hole after the start pos */\n\t\t} else if (cur_blk > o_start) {\n\t\t\t/* Skip hole */\n\t\t\td_start += cur_blk - o_start;\n\t\t\to_start = cur_blk;\n\t\t\t/* Extent inside requested range ?*/\n\t\t\tif (cur_blk >= o_end)\n\t\t\t\tgoto out;\n\t\t} else { /* in_range(o_start, o_blk, o_len) */\n\t\t\tcur_len += cur_blk - o_start;\n\t\t}\n\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\tif (o_end - o_start < cur_len)\n\t\t\tcur_len = o_end - o_start;\n\n\t\torig_page_index = o_start >> (PAGE_CACHE_SHIFT -\n\t\t\t\t\t       orig_inode->i_blkbits);\n\t\tdonor_page_index = d_start >> (PAGE_CACHE_SHIFT -\n\t\t\t\t\t       donor_inode->i_blkbits);\n\t\toffset_in_page = o_start % blocks_per_page;\n\t\tif (cur_len > blocks_per_page- offset_in_page)\n\t\t\tcur_len = blocks_per_page - offset_in_page;\n\t\t/*\n\t\t * Up semaphore to avoid following problems:\n\t\t * a. transaction deadlock among ext4_journal_start,\n\t\t *    ->write_begin via pagefault, and jbd2_journal_commit\n\t\t * b. racing with ->readpage, ->write_begin, and ext4_get_block\n\t\t *    in move_extent_per_page\n\t\t */\n\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\t/* Swap original branches with new branches */\n\t\tmove_extent_per_page(o_filp, donor_inode,\n\t\t\t\t     orig_page_index, donor_page_index,\n\t\t\t\t     offset_in_page, cur_len,\n\t\t\t\t     unwritten, &ret);\n\t\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\to_start += cur_len;\n\t\td_start += cur_len;\n\t}\n\t*moved_len = o_start - orig_blk;\n\tif (*moved_len > len)\n\t\t*moved_len = len;\n\nout:\n\tif (*moved_len) {\n\t\text4_discard_preallocations(orig_inode);\n\t\text4_discard_preallocations(donor_inode);\n\t}\n\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\text4_inode_resume_unlocked_dio(orig_inode);\n\text4_inode_resume_unlocked_dio(donor_inode);\n\tunlock_two_nondirectories(orig_inode, donor_inode);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_BIGALLOC"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "me.donor_fd"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_extend",
          "args": [
            "sb",
            "EXT4_SB(sb)->s_es",
            "n_blocks_count"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1703-1769",
          "snippet": "int ext4_group_extend(struct super_block *sb, struct ext4_super_block *es,\n\t\t      ext4_fsblk_t n_blocks_count)\n{\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_grpblk_t add;\n\tstruct buffer_head *bh;\n\tint err;\n\text4_group_t group;\n\n\to_blocks_count = ext4_blocks_count(es);\n\n\tif (test_opt(sb, DEBUG))\n\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t \"extending last group from %llu to %llu blocks\",\n\t\t\t o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count == 0 || n_blocks_count == o_blocks_count)\n\t\treturn 0;\n\n\tif (n_blocks_count > (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"filesystem too large to resize to %llu blocks safely\",\n\t\t\t n_blocks_count);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_warning(sb, \"CONFIG_LBDAF not enabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\text4_warning(sb, \"can't shrink FS - resize aborted\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Handle the remaining blocks in the last group only. */\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\n\tif (last == 0) {\n\t\text4_warning(sb, \"need to use ext2online to resize further\");\n\t\treturn -EPERM;\n\t}\n\n\tadd = EXT4_BLOCKS_PER_GROUP(sb) - last;\n\n\tif (o_blocks_count + add < o_blocks_count) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (o_blocks_count + add > n_blocks_count)\n\t\tadd = n_blocks_count - o_blocks_count;\n\n\tif (o_blocks_count + add < n_blocks_count)\n\t\text4_warning(sb, \"will only finish group (%llu blocks, %u new)\",\n\t\t\t     o_blocks_count + add, add);\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, o_blocks_count + add - 1);\n\tif (!bh) {\n\t\text4_warning(sb, \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\terr = ext4_group_extend_no_check(sb, o_blocks_count, add);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nint ext4_group_extend(struct super_block *sb, struct ext4_super_block *es,\n\t\t      ext4_fsblk_t n_blocks_count)\n{\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_grpblk_t add;\n\tstruct buffer_head *bh;\n\tint err;\n\text4_group_t group;\n\n\to_blocks_count = ext4_blocks_count(es);\n\n\tif (test_opt(sb, DEBUG))\n\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t \"extending last group from %llu to %llu blocks\",\n\t\t\t o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count == 0 || n_blocks_count == o_blocks_count)\n\t\treturn 0;\n\n\tif (n_blocks_count > (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"filesystem too large to resize to %llu blocks safely\",\n\t\t\t n_blocks_count);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_warning(sb, \"CONFIG_LBDAF not enabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\text4_warning(sb, \"can't shrink FS - resize aborted\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Handle the remaining blocks in the last group only. */\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\n\tif (last == 0) {\n\t\text4_warning(sb, \"need to use ext2online to resize further\");\n\t\treturn -EPERM;\n\t}\n\n\tadd = EXT4_BLOCKS_PER_GROUP(sb) - last;\n\n\tif (o_blocks_count + add < o_blocks_count) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (o_blocks_count + add > n_blocks_count)\n\t\tadd = n_blocks_count - o_blocks_count;\n\n\tif (o_blocks_count + add < n_blocks_count)\n\t\text4_warning(sb, \"will only finish group (%llu blocks, %u new)\",\n\t\t\t     o_blocks_count + add, add);\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, o_blocks_count + add - 1);\n\tif (!bh) {\n\t\text4_warning(sb, \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\terr = ext4_group_extend_no_check(sb, o_blocks_count, add);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_BIGALLOC"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "n_blocks_count",
            "(__u32 __user *)arg"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4800-4815",
          "snippet": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "inode"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_reserve_inode_write",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4822-4839",
          "snippet": "int\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_INODE",
            "1"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Setting inode version is not \"\n\t\t\t\t     \"supported with metadata_csum enabled.\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "inode->i_generation",
            "(int __user *) arg"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ind_migrate",
          "args": [
            "inode"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ind_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "616-672",
          "snippet": "int ext4_ind_migrate(struct inode *inode)\n{\n\tstruct ext4_extent_header\t*eh;\n\tstruct ext4_super_block\t\t*es = EXT4_SB(inode->i_sb)->s_es;\n\tstruct ext4_inode_info\t\t*ei = EXT4_I(inode);\n\tstruct ext4_extent\t\t*ex;\n\tunsigned int\t\t\ti, len;\n\text4_fsblk_t\t\t\tblk;\n\thandle_t\t\t\t*handle;\n\tint\t\t\t\tret;\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_INCOMPAT_EXTENTS) ||\n\t    (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn -EINVAL;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC))\n\t\treturn -EOPNOTSUPP;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_ext_check_inode(inode);\n\tif (ret)\n\t\tgoto errout;\n\n\teh = ext_inode_hdr(inode);\n\tex  = EXT_FIRST_EXTENT(eh);\n\tif (ext4_blocks_count(es) > EXT4_MAX_BLOCK_FILE_PHYS ||\n\t    eh->eh_depth != 0 || le16_to_cpu(eh->eh_entries) > 1) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto errout;\n\t}\n\tif (eh->eh_entries == 0)\n\t\tblk = len = 0;\n\telse {\n\t\tlen = le16_to_cpu(ex->ee_len);\n\t\tblk = ext4_ext_pblock(ex);\n\t\tif (len > EXT4_NDIR_BLOCKS) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tfor (i=0; i < len; i++)\n\t\tei->i_data[i] = cpu_to_le32(blk++);\n\text4_mark_inode_dirty(handle, inode);\nerrout:\n\text4_journal_stop(handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nint ext4_ind_migrate(struct inode *inode)\n{\n\tstruct ext4_extent_header\t*eh;\n\tstruct ext4_super_block\t\t*es = EXT4_SB(inode->i_sb)->s_es;\n\tstruct ext4_inode_info\t\t*ei = EXT4_I(inode);\n\tstruct ext4_extent\t\t*ex;\n\tunsigned int\t\t\ti, len;\n\text4_fsblk_t\t\t\tblk;\n\thandle_t\t\t\t*handle;\n\tint\t\t\t\tret;\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_INCOMPAT_EXTENTS) ||\n\t    (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn -EINVAL;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC))\n\t\treturn -EOPNOTSUPP;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_ext_check_inode(inode);\n\tif (ret)\n\t\tgoto errout;\n\n\teh = ext_inode_hdr(inode);\n\tex  = EXT_FIRST_EXTENT(eh);\n\tif (ext4_blocks_count(es) > EXT4_MAX_BLOCK_FILE_PHYS ||\n\t    eh->eh_depth != 0 || le16_to_cpu(eh->eh_entries) > 1) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto errout;\n\t}\n\tif (eh->eh_entries == 0)\n\t\tblk = len = 0;\n\telse {\n\t\tlen = le16_to_cpu(ex->ee_len);\n\t\tblk = ext4_ext_pblock(ex);\n\t\tif (len > EXT4_NDIR_BLOCKS) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tfor (i=0; i < len; i++)\n\t\tei->i_data[i] = cpu_to_le32(blk++);\n\text4_mark_inode_dirty(handle, inode);\nerrout:\n\text4_journal_stop(handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_change_inode_journal_flag",
          "args": [
            "inode",
            "jflag"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_change_inode_journal_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4997-5072",
          "snippet": "int ext4_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\n\t/*\n\t * We have to be very careful here: changing a data block's\n\t * journaling status dynamically is dangerous.  If we write a\n\t * data block to the journal, change the status and then delete\n\t * that block, we risk forgetting to revoke the old log record\n\t * from the journal and so a subsequent replay can corrupt data.\n\t * So, first we make sure that the journal is empty and that\n\t * nobody is changing anything.\n\t */\n\n\tjournal = EXT4_JOURNAL(inode);\n\tif (!journal)\n\t\treturn 0;\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\t/* We have to allocate physical blocks for delalloc blocks\n\t * before flushing journal. otherwise delalloc blocks can not\n\t * be allocated any more. even more truncate on delalloc blocks\n\t * could trigger BUG by flushing delalloc blocks in journal.\n\t * There is no delalloc block in non-journal data mode.\n\t */\n\tif (val && test_opt(inode->i_sb, DELALLOC)) {\n\t\terr = ext4_alloc_da_blocks(inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\tjbd2_journal_lock_updates(journal);\n\n\t/*\n\t * OK, there are no updates running now, and all cached data is\n\t * synced to disk.  We are now in a completely consistent state\n\t * which doesn't have anything in the journal, and we know that\n\t * no filesystem updates are running, so it is safe to modify\n\t * the inode's in-core data-journaling state flag now.\n\t */\n\n\tif (val)\n\t\text4_set_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\telse {\n\t\terr = jbd2_journal_flush(journal);\n\t\tif (err < 0) {\n\t\t\tjbd2_journal_unlock_updates(journal);\n\t\t\text4_inode_resume_unlocked_dio(inode);\n\t\t\treturn err;\n\t\t}\n\t\text4_clear_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\t}\n\text4_set_aops(inode);\n\n\tjbd2_journal_unlock_updates(journal);\n\text4_inode_resume_unlocked_dio(inode);\n\n\t/* Finally we can mark the inode as dirty. */\n\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\text4_handle_sync(handle);\n\text4_journal_stop(handle);\n\text4_std_error(inode->i_sb, err);\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\n\t/*\n\t * We have to be very careful here: changing a data block's\n\t * journaling status dynamically is dangerous.  If we write a\n\t * data block to the journal, change the status and then delete\n\t * that block, we risk forgetting to revoke the old log record\n\t * from the journal and so a subsequent replay can corrupt data.\n\t * So, first we make sure that the journal is empty and that\n\t * nobody is changing anything.\n\t */\n\n\tjournal = EXT4_JOURNAL(inode);\n\tif (!journal)\n\t\treturn 0;\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\t/* We have to allocate physical blocks for delalloc blocks\n\t * before flushing journal. otherwise delalloc blocks can not\n\t * be allocated any more. even more truncate on delalloc blocks\n\t * could trigger BUG by flushing delalloc blocks in journal.\n\t * There is no delalloc block in non-journal data mode.\n\t */\n\tif (val && test_opt(inode->i_sb, DELALLOC)) {\n\t\terr = ext4_alloc_da_blocks(inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\tjbd2_journal_lock_updates(journal);\n\n\t/*\n\t * OK, there are no updates running now, and all cached data is\n\t * synced to disk.  We are now in a completely consistent state\n\t * which doesn't have anything in the journal, and we know that\n\t * no filesystem updates are running, so it is safe to modify\n\t * the inode's in-core data-journaling state flag now.\n\t */\n\n\tif (val)\n\t\text4_set_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\telse {\n\t\terr = jbd2_journal_flush(journal);\n\t\tif (err < 0) {\n\t\t\tjbd2_journal_unlock_updates(journal);\n\t\t\text4_inode_resume_unlocked_dio(inode);\n\t\t\treturn err;\n\t\t}\n\t\text4_clear_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\t}\n\text4_set_aops(inode);\n\n\tjbd2_journal_unlock_updates(journal);\n\text4_inode_resume_unlocked_dio(inode);\n\n\t/* Finally we can mark the inode as dirty. */\n\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\text4_handle_sync(handle);\n\text4_journal_stop(handle);\n\text4_std_error(inode->i_sb, err);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3823-3842",
          "snippet": "void ext4_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT4_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & EXT4_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & EXT4_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & EXT4_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & EXT4_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & EXT4_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tnew_fl |= S_DAX;\n\tinode_set_flags(inode, new_fl,\n\t\t\tS_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_DAX);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT4_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & EXT4_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & EXT4_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & EXT4_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & EXT4_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & EXT4_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tnew_fl |= S_DAX;\n\tinode_set_flags(inode, new_fl,\n\t\t\tS_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_DAX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_flag",
          "args": [
            "inode",
            "i"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_flag",
          "args": [
            "inode",
            "i"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_truncate",
          "args": [
            "inode"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3577-3671",
          "snippet": "void ext4_truncate(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int credits;\n\thandle_t *handle;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/*\n\t * There is a possibility that we're either freeing the inode\n\t * or it's a completely new inode. In those cases we might not\n\t * have i_mutex locked because it's not necessary.\n\t */\n\tif (!(inode->i_state & (I_NEW|I_FREEING)))\n\t\tWARN_ON(!mutex_is_locked(&inode->i_mutex));\n\ttrace_ext4_truncate_enter(inode);\n\n\tif (!ext4_can_truncate(inode))\n\t\treturn;\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\n\tif (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline = 1;\n\n\t\text4_inline_data_truncate(inode, &has_inline);\n\t\tif (has_inline)\n\t\t\treturn;\n\t}\n\n\t/* If we zero-out tail of the page, we have to create jinode for jbd2 */\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1)) {\n\t\tif (ext4_inode_attach_jinode(inode) < 0)\n\t\t\treturn;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\treturn;\n\t}\n\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\t/*\n\t * We add the inode to the orphan list, so that if this\n\t * truncate spans multiple transactions, and we crash, we will\n\t * resume the truncate when the filesystem recovers.  It also\n\t * marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\text4_discard_preallocations(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_ext_truncate(handle, inode);\n\telse\n\t\text4_ind_truncate(handle, inode);\n\n\tup_write(&ei->i_data_sem);\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\ttrace_ext4_truncate_exit(inode);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nvoid ext4_truncate(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int credits;\n\thandle_t *handle;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/*\n\t * There is a possibility that we're either freeing the inode\n\t * or it's a completely new inode. In those cases we might not\n\t * have i_mutex locked because it's not necessary.\n\t */\n\tif (!(inode->i_state & (I_NEW|I_FREEING)))\n\t\tWARN_ON(!mutex_is_locked(&inode->i_mutex));\n\ttrace_ext4_truncate_enter(inode);\n\n\tif (!ext4_can_truncate(inode))\n\t\treturn;\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\n\tif (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline = 1;\n\n\t\text4_inline_data_truncate(inode, &has_inline);\n\t\tif (has_inline)\n\t\t\treturn;\n\t}\n\n\t/* If we zero-out tail of the page, we have to create jinode for jbd2 */\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1)) {\n\t\tif (ext4_inode_attach_jinode(inode) < 0)\n\t\t\treturn;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\treturn;\n\t}\n\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\t/*\n\t * We add the inode to the orphan list, so that if this\n\t * truncate spans multiple transactions, and we crash, we will\n\t * resume the truncate when the filesystem recovers.  It also\n\t * marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\text4_discard_preallocations(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_ext_truncate(handle, inode);\n\telse\n\t\text4_ind_truncate(handle, inode);\n\n\tup_write(&ei->i_data_sem);\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\ttrace_ext4_truncate_exit(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_NOQUOTA",
          "args": [
            "inode"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mask_flags",
          "args": [
            "inode->i_mode",
            "flags"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mask_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "399-407",
          "snippet": "static inline __u32 ext4_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT4_REG_FLMASK;\n\telse\n\t\treturn flags & EXT4_OTHER_FLMASK;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_OTHER_FLMASK (EXT4_NODUMP_FL | EXT4_NOATIME_FL)",
            "#define EXT4_REG_FLMASK (~(EXT4_DIRSYNC_FL | EXT4_TOPDIR_FL))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_OTHER_FLMASK (EXT4_NODUMP_FL | EXT4_NOATIME_FL)\n#define EXT4_REG_FLMASK (~(EXT4_DIRSYNC_FL | EXT4_TOPDIR_FL))\n\nstatic inline __u32 ext4_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT4_REG_FLMASK;\n\telse\n\t\treturn flags & EXT4_OTHER_FLMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "flags",
            "(int __user *) arg"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_flags",
          "args": [
            "ei"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3845-3867",
          "snippet": "void ext4_get_inode_flags(struct ext4_inode_info *ei)\n{\n\tunsigned int vfs_fl;\n\tunsigned long old_fl, new_fl;\n\n\tdo {\n\t\tvfs_fl = ei->vfs_inode.i_flags;\n\t\told_fl = ei->i_flags;\n\t\tnew_fl = old_fl & ~(EXT4_SYNC_FL|EXT4_APPEND_FL|\n\t\t\t\tEXT4_IMMUTABLE_FL|EXT4_NOATIME_FL|\n\t\t\t\tEXT4_DIRSYNC_FL);\n\t\tif (vfs_fl & S_SYNC)\n\t\t\tnew_fl |= EXT4_SYNC_FL;\n\t\tif (vfs_fl & S_APPEND)\n\t\t\tnew_fl |= EXT4_APPEND_FL;\n\t\tif (vfs_fl & S_IMMUTABLE)\n\t\t\tnew_fl |= EXT4_IMMUTABLE_FL;\n\t\tif (vfs_fl & S_NOATIME)\n\t\t\tnew_fl |= EXT4_NOATIME_FL;\n\t\tif (vfs_fl & S_DIRSYNC)\n\t\t\tnew_fl |= EXT4_DIRSYNC_FL;\n\t} while (cmpxchg(&ei->i_flags, old_fl, new_fl) != old_fl);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_get_inode_flags(struct ext4_inode_info *ei)\n{\n\tunsigned int vfs_fl;\n\tunsigned long old_fl, new_fl;\n\n\tdo {\n\t\tvfs_fl = ei->vfs_inode.i_flags;\n\t\told_fl = ei->i_flags;\n\t\tnew_fl = old_fl & ~(EXT4_SYNC_FL|EXT4_APPEND_FL|\n\t\t\t\tEXT4_IMMUTABLE_FL|EXT4_NOATIME_FL|\n\t\t\t\tEXT4_DIRSYNC_FL);\n\t\tif (vfs_fl & S_SYNC)\n\t\t\tnew_fl |= EXT4_SYNC_FL;\n\t\tif (vfs_fl & S_APPEND)\n\t\t\tnew_fl |= EXT4_APPEND_FL;\n\t\tif (vfs_fl & S_IMMUTABLE)\n\t\t\tnew_fl |= EXT4_IMMUTABLE_FL;\n\t\tif (vfs_fl & S_NOATIME)\n\t\t\tnew_fl |= EXT4_NOATIME_FL;\n\t\tif (vfs_fl & S_DIRSYNC)\n\t\t\tnew_fl |= EXT4_DIRSYNC_FL;\n\t} while (cmpxchg(&ei->i_flags, old_fl, new_fl) != old_fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"cmd = %u, arg = %lu\\n\"",
            "cmd",
            "arg"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nlong ext4_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int flags;\n\n\text4_debug(\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT4_IOC_GETFLAGS:\n\t\text4_get_inode_flags(ei);\n\t\tflags = ei->i_flags & EXT4_FL_USER_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase EXT4_IOC_SETFLAGS: {\n\t\thandle_t *handle = NULL;\n\t\tint err, migrate = 0;\n\t\tstruct ext4_iloc iloc;\n\t\tunsigned int oldflags, mask, i;\n\t\tunsigned int jflag;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tflags = ext4_mask_flags(inode->i_mode, flags);\n\n\t\terr = -EPERM;\n\t\tmutex_lock(&inode->i_mutex);\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\tif (IS_NOQUOTA(inode))\n\t\t\tgoto flags_out;\n\n\t\toldflags = ei->i_flags;\n\n\t\t/* The JOURNAL_DATA flag is modifiable only by root */\n\t\tjflag = flags & EXT4_JOURNAL_DATA_FL;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t *\n\t\t * This test looks nicer. Thanks to Pauline Middelink\n\t\t */\n\t\tif ((flags ^ oldflags) & (EXT4_APPEND_FL | EXT4_IMMUTABLE_FL)) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\n\t\t/*\n\t\t * The JOURNAL_DATA flag can only be changed by\n\t\t * the relevant capability.\n\t\t */\n\t\tif ((jflag ^ oldflags) & (EXT4_JOURNAL_DATA_FL)) {\n\t\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\t\tif ((flags ^ oldflags) & EXT4_EXTENTS_FL)\n\t\t\tmigrate = 1;\n\n\t\tif (flags & EXT4_EOFBLOCKS_FL) {\n\t\t\t/* we don't support adding EOFBLOCKS flag */\n\t\t\tif (!(oldflags & EXT4_EOFBLOCKS_FL)) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto flags_out;\n\t\t\t}\n\t\t} else if (oldflags & EXT4_EOFBLOCKS_FL)\n\t\t\text4_truncate(inode);\n\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto flags_out;\n\t\t}\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err)\n\t\t\tgoto flags_err;\n\n\t\tfor (i = 0, mask = 1; i < 32; i++, mask <<= 1) {\n\t\t\tif (!(mask & EXT4_FL_USER_MODIFIABLE))\n\t\t\t\tcontinue;\n\t\t\tif (mask & flags)\n\t\t\t\text4_set_inode_flag(inode, i);\n\t\t\telse\n\t\t\t\text4_clear_inode_flag(inode, i);\n\t\t}\n\n\t\text4_set_inode_flags(inode);\n\t\tinode->i_ctime = ext4_current_time(inode);\n\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nflags_err:\n\t\text4_journal_stop(handle);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\n\t\tif ((jflag ^ oldflags) & (EXT4_JOURNAL_DATA_FL))\n\t\t\terr = ext4_change_inode_journal_flag(inode, jflag);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\t\tif (migrate) {\n\t\t\tif (flags & EXT4_EXTENTS_FL)\n\t\t\t\terr = ext4_ext_migrate(inode);\n\t\t\telse\n\t\t\t\terr = ext4_ind_migrate(inode);\n\t\t}\n\nflags_out:\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT4_IOC_GETVERSION:\n\tcase EXT4_IOC_GETVERSION_OLD:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT4_IOC_SETVERSION:\n\tcase EXT4_IOC_SETVERSION_OLD: {\n\t\thandle_t *handle;\n\t\tstruct ext4_iloc iloc;\n\t\t__u32 generation;\n\t\tint err;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (ext4_has_metadata_csum(inode->i_sb)) {\n\t\t\text4_warning(sb, \"Setting inode version is not \"\n\t\t\t\t     \"supported with metadata_csum enabled.\");\n\t\t\treturn -ENOTTY;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock_out;\n\t\t}\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err == 0) {\n\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\tinode->i_generation = generation;\n\t\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\t}\n\t\text4_journal_stop(handle);\n\nunlock_out:\n\t\tmutex_unlock(&inode->i_mutex);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT4_IOC_GROUP_EXTEND: {\n\t\text4_fsblk_t n_blocks_count;\n\t\tint err, err2=0;\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (get_user(n_blocks_count, (__u32 __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_extend_out;\n\t\t}\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online resizing not supported with bigalloc\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto group_extend_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto group_extend_out;\n\n\t\terr = ext4_group_extend(sb, EXT4_SB(sb)->s_es, n_blocks_count);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\ngroup_extend_out:\n\t\text4_resize_end(sb);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_MOVE_EXT: {\n\t\tstruct move_extent me;\n\t\tstruct fd donor;\n\t\tint err;\n\n\t\tif (!(filp->f_mode & FMODE_READ) ||\n\t\t    !(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\n\t\tif (copy_from_user(&me,\n\t\t\t(struct move_extent __user *)arg, sizeof(me)))\n\t\t\treturn -EFAULT;\n\t\tme.moved_len = 0;\n\n\t\tdonor = fdget(me.donor_fd);\n\t\tif (!donor.file)\n\t\t\treturn -EBADF;\n\n\t\tif (!(donor.file->f_mode & FMODE_WRITE)) {\n\t\t\terr = -EBADF;\n\t\t\tgoto mext_out;\n\t\t}\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online defrag not supported with bigalloc\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto mext_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto mext_out;\n\n\t\terr = ext4_move_extents(filp, donor.file, me.orig_start,\n\t\t\t\t\tme.donor_start, me.len, &me.moved_len);\n\t\tmnt_drop_write_file(filp);\n\n\t\tif (copy_to_user((struct move_extent __user *)arg,\n\t\t\t\t &me, sizeof(me)))\n\t\t\terr = -EFAULT;\nmext_out:\n\t\tfdput(donor);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_GROUP_ADD: {\n\t\tstruct ext4_new_group_data input;\n\t\tint err, err2=0;\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (copy_from_user(&input, (struct ext4_new_group_input __user *)arg,\n\t\t\t\tsizeof(input))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_add_out;\n\t\t}\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online resizing not supported with bigalloc\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto group_add_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto group_add_out;\n\n\t\terr = ext4_group_add(sb, &input);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\n\t\tif (!err && ext4_has_group_desc_csum(sb) &&\n\t\t    test_opt(sb, INIT_INODE_TABLE))\n\t\t\terr = ext4_register_li_request(sb, input.group);\ngroup_add_out:\n\t\text4_resize_end(sb);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_MIGRATE:\n\t{\n\t\tint err;\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * inode_mutex prevent write and truncate on the file.\n\t\t * Read still goes through. We take i_data_sem in\n\t\t * ext4_ext_swap_inode_data before we switch the\n\t\t * inode format to prevent read.\n\t\t */\n\t\tmutex_lock(&(inode->i_mutex));\n\t\terr = ext4_ext_migrate(inode);\n\t\tmutex_unlock(&(inode->i_mutex));\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_ALLOC_DA_BLKS:\n\t{\n\t\tint err;\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = ext4_alloc_da_blocks(inode);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_SWAP_BOOT:\n\t{\n\t\tint err;\n\t\tif (!(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = swap_inode_boot_loader(sb, inode);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_RESIZE_FS: {\n\t\text4_fsblk_t n_blocks_count;\n\t\tint err = 0, err2 = 0;\n\t\text4_group_t o_group = EXT4_SB(sb)->s_groups_count;\n\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Online resizing not (yet) supported with bigalloc\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (copy_from_user(&n_blocks_count, (__u64 __user *)arg,\n\t\t\t\t   sizeof(__u64))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto resizefs_out;\n\n\t\terr = ext4_resize_fs(sb, n_blocks_count);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\n\t\tif (!err && (o_group > EXT4_SB(sb)->s_groups_count) &&\n\t\t    ext4_has_group_desc_csum(sb) &&\n\t\t    test_opt(sb, INIT_INODE_TABLE))\n\t\t\terr = ext4_register_li_request(sb, o_group);\n\nresizefs_out:\n\t\text4_resize_end(sb);\n\t\treturn err;\n\t}\n\n\tcase FITRIM:\n\t{\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!blk_queue_discard(q))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max((unsigned int)range.minlen,\n\t\t\t\t   q->limits.discard_granularity);\n\t\tret = ext4_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase EXT4_IOC_PRECACHE_EXTENTS:\n\t\treturn ext4_ext_precache(inode);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
  },
  {
    "function_name": "swap_inode_boot_loader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
    "lines": "96-197",
    "snippet": "static long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\tfilemap_flush(inode->i_mapping);\n\tfilemap_flush(inode_bl->i_mapping);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\text4_inode_block_unlocked_dio(inode_bl);\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (inode_bl->i_nlink == 0) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_bl->i_version = 1;\n\t\ti_size_write(inode_bl, 0);\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);\n\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tinode_bl->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\text4_discard_preallocations(inode);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\text4_warning(inode->i_sb,\n\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t} else {\n\t\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\t\tif (err < 0) {\n\t\t\text4_warning(inode_bl->i_sb,\n\t\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\t\tinode_bl->i_ino, err);\n\t\t\t/* Revert all changes: */\n\t\t\tswap_inode_data(inode, inode_bl);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\njournal_err_out:\n\text4_inode_resume_unlocked_dio(inode);\n\text4_inode_resume_unlocked_dio(inode_bl);\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/capability.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode_bl"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_two_nondirectories",
          "args": [
            "inode",
            "inode_bl"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_two_nondirectories",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "962-968",
          "snippet": "void unlock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tmutex_unlock(&inode1->i_mutex);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tmutex_unlock(&inode2->i_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tmutex_unlock(&inode1->i_mutex);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tmutex_unlock(&inode2->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_resume_unlocked_dio",
          "args": [
            "inode_bl"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2830-2834",
          "snippet": "static inline void ext4_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb();\n\text4_clear_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb();\n\text4_clear_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_double_up_write_data_sem",
          "args": [
            "inode",
            "inode_bl"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_double_up_write_data_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "78-84",
          "snippet": "void\next4_double_up_write_data_sem(struct inode *orig_inode,\n\t\t\t      struct inode *donor_inode)\n{\n\tup_write(&EXT4_I(orig_inode)->i_data_sem);\n\tup_write(&EXT4_I(donor_inode)->i_data_sem);\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid\next4_double_up_write_data_sem(struct inode *orig_inode,\n\t\t\t      struct inode *donor_inode)\n{\n\tup_write(&EXT4_I(orig_inode)->i_data_sem);\n\tup_write(&EXT4_I(donor_inode)->i_data_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_inode_data",
          "args": [
            "inode",
            "inode_bl"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "swap_inode_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
          "lines": "58-85",
          "snippet": "static void swap_inode_data(struct inode *inode1, struct inode *inode2)\n{\n\tloff_t isize;\n\tstruct ext4_inode_info *ei1;\n\tstruct ext4_inode_info *ei2;\n\n\tei1 = EXT4_I(inode1);\n\tei2 = EXT4_I(inode2);\n\n\tmemswap(&inode1->i_flags, &inode2->i_flags, sizeof(inode1->i_flags));\n\tmemswap(&inode1->i_version, &inode2->i_version,\n\t\t  sizeof(inode1->i_version));\n\tmemswap(&inode1->i_blocks, &inode2->i_blocks,\n\t\t  sizeof(inode1->i_blocks));\n\tmemswap(&inode1->i_bytes, &inode2->i_bytes, sizeof(inode1->i_bytes));\n\tmemswap(&inode1->i_atime, &inode2->i_atime, sizeof(inode1->i_atime));\n\tmemswap(&inode1->i_mtime, &inode2->i_mtime, sizeof(inode1->i_mtime));\n\n\tmemswap(ei1->i_data, ei2->i_data, sizeof(ei1->i_data));\n\tmemswap(&ei1->i_flags, &ei2->i_flags, sizeof(ei1->i_flags));\n\tmemswap(&ei1->i_disksize, &ei2->i_disksize, sizeof(ei1->i_disksize));\n\text4_es_remove_extent(inode1, 0, EXT_MAX_BLOCKS);\n\text4_es_remove_extent(inode2, 0, EXT_MAX_BLOCKS);\n\n\tisize = i_size_read(inode1);\n\ti_size_write(inode1, i_size_read(inode2));\n\ti_size_write(inode2, isize);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/capability.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic void swap_inode_data(struct inode *inode1, struct inode *inode2)\n{\n\tloff_t isize;\n\tstruct ext4_inode_info *ei1;\n\tstruct ext4_inode_info *ei2;\n\n\tei1 = EXT4_I(inode1);\n\tei2 = EXT4_I(inode2);\n\n\tmemswap(&inode1->i_flags, &inode2->i_flags, sizeof(inode1->i_flags));\n\tmemswap(&inode1->i_version, &inode2->i_version,\n\t\t  sizeof(inode1->i_version));\n\tmemswap(&inode1->i_blocks, &inode2->i_blocks,\n\t\t  sizeof(inode1->i_blocks));\n\tmemswap(&inode1->i_bytes, &inode2->i_bytes, sizeof(inode1->i_bytes));\n\tmemswap(&inode1->i_atime, &inode2->i_atime, sizeof(inode1->i_atime));\n\tmemswap(&inode1->i_mtime, &inode2->i_mtime, sizeof(inode1->i_mtime));\n\n\tmemswap(ei1->i_data, ei2->i_data, sizeof(ei1->i_data));\n\tmemswap(&ei1->i_flags, &ei2->i_flags, sizeof(ei1->i_flags));\n\tmemswap(&ei1->i_disksize, &ei2->i_disksize, sizeof(ei1->i_disksize));\n\text4_es_remove_extent(inode1, 0, EXT_MAX_BLOCKS);\n\text4_es_remove_extent(inode2, 0, EXT_MAX_BLOCKS);\n\n\tisize = i_size_read(inode1);\n\ti_size_write(inode1, i_size_read(inode2));\n\ti_size_write(inode2, isize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode_bl->i_sb",
            "\"couldn't mark inode #%lu dirty (err %d)\"",
            "inode_bl->i_ino",
            "err"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_discard_preallocations",
          "args": [
            "inode"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_discard_preallocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3920-4020",
          "snippet": "void ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_next_gen_lock"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_next_gen_lock"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ei_bl->i_data",
            "0",
            "sizeof(ei_bl->i_data)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ext_tree_init",
          "args": [
            "handle",
            "inode_bl"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_tree_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "844-855",
          "snippet": "int ext4_ext_tree_init(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_extent_header *eh;\n\n\teh = ext_inode_hdr(inode);\n\teh->eh_depth = 0;\n\teh->eh_entries = 0;\n\teh->eh_magic = EXT4_EXT_MAGIC;\n\teh->eh_max = cpu_to_le16(ext4_ext_space_root(inode, 0));\n\text4_mark_inode_dirty(handle, inode);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_ext_tree_init(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_extent_header *eh;\n\n\teh = ext_inode_hdr(inode);\n\teh->eh_depth = 0;\n\teh->eh_entries = 0;\n\teh->eh_magic = EXT4_EXT_MAGIC;\n\teh->eh_max = cpu_to_le16(ext4_ext_space_root(inode, 0));\n\text4_mark_inode_dirty(handle, inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_flag",
          "args": [
            "inode_bl",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_EXTENTS"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode_bl",
            "0"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode_bl",
            "0"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode_bl",
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode_bl",
            "1"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_double_down_write_data_sem",
          "args": [
            "inode",
            "inode_bl"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_double_down_write_data_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/move_extent.c",
          "lines": "58-69",
          "snippet": "void\next4_double_down_write_data_sem(struct inode *first, struct inode *second)\n{\n\tif (first < second) {\n\t\tdown_write(&EXT4_I(first)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(second)->i_data_sem, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tdown_write(&EXT4_I(second)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(first)->i_data_sem, SINGLE_DEPTH_NESTING);\n\n\t}\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid\next4_double_down_write_data_sem(struct inode *first, struct inode *second)\n{\n\tif (first < second) {\n\t\tdown_write(&EXT4_I(first)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(second)->i_data_sem, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tdown_write(&EXT4_I(second)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(first)->i_data_sem, SINGLE_DEPTH_NESTING);\n\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode_bl",
            "EXT4_HT_MOVE_EXTENTS",
            "2"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode_bl"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_block_unlocked_dio",
          "args": [
            "inode_bl"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_block_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2825-2829",
          "snippet": "static inline void ext4_inode_block_unlocked_dio(struct inode *inode)\n{\n\text4_set_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n\tsmp_mb();\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_block_unlocked_dio(struct inode *inode)\n{\n\text4_set_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "&inode_bl->i_data",
            "0"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "&inode->i_data",
            "0"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_flush",
          "args": [
            "inode_bl->i_mapping"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_flush",
          "args": [
            "inode->i_mapping"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode_bl"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode_bl"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode_bl"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_iget",
          "args": [
            "sb",
            "EXT4_BOOT_LOADER_INO"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_iget_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4138-4143",
          "snippet": "struct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\tfilemap_flush(inode->i_mapping);\n\tfilemap_flush(inode_bl->i_mapping);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\text4_inode_block_unlocked_dio(inode_bl);\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (inode_bl->i_nlink == 0) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_bl->i_version = 1;\n\t\ti_size_write(inode_bl, 0);\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);\n\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tinode_bl->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\text4_discard_preallocations(inode);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\text4_warning(inode->i_sb,\n\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t} else {\n\t\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\t\tif (err < 0) {\n\t\t\text4_warning(inode_bl->i_sb,\n\t\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\t\tinode_bl->i_ino, err);\n\t\t\t/* Revert all changes: */\n\t\t\tswap_inode_data(inode, inode_bl);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\njournal_err_out:\n\text4_inode_resume_unlocked_dio(inode);\n\text4_inode_resume_unlocked_dio(inode_bl);\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}"
  },
  {
    "function_name": "swap_inode_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
    "lines": "58-85",
    "snippet": "static void swap_inode_data(struct inode *inode1, struct inode *inode2)\n{\n\tloff_t isize;\n\tstruct ext4_inode_info *ei1;\n\tstruct ext4_inode_info *ei2;\n\n\tei1 = EXT4_I(inode1);\n\tei2 = EXT4_I(inode2);\n\n\tmemswap(&inode1->i_flags, &inode2->i_flags, sizeof(inode1->i_flags));\n\tmemswap(&inode1->i_version, &inode2->i_version,\n\t\t  sizeof(inode1->i_version));\n\tmemswap(&inode1->i_blocks, &inode2->i_blocks,\n\t\t  sizeof(inode1->i_blocks));\n\tmemswap(&inode1->i_bytes, &inode2->i_bytes, sizeof(inode1->i_bytes));\n\tmemswap(&inode1->i_atime, &inode2->i_atime, sizeof(inode1->i_atime));\n\tmemswap(&inode1->i_mtime, &inode2->i_mtime, sizeof(inode1->i_mtime));\n\n\tmemswap(ei1->i_data, ei2->i_data, sizeof(ei1->i_data));\n\tmemswap(&ei1->i_flags, &ei2->i_flags, sizeof(ei1->i_flags));\n\tmemswap(&ei1->i_disksize, &ei2->i_disksize, sizeof(ei1->i_disksize));\n\text4_es_remove_extent(inode1, 0, EXT_MAX_BLOCKS);\n\text4_es_remove_extent(inode2, 0, EXT_MAX_BLOCKS);\n\n\tisize = i_size_read(inode1);\n\ti_size_write(inode1, i_size_read(inode2));\n\ti_size_write(inode2, isize);\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/capability.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode2",
            "isize"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode2"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode1"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_remove_extent",
          "args": [
            "inode2",
            "0",
            "EXT_MAX_BLOCKS"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "938-964",
          "snippet": "int ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nint ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memswap",
          "args": [
            "&ei1->i_disksize",
            "&ei2->i_disksize",
            "sizeof(ei1->i_disksize)"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "memswap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
          "lines": "31-45",
          "snippet": "static void memswap(void *a, void *b, size_t len)\n{\n\tunsigned char *ap, *bp;\n\tunsigned char tmp;\n\n\tap = (unsigned char *)a;\n\tbp = (unsigned char *)b;\n\twhile (len-- > 0) {\n\t\ttmp = *ap;\n\t\t*ap = *bp;\n\t\t*bp = tmp;\n\t\tap++;\n\t\tbp++;\n\t}\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/capability.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic void memswap(void *a, void *b, size_t len)\n{\n\tunsigned char *ap, *bp;\n\tunsigned char tmp;\n\n\tap = (unsigned char *)a;\n\tbp = (unsigned char *)b;\n\twhile (len-- > 0) {\n\t\ttmp = *ap;\n\t\t*ap = *bp;\n\t\t*bp = tmp;\n\t\tap++;\n\t\tbp++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode2"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic void swap_inode_data(struct inode *inode1, struct inode *inode2)\n{\n\tloff_t isize;\n\tstruct ext4_inode_info *ei1;\n\tstruct ext4_inode_info *ei2;\n\n\tei1 = EXT4_I(inode1);\n\tei2 = EXT4_I(inode2);\n\n\tmemswap(&inode1->i_flags, &inode2->i_flags, sizeof(inode1->i_flags));\n\tmemswap(&inode1->i_version, &inode2->i_version,\n\t\t  sizeof(inode1->i_version));\n\tmemswap(&inode1->i_blocks, &inode2->i_blocks,\n\t\t  sizeof(inode1->i_blocks));\n\tmemswap(&inode1->i_bytes, &inode2->i_bytes, sizeof(inode1->i_bytes));\n\tmemswap(&inode1->i_atime, &inode2->i_atime, sizeof(inode1->i_atime));\n\tmemswap(&inode1->i_mtime, &inode2->i_mtime, sizeof(inode1->i_mtime));\n\n\tmemswap(ei1->i_data, ei2->i_data, sizeof(ei1->i_data));\n\tmemswap(&ei1->i_flags, &ei2->i_flags, sizeof(ei1->i_flags));\n\tmemswap(&ei1->i_disksize, &ei2->i_disksize, sizeof(ei1->i_disksize));\n\text4_es_remove_extent(inode1, 0, EXT_MAX_BLOCKS);\n\text4_es_remove_extent(inode2, 0, EXT_MAX_BLOCKS);\n\n\tisize = i_size_read(inode1);\n\ti_size_write(inode1, i_size_read(inode2));\n\ti_size_write(inode2, isize);\n}"
  },
  {
    "function_name": "memswap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
    "lines": "31-45",
    "snippet": "static void memswap(void *a, void *b, size_t len)\n{\n\tunsigned char *ap, *bp;\n\tunsigned char tmp;\n\n\tap = (unsigned char *)a;\n\tbp = (unsigned char *)b;\n\twhile (len-- > 0) {\n\t\ttmp = *ap;\n\t\t*ap = *bp;\n\t\t*bp = tmp;\n\t\tap++;\n\t\tbp++;\n\t}\n}",
    "includes": [
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/time.h>",
      "#include <linux/capability.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic void memswap(void *a, void *b, size_t len)\n{\n\tunsigned char *ap, *bp;\n\tunsigned char tmp;\n\n\tap = (unsigned char *)a;\n\tbp = (unsigned char *)b;\n\twhile (len-- > 0) {\n\t\ttmp = *ap;\n\t\t*ap = *bp;\n\t\t*bp = tmp;\n\t\tap++;\n\t\tbp++;\n\t}\n}"
  }
]