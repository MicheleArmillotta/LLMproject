[
  {
    "function_name": "lsave(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "2005-2037",
    "snippet": "g_populate_lsave(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tint i;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\tif (prandom_u32() & 3)\n\t\treturn 0;\n\n\tfor (i = 0; i < c->lsave_cnt; i++)\n\t\tc->lsave[i] = c->main_first;\n\n\tlist_for_each_entry(lprops, &c->empty_list, list)\n\t\tc->lsave[prandom_u32() % c->lsave_cnt] = lprops->lnum;\n\tlist_for_each_entry(lprops, &c->freeable_list, list)\n\t\tc->lsave[prandom_u32() % c->lsave_cnt] = lprops->lnum;\n\tlist_for_each_entry(lprops, &c->frdi_idx_list, list)\n\t\tc->lsave[prandom_u32() % c->lsave_cnt] = lprops->lnum;\n\n\theap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\n\tfor (i = 0; i < heap->cnt; i++)\n\t\tc->lsave[prandom_u32() % c->lsave_cnt] = heap->arr[i]->lnum;\n\theap = &c->lpt_heap[LPROPS_DIRTY - 1];\n\tfor (i = 0; i < heap->cnt; i++)\n\t\tc->lsave[prandom_u32() % c->lsave_cnt] = heap->arr[i]->lnum;\n\theap = &c->lpt_heap[LPROPS_FREE - 1];\n\tfor (i = 0; i < heap->cnt; i++)\n\t\tc->lsave[prandom_u32() % c->lsave_cnt] = heap->arr[i]->lnum;\n\n\treturn 1;\n}",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "% c->lsave",
          "args": [],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "% c->lsave",
          "args": [],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "% c->lsave",
          "args": [],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "% c->lsave",
          "args": [],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "rdi_id",
            "list, list)\n\t\tc->",
            "ave["
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "% c->lsave",
          "args": [],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "reeabl",
            "list, list)\n\t\tc->",
            "ave["
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "% c->lsave",
          "args": [],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "mpty_l",
            "t, list)\n\t\tc->",
            "ave["
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "& 3)\n\t\tret",
          "args": [],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\ng_populate_lsave(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tint i;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\tif (prandom_u32() & 3)\n\t\treturn 0;\n\n\tfor (i = 0; i < c->lsave_cnt; i++)\n\t\tc->lsave[i] = c->main_first;\n\n\tlist_for_each_entry(lprops, &c->empty_list, list)\n\t\tc->lsave[prandom_u32() % c->lsave_cnt] = lprops->lnum;\n\tlist_for_each_entry(lprops, &c->freeable_list, list)\n\t\tc->lsave[prandom_u32() % c->lsave_cnt] = lprops->lnum;\n\tlist_for_each_entry(lprops, &c->frdi_idx_list, list)\n\t\tc->lsave[prandom_u32() % c->lsave_cnt] = lprops->lnum;\n\n\theap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\n\tfor (i = 0; i < heap->cnt; i++)\n\t\tc->lsave[prandom_u32() % c->lsave_cnt] = heap->arr[i]->lnum;\n\theap = &c->lpt_heap[LPROPS_DIRTY - 1];\n\tfor (i = 0; i < heap->cnt; i++)\n\t\tc->lsave[prandom_u32() % c->lsave_cnt] = heap->arr[i]->lnum;\n\theap = &c->lpt_heap[LPROPS_FREE - 1];\n\tfor (i = 0; i < heap->cnt; i++)\n\t\tc->lsave[prandom_u32() % c->lsave_cnt] = heap->arr[i]->lnum;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "t_lebs(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1986-1994",
    "snippet": "mp_lpt_lebs(const struct ubifs_info *c)\n{\n\tint i;\n\n\tpr_err(\"(pid %d) start dumping all LPT LEBs\\n\", current->pid);\n\tfor (i = 0; i < c->lpt_lebs; i++)\n\t\tdump_lpt_leb(c, i + c->lpt_first);\n\tpr_err(\"(pid %d) finish dumping all LPT LEBs\\n\", current->pid);\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "%d) fi",
          "args": [
            "ish dumping all LPT LEBs\\n\", current->pi",
            ";\n}\n\n/**\n *"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, i + c->lp",
          "args": [
            "_",
            "rst);\n\tpr_err(\"("
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d) st",
          "args": [
            "rt dumping all LPT LEBs\\n\", current->pi",
            ";\n\tfor (i ="
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nmp_lpt_lebs(const struct ubifs_info *c)\n{\n\tint i;\n\n\tpr_err(\"(pid %d) start dumping all LPT LEBs\\n\", current->pid);\n\tfor (i = 0; i < c->lpt_lebs; i++)\n\t\tdump_lpt_leb(c, i + c->lpt_first);\n\tpr_err(\"(pid %d) finish dumping all LPT LEBs\\n\", current->pid);\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1882-1977",
    "snippet": "ump_lpt_leb(const struct ubifs_info *c, int lnum)\n{\n\tint err, len = c->leb_size, node_type, node_num, node_len, offs;\n\tvoid *buf, *p;\n\n\tpr_err(\"(pid %d) start dumping LEB %d\\n\", current->pid, lnum);\n\tbuf = p = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory to dump LPT\");\n\t\treturn;\n\t}\n\n\terr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\n\tif (err)\n\t\tgoto out;\n\n\twhile (1) {\n\t\toffs = c->leb_size - len;\n\t\tif (!is_a_node(c, p, len)) {\n\t\t\tint pad_len;\n\n\t\t\tpad_len = get_pad_len(c, p, len);\n\t\t\tif (pad_len) {\n\t\t\t\tpr_err(\"LEB %d:%d, pad %d bytes\\n\",\n\t\t\t\t       lnum, offs, pad_len);\n\t\t\t\tp += pad_len;\n\t\t\t\tlen -= pad_len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (len)\n\t\t\t\tpr_err(\"LEB %d:%d, free %d bytes\\n\",\n\t\t\t\t       lnum, offs, len);\n\t\t\tbreak;\n\t\t}\n\n\t\tnode_type = get_lpt_node_type(c, p, &node_num);\n\t\tswitch (node_type) {\n\t\tcase UBIFS_LPT_PNODE:\n\t\t{\n\t\t\tnode_len = c->pnode_sz;\n\t\t\tif (c->big_lpt)\n\t\t\t\tpr_err(\"LEB %d:%d, pnode num %d\\n\",\n\t\t\t\t       lnum, offs, node_num);\n\t\t\telse\n\t\t\t\tpr_err(\"LEB %d:%d, pnode\\n\", lnum, offs);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_LPT_NNODE:\n\t\t{\n\t\t\tint i;\n\t\t\tstruct ubifs_nnode nnode;\n\n\t\t\tnode_len = c->nnode_sz;\n\t\t\tif (c->big_lpt)\n\t\t\t\tpr_err(\"LEB %d:%d, nnode num %d, \",\n\t\t\t\t       lnum, offs, node_num);\n\t\t\telse\n\t\t\t\tpr_err(\"LEB %d:%d, nnode, \",\n\t\t\t\t       lnum, offs);\n\t\t\terr = ubifs_unpack_nnode(c, p, &nnode);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"failed to unpack_node, error %d\\n\",\n\t\t\t\t       err);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\t\tpr_cont(\"%d:%d\", nnode.nbranch[i].lnum,\n\t\t\t\t       nnode.nbranch[i].offs);\n\t\t\t\tif (i != UBIFS_LPT_FANOUT - 1)\n\t\t\t\t\tpr_cont(\", \");\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_LPT_LTAB:\n\t\t\tnode_len = c->ltab_sz;\n\t\t\tpr_err(\"LEB %d:%d, ltab\\n\", lnum, offs);\n\t\t\tbreak;\n\t\tcase UBIFS_LPT_LSAVE:\n\t\t\tnode_len = c->lsave_sz;\n\t\t\tpr_err(\"LEB %d:%d, lsave len\\n\", lnum, offs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tubifs_err(\"LPT node type %d not recognized\", node_type);\n\t\t\tgoto out;\n\t\t}\n\n\t\tp += node_len;\n\t\tlen -= node_len;\n\t}\n\n\tpr_err(\"(pid %d) finish dumping LEB %d\\n\", current->pid, lnum);\nout:\n\tvfree(buf);\n\treturn;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            ";\n}"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "%d) fi",
          "args": [
            "ish dumping LEB %d\\n\", current->pi",
            "lnum);\nout:",
            "vfre"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T node ty",
          "args": [
            "e %d not recognized\", node_type);",
            "goto ou"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "save len\\n\", lnum, offs)",
            "b",
            "ak;"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "tab\\n\", lnum, offs)",
            "b",
            "ak;"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tbr",
          "args": [
            "ak;"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\t}",
          "args": [
            "pr"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d\", nno",
          "args": [
            "e.nbran",
            "[i].lnum,",
            "[i].offs);\n\t\t\t\tif (i"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d to u",
          "args": [
            "pack_node, error %d\\n\",",
            "ak;"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnode(c, p, &nnode",
          "args": [
            ";",
            "f (err"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "node, \",",
            "e",
            "= u"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "node num %d, \",",
            "ode_",
            "m);",
            "else"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "node\\n\", lnum, offs)",
            "b",
            "ak;"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "node num %d\\n\",",
            "ode_",
            "m);",
            "else"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type(c, p, &node_",
          "args": [
            "u",
            ";",
            "switch ("
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "ree %d bytes\\n\",",
            "en);",
            "br",
            "k;"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "ad %d bytes\\n\",",
            "ad_l",
            ");",
            "p += p"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", p, len);",
          "args": [
            "f",
            "pad"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p, len))",
          "args": [
            "t p"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, buf",
          "args": [
            "c->",
            "b_s",
            "e",
            "1);\n\tif (er"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot allo",
          "args": [
            "ate memory to dump LPT\");\n\t\treturn;"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb_size,",
          "args": [
            "GFP_NOFS, P",
            "E_KERNEL",
            "if (!buf)"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d) st",
          "args": [
            "rt dumping LEB %d\\n\", current->pi",
            "lnum);\n\tbuf",
            "p ="
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nump_lpt_leb(const struct ubifs_info *c, int lnum)\n{\n\tint err, len = c->leb_size, node_type, node_num, node_len, offs;\n\tvoid *buf, *p;\n\n\tpr_err(\"(pid %d) start dumping LEB %d\\n\", current->pid, lnum);\n\tbuf = p = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory to dump LPT\");\n\t\treturn;\n\t}\n\n\terr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\n\tif (err)\n\t\tgoto out;\n\n\twhile (1) {\n\t\toffs = c->leb_size - len;\n\t\tif (!is_a_node(c, p, len)) {\n\t\t\tint pad_len;\n\n\t\t\tpad_len = get_pad_len(c, p, len);\n\t\t\tif (pad_len) {\n\t\t\t\tpr_err(\"LEB %d:%d, pad %d bytes\\n\",\n\t\t\t\t       lnum, offs, pad_len);\n\t\t\t\tp += pad_len;\n\t\t\t\tlen -= pad_len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (len)\n\t\t\t\tpr_err(\"LEB %d:%d, free %d bytes\\n\",\n\t\t\t\t       lnum, offs, len);\n\t\t\tbreak;\n\t\t}\n\n\t\tnode_type = get_lpt_node_type(c, p, &node_num);\n\t\tswitch (node_type) {\n\t\tcase UBIFS_LPT_PNODE:\n\t\t{\n\t\t\tnode_len = c->pnode_sz;\n\t\t\tif (c->big_lpt)\n\t\t\t\tpr_err(\"LEB %d:%d, pnode num %d\\n\",\n\t\t\t\t       lnum, offs, node_num);\n\t\t\telse\n\t\t\t\tpr_err(\"LEB %d:%d, pnode\\n\", lnum, offs);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_LPT_NNODE:\n\t\t{\n\t\t\tint i;\n\t\t\tstruct ubifs_nnode nnode;\n\n\t\t\tnode_len = c->nnode_sz;\n\t\t\tif (c->big_lpt)\n\t\t\t\tpr_err(\"LEB %d:%d, nnode num %d, \",\n\t\t\t\t       lnum, offs, node_num);\n\t\t\telse\n\t\t\t\tpr_err(\"LEB %d:%d, nnode, \",\n\t\t\t\t       lnum, offs);\n\t\t\terr = ubifs_unpack_nnode(c, p, &nnode);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"failed to unpack_node, error %d\\n\",\n\t\t\t\t       err);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\t\tpr_cont(\"%d:%d\", nnode.nbranch[i].lnum,\n\t\t\t\t       nnode.nbranch[i].offs);\n\t\t\t\tif (i != UBIFS_LPT_FANOUT - 1)\n\t\t\t\t\tpr_cont(\", \");\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_LPT_LTAB:\n\t\t\tnode_len = c->ltab_sz;\n\t\t\tpr_err(\"LEB %d:%d, ltab\\n\", lnum, offs);\n\t\t\tbreak;\n\t\tcase UBIFS_LPT_LSAVE:\n\t\t\tnode_len = c->lsave_sz;\n\t\t\tpr_err(\"LEB %d:%d, lsave len\\n\", lnum, offs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tubifs_err(\"LPT node type %d not recognized\", node_type);\n\t\t\tgoto out;\n\t\t}\n\n\t\tp += node_len;\n\t\tlen -= node_len;\n\t}\n\n\tpr_err(\"(pid %d) finish dumping LEB %d\\n\", current->pid, lnum);\nout:\n\tvfree(buf);\n\treturn;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "z(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1784-1870",
    "snippet": "pt_sz(struct ubifs_info *c, int action, int len)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\tlong long chk_lpt_sz, lpt_sz;\n\tint err = 0;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tswitch (action) {\n\tcase 0:\n\t\td->chk_lpt_sz = 0;\n\t\td->chk_lpt_sz2 = 0;\n\t\td->chk_lpt_lebs = 0;\n\t\td->chk_lpt_wastage = 0;\n\t\tif (c->dirty_pn_cnt > c->pnode_cnt) {\n\t\t\tubifs_err(\"dirty pnodes %d exceed max %d\",\n\t\t\t\t  c->dirty_pn_cnt, c->pnode_cnt);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (c->dirty_nn_cnt > c->nnode_cnt) {\n\t\t\tubifs_err(\"dirty nnodes %d exceed max %d\",\n\t\t\t\t  c->dirty_nn_cnt, c->nnode_cnt);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\treturn err;\n\tcase 1:\n\t\td->chk_lpt_sz += len;\n\t\treturn 0;\n\tcase 2:\n\t\td->chk_lpt_sz += len;\n\t\td->chk_lpt_wastage += len;\n\t\td->chk_lpt_lebs += 1;\n\t\treturn 0;\n\tcase 3:\n\t\tchk_lpt_sz = c->leb_size;\n\t\tchk_lpt_sz *= d->chk_lpt_lebs;\n\t\tchk_lpt_sz += len - c->nhead_offs;\n\t\tif (d->chk_lpt_sz != chk_lpt_sz) {\n\t\t\tubifs_err(\"LPT wrote %lld but space used was %lld\",\n\t\t\t\t  d->chk_lpt_sz, chk_lpt_sz);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (d->chk_lpt_sz > c->lpt_sz) {\n\t\t\tubifs_err(\"LPT wrote %lld but lpt_sz is %lld\",\n\t\t\t\t  d->chk_lpt_sz, c->lpt_sz);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (d->chk_lpt_sz2 && d->chk_lpt_sz != d->chk_lpt_sz2) {\n\t\t\tubifs_err(\"LPT layout size %lld but wrote %lld\",\n\t\t\t\t  d->chk_lpt_sz, d->chk_lpt_sz2);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (d->chk_lpt_sz2 && d->new_nhead_offs != len) {\n\t\t\tubifs_err(\"LPT new nhead offs: expected %d was %d\",\n\t\t\t\t  d->new_nhead_offs, len);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tlpt_sz = (long long)c->pnode_cnt * c->pnode_sz;\n\t\tlpt_sz += (long long)c->nnode_cnt * c->nnode_sz;\n\t\tlpt_sz += c->ltab_sz;\n\t\tif (c->big_lpt)\n\t\t\tlpt_sz += c->lsave_sz;\n\t\tif (d->chk_lpt_sz - d->chk_lpt_wastage > lpt_sz) {\n\t\t\tubifs_err(\"LPT chk_lpt_sz %lld + waste %lld exceeds %lld\",\n\t\t\t\t  d->chk_lpt_sz, d->chk_lpt_wastage, lpt_sz);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (err) {\n\t\t\tubifs_dump_lpt_info(c);\n\t\t\tubifs_dump_lpt_lebs(c);\n\t\t\tdump_stack();\n\t\t}\n\t\td->chk_lpt_sz2 = d->chk_lpt_sz;\n\t\td->chk_lpt_sz = 0;\n\t\td->chk_lpt_wastage = 0;\n\t\td->chk_lpt_lebs = 0;\n\t\td->new_nhead_offs = len;\n\t\treturn err;\n\tcase 4:\n\t\td->chk_lpt_sz += len;\n\t\td->chk_lpt_wastage += len;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\t\td->",
          "args": [],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_lebs(c);\n\t\t\tdump_",
          "args": [
            "t"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_info(c);\n\t\t\tubifs",
          "args": [
            "d"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T chk_lpt",
          "args": [
            "sz %lld + waste %lld exceeds %lld\",\n\t\t\t\t  d->ch",
            ", d->chk_lpt_",
            "stage, lpt_sz);",
            "rr = -"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T new nhe",
          "args": [
            "d offs: expected %d was %d\",\n\t\t\t\t  d->ne",
            "offs, len);\n\t\t\ter",
            "= -"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T layout",
          "args": [
            "ize %lld but wrote %lld\",\n\t\t\t\t  d->ch",
            ", d->chk_lpt_",
            "2);\n\t\t\terr = -"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T wrote %",
          "args": [
            "ld but lpt_sz is %lld\",\n\t\t\t\t  d->ch",
            ", c->lpt_sz);",
            "err = -"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T wrote %",
          "args": [
            "ld but space used was %lld\",\n\t\t\t\t  d->ch",
            ", chk_lpt_sz)",
            "err = -"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty nnode",
          "args": [
            "%d exceed max %d\",\n\t\t\t\t  c->di",
            "nt, c->nnode_cn",
            ";\n\t\t\terr = -"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty pnode",
          "args": [
            "%d exceed max %d\",\n\t\t\t\t  c->di",
            "nt, c->pnode_cn",
            ";\n\t\t\terr = -"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\npt_sz(struct ubifs_info *c, int action, int len)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\tlong long chk_lpt_sz, lpt_sz;\n\tint err = 0;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tswitch (action) {\n\tcase 0:\n\t\td->chk_lpt_sz = 0;\n\t\td->chk_lpt_sz2 = 0;\n\t\td->chk_lpt_lebs = 0;\n\t\td->chk_lpt_wastage = 0;\n\t\tif (c->dirty_pn_cnt > c->pnode_cnt) {\n\t\t\tubifs_err(\"dirty pnodes %d exceed max %d\",\n\t\t\t\t  c->dirty_pn_cnt, c->pnode_cnt);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (c->dirty_nn_cnt > c->nnode_cnt) {\n\t\t\tubifs_err(\"dirty nnodes %d exceed max %d\",\n\t\t\t\t  c->dirty_nn_cnt, c->nnode_cnt);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\treturn err;\n\tcase 1:\n\t\td->chk_lpt_sz += len;\n\t\treturn 0;\n\tcase 2:\n\t\td->chk_lpt_sz += len;\n\t\td->chk_lpt_wastage += len;\n\t\td->chk_lpt_lebs += 1;\n\t\treturn 0;\n\tcase 3:\n\t\tchk_lpt_sz = c->leb_size;\n\t\tchk_lpt_sz *= d->chk_lpt_lebs;\n\t\tchk_lpt_sz += len - c->nhead_offs;\n\t\tif (d->chk_lpt_sz != chk_lpt_sz) {\n\t\t\tubifs_err(\"LPT wrote %lld but space used was %lld\",\n\t\t\t\t  d->chk_lpt_sz, chk_lpt_sz);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (d->chk_lpt_sz > c->lpt_sz) {\n\t\t\tubifs_err(\"LPT wrote %lld but lpt_sz is %lld\",\n\t\t\t\t  d->chk_lpt_sz, c->lpt_sz);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (d->chk_lpt_sz2 && d->chk_lpt_sz != d->chk_lpt_sz2) {\n\t\t\tubifs_err(\"LPT layout size %lld but wrote %lld\",\n\t\t\t\t  d->chk_lpt_sz, d->chk_lpt_sz2);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (d->chk_lpt_sz2 && d->new_nhead_offs != len) {\n\t\t\tubifs_err(\"LPT new nhead offs: expected %d was %d\",\n\t\t\t\t  d->new_nhead_offs, len);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tlpt_sz = (long long)c->pnode_cnt * c->pnode_sz;\n\t\tlpt_sz += (long long)c->nnode_cnt * c->nnode_sz;\n\t\tlpt_sz += c->ltab_sz;\n\t\tif (c->big_lpt)\n\t\t\tlpt_sz += c->lsave_sz;\n\t\tif (d->chk_lpt_sz - d->chk_lpt_wastage > lpt_sz) {\n\t\t\tubifs_err(\"LPT chk_lpt_sz %lld + waste %lld exceeds %lld\",\n\t\t\t\t  d->chk_lpt_sz, d->chk_lpt_wastage, lpt_sz);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (err) {\n\t\t\tubifs_dump_lpt_info(c);\n\t\t\tubifs_dump_lpt_lebs(c);\n\t\t\tdump_stack();\n\t\t}\n\t\td->chk_lpt_sz2 = d->chk_lpt_sz;\n\t\td->chk_lpt_sz = 0;\n\t\td->chk_lpt_wastage = 0;\n\t\td->chk_lpt_lebs = 0;\n\t\td->new_nhead_offs = len;\n\t\treturn err;\n\tcase 4:\n\t\td->chk_lpt_sz += len;\n\t\td->chk_lpt_wastage += len;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ree_spc(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1743-1768",
    "snippet": "pt_free_spc(struct ubifs_info *c)\n{\n\tlong long free = 0;\n\tint i;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tif (c->ltab[i].tgc || c->ltab[i].cmt)\n\t\t\tcontinue;\n\t\tif (i + c->lpt_first == c->nhead_lnum)\n\t\t\tfree += c->leb_size - c->nhead_offs;\n\t\telse if (c->ltab[i].free == c->leb_size)\n\t\t\tfree += c->leb_size;\n\t}\n\tif (free < c->lpt_sz) {\n\t\tubifs_err(\"LPT space error: free %lld lpt_sz %lld\",\n\t\t\t  free, c->lpt_sz);\n\t\tubifs_dump_lpt_info(c);\n\t\tubifs_dump_lpt_lebs(c);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return",
          "args": [],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "coda_return_EIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "32-35",
          "snippet": "static int coda_return_EIO(void)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_return_EIO(void)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_lebs(c);\n\t\tdump_s",
          "args": [
            "a"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_info(c);\n\t\tubifs_",
          "args": [
            "u"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T space e",
          "args": [
            "ror: free %lld lpt_sz %lld\",\n\t\t\t  free,",
            "sz);",
            "ubifs_du"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\npt_free_spc(struct ubifs_info *c)\n{\n\tlong long free = 0;\n\tint i;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tif (c->ltab[i].tgc || c->ltab[i].cmt)\n\t\t\tcontinue;\n\t\tif (i + c->lpt_first == c->nhead_lnum)\n\t\t\tfree += c->leb_size - c->nhead_offs;\n\t\telse if (c->ltab[i].free == c->leb_size)\n\t\t\tfree += c->leb_size;\n\t}\n\tif (free < c->lpt_sz) {\n\t\tubifs_err(\"LPT space error: free %lld lpt_sz %lld\",\n\t\t\t  free, c->lpt_sz);\n\t\tubifs_dump_lpt_info(c);\n\t\tubifs_dump_lpt_lebs(c);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "b(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1701-1735",
    "snippet": "_ltab(struct ubifs_info *c)\n{\n\tint lnum, err, i, cnt;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\t/* Bring the entire tree into memory */\n\tcnt = DIV_ROUND_UP(c->main_lebs, UBIFS_LPT_FANOUT);\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct ubifs_pnode *pnode;\n\n\t\tpnode = pnode_lookup(c, i);\n\t\tif (IS_ERR(pnode))\n\t\t\treturn PTR_ERR(pnode);\n\t\tcond_resched();\n\t}\n\n\t/* Check nodes */\n\terr = dbg_check_lpt_nodes(c, (struct ubifs_cnode *)c->nroot, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\t/* Check each LEB */\n\tfor (lnum = c->lpt_first; lnum <= c->lpt_last; lnum++) {\n\t\terr = dbg_check_ltab_lnum(c, lnum);\n\t\tif (err) {\n\t\t\tubifs_err(\"failed at LEB %d\", lnum);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdbg_lp(\"succeeded\");\n\treturn 0;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eded\")",
          "args": [
            "return 0;"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iled at L",
          "args": [
            "B %d\", lnum);\n\t\t\tr",
            "urn"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_lnum(c, lnum);",
          "args": [
            "f",
            "err)"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_nodes(c, (struct u",
          "args": [
            "i",
            "_cnode *)c->nroot, 0, 0);\n\tif",
            "r"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t}\n\n\t/* C",
          "args": [],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tco",
          "args": [
            "d_res"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, i);\n\t\tif",
          "args": [
            "I",
            "E"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->main_lebs",
          "args": [
            "UBIFS_LPT_F",
            "OUT);\n\tfor (i ="
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\n_ltab(struct ubifs_info *c)\n{\n\tint lnum, err, i, cnt;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\t/* Bring the entire tree into memory */\n\tcnt = DIV_ROUND_UP(c->main_lebs, UBIFS_LPT_FANOUT);\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct ubifs_pnode *pnode;\n\n\t\tpnode = pnode_lookup(c, i);\n\t\tif (IS_ERR(pnode))\n\t\t\treturn PTR_ERR(pnode);\n\t\tcond_resched();\n\t}\n\n\t/* Check nodes */\n\terr = dbg_check_lpt_nodes(c, (struct ubifs_cnode *)c->nroot, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\t/* Check each LEB */\n\tfor (lnum = c->lpt_first; lnum <= c->lpt_last; lnum++) {\n\t\terr = dbg_check_ltab_lnum(c, lnum);\n\t\tif (err) {\n\t\t\tubifs_err(\"failed at LEB %d\", lnum);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdbg_lp(\"succeeded\");\n\treturn 0;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "b_lnum(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1630-1693",
    "snippet": "g_check_ltab_lnum(struct ubifs_info *c, int lnum)\n{\n\tint err, len = c->leb_size, dirty = 0, node_type, node_num, node_len;\n\tint ret;\n\tvoid *buf, *p;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tbuf = p = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory for ltab checking\");\n\t\treturn 0;\n\t}\n\n\tdbg_lp(\"LEB %d\", lnum);\n\n\terr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\n\tif (err)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tif (!is_a_node(c, p, len)) {\n\t\t\tint i, pad_len;\n\n\t\t\tpad_len = get_pad_len(c, p, len);\n\t\t\tif (pad_len) {\n\t\t\t\tp += pad_len;\n\t\t\t\tlen -= pad_len;\n\t\t\t\tdirty += pad_len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!dbg_is_all_ff(p, len)) {\n\t\t\t\tubifs_err(\"invalid empty space in LEB %d at %d\",\n\t\t\t\t\t  lnum, c->leb_size - len);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\ti = lnum - c->lpt_first;\n\t\t\tif (len != c->ltab[i].free) {\n\t\t\t\tubifs_err(\"invalid free space in LEB %d (free %d, expected %d)\",\n\t\t\t\t\t  lnum, len, c->ltab[i].free);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tif (dirty != c->ltab[i].dirty) {\n\t\t\t\tubifs_err(\"invalid dirty space in LEB %d (dirty %d, expected %d)\",\n\t\t\t\t\t  lnum, dirty, c->ltab[i].dirty);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tnode_type = get_lpt_node_type(c, p, &node_num);\n\t\tnode_len = get_lpt_node_len(c, node_type);\n\t\tret = dbg_is_node_dirty(c, node_type, lnum, c->leb_size - len);\n\t\tif (ret == 1)\n\t\t\tdirty += node_len;\n\t\tp += node_len;\n\t\tlen -= node_len;\n\t}\n\n\terr = 0;\nout:\n\tvfree(buf);\n\treturn err;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "er"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irty(c, node_type",
          "args": [
            "um, c->le",
            "size",
            "len);\n\t\tif (ret"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len(c, node_type",
          "args": [
            ";",
            "ret = db"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type(c, p, &node_",
          "args": [
            "u",
            ";",
            "node_len"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid dir",
          "args": [
            "y space in LEB %d (dirty %d, expected %d)\",\n\t\t\t\t\t  lnum",
            "c->l",
            "b[i].",
            "rty);\n\t\t\t\terr ="
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid fre",
          "args": [
            "space in LEB %d (free %d, expected %d)\",\n\t\t\t\t\t  lnum",
            ">lta",
            "i].",
            "ee);\n\t\t\t\terr ="
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid emp",
          "args": [
            "y space in LEB %d at %d\",\n\t\t\t\t\t  lnum",
            "size",
            "len);\n\t\t\t\terr ="
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(p, len)) {",
          "args": [
            "bif"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", p, len);",
          "args": [
            "f",
            "pad"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p, len))",
          "args": [
            "t i"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, buf",
          "args": [
            "c->",
            "b_s",
            "e",
            "1);\n\tif (er"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d\", ln",
          "args": [
            "m);\n\n\ter",
            "= ub"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot allo",
          "args": [
            "ate memory for ltab checking\");\n\t\treturn 0"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb_size,",
          "args": [
            "GFP_NOFS, P",
            "E_KERNEL",
            "if (!buf)"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\ng_check_ltab_lnum(struct ubifs_info *c, int lnum)\n{\n\tint err, len = c->leb_size, dirty = 0, node_type, node_num, node_len;\n\tint ret;\n\tvoid *buf, *p;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tbuf = p = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory for ltab checking\");\n\t\treturn 0;\n\t}\n\n\tdbg_lp(\"LEB %d\", lnum);\n\n\terr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\n\tif (err)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tif (!is_a_node(c, p, len)) {\n\t\t\tint i, pad_len;\n\n\t\t\tpad_len = get_pad_len(c, p, len);\n\t\t\tif (pad_len) {\n\t\t\t\tp += pad_len;\n\t\t\t\tlen -= pad_len;\n\t\t\t\tdirty += pad_len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!dbg_is_all_ff(p, len)) {\n\t\t\t\tubifs_err(\"invalid empty space in LEB %d at %d\",\n\t\t\t\t\t  lnum, c->leb_size - len);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\ti = lnum - c->lpt_first;\n\t\t\tif (len != c->ltab[i].free) {\n\t\t\t\tubifs_err(\"invalid free space in LEB %d (free %d, expected %d)\",\n\t\t\t\t\t  lnum, len, c->ltab[i].free);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tif (dirty != c->ltab[i].dirty) {\n\t\t\t\tubifs_err(\"invalid dirty space in LEB %d (dirty %d, expected %d)\",\n\t\t\t\t\t  lnum, dirty, c->ltab[i].dirty);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tnode_type = get_lpt_node_type(c, p, &node_num);\n\t\tnode_len = get_lpt_node_len(c, node_type);\n\t\tret = dbg_is_node_dirty(c, node_type, lnum, c->leb_size - len);\n\t\tif (ret == 1)\n\t\t\tdirty += node_len;\n\t\tp += node_len;\n\t\tlen -= node_len;\n\t}\n\n\terr = 0;\nout:\n\tvfree(buf);\n\treturn err;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "irty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1606-1620",
    "snippet": "g_is_node_dirty(struct ubifs_info *c, int node_type, int lnum,\n\t\t\t     int offs)\n{\n\tswitch (node_type) {\n\tcase UBIFS_LPT_NNODE:\n\t\treturn dbg_is_nnode_dirty(c, lnum, offs);\n\tcase UBIFS_LPT_PNODE:\n\t\treturn dbg_is_pnode_dirty(c, lnum, offs);\n\tcase UBIFS_LPT_LTAB:\n\t\treturn dbg_is_ltab_dirty(c, lnum, offs);\n\tcase UBIFS_LPT_LSAVE:\n\t\treturn dbg_is_lsave_dirty(c, lnum, offs);\n\t}\n\treturn 1;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dirty(c, lnum, off",
          "args": [
            ")",
            "}",
            "turn"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irty(c, lnum, off",
          "args": [
            ")",
            "cas",
            "UBIF"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirty(c, lnum, off",
          "args": [
            ")",
            "cas",
            "UBIF"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirty(c, lnum, off",
          "args": [
            ")",
            "cas",
            "UBIF"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\ng_is_node_dirty(struct ubifs_info *c, int node_type, int lnum,\n\t\t\t     int offs)\n{\n\tswitch (node_type) {\n\tcase UBIFS_LPT_NNODE:\n\t\treturn dbg_is_nnode_dirty(c, lnum, offs);\n\tcase UBIFS_LPT_PNODE:\n\t\treturn dbg_is_pnode_dirty(c, lnum, offs);\n\tcase UBIFS_LPT_LTAB:\n\t\treturn dbg_is_ltab_dirty(c, lnum, offs);\n\tcase UBIFS_LPT_LSAVE:\n\t\treturn dbg_is_lsave_dirty(c, lnum, offs);\n\t}\n\treturn 1;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "dirty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1592-1597",
    "snippet": "g_is_lsave_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tif (lnum != c->lsave_lnum || offs != c->lsave_offs)\n\t\treturn 1;\n\treturn (c->lpt_drty_flgs & LSAVE_DIRTY) != 0;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\ng_is_lsave_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tif (lnum != c->lsave_lnum || offs != c->lsave_offs)\n\t\treturn 1;\n\treturn (c->lpt_drty_flgs & LSAVE_DIRTY) != 0;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "irty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1579-1584",
    "snippet": "g_is_ltab_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tif (lnum != c->ltab_lnum || offs != c->ltab_offs)\n\t\treturn 1;\n\treturn (c->lpt_drty_flgs & LTAB_DIRTY) != 0;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\ng_is_ltab_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tif (lnum != c->ltab_lnum || offs != c->ltab_offs)\n\t\treturn 1;\n\treturn (c->lpt_drty_flgs & LTAB_DIRTY) != 0;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "dirty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1550-1571",
    "snippet": "g_is_pnode_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tint i, cnt;\n\n\tcnt = DIV_ROUND_UP(c->main_lebs, UBIFS_LPT_FANOUT);\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct ubifs_pnode *pnode;\n\t\tstruct ubifs_nbranch *branch;\n\n\t\tcond_resched();\n\t\tpnode = pnode_lookup(c, i);\n\t\tif (IS_ERR(pnode))\n\t\t\treturn PTR_ERR(pnode);\n\t\tbranch = &pnode->parent->nbranch[pnode->iip];\n\t\tif (branch->lnum != lnum || branch->offs != offs)\n\t\t\tcontinue;\n\t\tif (test_bit(DIRTY_CNODE, &pnode->flags))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y_CNODE,",
          "args": [
            "&pnode->fla",
            "))\n\t\t\treturn"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tbr",
          "args": [
            "nch ="
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, i);\n\t\tif",
          "args": [
            "I",
            "E"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tpnode =",
          "args": [],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->main_lebs",
          "args": [
            "UBIFS_LPT_F",
            "OUT);\n\tfor (i ="
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\ng_is_pnode_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tint i, cnt;\n\n\tcnt = DIV_ROUND_UP(c->main_lebs, UBIFS_LPT_FANOUT);\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct ubifs_pnode *pnode;\n\t\tstruct ubifs_nbranch *branch;\n\n\t\tcond_resched();\n\t\tpnode = pnode_lookup(c, i);\n\t\tif (IS_ERR(pnode))\n\t\t\treturn PTR_ERR(pnode);\n\t\tbranch = &pnode->parent->nbranch[pnode->iip];\n\t\tif (branch->lnum != lnum || branch->offs != offs)\n\t\t\tcontinue;\n\t\tif (test_bit(DIRTY_CNODE, &pnode->flags))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "dirty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1515-1542",
    "snippet": "g_is_nnode_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tstruct ubifs_nnode *nnode;\n\tint hght;\n\n\t/* Entire tree is in memory so first_nnode / next_nnode are OK */\n\tnnode = first_nnode(c, &hght);\n\tfor (; nnode; nnode = next_nnode(c, nnode, &hght)) {\n\t\tstruct ubifs_nbranch *branch;\n\n\t\tcond_resched();\n\t\tif (nnode->parent) {\n\t\t\tbranch = &nnode->parent->nbranch[nnode->iip];\n\t\t\tif (branch->lnum != lnum || branch->offs != offs)\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(DIRTY_CNODE, &nnode->flags))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (c->lpt_lnum != lnum || c->lpt_offs != offs)\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(DIRTY_CNODE, &nnode->flags))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y_CNODE,",
          "args": [
            "&nnode->fla",
            "))\n\t\t\t\treturn"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y_CNODE,",
          "args": [
            "&nnode->fla",
            "))\n\t\t\t\treturn"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tif (nno",
          "args": [],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnode, &h",
          "args": [
            "h",
            ") {",
            "truct"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", &hght);",
          "args": [
            "o",
            "(; nn"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\ng_is_nnode_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tstruct ubifs_nnode *nnode;\n\tint hght;\n\n\t/* Entire tree is in memory so first_nnode / next_nnode are OK */\n\tnnode = first_nnode(c, &hght);\n\tfor (; nnode; nnode = next_nnode(c, nnode, &hght)) {\n\t\tstruct ubifs_nbranch *branch;\n\n\t\tcond_resched();\n\t\tif (nnode->parent) {\n\t\t\tbranch = &nnode->parent->nbranch[nnode->iip];\n\t\t\tif (branch->lnum != lnum || branch->offs != offs)\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(DIRTY_CNODE, &nnode->flags))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (c->lpt_lnum != lnum || c->lpt_offs != offs)\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(DIRTY_CNODE, &nnode->flags))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "(uint8_t *buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1499-1507",
    "snippet": "g_is_all_ff(uint8_t *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (buf[i] != 0xff)\n\t\t\treturn 0;\n\treturn 1;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\ng_is_all_ff(uint8_t *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (buf[i] != 0xff)\n\t\t\treturn 0;\n\treturn 1;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "e(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1455-1488",
    "snippet": "t_free(struct ubifs_info *c, int wr_only)\n{\n\tstruct ubifs_nnode *nnode;\n\tint i, hght;\n\n\t/* Free write-only things first */\n\n\tfree_obsolete_cnodes(c); /* Leftover from a failed commit */\n\n\tvfree(c->ltab_cmt);\n\tc->ltab_cmt = NULL;\n\tvfree(c->lpt_buf);\n\tc->lpt_buf = NULL;\n\tkfree(c->lsave);\n\tc->lsave = NULL;\n\n\tif (wr_only)\n\t\treturn;\n\n\t/* Now free the rest */\n\n\tnnode = first_nnode(c, &hght);\n\twhile (nnode) {\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++)\n\t\t\tkfree(nnode->nbranch[i].nnode);\n\t\tnnode = next_nnode(c, nnode, &hght);\n\t}\n\tfor (i = 0; i < LPROPS_HEAP_CNT; i++)\n\t\tkfree(c->lpt_heap[i].arr);\n\tkfree(c->dirty_idx.arr);\n\tkfree(c->nroot);\n\tvfree(c->ltab);\n\tkfree(c->lpt_nod_buf);\n}\n\n/*\n * Every",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nod_b",
          "args": [
            "f);\n}\n\n/*\n * E"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tk",
          "args": [
            "ree(c->"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t);",
          "args": [
            "free(c->"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y_idx",
          "args": [
            "arr);\n\tkfree(c->"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "rty_idx_leb(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
          "lines": "963-985",
          "snippet": "d_dirty_idx_leb(struct ubifs_info *c)\n{\n\tint err;\n\n\tubifs_get_lprops(c);\n\n\t/*\n\t * We made an array of the dirtiest index LEB numbers as at the start of\n\t * last commit.  Try that array first.\n\t */\n\terr = find_dirtiest_idx_leb(c);\n\n\t/* Next try scanning the entire LPT */\n\tif (err == -ENOSPC)\n\t\terr = find_dirty_idx_leb(c);\n\n\t/* Finally take any index LEBs awaiting trivial GC */\n\tif (err == -ENOSPC)\n\t\terr = get_idx_gc_leb(c);\n\n\tubifs_release_lprops(c);\n\treturn err;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * struc",
            "ux/sort.h>\n#include \"ubi"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nd_dirty_idx_leb(struct ubifs_info *c)\n{\n\tint err;\n\n\tubifs_get_lprops(c);\n\n\t/*\n\t * We made an array of the dirtiest index LEB numbers as at the start of\n\t * last commit.  Try that array first.\n\t */\n\terr = find_dirtiest_idx_leb(c);\n\n\t/* Next try scanning the entire LPT */\n\tif (err == -ENOSPC)\n\t\terr = find_dirty_idx_leb(c);\n\n\t/* Finally take any index LEBs awaiting trivial GC */\n\tif (err == -ENOSPC)\n\t\terr = get_idx_gc_leb(c);\n\n\tubifs_release_lprops(c);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap[",
          "args": [
            "].arr);\n\tkfree(c->"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnode, &h",
          "args": [
            "h",
            ";\n\t}",
            "or (i"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nbran",
          "args": [
            "h[i].nnode);\n\t\tnnode ="
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", &hght);",
          "args": [
            "h",
            "e (nn"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e);",
          "args": [
            "->lsave"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf);",
          "args": [
            "c->lpt_bu"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cmt)",
          "args": [
            "c->ltab_c"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cnodes(c); /* Lefto",
          "args": [
            "e"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nt_free(struct ubifs_info *c, int wr_only)\n{\n\tstruct ubifs_nnode *nnode;\n\tint i, hght;\n\n\t/* Free write-only things first */\n\n\tfree_obsolete_cnodes(c); /* Leftover from a failed commit */\n\n\tvfree(c->ltab_cmt);\n\tc->ltab_cmt = NULL;\n\tvfree(c->lpt_buf);\n\tc->lpt_buf = NULL;\n\tkfree(c->lsave);\n\tc->lsave = NULL;\n\n\tif (wr_only)\n\t\treturn;\n\n\t/* Now free the rest */\n\n\tnnode = first_nnode(c, &hght);\n\twhile (nnode) {\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++)\n\t\t\tkfree(nnode->nbranch[i].nnode);\n\t\tnnode = next_nnode(c, nnode, &hght);\n\t}\n\tfor (i = 0; i < LPROPS_HEAP_CNT; i++)\n\t\tkfree(c->lpt_heap[i].arr);\n\tkfree(c->dirty_idx.arr);\n\tkfree(c->nroot);\n\tvfree(c->ltab);\n\tkfree(c->lpt_nod_buf);\n}\n\n/*\n * Every"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1412-1448",
    "snippet": "ubifs_nnode *next_nnode(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_nnode *nnode, int *hght)\n{\n\tstruct ubifs_nnode *parent;\n\tint iip, h, i, found;\n\n\tparent = nnode->parent;\n\tif (!parent)\n\t\treturn NULL;\n\tif (nnode->iip == UBIFS_LPT_FANOUT - 1) {\n\t\t*hght -= 1;\n\t\treturn parent;\n\t}\n\tfor (iip = nnode->iip + 1; iip < UBIFS_LPT_FANOUT; iip++) {\n\t\tnnode = parent->nbranch[iip].nnode;\n\t\tif (nnode)\n\t\t\tbreak;\n\t}\n\tif (!nnode) {\n\t\t*hght -= 1;\n\t\treturn parent;\n\t}\n\tfor (h = *hght + 1; h < c->lpt_hght; h++) {\n\t\tfound = 0;\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tif (nnode->nbranch[i].nnode) {\n\t\t\t\tfound = 1;\n\t\t\t\tnnode = nnode->nbranch[i].nnode;\n\t\t\t\t*hght = h;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\treturn nnode;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nubifs_nnode *next_nnode(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_nnode *nnode, int *hght)\n{\n\tstruct ubifs_nnode *parent;\n\tint iip, h, i, found;\n\n\tparent = nnode->parent;\n\tif (!parent)\n\t\treturn NULL;\n\tif (nnode->iip == UBIFS_LPT_FANOUT - 1) {\n\t\t*hght -= 1;\n\t\treturn parent;\n\t}\n\tfor (iip = nnode->iip + 1; iip < UBIFS_LPT_FANOUT; iip++) {\n\t\tnnode = parent->nbranch[iip].nnode;\n\t\tif (nnode)\n\t\t\tbreak;\n\t}\n\tif (!nnode) {\n\t\t*hght -= 1;\n\t\treturn parent;\n\t}\n\tfor (h = *hght + 1; h < c->lpt_hght; h++) {\n\t\tfound = 0;\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tif (nnode->nbranch[i].nnode) {\n\t\t\t\tfound = 1;\n\t\t\t\tnnode = nnode->nbranch[i].nnode;\n\t\t\t\t*hght = h;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\treturn nnode;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1378-1401",
    "snippet": "ubifs_nnode *first_nnode(struct ubifs_info *c, int *hght)\n{\n\tstruct ubifs_nnode *nnode;\n\tint h, i, found;\n\n\tnnode = c->nroot;\n\t*hght = 0;\n\tif (!nnode)\n\t\treturn NULL;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tfound = 0;\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tif (nnode->nbranch[i].nnode) {\n\t\t\t\tfound = 1;\n\t\t\t\tnnode = nnode->nbranch[i].nnode;\n\t\t\t\t*hght = h;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\treturn nnode;\n}\n\n/**\n * next",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nubifs_nnode *first_nnode(struct ubifs_info *c, int *hght)\n{\n\tstruct ubifs_nnode *nnode;\n\tint h, i, found;\n\n\tnnode = c->nroot;\n\t*hght = 0;\n\tif (!nnode)\n\t\treturn NULL;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tfound = 0;\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tif (nnode->nbranch[i].nnode) {\n\t\t\t\tfound = 1;\n\t\t\t\tnnode = nnode->nbranch[i].nnode;\n\t\t\t\t*hght = h;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\treturn nnode;\n}\n\n/**\n * next"
  },
  {
    "function_name": "t_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1349-1368",
    "snippet": "_post_commit(struct ubifs_info *c)\n{\n\tint err;\n\n\tmutex_lock(&c->lp_mutex);\n\terr = lpt_tgc_end(c);\n\tif (err)\n\t\tgoto out;\n\tif (c->big_lpt)\n\t\twhile (need_write_all(c)) {\n\t\t\tmutex_unlock(&c->lp_mutex);\n\t\t\terr = lpt_gc(c);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tmutex_lock(&c->lp_mutex);\n\t\t}\nout:\n\tmutex_unlock(&c->lp_mutex);\n\treturn err;\n}\n\n/**\n * firs",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "g_populate_lsave(struct ubifs_info *c);\n\n/**\n * firs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->lp_mutex",
          "args": [
            ";\n\treturn er"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lp_mutex",
          "args": [
            ";\n\t\t}\nout:"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (e",
          "args": [
            "r"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->lp_mutex",
          "args": [
            ";\n\t\t\terr = l"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l(c)) {\n\t\t\tmut",
          "args": [
            "x"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tif (err",
          "args": [],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lp_mutex",
          "args": [
            ";\n\terr = lpt"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\ng_populate_lsave(struct ubifs_info *c);\n\n/**\n * firs;\n\n_post_commit(struct ubifs_info *c)\n{\n\tint err;\n\n\tmutex_lock(&c->lp_mutex);\n\terr = lpt_tgc_end(c);\n\tif (err)\n\t\tgoto out;\n\tif (c->big_lpt)\n\t\twhile (need_write_all(c)) {\n\t\t\tmutex_unlock(&c->lp_mutex);\n\t\t\terr = lpt_gc(c);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tmutex_lock(&c->lp_mutex);\n\t\t}\nout:\n\tmutex_unlock(&c->lp_mutex);\n\treturn err;\n}\n\n/**\n * firs"
  },
  {
    "function_name": "_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1322-1340",
    "snippet": "_end_commit(struct ubifs_info *c)\n{\n\tint err;\n\n\tdbg_lp(\"\");\n\n\tif (!c->lpt_cnext)\n\t\treturn 0;\n\n\terr = write_cnodes(c);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&c->lp_mutex);\n\tfree_obsolete_cnodes(c);\n\tmutex_unlock(&c->lp_mutex);\n\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->lp_mutex",
          "args": [
            ";\n\n\treturn 0"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cnodes(c);\n\tmutex_u",
          "args": [
            "l"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lp_mutex",
          "args": [
            ";\n\tfree_obso"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c);\n\tif (err",
          "args": [],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (!",
          "args": [
            "->"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\n_end_commit(struct ubifs_info *c)\n{\n\tint err;\n\n\tdbg_lp(\"\");\n\n\tif (!c->lpt_cnext)\n\t\treturn 0;\n\n\terr = write_cnodes(c);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&c->lp_mutex);\n\tfree_obsolete_cnodes(c);\n\tmutex_unlock(&c->lp_mutex);\n\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_cnodes(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1295-1311",
    "snippet": "ree_obsolete_cnodes(struct ubifs_info *c)\n{\n\tstruct ubifs_cnode *cnode, *cnext;\n\n\tcnext = c->lpt_cnext;\n\tif (!cnext)\n\t\treturn;\n\tdo {\n\t\tcnode = cnext;\n\t\tcnext = cnode->cnext;\n\t\tif (test_bit(OBSOLETE_CNODE, &cnode->flags))\n\t\t\tkfree(cnode);\n\t\telse\n\t\t\tcnode->cnext = NULL;\n\t} while (cnext != c->lpt_cnext);\n\tc->lpt_cnext = NULL;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "el",
          "args": [
            "e"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "erase_deleted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "440-459",
          "snippet": "static void erase_deleted(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orphan, *dnext;\n\n\tspin_lock(&c->orphan_lock);\n\tdnext = c->orph_dnext;\n\twhile (dnext) {\n\t\torphan = dnext;\n\t\tdnext = orphan->dnext;\n\t\tubifs_assert(!orphan->new);\n\t\tubifs_assert(orphan->del);\n\t\trb_erase(&orphan->rb, &c->orph_tree);\n\t\tlist_del(&orphan->list);\n\t\tc->tot_orphans -= 1;\n\t\tdbg_gen(\"deleting orphan ino %lu\", (unsigned long)orphan->inum);\n\t\tkfree(orphan);\n\t}\n\tc->orph_dnext = NULL;\n\tspin_unlock(&c->orphan_lock);\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic void erase_deleted(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orphan, *dnext;\n\n\tspin_lock(&c->orphan_lock);\n\tdnext = c->orph_dnext;\n\twhile (dnext) {\n\t\torphan = dnext;\n\t\tdnext = orphan->dnext;\n\t\tubifs_assert(!orphan->new);\n\t\tubifs_assert(orphan->del);\n\t\trb_erase(&orphan->rb, &c->orph_tree);\n\t\tlist_del(&orphan->list);\n\t\tc->tot_orphans -= 1;\n\t\tdbg_gen(\"deleting orphan ino %lu\", (unsigned long)orphan->inum);\n\t\tkfree(orphan);\n\t}\n\tc->orph_dnext = NULL;\n\tspin_unlock(&c->orphan_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LETE_CNO",
          "args": [
            "E, &cnode->fla",
            "))\n\t\t\tkfree(c"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nree_obsolete_cnodes(struct ubifs_info *c)\n{\n\tstruct ubifs_cnode *cnode, *cnext;\n\n\tcnext = c->lpt_cnext;\n\tif (!cnext)\n\t\treturn;\n\tdo {\n\t\tcnode = cnext;\n\t\tcnext = cnode->cnext;\n\t\tif (test_bit(OBSOLETE_CNODE, &cnode->flags))\n\t\t\tkfree(cnode);\n\t\telse\n\t\t\tcnode->cnext = NULL;\n\t} while (cnext != c->lpt_cnext);\n\tc->lpt_cnext = NULL;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "rt_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1224-1289",
    "snippet": "_start_commit(struct ubifs_info *c)\n{\n\tint err, cnt;\n\n\tdbg_lp(\"\");\n\n\tmutex_lock(&c->lp_mutex);\n\terr = dbg_chk_lpt_free_spc(c);\n\tif (err)\n\t\tgoto out;\n\terr = dbg_check_ltab(c);\n\tif (err)\n\t\tgoto out;\n\n\tif (c->check_lpt_free) {\n\t\t/*\n\t\t * We ensure there is enough free space in\n\t\t * ubifs_lpt_post_commit() by marking nodes dirty. That\n\t\t * information is lost when we unmount, so we also need\n\t\t * to check free space once after mounting also.\n\t\t */\n\t\tc->check_lpt_free = 0;\n\t\twhile (need_write_all(c)) {\n\t\t\tmutex_unlock(&c->lp_mutex);\n\t\t\terr = lpt_gc(c);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tmutex_lock(&c->lp_mutex);\n\t\t}\n\t}\n\n\tlpt_tgc_start(c);\n\n\tif (!c->dirty_pn_cnt) {\n\t\tdbg_cmt(\"no cnodes to commit\");\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (!c->big_lpt && need_write_all(c)) {\n\t\t/* If needed, write everything */\n\t\terr = make_tree_dirty(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlpt_tgc_start(c);\n\t}\n\n\tif (c->big_lpt)\n\t\tpopulate_lsave(c);\n\n\tcnt = get_cnodes_to_commit(c);\n\tubifs_assert(cnt != 0);\n\n\terr = layout_cnodes(c);\n\tif (err)\n\t\tgoto out;\n\n\t/* Copy the LPT's own lprops for end commit to write */\n\tmemcpy(c->ltab_cmt, c->ltab,\n\t       sizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\n\tc->lpt_drty_flgs &= ~(LTAB_DIRTY | LSAVE_DIRTY);\n\nout:\n\tmutex_unlock(&c->lp_mutex);\n\treturn err;\n}\n\n/**\n * free",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->lp_mutex",
          "args": [
            ";\n\treturn er"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_cmt,",
          "args": [
            "c->ltab,",
            "siz",
            "ubifs_lpt_lprops) * c->lpt_lebs);\n\tc->lpt_dr"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c);\n\tif (err",
          "args": [],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cnt != 0);",
          "args": [
            "err = la"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_commit(c);\n\tubifs_a",
          "args": [
            "s"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c);\n\n\tcnt =",
          "args": [
            "e"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c);\n\t}\n\n\tif",
          "args": [
            "c"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ty(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l(c)) {\n\t\t/* I",
          "args": [],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes t",
          "args": [
            "commit\");\n\t\terr = 0;"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c);\n\n\tif (!c",
          "args": [
            ">"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lp_mutex",
          "args": [
            ";\n\t\t}\n\t}\n\n\tl"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (e",
          "args": [
            "r"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->lp_mutex",
          "args": [
            ";\n\t\t\terr = l"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l(c)) {\n\t\t\tmut",
          "args": [
            "x"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b(c);\n\tif (err",
          "args": [],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_spc(c);\n\tif (err",
          "args": [],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lp_mutex",
          "args": [
            ";\n\terr = dbg"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex",
          "args": [
            "lo"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_annotate_inode_mutex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "897-913",
          "snippet": "void lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_mutex, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\tmutex_destroy(&inode->i_mutex);\n\t\t\tmutex_init(&inode->i_mutex);\n\t\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_mutex, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\tmutex_destroy(&inode->i_mutex);\n\t\t\tmutex_init(&inode->i_mutex);\n\t\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\n_start_commit(struct ubifs_info *c)\n{\n\tint err, cnt;\n\n\tdbg_lp(\"\");\n\n\tmutex_lock(&c->lp_mutex);\n\terr = dbg_chk_lpt_free_spc(c);\n\tif (err)\n\t\tgoto out;\n\terr = dbg_check_ltab(c);\n\tif (err)\n\t\tgoto out;\n\n\tif (c->check_lpt_free) {\n\t\t/*\n\t\t * We ensure there is enough free space in\n\t\t * ubifs_lpt_post_commit() by marking nodes dirty. That\n\t\t * information is lost when we unmount, so we also need\n\t\t * to check free space once after mounting also.\n\t\t */\n\t\tc->check_lpt_free = 0;\n\t\twhile (need_write_all(c)) {\n\t\t\tmutex_unlock(&c->lp_mutex);\n\t\t\terr = lpt_gc(c);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tmutex_lock(&c->lp_mutex);\n\t\t}\n\t}\n\n\tlpt_tgc_start(c);\n\n\tif (!c->dirty_pn_cnt) {\n\t\tdbg_cmt(\"no cnodes to commit\");\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (!c->big_lpt && need_write_all(c)) {\n\t\t/* If needed, write everything */\n\t\terr = make_tree_dirty(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlpt_tgc_start(c);\n\t}\n\n\tif (c->big_lpt)\n\t\tpopulate_lsave(c);\n\n\tcnt = get_cnodes_to_commit(c);\n\tubifs_assert(cnt != 0);\n\n\terr = layout_cnodes(c);\n\tif (err)\n\t\tgoto out;\n\n\t/* Copy the LPT's own lprops for end commit to write */\n\tmemcpy(c->ltab_cmt, c->ltab,\n\t       sizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\n\tc->lpt_drty_flgs &= ~(LTAB_DIRTY | LSAVE_DIRTY);\n\nout:\n\tmutex_unlock(&c->lp_mutex);\n\treturn err;\n}\n\n/**\n * free"
  },
  {
    "function_name": "ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1193-1212",
    "snippet": "t_gc(struct ubifs_info *c)\n{\n\tint i, lnum = -1, dirty = 0;\n\n\tmutex_lock(&c->lp_mutex);\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tubifs_assert(!c->ltab[i].tgc);\n\t\tif (i + c->lpt_first == c->nhead_lnum ||\n\t\t    c->ltab[i].free + c->ltab[i].dirty == c->leb_size)\n\t\t\tcontinue;\n\t\tif (c->ltab[i].dirty > dirty) {\n\t\t\tdirty = c->ltab[i].dirty;\n\t\t\tlnum = i + c->lpt_first;\n\t\t}\n\t}\n\tmutex_unlock(&c->lp_mutex);\n\tif (lnum == -1)\n\t\treturn -ENOSPC;\n\treturn lpt_gc_lnum(c, lnum);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ", lnum);\n}",
          "args": [
            "/",
            "*"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->lp_mutex",
          "args": [
            ";\n\tif (lnum"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ltab[i].",
          "args": [
            "gc);\n\t\tif (i +"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lp_mutex",
          "args": [
            ";\n\tfor (i ="
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nt_gc(struct ubifs_info *c)\n{\n\tint i, lnum = -1, dirty = 0;\n\n\tmutex_lock(&c->lp_mutex);\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tubifs_assert(!c->ltab[i].tgc);\n\t\tif (i + c->lpt_first == c->nhead_lnum ||\n\t\t    c->ltab[i].free + c->ltab[i].dirty == c->leb_size)\n\t\t\tcontinue;\n\t\tif (c->ltab[i].dirty > dirty) {\n\t\t\tdirty = c->ltab[i].dirty;\n\t\t\tlnum = i + c->lpt_first;\n\t\t}\n\t}\n\tmutex_unlock(&c->lp_mutex);\n\tif (lnum == -1)\n\t\treturn -ENOSPC;\n\treturn lpt_gc_lnum(c, lnum);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1148-1184",
    "snippet": "t_gc_lnum(struct ubifs_info *c, int lnum)\n{\n\tint err, len = c->leb_size, node_type, node_num, node_len, offs;\n\tvoid *buf = c->lpt_buf;\n\n\tdbg_lp(\"LEB %d\", lnum);\n\n\terr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\n\tif (err)\n\t\treturn err;\n\n\twhile (1) {\n\t\tif (!is_a_node(c, buf, len)) {\n\t\t\tint pad_len;\n\n\t\t\tpad_len = get_pad_len(c, buf, len);\n\t\t\tif (pad_len) {\n\t\t\t\tbuf += pad_len;\n\t\t\t\tlen -= pad_len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tnode_type = get_lpt_node_type(c, buf, &node_num);\n\t\tnode_len = get_lpt_node_len(c, node_type);\n\t\toffs = c->leb_size - len;\n\t\tubifs_assert(node_len != 0);\n\t\tmutex_lock(&c->lp_mutex);\n\t\terr = make_node_dirty(c, node_type, node_num, lnum, offs);\n\t\tmutex_unlock(&c->lp_mutex);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbuf += node_len;\n\t\tlen -= node_len;\n\t}\n\treturn 0;\n}\n\n/**\n * lpt_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->lp_mutex",
          "args": [
            ";\n\t\tif (err)"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ty(c, node_type",
          "args": [
            "de_num, l",
            "m, offs)",
            "mu",
            "x_un"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lp_mutex",
          "args": [
            ";\n\t\terr = ma"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_len !=",
          "args": [
            ");\n\t\tmutex_lo"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len(c, node_type",
          "args": [
            ";",
            "offs = c"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type(c, buf, &nod",
          "args": [
            "_",
            "m);",
            "node_len"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", buf, len)",
          "args": [
            "if",
            "pad"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf, len)",
          "args": [
            "t p"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, buf",
          "args": [
            "c->",
            "b_s",
            "e",
            "1);\n\tif (er"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d\", ln",
          "args": [
            "m);\n\n\ter",
            "= ub"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nt_gc_lnum(struct ubifs_info *c, int lnum)\n{\n\tint err, len = c->leb_size, node_type, node_num, node_len, offs;\n\tvoid *buf = c->lpt_buf;\n\n\tdbg_lp(\"LEB %d\", lnum);\n\n\terr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\n\tif (err)\n\t\treturn err;\n\n\twhile (1) {\n\t\tif (!is_a_node(c, buf, len)) {\n\t\t\tint pad_len;\n\n\t\t\tpad_len = get_pad_len(c, buf, len);\n\t\t\tif (pad_len) {\n\t\t\t\tbuf += pad_len;\n\t\t\t\tlen -= pad_len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tnode_type = get_lpt_node_type(c, buf, &node_num);\n\t\tnode_len = get_lpt_node_len(c, node_type);\n\t\toffs = c->leb_size - len;\n\t\tubifs_assert(node_len != 0);\n\t\tmutex_lock(&c->lp_mutex);\n\t\terr = make_node_dirty(c, node_type, node_num, lnum, offs);\n\t\tmutex_unlock(&c->lp_mutex);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbuf += node_len;\n\t\tlen -= node_len;\n\t}\n\treturn 0;\n}\n\n/**\n * lpt_"
  },
  {
    "function_name": "st struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1112-1134",
    "snippet": "_a_node(const struct ubifs_info *c, uint8_t *buf, int len)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint pos = 0, node_type, node_len;\n\tuint16_t crc, calc_crc;\n\n\tif (len < UBIFS_LPT_CRC_BYTES + (UBIFS_LPT_TYPE_BITS + 7) / 8)\n\t\treturn 0;\n\tnode_type = ubifs_unpack_bits(&addr, &pos, UBIFS_LPT_TYPE_BITS);\n\tif (node_type == UBIFS_LPT_NOT_A_NODE)\n\t\treturn 0;\n\tnode_len = get_lpt_node_len(c, node_type);\n\tif (!node_len || node_len > len)\n\t\treturn 0;\n\tpos = 0;\n\taddr = buf;\n\tcrc = ubifs_unpack_bits(&addr, &pos, UBIFS_LPT_CRC_BITS);\n\tcalc_crc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t\t node_len - UBIFS_LPT_CRC_BYTES);\n\tif (crc != calc_crc)\n\t\treturn 0;\n\treturn 1;\n}\n\n/**\n * lpt_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "+ UB",
          "args": [
            "FS",
            "PT_CRC_BYTES,\n\t\t\t node_le",
            "IFS_LPT_CRC_BYTES);\n\tif (crc !"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "UBIFS",
            "PT_C",
            "_BITS);\n\tcalc_crc"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len(c, node_type",
          "args": [
            ";",
            "if (!node"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "UBIFS",
            "PT_T",
            "E_BITS);\n\tif (node_"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\n_a_node(const struct ubifs_info *c, uint8_t *buf, int len)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint pos = 0, node_type, node_len;\n\tuint16_t crc, calc_crc;\n\n\tif (len < UBIFS_LPT_CRC_BYTES + (UBIFS_LPT_TYPE_BITS + 7) / 8)\n\t\treturn 0;\n\tnode_type = ubifs_unpack_bits(&addr, &pos, UBIFS_LPT_TYPE_BITS);\n\tif (node_type == UBIFS_LPT_NOT_A_NODE)\n\t\treturn 0;\n\tnode_len = get_lpt_node_len(c, node_type);\n\tif (!node_len || node_len > len)\n\t\treturn 0;\n\tpos = 0;\n\taddr = buf;\n\tcrc = ubifs_unpack_bits(&addr, &pos, UBIFS_LPT_CRC_BITS);\n\tcalc_crc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t\t node_len - UBIFS_LPT_CRC_BYTES);\n\tif (crc != calc_crc)\n\t\treturn 0;\n\treturn 1;\n}\n\n/**\n * lpt_"
  },
  {
    "function_name": "type(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1093-1102",
    "snippet": "t_lpt_node_type(const struct ubifs_info *c, uint8_t *buf,\n\t\t\t     int *node_num)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint pos = 0, node_type;\n\n\tnode_type = ubifs_unpack_bits(&addr, &pos, UBIFS_LPT_TYPE_BITS);\n\t*node_num = ubifs_unpack_bits(&addr, &pos, c->pcnt_bits);\n\treturn node_type;\n}\n\n/**\n * is_a",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "c->pc",
            "_bit",
            ";\n\treturn no"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "UBIFS",
            "PT_T",
            "E_BITS);\n\t*node_num"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nt_lpt_node_type(const struct ubifs_info *c, uint8_t *buf,\n\t\t\t     int *node_num)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint pos = 0, node_type;\n\n\tnode_type = ubifs_unpack_bits(&addr, &pos, UBIFS_LPT_TYPE_BITS);\n\t*node_num = ubifs_unpack_bits(&addr, &pos, c->pcnt_bits);\n\treturn node_type;\n}\n\n/**\n * is_a"
  },
  {
    "function_name": "onst struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1076-1085",
    "snippet": "t_pad_len(const struct ubifs_info *c, uint8_t *buf, int len)\n{\n\tint offs, pad_len;\n\n\tif (c->min_io_size == 1)\n\t\treturn 0;\n\toffs = c->leb_size - len;\n\tpad_len = ALIGN(offs, c->min_io_size) - offs;\n\treturn pad_len;\n}\n\n/**\n * get_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "->min",
          "args": [
            "io_s",
            "e) - offs;\n\tre"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nt_pad_len(const struct ubifs_info *c, uint8_t *buf, int len)\n{\n\tint offs, pad_len;\n\n\tif (c->min_io_size == 1)\n\t\treturn 0;\n\toffs = c->leb_size - len;\n\tpad_len = ALIGN(offs, c->min_io_size) - offs;\n\treturn pad_len;\n}\n\n/**\n * get_"
  },
  {
    "function_name": "len(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1055-1068",
    "snippet": "t_lpt_node_len(const struct ubifs_info *c, int node_type)\n{\n\tswitch (node_type) {\n\tcase UBIFS_LPT_NNODE:\n\t\treturn c->nnode_sz;\n\tcase UBIFS_LPT_PNODE:\n\t\treturn c->pnode_sz;\n\tcase UBIFS_LPT_LTAB:\n\t\treturn c->ltab_sz;\n\tcase UBIFS_LPT_LSAVE:\n\t\treturn c->lsave_sz;\n\t}\n\treturn 0;\n}\n\n/**\n * get_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nt_lpt_node_len(const struct ubifs_info *c, int node_type)\n{\n\tswitch (node_type) {\n\tcase UBIFS_LPT_NNODE:\n\t\treturn c->nnode_sz;\n\tcase UBIFS_LPT_PNODE:\n\t\treturn c->pnode_sz;\n\tcase UBIFS_LPT_LTAB:\n\t\treturn c->ltab_sz;\n\tcase UBIFS_LPT_LSAVE:\n\t\treturn c->lsave_sz;\n\t}\n\treturn 0;\n}\n\n/**\n * get_"
  },
  {
    "function_name": "ty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1034-1048",
    "snippet": "ke_node_dirty(struct ubifs_info *c, int node_type, int node_num,\n\t\t\t   int lnum, int offs)\n{\n\tswitch (node_type) {\n\tcase UBIFS_LPT_NNODE:\n\t\treturn make_nnode_dirty(c, node_num, lnum, offs);\n\tcase UBIFS_LPT_PNODE:\n\t\treturn make_pnode_dirty(c, node_num, lnum, offs);\n\tcase UBIFS_LPT_LTAB:\n\t\treturn make_ltab_dirty(c, lnum, offs);\n\tcase UBIFS_LPT_LSAVE:\n\t\treturn make_lsave_dirty(c, lnum, offs);\n\t}\n\treturn -EINVAL;\n}\n\n/**\n * get_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rty(c, lnum, off",
          "args": [
            ")",
            "}",
            "turn"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ty(c, lnum, off",
          "args": [
            ")",
            "cas",
            "UBIF"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty(c, node_num,",
          "args": [
            "l",
            "m, offs)",
            "cas",
            "UBIF"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty(c, node_num,",
          "args": [
            "l",
            "m, offs)",
            "cas",
            "UBIF"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nke_node_dirty(struct ubifs_info *c, int node_type, int node_num,\n\t\t\t   int lnum, int offs)\n{\n\tswitch (node_type) {\n\tcase UBIFS_LPT_NNODE:\n\t\treturn make_nnode_dirty(c, node_num, lnum, offs);\n\tcase UBIFS_LPT_PNODE:\n\t\treturn make_pnode_dirty(c, node_num, lnum, offs);\n\tcase UBIFS_LPT_LTAB:\n\t\treturn make_ltab_dirty(c, lnum, offs);\n\tcase UBIFS_LPT_LSAVE:\n\t\treturn make_lsave_dirty(c, lnum, offs);\n\t}\n\treturn -EINVAL;\n}\n\n/**\n * get_"
  },
  {
    "function_name": "rty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "1007-1016",
    "snippet": "ke_lsave_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tif (lnum != c->lsave_lnum || offs != c->lsave_offs)\n\t\treturn 0; /* This lsave node is obsolete */\n\tif (!(c->lpt_drty_flgs & LSAVE_DIRTY)) {\n\t\tc->lpt_drty_flgs |= LSAVE_DIRTY;\n\t\tubifs_add_lpt_dirt(c, c->lsave_lnum, c->lsave_sz);\n\t}\n\treturn 0;\n}\n\n/**\n * make",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_dirt(c, c->lsave_",
          "args": [
            "n",
            ", c->lsave_sz",
            "}\n\treturn"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nke_lsave_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tif (lnum != c->lsave_lnum || offs != c->lsave_offs)\n\t\treturn 0; /* This lsave node is obsolete */\n\tif (!(c->lpt_drty_flgs & LSAVE_DIRTY)) {\n\t\tc->lpt_drty_flgs |= LSAVE_DIRTY;\n\t\tubifs_add_lpt_dirt(c, c->lsave_lnum, c->lsave_sz);\n\t}\n\treturn 0;\n}\n\n/**\n * make"
  },
  {
    "function_name": "ty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "982-991",
    "snippet": "ke_ltab_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tif (lnum != c->ltab_lnum || offs != c->ltab_offs)\n\t\treturn 0; /* This ltab node is obsolete */\n\tif (!(c->lpt_drty_flgs & LTAB_DIRTY)) {\n\t\tc->lpt_drty_flgs |= LTAB_DIRTY;\n\t\tubifs_add_lpt_dirt(c, c->ltab_lnum, c->ltab_sz);\n\t}\n\treturn 0;\n}\n\n/**\n * make",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_dirt(c, c->ltab_l",
          "args": [
            "u",
            "c->ltab_sz)",
            "}\n\treturn"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nke_ltab_dirty(struct ubifs_info *c, int lnum, int offs)\n{\n\tif (lnum != c->ltab_lnum || offs != c->ltab_offs)\n\t\treturn 0; /* This ltab node is obsolete */\n\tif (!(c->lpt_drty_flgs & LTAB_DIRTY)) {\n\t\tc->lpt_drty_flgs |= LTAB_DIRTY;\n\t\tubifs_add_lpt_dirt(c, c->ltab_lnum, c->ltab_sz);\n\t}\n\treturn 0;\n}\n\n/**\n * make"
  },
  {
    "function_name": "rty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "952-966",
    "snippet": "ke_pnode_dirty(struct ubifs_info *c, int node_num, int lnum,\n\t\t\t    int offs)\n{\n\tstruct ubifs_pnode *pnode;\n\tstruct ubifs_nbranch *branch;\n\n\tpnode = pnode_lookup(c, node_num);\n\tif (IS_ERR(pnode))\n\t\treturn PTR_ERR(pnode);\n\tbranch = &pnode->parent->nbranch[pnode->iip];\n\tif (branch->lnum != lnum || branch->offs != offs)\n\t\treturn 0;\n\tdo_make_pnode_dirty(c, pnode);\n\treturn 0;\n}\n\n/**\n * make",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_dirty(c, pnode);",
          "args": [
            "e",
            "rn 0;"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tbra",
          "args": [
            "ch ="
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tre",
          "args": [
            "urn P"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, node_num)",
          "args": [
            "f (IS_ER"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nke_pnode_dirty(struct ubifs_info *c, int node_num, int lnum,\n\t\t\t    int offs)\n{\n\tstruct ubifs_pnode *pnode;\n\tstruct ubifs_nbranch *branch;\n\n\tpnode = pnode_lookup(c, node_num);\n\tif (IS_ERR(pnode))\n\t\treturn PTR_ERR(pnode);\n\tbranch = &pnode->parent->nbranch[pnode->iip];\n\tif (branch->lnum != lnum || branch->offs != offs)\n\t\treturn 0;\n\tdo_make_pnode_dirty(c, pnode);\n\treturn 0;\n}\n\n/**\n * make"
  },
  {
    "function_name": "rty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "903-935",
    "snippet": "ke_nnode_dirty(struct ubifs_info *c, int node_num, int lnum,\n\t\t\t    int offs)\n{\n\tstruct ubifs_nnode *nnode;\n\n\tnnode = nnode_lookup(c, node_num);\n\tif (IS_ERR(nnode))\n\t\treturn PTR_ERR(nnode);\n\tif (nnode->parent) {\n\t\tstruct ubifs_nbranch *branch;\n\n\t\tbranch = &nnode->parent->nbranch[nnode->iip];\n\t\tif (branch->lnum != lnum || branch->offs != offs)\n\t\t\treturn 0; /* nnode is obsolete */\n\t} else if (c->lpt_lnum != lnum || c->lpt_offs != offs)\n\t\t\treturn 0; /* nnode is obsolete */\n\t/* Assumes cnext list is empty i.e. not called during commit */\n\tif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\n\t\tc->dirty_nn_cnt += 1;\n\t\tubifs_add_nnode_dirt(c, nnode);\n\t\t/* Mark parent and ancestors dirty too */\n\t\tnnode = nnode->parent;\n\t\twhile (nnode) {\n\t\t\tif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\n\t\t\t\tc->dirty_nn_cnt += 1;\n\t\t\t\tubifs_add_nnode_dirt(c, nnode);\n\t\t\t\tnnode = nnode->parent;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * make",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de_dirt(c, nnode);",
          "args": [
            "node"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit(DIRTY_CNODE,",
          "args": [
            "&nnode->fla",
            ")) {\n\t\t\t\tc->d"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_dirt(c, nnode);",
          "args": [
            "/",
            "Mark"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit(DIRTY_CNODE,",
          "args": [
            "&nnode->fla",
            ")) {\n\t\tc->dir"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tif",
          "args": [
            "nnode"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tre",
          "args": [
            "urn P"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, node_num)",
          "args": [
            "f (IS_ER"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nke_nnode_dirty(struct ubifs_info *c, int node_num, int lnum,\n\t\t\t    int offs)\n{\n\tstruct ubifs_nnode *nnode;\n\n\tnnode = nnode_lookup(c, node_num);\n\tif (IS_ERR(nnode))\n\t\treturn PTR_ERR(nnode);\n\tif (nnode->parent) {\n\t\tstruct ubifs_nbranch *branch;\n\n\t\tbranch = &nnode->parent->nbranch[nnode->iip];\n\t\tif (branch->lnum != lnum || branch->offs != offs)\n\t\t\treturn 0; /* nnode is obsolete */\n\t} else if (c->lpt_lnum != lnum || c->lpt_offs != offs)\n\t\t\treturn 0; /* nnode is obsolete */\n\t/* Assumes cnext list is empty i.e. not called during commit */\n\tif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\n\t\tc->dirty_nn_cnt += 1;\n\t\tubifs_add_nnode_dirt(c, nnode);\n\t\t/* Mark parent and ancestors dirty too */\n\t\tnnode = nnode->parent;\n\t\twhile (nnode) {\n\t\t\tif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\n\t\t\t\tc->dirty_nn_cnt += 1;\n\t\t\t\tubifs_add_nnode_dirt(c, nnode);\n\t\t\t\tnnode = nnode->parent;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * make"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "865-886",
    "snippet": "ubifs_nnode *nnode_lookup(struct ubifs_info *c, int i)\n{\n\tint err, iip;\n\tstruct ubifs_nnode *nnode;\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tnnode = c->nroot;\n\twhile (1) {\n\t\tiip = i & (UBIFS_LPT_FANOUT - 1);\n\t\ti >>= UBIFS_LPT_FANOUT_SHIFT;\n\t\tif (!i)\n\t\t\tbreak;\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn nnode;\n\t}\n\treturn nnode;\n}\n\n/**\n * make",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, nnode, ii",
          "args": [
            ")",
            "if",
            "S_E"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}\n\tnn",
          "args": [
            "de"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, NULL, 0);",
          "args": [
            "f (e",
            ")"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nubifs_nnode *nnode_lookup(struct ubifs_info *c, int i)\n{\n\tint err, iip;\n\tstruct ubifs_nnode *nnode;\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tnnode = c->nroot;\n\twhile (1) {\n\t\tiip = i & (UBIFS_LPT_FANOUT - 1);\n\t\ti >>= UBIFS_LPT_FANOUT_SHIFT;\n\t\tif (!i)\n\t\t\tbreak;\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn nnode;\n\t}\n\treturn nnode;\n}\n\n/**\n * make"
  },
  {
    "function_name": "e(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "804-855",
    "snippet": "opulate_lsave(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tint i, cnt = 0;\n\n\tubifs_assert(c->big_lpt);\n\tif (!(c->lpt_drty_flgs & LSAVE_DIRTY)) {\n\t\tc->lpt_drty_flgs |= LSAVE_DIRTY;\n\t\tubifs_add_lpt_dirt(c, c->lsave_lnum, c->lsave_sz);\n\t}\n\n\tif (dbg_populate_lsave(c))\n\t\treturn;\n\n\tlist_for_each_entry(lprops, &c->empty_list, list) {\n\t\tc->lsave[cnt++] = lprops->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\tlist_for_each_entry(lprops, &c->freeable_list, list) {\n\t\tc->lsave[cnt++] = lprops->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\tlist_for_each_entry(lprops, &c->frdi_idx_list, list) {\n\t\tc->lsave[cnt++] = lprops->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\theap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tc->lsave[cnt++] = heap->arr[i]->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\theap = &c->lpt_heap[LPROPS_DIRTY - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tc->lsave[cnt++] = heap->arr[i]->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\theap = &c->lpt_heap[LPROPS_FREE - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tc->lsave[cnt++] = heap->arr[i]->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\t/* Fill it up completely */\n\twhile (cnt < c->lsave_cnt)\n\t\tc->lsave[cnt++] = c->main_first;\n}\n\n/**\n * nnod",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "rdi_id",
            "list, list) {\n\t\tc",
            "lsav"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "reeabl",
            "list, list) {\n\t\tc",
            "lsav"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "mpty_l",
            "t, list) {\n\t\tc",
            "lsav"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsave(c))\n\t\treturn",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dirt(c, c->lsave_",
          "args": [
            "n",
            ", c->lsave_sz",
            "}\n\n\tif (d"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->big_lpt);",
          "args": [
            "if (!(c->"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nopulate_lsave(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tint i, cnt = 0;\n\n\tubifs_assert(c->big_lpt);\n\tif (!(c->lpt_drty_flgs & LSAVE_DIRTY)) {\n\t\tc->lpt_drty_flgs |= LSAVE_DIRTY;\n\t\tubifs_add_lpt_dirt(c, c->lsave_lnum, c->lsave_sz);\n\t}\n\n\tif (dbg_populate_lsave(c))\n\t\treturn;\n\n\tlist_for_each_entry(lprops, &c->empty_list, list) {\n\t\tc->lsave[cnt++] = lprops->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\tlist_for_each_entry(lprops, &c->freeable_list, list) {\n\t\tc->lsave[cnt++] = lprops->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\tlist_for_each_entry(lprops, &c->frdi_idx_list, list) {\n\t\tc->lsave[cnt++] = lprops->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\theap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tc->lsave[cnt++] = heap->arr[i]->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\theap = &c->lpt_heap[LPROPS_DIRTY - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tc->lsave[cnt++] = heap->arr[i]->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\theap = &c->lpt_heap[LPROPS_FREE - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tc->lsave[cnt++] = heap->arr[i]->lnum;\n\t\tif (cnt >= c->lsave_cnt)\n\t\t\treturn;\n\t}\n\t/* Fill it up completely */\n\twhile (cnt < c->lsave_cnt)\n\t\tc->lsave[cnt++] = c->main_first;\n}\n\n/**\n * nnod"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "777-790",
    "snippet": "t_tgc_end(struct ubifs_info *c)\n{\n\tint i, err;\n\n\tfor (i = 0; i < c->lpt_lebs; i++)\n\t\tif (c->ltab[i].tgc) {\n\t\t\terr = ubifs_leb_unmap(c, i + c->lpt_first);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->ltab[i].tgc = 0;\n\t\t\tdbg_lp(\"LEB %d\", i + c->lpt_first);\n\t\t}\n\treturn 0;\n}\n\n/**\n * popu",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d\", i",
          "args": [
            "c->lpt_",
            "rst);\n\t\t}\n\tretur"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, i + c->lp",
          "args": [
            "_",
            "rst);\n\t\t\tif (err"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nt_tgc_end(struct ubifs_info *c)\n{\n\tint i, err;\n\n\tfor (i = 0; i < c->lpt_lebs; i++)\n\t\tif (c->ltab[i].tgc) {\n\t\t\terr = ubifs_leb_unmap(c, i + c->lpt_first);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->ltab[i].tgc = 0;\n\t\t\tdbg_lp(\"LEB %d\", i + c->lpt_first);\n\t\t}\n\treturn 0;\n}\n\n/**\n * popu"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "751-766",
    "snippet": "pt_tgc_start(struct ubifs_info *c)\n{\n\tint i;\n\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tif (i + c->lpt_first == c->nhead_lnum)\n\t\t\tcontinue;\n\t\tif (c->ltab[i].dirty > 0 &&\n\t\t    c->ltab[i].free + c->ltab[i].dirty == c->leb_size) {\n\t\t\tc->ltab[i].tgc = 1;\n\t\t\tc->ltab[i].free = c->leb_size;\n\t\t\tc->ltab[i].dirty = 0;\n\t\t\tdbg_lp(\"LEB %d\", i + c->lpt_first);\n\t\t}\n\t}\n}\n\n/**\n * lpt_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d\", i",
          "args": [
            "c->lpt_",
            "rst);\n\t\t}\n\t}\n}"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\npt_tgc_start(struct ubifs_info *c)\n{\n\tint i;\n\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tif (i + c->lpt_first == c->nhead_lnum)\n\t\t\tcontinue;\n\t\tif (c->ltab[i].dirty > 0 &&\n\t\t    c->ltab[i].free + c->ltab[i].dirty == c->leb_size) {\n\t\t\tc->ltab[i].tgc = 1;\n\t\t\tc->ltab[i].free = c->leb_size;\n\t\t\tc->ltab[i].dirty = 0;\n\t\t\tdbg_lp(\"LEB %d\", i + c->lpt_first);\n\t\t}\n\t}\n}\n\n/**\n * lpt_"
  },
  {
    "function_name": "l(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "724-741",
    "snippet": "ed_write_all(struct ubifs_info *c)\n{\n\tlong long free = 0;\n\tint i;\n\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tif (i + c->lpt_first == c->nhead_lnum)\n\t\t\tfree += c->leb_size - c->nhead_offs;\n\t\telse if (c->ltab[i].free == c->leb_size)\n\t\t\tfree += c->leb_size;\n\t\telse if (c->ltab[i].free + c->ltab[i].dirty == c->leb_size)\n\t\t\tfree += c->leb_size;\n\t}\n\t/* Less than twice the size left */\n\tif (free <= c->lpt_sz * 2)\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * lpt_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\ned_write_all(struct ubifs_info *c)\n{\n\tlong long free = 0;\n\tint i;\n\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tif (i + c->lpt_first == c->nhead_lnum)\n\t\t\tfree += c->leb_size - c->nhead_offs;\n\t\telse if (c->ltab[i].free == c->leb_size)\n\t\t\tfree += c->leb_size;\n\t\telse if (c->ltab[i].free + c->ltab[i].dirty == c->leb_size)\n\t\t\tfree += c->leb_size;\n\t}\n\t/* Less than twice the size left */\n\tif (free <= c->lpt_sz * 2)\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * lpt_"
  },
  {
    "function_name": "ty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "700-715",
    "snippet": "ke_tree_dirty(struct ubifs_info *c)\n{\n\tstruct ubifs_pnode *pnode;\n\n\tpnode = pnode_lookup(c, 0);\n\tif (IS_ERR(pnode))\n\t\treturn PTR_ERR(pnode);\n\n\twhile (pnode) {\n\t\tdo_make_pnode_dirty(c, pnode);\n\t\tpnode = next_pnode_to_dirty(c, pnode);\n\t\tif (IS_ERR(pnode))\n\t\t\treturn PTR_ERR(pnode);\n\t}\n\treturn 0;\n}\n\n/**\n * need",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ");\n\t}",
          "args": [
            "eturn"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dirty(c, pnode);",
          "args": [
            "i",
            "(IS_E"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dirty(c, pnode);",
          "args": [
            "p",
            "de ="
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\twh",
          "args": [
            "le (p"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tre",
          "args": [
            "urn P"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, 0);\n\tif (",
          "args": [
            "S",
            "R"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nke_tree_dirty(struct ubifs_info *c)\n{\n\tstruct ubifs_pnode *pnode;\n\n\tpnode = pnode_lookup(c, 0);\n\tif (IS_ERR(pnode))\n\t\treturn PTR_ERR(pnode);\n\n\twhile (pnode) {\n\t\tdo_make_pnode_dirty(c, pnode);\n\t\tpnode = next_pnode_to_dirty(c, pnode);\n\t\tif (IS_ERR(pnode))\n\t\t\treturn PTR_ERR(pnode);\n\t}\n\treturn 0;\n}\n\n/**\n * need"
  },
  {
    "function_name": "_dirty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "668-687",
    "snippet": "o_make_pnode_dirty(struct ubifs_info *c, struct ubifs_pnode *pnode)\n{\n\t/* Assumes cnext list is empty i.e. not called during commit */\n\tif (!test_and_set_bit(DIRTY_CNODE, &pnode->flags)) {\n\t\tstruct ubifs_nnode *nnode;\n\n\t\tc->dirty_pn_cnt += 1;\n\t\tadd_pnode_dirt(c, pnode);\n\t\t/* Mark parent and ancestors dirty too */\n\t\tnnode = pnode->parent;\n\t\twhile (nnode) {\n\t\t\tif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\n\t\t\t\tc->dirty_nn_cnt += 1;\n\t\t\t\tubifs_add_nnode_dirt(c, nnode);\n\t\t\t\tnnode = nnode->parent;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * make",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de_dirt(c, nnode);",
          "args": [
            "node"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit(DIRTY_CNODE,",
          "args": [
            "&nnode->fla",
            ")) {\n\t\t\t\tc->d"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, pnode);",
          "args": [
            "/",
            "Mark"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit(DIRTY_CNODE,",
          "args": [
            "&pnode->fla",
            ")) {\n\t\tstruct"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\no_make_pnode_dirty(struct ubifs_info *c, struct ubifs_pnode *pnode)\n{\n\t/* Assumes cnext list is empty i.e. not called during commit */\n\tif (!test_and_set_bit(DIRTY_CNODE, &pnode->flags)) {\n\t\tstruct ubifs_nnode *nnode;\n\n\t\tc->dirty_pn_cnt += 1;\n\t\tadd_pnode_dirt(c, pnode);\n\t\t/* Mark parent and ancestors dirty too */\n\t\tnnode = pnode->parent;\n\t\twhile (nnode) {\n\t\t\tif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\n\t\t\t\tc->dirty_nn_cnt += 1;\n\t\t\t\tubifs_add_nnode_dirt(c, nnode);\n\t\t\t\tnnode = nnode->parent;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * make"
  },
  {
    "function_name": "t(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "657-661",
    "snippet": "dd_pnode_dirt(struct ubifs_info *c, struct ubifs_pnode *pnode)\n{\n\tubifs_add_lpt_dirt(c, pnode->parent->nbranch[pnode->iip].lnum,\n\t\t\t   c->pnode_sz);\n}\n\n/**\n * do_m",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_dirt(c, pnode->pa",
          "args": [
            "e",
            "->nbranch[pnode->iip].lnum,\n\t\t\t   c->pn",
            "}\n\n/**\n *"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\ndd_pnode_dirt(struct ubifs_info *c, struct ubifs_pnode *pnode)\n{\n\tubifs_add_lpt_dirt(c, pnode->parent->nbranch[pnode->iip].lnum,\n\t\t\t   c->pnode_sz);\n}\n\n/**\n * do_m"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "628-650",
    "snippet": "ubifs_pnode *pnode_lookup(struct ubifs_info *c, int i)\n{\n\tint err, h, iip, shft;\n\tstruct ubifs_nnode *nnode;\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\ti <<= UBIFS_LPT_FANOUT_SHIFT;\n\tnnode = c->nroot;\n\tshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\t\tshft -= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn ERR_CAST(nnode);\n\t}\n\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\treturn ubifs_get_pnode(c, nnode, iip);\n}\n\n/**\n * add_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de(c, nnode, ii",
          "args": [
            ")",
            "}\n\n/*",
            "*"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e);\n\t}",
          "args": [
            "ip ="
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, nnode, ii",
          "args": [
            ")",
            "if",
            "S_E"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}\n\ti",
          "args": [
            "<="
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, NULL, 0);",
          "args": [
            "f (e",
            ")"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nubifs_pnode *pnode_lookup(struct ubifs_info *c, int i)\n{\n\tint err, h, iip, shft;\n\tstruct ubifs_nnode *nnode;\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\ti <<= UBIFS_LPT_FANOUT_SHIFT;\n\tnnode = c->nroot;\n\tshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\t\tshft -= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn ERR_CAST(nnode);\n\t}\n\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\treturn ubifs_get_pnode(c, nnode, iip);\n}\n\n/**\n * add_"
  },
  {
    "function_name": "_dirty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "563-618",
    "snippet": "ubifs_pnode *next_pnode_to_dirty(struct ubifs_info *c,\n\t\t\t\t\t       struct ubifs_pnode *pnode)\n{\n\tstruct ubifs_nnode *nnode;\n\tint iip;\n\n\t/* Try to go right */\n\tnnode = pnode->parent;\n\tfor (iip = pnode->iip + 1; iip < UBIFS_LPT_FANOUT; iip++) {\n\t\tif (nnode->nbranch[iip].lnum)\n\t\t\treturn ubifs_get_pnode(c, nnode, iip);\n\t}\n\n\t/* Go up while can't go right */\n\tdo {\n\t\tiip = nnode->iip + 1;\n\t\tnnode = nnode->parent;\n\t\tif (!nnode)\n\t\t\treturn NULL;\n\t\tfor (; iip < UBIFS_LPT_FANOUT; iip++) {\n\t\t\tif (nnode->nbranch[iip].lnum)\n\t\t\t\tbreak;\n\t\t}\n\t} while (iip >= UBIFS_LPT_FANOUT);\n\n\t/* Go right */\n\tnnode = ubifs_get_nnode(c, nnode, iip);\n\tif (IS_ERR(nnode))\n\t\treturn (void *)nnode;\n\n\t/* Go down to level 1 */\n\twhile (nnode->level > 1) {\n\t\tfor (iip = 0; iip < UBIFS_LPT_FANOUT; iip++) {\n\t\t\tif (nnode->nbranch[iip].lnum)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (iip >= UBIFS_LPT_FANOUT) {\n\t\t\t/*\n\t\t\t * Should not happen, but we need to keep going\n\t\t\t * if it does.\n\t\t\t */\n\t\t\tiip = 0;\n\t\t}\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn (void *)nnode;\n\t}\n\n\tfor (iip = 0; iip < UBIFS_LPT_FANOUT; iip++)\n\t\tif (nnode->nbranch[iip].lnum)\n\t\t\tbreak;\n\tif (iip >= UBIFS_LPT_FANOUT)\n\t\t/* Should not happen, but we need to keep going if it does */\n\t\tiip = 0;\n\treturn ubifs_get_pnode(c, nnode, iip);\n}\n\n/**\n * pnod",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de(c, nnode, ii",
          "args": [
            ")",
            "}\n\n/*",
            "*"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, nnode, ii",
          "args": [
            ")",
            "if",
            "S_E"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tre",
          "args": [
            "urn ("
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, nnode, ii",
          "args": [
            ")",
            "if (",
            "_ER"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, nnode, ii",
          "args": [
            ")",
            "}",
            "Go"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nubifs_pnode *next_pnode_to_dirty(struct ubifs_info *c,\n\t\t\t\t\t       struct ubifs_pnode *pnode)\n{\n\tstruct ubifs_nnode *nnode;\n\tint iip;\n\n\t/* Try to go right */\n\tnnode = pnode->parent;\n\tfor (iip = pnode->iip + 1; iip < UBIFS_LPT_FANOUT; iip++) {\n\t\tif (nnode->nbranch[iip].lnum)\n\t\t\treturn ubifs_get_pnode(c, nnode, iip);\n\t}\n\n\t/* Go up while can't go right */\n\tdo {\n\t\tiip = nnode->iip + 1;\n\t\tnnode = nnode->parent;\n\t\tif (!nnode)\n\t\t\treturn NULL;\n\t\tfor (; iip < UBIFS_LPT_FANOUT; iip++) {\n\t\t\tif (nnode->nbranch[iip].lnum)\n\t\t\t\tbreak;\n\t\t}\n\t} while (iip >= UBIFS_LPT_FANOUT);\n\n\t/* Go right */\n\tnnode = ubifs_get_nnode(c, nnode, iip);\n\tif (IS_ERR(nnode))\n\t\treturn (void *)nnode;\n\n\t/* Go down to level 1 */\n\twhile (nnode->level > 1) {\n\t\tfor (iip = 0; iip < UBIFS_LPT_FANOUT; iip++) {\n\t\t\tif (nnode->nbranch[iip].lnum)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (iip >= UBIFS_LPT_FANOUT) {\n\t\t\t/*\n\t\t\t * Should not happen, but we need to keep going\n\t\t\t * if it does.\n\t\t\t */\n\t\t\tiip = 0;\n\t\t}\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn (void *)nnode;\n\t}\n\n\tfor (iip = 0; iip < UBIFS_LPT_FANOUT; iip++)\n\t\tif (nnode->nbranch[iip].lnum)\n\t\t\tbreak;\n\tif (iip >= UBIFS_LPT_FANOUT)\n\t\t/* Should not happen, but we need to keep going if it does */\n\t\tiip = 0;\n\treturn ubifs_get_pnode(c, nnode, iip);\n}\n\n/**\n * pnod"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "371-552",
    "snippet": "ite_cnodes(struct ubifs_info *c)\n{\n\tint lnum, offs, len, from, err, wlen, alen, done_ltab, done_lsave;\n\tstruct ubifs_cnode *cnode;\n\tvoid *buf = c->lpt_buf;\n\n\tcnode = c->lpt_cnext;\n\tif (!cnode)\n\t\treturn 0;\n\tlnum = c->nhead_lnum;\n\toffs = c->nhead_offs;\n\tfrom = offs;\n\t/* Ensure empty LEB is unmapped */\n\tif (offs == 0) {\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t/* Try to place lsave and ltab nicely */\n\tdone_lsave = !c->big_lpt;\n\tdone_ltab = 0;\n\tif (!done_lsave && offs + c->lsave_sz <= c->leb_size) {\n\t\tdone_lsave = 1;\n\t\tubifs_pack_lsave(c, buf + offs, c->lsave);\n\t\toffs += c->lsave_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t}\n\n\tif (offs + c->ltab_sz <= c->leb_size) {\n\t\tdone_ltab = 1;\n\t\tubifs_pack_ltab(c, buf + offs, c->ltab_cmt);\n\t\toffs += c->ltab_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t}\n\n\t/* Loop for each cnode */\n\tdo {\n\t\tif (cnode->level)\n\t\t\tlen = c->nnode_sz;\n\t\telse\n\t\t\tlen = c->pnode_sz;\n\t\twhile (offs + len > c->leb_size) {\n\t\t\twlen = offs - from;\n\t\t\tif (wlen) {\n\t\t\t\talen = ALIGN(wlen, c->min_io_size);\n\t\t\t\tmemset(buf + offs, 0xff, alen - wlen);\n\t\t\t\terr = ubifs_leb_write(c, lnum, buf + from, from,\n\t\t\t\t\t\t       alen);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = realloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = from = 0;\n\t\t\tubifs_assert(lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* Try to place lsave and ltab nicely */\n\t\t\tif (!done_lsave) {\n\t\t\t\tdone_lsave = 1;\n\t\t\t\tubifs_pack_lsave(c, buf + offs, c->lsave);\n\t\t\t\toffs += c->lsave_sz;\n\t\t\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!done_ltab) {\n\t\t\t\tdone_ltab = 1;\n\t\t\t\tubifs_pack_ltab(c, buf + offs, c->ltab_cmt);\n\t\t\t\toffs += c->ltab_sz;\n\t\t\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (cnode->level)\n\t\t\tubifs_pack_nnode(c, buf + offs,\n\t\t\t\t\t (struct ubifs_nnode *)cnode);\n\t\telse\n\t\t\tubifs_pack_pnode(c, buf + offs,\n\t\t\t\t\t (struct ubifs_pnode *)cnode);\n\t\t/*\n\t\t * The reason for the barriers is the same as in case of TNC.\n\t\t * See comment in 'write_index()'. 'dirty_cow_nnode()' and\n\t\t * 'dirty_cow_pnode()' are the functions for which this is\n\t\t * important.\n\t\t */\n\t\tclear_bit(DIRTY_CNODE, &cnode->flags);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(COW_CNODE, &cnode->flags);\n\t\tsmp_mb__after_atomic();\n\t\toffs += len;\n\t\tdbg_chk_lpt_sz(c, 1, len);\n\t\tcnode = cnode->cnext;\n\t} while (cnode && cnode != c->lpt_cnext);\n\n\t/* Make sure to place LPT's save table */\n\tif (!done_lsave) {\n\t\tif (offs + c->lsave_sz > c->leb_size) {\n\t\t\twlen = offs - from;\n\t\t\talen = ALIGN(wlen, c->min_io_size);\n\t\t\tmemset(buf + offs, 0xff, alen - wlen);\n\t\t\terr = ubifs_leb_write(c, lnum, buf + from, from, alen);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = realloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = from = 0;\n\t\t\tubifs_assert(lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tdone_lsave = 1;\n\t\tubifs_pack_lsave(c, buf + offs, c->lsave);\n\t\toffs += c->lsave_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t}\n\n\t/* Make sure to place LPT's own lprops table */\n\tif (!done_ltab) {\n\t\tif (offs + c->ltab_sz > c->leb_size) {\n\t\t\twlen = offs - from;\n\t\t\talen = ALIGN(wlen, c->min_io_size);\n\t\t\tmemset(buf + offs, 0xff, alen - wlen);\n\t\t\terr = ubifs_leb_write(c, lnum, buf + from, from, alen);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = realloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = from = 0;\n\t\t\tubifs_assert(lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tubifs_pack_ltab(c, buf + offs, c->ltab_cmt);\n\t\toffs += c->ltab_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t}\n\n\t/* Write remaining data in buffer */\n\twlen = offs - from;\n\talen = ALIGN(wlen, c->min_io_size);\n\tmemset(buf + offs, 0xff, alen - wlen);\n\terr = ubifs_leb_write(c, lnum, buf + from, from, alen);\n\tif (err)\n\t\treturn err;\n\n\tdbg_chk_lpt_sz(c, 4, alen - wlen);\n\terr = dbg_chk_lpt_sz(c, 3, ALIGN(offs, c->min_io_size));\n\tif (err)\n\t\treturn err;\n\n\tc->nhead_lnum = lnum;\n\tc->nhead_offs = ALIGN(offs, c->min_io_size);\n\n\tdbg_lp(\"LPT root is at %d:%d\", c->lpt_lnum, c->lpt_offs);\n\tdbg_lp(\"LPT head is at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\tdbg_lp(\"LPT ltab is at %d:%d\", c->ltab_lnum, c->ltab_offs);\n\tif (c->big_lpt)\n\t\tdbg_lp(\"LPT lsave is at %d:%d\", c->lsave_lnum, c->lsave_offs);\n\n\treturn 0;\n\nno_space:\n\tubifs_err(\"LPT out of space mismatch at LEB %d:%d needing %d, done_ltab %d, done_lsave %d\",\n\t\t  lnum, offs, len, done_ltab, done_lsave);\n\tubifs_dump_lpt_info(c);\n\tubifs_dump_lpt_lebs(c);\n\tdump_stack();\n\treturn err;\n}\n\n/**\n * next",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return e",
          "args": [],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_lebs(c);\n\tdump_st",
          "args": [
            "c"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_info(c);\n\tubifs_d",
          "args": [
            "m"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T out of",
          "args": [
            "pace mismatch at LEB %d:%d needing %d, done_ltab %d, done_lsave %d\",\n\t\t  lnum, o",
            "en,",
            "ne_l",
            "b,",
            "ne_lsave)",
            "ubifs_dum"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save i",
          "args": [
            "at %d:%d\", c->lsave_ln",
            ", c->lsave_of",
            ");\n\n\treturn 0"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tab is",
          "args": [
            "at %d:%d\", c->ltab_lnu",
            "c->ltab_off",
            ";\n\tif (c->bi"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead is",
          "args": [
            "at %d:%d\", c->nhead_ln",
            ", c->nhead_of",
            ");\n\tdbg_lp(\"L"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oot is",
          "args": [
            "at %d:%d\", c->lpt_lnum",
            "c->lpt_offs",
            "dbg_lp(\"L"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->min",
          "args": [
            "io_s",
            "e);\n\n\tdbg_lp(\""
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "z(c, 3, ALIGN(",
          "args": [
            "f",
            ",",
            "->min_io_size));\n\tif (err)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 4, alen -",
          "args": [
            "w",
            "n",
            "err = dbg"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(c, lnum, buf",
          "args": [
            "+",
            "rom,",
            "rom, alen)",
            "if",
            "rr)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offs,",
          "args": [
            "xff, alen",
            "wlen",
            "err = ubi"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, c->lta",
          "args": [
            "_",
            ")",
            "}\n\n\t/* Wr"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ab(c, buf + off",
          "args": [
            ",",
            "->ltab_cmt",
            "offs +="
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);",
          "args": [
            "i",
            "(err"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum >= c->l",
          "args": [
            "t_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\terr = u"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eb(c, &lnum);",
          "args": [
            "(err"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 2, c->leb",
          "args": [
            "s",
            "e",
            "offs);\n\t\t\terr = r"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(c, lnum, buf",
          "args": [
            "+",
            "rom,",
            "rom, alen)",
            "i",
            "(err"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offs,",
          "args": [
            "xff, alen",
            "wlen",
            "err = u"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, c->lsa",
          "args": [
            "e",
            "z",
            "}\n\n\t/* Ma"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ave(c, buf + off",
          "args": [
            ",",
            "->lsave);",
            "offs +="
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);",
          "args": [
            "i",
            "(err"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum >= c->l",
          "args": [
            "t_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\terr = u"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eb(c, &lnum);",
          "args": [
            "(err"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 2, c->leb",
          "args": [
            "s",
            "e",
            "offs);\n\t\t\terr = r"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(c, lnum, buf",
          "args": [
            "+",
            "rom,",
            "rom, alen)",
            "i",
            "(err"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offs,",
          "args": [
            "xff, alen",
            "wlen",
            "err = u"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, len);",
          "args": [
            "o",
            "="
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_atomic();\n\t\toffs +=",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CNODE, &",
          "args": [
            "node->fla",
            ");\n\t\tsmp_mb__"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_atomic();\n\t\tclear_b",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TY_CNODE,",
          "args": [
            "&cnode->fla",
            ");\n\t\tsmp_mb__"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, buf + off",
          "args": [
            ",",
            "(stru",
            "_pnode *)cnode);\n\t\t/*\n\t\t *"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, buf + off",
          "args": [
            ",",
            "(stru",
            "_nnode *)cnode);\n\t\telse"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, c->lta",
          "args": [
            "_",
            ")",
            "contin"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ab(c, buf + off",
          "args": [
            ",",
            "->ltab_cmt",
            "offs +"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, c->lsa",
          "args": [
            "e",
            "z",
            "contin"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ave(c, buf + off",
          "args": [
            ",",
            "->lsave);",
            "offs +"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);",
          "args": [
            "i",
            "(err"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum >= c->l",
          "args": [
            "t_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\terr = u"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eb(c, &lnum);",
          "args": [
            "(err"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 2, c->leb",
          "args": [
            "s",
            "e",
            "offs);\n\t\t\terr = r"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(c, lnum, buf",
          "args": [
            "+",
            "rom,",
            "rom,",
            "(er"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offs,",
          "args": [
            "xff, alen",
            "wlen",
            "err ="
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, c->lta",
          "args": [
            "_",
            ")",
            "}\n\n\t/* Lo"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ab(c, buf + off",
          "args": [
            ",",
            "->ltab_cmt",
            "offs +="
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, c->lsa",
          "args": [
            "e",
            "z",
            "}\n\n\tif (o"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ave(c, buf + off",
          "args": [
            ",",
            "->lsave);",
            "offs +="
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);",
          "args": [
            "f",
            "err)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nite_cnodes(struct ubifs_info *c)\n{\n\tint lnum, offs, len, from, err, wlen, alen, done_ltab, done_lsave;\n\tstruct ubifs_cnode *cnode;\n\tvoid *buf = c->lpt_buf;\n\n\tcnode = c->lpt_cnext;\n\tif (!cnode)\n\t\treturn 0;\n\tlnum = c->nhead_lnum;\n\toffs = c->nhead_offs;\n\tfrom = offs;\n\t/* Ensure empty LEB is unmapped */\n\tif (offs == 0) {\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t/* Try to place lsave and ltab nicely */\n\tdone_lsave = !c->big_lpt;\n\tdone_ltab = 0;\n\tif (!done_lsave && offs + c->lsave_sz <= c->leb_size) {\n\t\tdone_lsave = 1;\n\t\tubifs_pack_lsave(c, buf + offs, c->lsave);\n\t\toffs += c->lsave_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t}\n\n\tif (offs + c->ltab_sz <= c->leb_size) {\n\t\tdone_ltab = 1;\n\t\tubifs_pack_ltab(c, buf + offs, c->ltab_cmt);\n\t\toffs += c->ltab_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t}\n\n\t/* Loop for each cnode */\n\tdo {\n\t\tif (cnode->level)\n\t\t\tlen = c->nnode_sz;\n\t\telse\n\t\t\tlen = c->pnode_sz;\n\t\twhile (offs + len > c->leb_size) {\n\t\t\twlen = offs - from;\n\t\t\tif (wlen) {\n\t\t\t\talen = ALIGN(wlen, c->min_io_size);\n\t\t\t\tmemset(buf + offs, 0xff, alen - wlen);\n\t\t\t\terr = ubifs_leb_write(c, lnum, buf + from, from,\n\t\t\t\t\t\t       alen);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = realloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = from = 0;\n\t\t\tubifs_assert(lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* Try to place lsave and ltab nicely */\n\t\t\tif (!done_lsave) {\n\t\t\t\tdone_lsave = 1;\n\t\t\t\tubifs_pack_lsave(c, buf + offs, c->lsave);\n\t\t\t\toffs += c->lsave_sz;\n\t\t\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!done_ltab) {\n\t\t\t\tdone_ltab = 1;\n\t\t\t\tubifs_pack_ltab(c, buf + offs, c->ltab_cmt);\n\t\t\t\toffs += c->ltab_sz;\n\t\t\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (cnode->level)\n\t\t\tubifs_pack_nnode(c, buf + offs,\n\t\t\t\t\t (struct ubifs_nnode *)cnode);\n\t\telse\n\t\t\tubifs_pack_pnode(c, buf + offs,\n\t\t\t\t\t (struct ubifs_pnode *)cnode);\n\t\t/*\n\t\t * The reason for the barriers is the same as in case of TNC.\n\t\t * See comment in 'write_index()'. 'dirty_cow_nnode()' and\n\t\t * 'dirty_cow_pnode()' are the functions for which this is\n\t\t * important.\n\t\t */\n\t\tclear_bit(DIRTY_CNODE, &cnode->flags);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(COW_CNODE, &cnode->flags);\n\t\tsmp_mb__after_atomic();\n\t\toffs += len;\n\t\tdbg_chk_lpt_sz(c, 1, len);\n\t\tcnode = cnode->cnext;\n\t} while (cnode && cnode != c->lpt_cnext);\n\n\t/* Make sure to place LPT's save table */\n\tif (!done_lsave) {\n\t\tif (offs + c->lsave_sz > c->leb_size) {\n\t\t\twlen = offs - from;\n\t\t\talen = ALIGN(wlen, c->min_io_size);\n\t\t\tmemset(buf + offs, 0xff, alen - wlen);\n\t\t\terr = ubifs_leb_write(c, lnum, buf + from, from, alen);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = realloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = from = 0;\n\t\t\tubifs_assert(lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tdone_lsave = 1;\n\t\tubifs_pack_lsave(c, buf + offs, c->lsave);\n\t\toffs += c->lsave_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t}\n\n\t/* Make sure to place LPT's own lprops table */\n\tif (!done_ltab) {\n\t\tif (offs + c->ltab_sz > c->leb_size) {\n\t\t\twlen = offs - from;\n\t\t\talen = ALIGN(wlen, c->min_io_size);\n\t\t\tmemset(buf + offs, 0xff, alen - wlen);\n\t\t\terr = ubifs_leb_write(c, lnum, buf + from, from, alen);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = realloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = from = 0;\n\t\t\tubifs_assert(lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tubifs_pack_ltab(c, buf + offs, c->ltab_cmt);\n\t\toffs += c->ltab_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t}\n\n\t/* Write remaining data in buffer */\n\twlen = offs - from;\n\talen = ALIGN(wlen, c->min_io_size);\n\tmemset(buf + offs, 0xff, alen - wlen);\n\terr = ubifs_leb_write(c, lnum, buf + from, from, alen);\n\tif (err)\n\t\treturn err;\n\n\tdbg_chk_lpt_sz(c, 4, alen - wlen);\n\terr = dbg_chk_lpt_sz(c, 3, ALIGN(offs, c->min_io_size));\n\tif (err)\n\t\treturn err;\n\n\tc->nhead_lnum = lnum;\n\tc->nhead_offs = ALIGN(offs, c->min_io_size);\n\n\tdbg_lp(\"LPT root is at %d:%d\", c->lpt_lnum, c->lpt_offs);\n\tdbg_lp(\"LPT head is at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\tdbg_lp(\"LPT ltab is at %d:%d\", c->ltab_lnum, c->ltab_offs);\n\tif (c->big_lpt)\n\t\tdbg_lp(\"LPT lsave is at %d:%d\", c->lsave_lnum, c->lsave_offs);\n\n\treturn 0;\n\nno_space:\n\tubifs_err(\"LPT out of space mismatch at LEB %d:%d needing %d, done_ltab %d, done_lsave %d\",\n\t\t  lnum, offs, len, done_ltab, done_lsave);\n\tubifs_dump_lpt_info(c);\n\tubifs_dump_lpt_lebs(c);\n\tdump_stack();\n\treturn err;\n}\n\n/**\n * next"
  },
  {
    "function_name": "eb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "344-363",
    "snippet": "alloc_lpt_leb(struct ubifs_info *c, int *lnum)\n{\n\tint i, n;\n\n\tn = *lnum - c->lpt_first + 1;\n\tfor (i = n; i < c->lpt_lebs; i++)\n\t\tif (c->ltab[i].cmt) {\n\t\t\tc->ltab[i].cmt = 0;\n\t\t\t*lnum = i + c->lpt_first;\n\t\t\treturn 0;\n\t\t}\n\n\tfor (i = 0; i < n; i++)\n\t\tif (c->ltab[i].cmt) {\n\t\t\tc->ltab[i].cmt = 0;\n\t\t\t*lnum = i + c->lpt_first;\n\t\t\treturn 0;\n\t\t}\n\treturn -ENOSPC;\n}\n\n/**\n * writ",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nalloc_lpt_leb(struct ubifs_info *c, int *lnum)\n{\n\tint i, n;\n\n\tn = *lnum - c->lpt_first + 1;\n\tfor (i = n; i < c->lpt_lebs; i++)\n\t\tif (c->ltab[i].cmt) {\n\t\t\tc->ltab[i].cmt = 0;\n\t\t\t*lnum = i + c->lpt_first;\n\t\t\treturn 0;\n\t\t}\n\n\tfor (i = 0; i < n; i++)\n\t\tif (c->ltab[i].cmt) {\n\t\t\tc->ltab[i].cmt = 0;\n\t\t\t*lnum = i + c->lpt_first;\n\t\t\treturn 0;\n\t\t}\n\treturn -ENOSPC;\n}\n\n/**\n * writ"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "193-328",
    "snippet": "yout_cnodes(struct ubifs_info *c)\n{\n\tint lnum, offs, len, alen, done_lsave, done_ltab, err;\n\tstruct ubifs_cnode *cnode;\n\n\terr = dbg_chk_lpt_sz(c, 0, 0);\n\tif (err)\n\t\treturn err;\n\tcnode = c->lpt_cnext;\n\tif (!cnode)\n\t\treturn 0;\n\tlnum = c->nhead_lnum;\n\toffs = c->nhead_offs;\n\t/* Try to place lsave and ltab nicely */\n\tdone_lsave = !c->big_lpt;\n\tdone_ltab = 0;\n\tif (!done_lsave && offs + c->lsave_sz <= c->leb_size) {\n\t\tdone_lsave = 1;\n\t\tc->lsave_lnum = lnum;\n\t\tc->lsave_offs = offs;\n\t\toffs += c->lsave_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t}\n\n\tif (offs + c->ltab_sz <= c->leb_size) {\n\t\tdone_ltab = 1;\n\t\tc->ltab_lnum = lnum;\n\t\tc->ltab_offs = offs;\n\t\toffs += c->ltab_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t}\n\n\tdo {\n\t\tif (cnode->level) {\n\t\t\tlen = c->nnode_sz;\n\t\t\tc->dirty_nn_cnt -= 1;\n\t\t} else {\n\t\t\tlen = c->pnode_sz;\n\t\t\tc->dirty_pn_cnt -= 1;\n\t\t}\n\t\twhile (offs + len > c->leb_size) {\n\t\t\talen = ALIGN(offs, c->min_io_size);\n\t\t\tupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = alloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = 0;\n\t\t\tubifs_assert(lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\t/* Try to place lsave and ltab nicely */\n\t\t\tif (!done_lsave) {\n\t\t\t\tdone_lsave = 1;\n\t\t\t\tc->lsave_lnum = lnum;\n\t\t\t\tc->lsave_offs = offs;\n\t\t\t\toffs += c->lsave_sz;\n\t\t\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!done_ltab) {\n\t\t\t\tdone_ltab = 1;\n\t\t\t\tc->ltab_lnum = lnum;\n\t\t\t\tc->ltab_offs = offs;\n\t\t\t\toffs += c->ltab_sz;\n\t\t\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (cnode->parent) {\n\t\t\tcnode->parent->nbranch[cnode->iip].lnum = lnum;\n\t\t\tcnode->parent->nbranch[cnode->iip].offs = offs;\n\t\t} else {\n\t\t\tc->lpt_lnum = lnum;\n\t\t\tc->lpt_offs = offs;\n\t\t}\n\t\toffs += len;\n\t\tdbg_chk_lpt_sz(c, 1, len);\n\t\tcnode = cnode->cnext;\n\t} while (cnode && cnode != c->lpt_cnext);\n\n\t/* Make sure to place LPT's save table */\n\tif (!done_lsave) {\n\t\tif (offs + c->lsave_sz > c->leb_size) {\n\t\t\talen = ALIGN(offs, c->min_io_size);\n\t\t\tupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = alloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = 0;\n\t\t\tubifs_assert(lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t}\n\t\tdone_lsave = 1;\n\t\tc->lsave_lnum = lnum;\n\t\tc->lsave_offs = offs;\n\t\toffs += c->lsave_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t}\n\n\t/* Make sure to place LPT's own lprops table */\n\tif (!done_ltab) {\n\t\tif (offs + c->ltab_sz > c->leb_size) {\n\t\t\talen = ALIGN(offs, c->min_io_size);\n\t\t\tupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = alloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = 0;\n\t\t\tubifs_assert(lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t}\n\t\tc->ltab_lnum = lnum;\n\t\tc->ltab_offs = offs;\n\t\toffs += c->ltab_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t}\n\n\talen = ALIGN(offs, c->min_io_size);\n\tupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\n\tdbg_chk_lpt_sz(c, 4, alen - offs);\n\terr = dbg_chk_lpt_sz(c, 3, alen);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n\nno_space:\n\tubifs_err(\"LPT out of space at LEB %d:%d needing %d, done_ltab %d, done_lsave %d\",\n\t\t  lnum, offs, len, done_ltab, done_lsave);\n\tubifs_dump_lpt_info(c);\n\tubifs_dump_lpt_lebs(c);\n\tdump_stack();\n\treturn err;\n}\n\n/**\n * real",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return e",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_lebs(c);\n\tdump_st",
          "args": [
            "c"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_info(c);\n\tubifs_d",
          "args": [
            "m"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T out of",
          "args": [
            "pace at LEB %d:%d needing %d, done_ltab %d, done_lsave %d\",\n\t\t  lnum, o",
            "en,",
            "ne_l",
            "b,",
            "ne_lsave)",
            "ubifs_dum"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 3, alen);",
          "args": [
            "rr)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 4, alen -",
          "args": [
            "o",
            "s",
            "err = dbg"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num, c->",
          "args": [
            "e",
            "size",
            "alen, alen - offs",
            "dbg_chk_l"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->min",
          "args": [
            "io_s",
            "e);\n\tupd_ltab("
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "z(c, 1, c->lta",
          "args": [
            "_",
            ")",
            "}\n\n\talen"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum >= c->l",
          "args": [
            "t_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t}\n\t\tc->l"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &lnum);",
          "args": [
            "(err"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 2, c->leb",
          "args": [
            "s",
            "e",
            "offs);\n\t\t\terr = a"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num, c->",
          "args": [
            "e",
            "size",
            "alen, alen - offs",
            "dbg_chk"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, c->lsa",
          "args": [
            "e",
            "z",
            "}\n\n\t/* Ma"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum >= c->l",
          "args": [
            "t_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t}\n\t\tdone"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &lnum);",
          "args": [
            "(err"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 2, c->leb",
          "args": [
            "s",
            "e",
            "offs);\n\t\t\terr = a"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num, c->",
          "args": [
            "e",
            "size",
            "alen, alen - offs",
            "dbg_chk"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, len);",
          "args": [
            "o",
            "="
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, c->lta",
          "args": [
            "_",
            ")",
            "contin"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, c->lsa",
          "args": [
            "e",
            "z",
            "contin"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum >= c->l",
          "args": [
            "t_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\t/* Try"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &lnum);",
          "args": [
            "(err"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 2, c->leb",
          "args": [
            "s",
            "e",
            "offs);\n\t\t\terr = a"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num, c->",
          "args": [
            "e",
            "size",
            "alen, alen - offs",
            "dbg_chk"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, c->lta",
          "args": [
            "_",
            ")",
            "}\n\n\tdo {"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 1, c->lsa",
          "args": [
            "e",
            "z",
            "}\n\n\tif (o"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z(c, 0, 0);\n\ti",
          "args": [
            "r"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nyout_cnodes(struct ubifs_info *c)\n{\n\tint lnum, offs, len, alen, done_lsave, done_ltab, err;\n\tstruct ubifs_cnode *cnode;\n\n\terr = dbg_chk_lpt_sz(c, 0, 0);\n\tif (err)\n\t\treturn err;\n\tcnode = c->lpt_cnext;\n\tif (!cnode)\n\t\treturn 0;\n\tlnum = c->nhead_lnum;\n\toffs = c->nhead_offs;\n\t/* Try to place lsave and ltab nicely */\n\tdone_lsave = !c->big_lpt;\n\tdone_ltab = 0;\n\tif (!done_lsave && offs + c->lsave_sz <= c->leb_size) {\n\t\tdone_lsave = 1;\n\t\tc->lsave_lnum = lnum;\n\t\tc->lsave_offs = offs;\n\t\toffs += c->lsave_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t}\n\n\tif (offs + c->ltab_sz <= c->leb_size) {\n\t\tdone_ltab = 1;\n\t\tc->ltab_lnum = lnum;\n\t\tc->ltab_offs = offs;\n\t\toffs += c->ltab_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t}\n\n\tdo {\n\t\tif (cnode->level) {\n\t\t\tlen = c->nnode_sz;\n\t\t\tc->dirty_nn_cnt -= 1;\n\t\t} else {\n\t\t\tlen = c->pnode_sz;\n\t\t\tc->dirty_pn_cnt -= 1;\n\t\t}\n\t\twhile (offs + len > c->leb_size) {\n\t\t\talen = ALIGN(offs, c->min_io_size);\n\t\t\tupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = alloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = 0;\n\t\t\tubifs_assert(lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t\t/* Try to place lsave and ltab nicely */\n\t\t\tif (!done_lsave) {\n\t\t\t\tdone_lsave = 1;\n\t\t\t\tc->lsave_lnum = lnum;\n\t\t\t\tc->lsave_offs = offs;\n\t\t\t\toffs += c->lsave_sz;\n\t\t\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!done_ltab) {\n\t\t\t\tdone_ltab = 1;\n\t\t\t\tc->ltab_lnum = lnum;\n\t\t\t\tc->ltab_offs = offs;\n\t\t\t\toffs += c->ltab_sz;\n\t\t\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (cnode->parent) {\n\t\t\tcnode->parent->nbranch[cnode->iip].lnum = lnum;\n\t\t\tcnode->parent->nbranch[cnode->iip].offs = offs;\n\t\t} else {\n\t\t\tc->lpt_lnum = lnum;\n\t\t\tc->lpt_offs = offs;\n\t\t}\n\t\toffs += len;\n\t\tdbg_chk_lpt_sz(c, 1, len);\n\t\tcnode = cnode->cnext;\n\t} while (cnode && cnode != c->lpt_cnext);\n\n\t/* Make sure to place LPT's save table */\n\tif (!done_lsave) {\n\t\tif (offs + c->lsave_sz > c->leb_size) {\n\t\t\talen = ALIGN(offs, c->min_io_size);\n\t\t\tupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = alloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = 0;\n\t\t\tubifs_assert(lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t}\n\t\tdone_lsave = 1;\n\t\tc->lsave_lnum = lnum;\n\t\tc->lsave_offs = offs;\n\t\toffs += c->lsave_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->lsave_sz);\n\t}\n\n\t/* Make sure to place LPT's own lprops table */\n\tif (!done_ltab) {\n\t\tif (offs + c->ltab_sz > c->leb_size) {\n\t\t\talen = ALIGN(offs, c->min_io_size);\n\t\t\tupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\n\t\t\tdbg_chk_lpt_sz(c, 2, c->leb_size - offs);\n\t\t\terr = alloc_lpt_leb(c, &lnum);\n\t\t\tif (err)\n\t\t\t\tgoto no_space;\n\t\t\toffs = 0;\n\t\t\tubifs_assert(lnum >= c->lpt_first &&\n\t\t\t\t     lnum <= c->lpt_last);\n\t\t}\n\t\tc->ltab_lnum = lnum;\n\t\tc->ltab_offs = offs;\n\t\toffs += c->ltab_sz;\n\t\tdbg_chk_lpt_sz(c, 1, c->ltab_sz);\n\t}\n\n\talen = ALIGN(offs, c->min_io_size);\n\tupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\n\tdbg_chk_lpt_sz(c, 4, alen - offs);\n\terr = dbg_chk_lpt_sz(c, 3, alen);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n\nno_space:\n\tubifs_err(\"LPT out of space at LEB %d:%d needing %d, done_ltab %d, done_lsave %d\",\n\t\t  lnum, offs, len, done_ltab, done_lsave);\n\tubifs_dump_lpt_info(c);\n\tubifs_dump_lpt_lebs(c);\n\tdump_stack();\n\treturn err;\n}\n\n/**\n * real"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "160-185",
    "snippet": "loc_lpt_leb(struct ubifs_info *c, int *lnum)\n{\n\tint i, n;\n\n\tn = *lnum - c->lpt_first + 1;\n\tfor (i = n; i < c->lpt_lebs; i++) {\n\t\tif (c->ltab[i].tgc || c->ltab[i].cmt)\n\t\t\tcontinue;\n\t\tif (c->ltab[i].free == c->leb_size) {\n\t\t\tc->ltab[i].cmt = 1;\n\t\t\t*lnum = i + c->lpt_first;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (c->ltab[i].tgc || c->ltab[i].cmt)\n\t\t\tcontinue;\n\t\tif (c->ltab[i].free == c->leb_size) {\n\t\t\tc->ltab[i].cmt = 1;\n\t\t\t*lnum = i + c->lpt_first;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOSPC;\n}\n\n/**\n * layo",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nloc_lpt_leb(struct ubifs_info *c, int *lnum)\n{\n\tint i, n;\n\n\tn = *lnum - c->lpt_first + 1;\n\tfor (i = n; i < c->lpt_lebs; i++) {\n\t\tif (c->ltab[i].tgc || c->ltab[i].cmt)\n\t\t\tcontinue;\n\t\tif (c->ltab[i].free == c->leb_size) {\n\t\t\tc->ltab[i].cmt = 1;\n\t\t\t*lnum = i + c->lpt_first;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (c->ltab[i].tgc || c->ltab[i].cmt)\n\t\t\tcontinue;\n\t\tif (c->ltab[i].free == c->leb_size) {\n\t\t\tc->ltab[i].cmt = 1;\n\t\t\t*lnum = i + c->lpt_first;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOSPC;\n}\n\n/**\n * layo"
  },
  {
    "function_name": "ct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "140-148",
    "snippet": "pd_ltab(struct ubifs_info *c, int lnum, int free, int dirty)\n{\n\tdbg_lp(\"LEB %d free %d dirty %d to %d +%d\",\n\t       lnum, c->ltab[lnum - c->lpt_first].free,\n\t       c->ltab[lnum - c->lpt_first].dirty, free, dirty);\n\tubifs_assert(lnum >= c->lpt_first && lnum <= c->lpt_last);\n\tc->ltab[lnum - c->lpt_first].free = free;\n\tc->ltab[lnum - c->lpt_first].dirty += dirty;\n}\n\n/**\n * allo",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lnum >= c->l",
          "args": [
            "t_first && lnum <= c->lpt_last);\n\tc->ltab[l"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d free",
          "args": [
            "%d dirty %d to %d +%d\",\n\t       lnu",
            "[lnu",
            "- c->lpt_first].free,\n\t       c->",
            "- c->lpt_first].dirty, free, dirty",
            "ub",
            "s_ass"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\npd_ltab(struct ubifs_info *c, int lnum, int free, int dirty)\n{\n\tdbg_lp(\"LEB %d free %d dirty %d to %d +%d\",\n\t       lnum, c->ltab[lnum - c->lpt_first].free,\n\t       c->ltab[lnum - c->lpt_first].dirty, free, dirty);\n\tubifs_assert(lnum >= c->lpt_first && lnum <= c->lpt_last);\n\tc->ltab[lnum - c->lpt_first].free = free;\n\tc->ltab[lnum - c->lpt_first].dirty += dirty;\n}\n\n/**\n * allo"
  },
  {
    "function_name": "_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "99-131",
    "snippet": "t_cnodes_to_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_cnode *cnode, *cnext;\n\tint cnt = 0;\n\n\tif (!c->nroot)\n\t\treturn 0;\n\n\tif (!test_bit(DIRTY_CNODE, &c->nroot->flags))\n\t\treturn 0;\n\n\tc->lpt_cnext = first_dirty_cnode(c->nroot);\n\tcnode = c->lpt_cnext;\n\tif (!cnode)\n\t\treturn 0;\n\tcnt += 1;\n\twhile (1) {\n\t\tubifs_assert(!test_bit(COW_CNODE, &cnode->flags));\n\t\t__set_bit(COW_CNODE, &cnode->flags);\n\t\tcnext = next_dirty_cnode(cnode);\n\t\tif (!cnext) {\n\t\t\tcnode->cnext = c->lpt_cnext;\n\t\t\tbreak;\n\t\t}\n\t\tcnode->cnext = cnext;\n\t\tcnode = cnext;\n\t\tcnt += 1;\n\t}\n\tdbg_cmt(\"committing %d cnodes\", cnt);\n\tdbg_lp(\"committing %d cnodes\", cnt);\n\tubifs_assert(cnt == c->dirty_nn_cnt + c->dirty_pn_cnt);\n\treturn cnt;\n}\n\n/**\n * upd_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cnt == c->di",
          "args": [
            "ty_nn_cnt + c->dirty_pn_cnt);\n\treturn cn"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tting",
          "args": [
            "d cnodes\", cnt);\n\tubif",
            "ass"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_efd_item_committing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extfree_item.c",
          "lines": "458-463",
          "snippet": "STATIC void\nxfs_efd_item_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_efd_item_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ode(cnode);\n\t\tif",
          "args": [
            "(!cne"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CNODE, &",
          "args": [
            "node->fla",
            ");\n\t\tcnext ="
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!test_bit(CO",
          "args": [
            "_CNODE, &cnode->flags));\n\t\t__set_bi"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNODE, &",
          "args": [
            "node->fla",
            "));\n\t\t__set_b"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node(c->nroot);",
          "args": [
            "node = c"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y_CNODE,",
          "args": [
            "&c->nroot->",
            "ags))\n\t\treturn 0"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nt_cnodes_to_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_cnode *cnode, *cnext;\n\tint cnt = 0;\n\n\tif (!c->nroot)\n\t\treturn 0;\n\n\tif (!test_bit(DIRTY_CNODE, &c->nroot->flags))\n\t\treturn 0;\n\n\tc->lpt_cnext = first_dirty_cnode(c->nroot);\n\tcnode = c->lpt_cnext;\n\tif (!cnode)\n\t\treturn 0;\n\tcnt += 1;\n\twhile (1) {\n\t\tubifs_assert(!test_bit(COW_CNODE, &cnode->flags));\n\t\t__set_bit(COW_CNODE, &cnode->flags);\n\t\tcnext = next_dirty_cnode(cnode);\n\t\tif (!cnext) {\n\t\t\tcnode->cnext = c->lpt_cnext;\n\t\t\tbreak;\n\t\t}\n\t\tcnode->cnext = cnext;\n\t\tcnode = cnext;\n\t\tcnt += 1;\n\t}\n\tdbg_cmt(\"committing %d cnodes\", cnt);\n\tdbg_lp(\"committing %d cnodes\", cnt);\n\tubifs_assert(cnt == c->dirty_nn_cnt + c->dirty_pn_cnt);\n\treturn cnt;\n}\n\n/**\n * upd_"
  },
  {
    "function_name": "ode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "72-91",
    "snippet": "ubifs_cnode *next_dirty_cnode(struct ubifs_cnode *cnode)\n{\n\tstruct ubifs_nnode *nnode;\n\tint i;\n\n\tubifs_assert(cnode);\n\tnnode = cnode->parent;\n\tif (!nnode)\n\t\treturn NULL;\n\tfor (i = cnode->iip + 1; i < UBIFS_LPT_FANOUT; i++) {\n\t\tcnode = nnode->nbranch[i].cnode;\n\t\tif (cnode && test_bit(DIRTY_CNODE, &cnode->flags)) {\n\t\t\tif (cnode->level == 0)\n\t\t\t\treturn cnode; /* cnode is a pnode */\n\t\t\t/* cnode is a nnode */\n\t\t\treturn first_dirty_cnode((struct ubifs_nnode *)cnode);\n\t\t}\n\t}\n\treturn (struct ubifs_cnode *)nnode;\n}\n\n/**\n * get_",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node((struct ubif",
          "args": [
            "_nnode *)cnode);\n\t\t}\n\t}\n\tre"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y_CNODE,",
          "args": [
            "&cnode->fla",
            ")) {\n\t\t\tif (c"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cnode);\n\tnno",
          "args": [
            "e = c"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nubifs_cnode *next_dirty_cnode(struct ubifs_cnode *cnode)\n{\n\tstruct ubifs_nnode *nnode;\n\tint i;\n\n\tubifs_assert(cnode);\n\tnnode = cnode->parent;\n\tif (!nnode)\n\t\treturn NULL;\n\tfor (i = cnode->iip + 1; i < UBIFS_LPT_FANOUT; i++) {\n\t\tcnode = nnode->nbranch[i].cnode;\n\t\tif (cnode && test_bit(DIRTY_CNODE, &cnode->flags)) {\n\t\t\tif (cnode->level == 0)\n\t\t\t\treturn cnode; /* cnode is a pnode */\n\t\t\t/* cnode is a nnode */\n\t\t\treturn first_dirty_cnode((struct ubifs_nnode *)cnode);\n\t\t}\n\t}\n\treturn (struct ubifs_cnode *)nnode;\n}\n\n/**\n * get_"
  },
  {
    "function_name": "node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
    "lines": "42-64",
    "snippet": "ubifs_cnode *first_dirty_cnode(struct ubifs_nnode *nnode)\n{\n\tubifs_assert(nnode);\n\twhile (1) {\n\t\tint i, cont = 0;\n\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tstruct ubifs_cnode *cnode;\n\n\t\t\tcnode = nnode->nbranch[i].cnode;\n\t\t\tif (cnode &&\n\t\t\t    test_bit(DIRTY_CNODE, &cnode->flags)) {\n\t\t\t\tif (cnode->level == 0)\n\t\t\t\t\treturn cnode;\n\t\t\t\tnnode = (struct ubifs_nnode *)cnode;\n\t\t\t\tcont = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!cont)\n\t\t\treturn (struct ubifs_cnode *)nnode;\n\t}\n}\n\n/**\n * next",
    "includes": [
      "fs.h\"\n\nstatic int d",
      "ux/random.h>\n#include \"ubi",
      "ux/slab.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y_CNODE,",
          "args": [
            "&cnode->fla",
            ")) {\n\t\t\t\tif ("
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnode);\n\twhi",
          "args": [
            "e (1)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\nubifs_cnode *first_dirty_cnode(struct ubifs_nnode *nnode)\n{\n\tubifs_assert(nnode);\n\twhile (1) {\n\t\tint i, cont = 0;\n\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tstruct ubifs_cnode *cnode;\n\n\t\t\tcnode = nnode->nbranch[i].cnode;\n\t\t\tif (cnode &&\n\t\t\t    test_bit(DIRTY_CNODE, &cnode->flags)) {\n\t\t\t\tif (cnode->level == 0)\n\t\t\t\t\treturn cnode;\n\t\t\t\tnnode = (struct ubifs_nnode *)cnode;\n\t\t\t\tcont = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!cont)\n\t\t\treturn (struct ubifs_cnode *)nnode;\n\t}\n}\n\n/**\n * next"
  }
]