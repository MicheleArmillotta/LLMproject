[
  {
    "function_name": "extRoundDown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
    "lines": "636-651",
    "snippet": "static s64 extRoundDown(s64 nb)\n{\n\tint i;\n\tu64 m, k;\n\n\tfor (i = 0, m = (u64) 1 << 63; i < 64; i++, m >>= 1) {\n\t\tif (m & nb)\n\t\t\tbreak;\n\t}\n\n\ti = 63 - i;\n\tk = (u64) 1 << i;\n\tk = ((k - 1) & nb) ? k : k >> 1;\n\n\treturn (k);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int extBalloc(struct inode *, s64, s64 *, s64 *);",
      "static s64 extRoundDown(s64 nb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\nstatic s64 extRoundDown(s64 nb);\n\nstatic s64 extRoundDown(s64 nb)\n{\n\tint i;\n\tu64 m, k;\n\n\tfor (i = 0, m = (u64) 1 << 63; i < 64; i++, m >>= 1) {\n\t\tif (m & nb)\n\t\t\tbreak;\n\t}\n\n\ti = 63 - i;\n\tk = (u64) 1 << i;\n\tk = ((k - 1) & nb) ? k : k >> 1;\n\n\treturn (k);\n}"
  },
  {
    "function_name": "extBrealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
    "lines": "601-620",
    "snippet": "static int\nextBrealloc(struct inode *ip,\n\t    s64 blkno, s64 nblks, s64 * newnblks, s64 * newblkno)\n{\n\tint rc;\n\n\t/* try to extend in place */\n\tif ((rc = dbExtend(ip, blkno, nblks, *newnblks - nblks)) == 0) {\n\t\t*newblkno = blkno;\n\t\treturn (0);\n\t} else {\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* in place extension not possible.\n\t * try to move the extent to a new set of blocks.\n\t */\n\treturn (extBalloc(ip, blkno, newnblks, newblkno));\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int extBalloc(struct inode *, s64, s64 *, s64 *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "extBalloc",
          "args": [
            "ip",
            "blkno",
            "newnblks",
            "newblkno"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "extBalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
          "lines": "508-564",
          "snippet": "static int\nextBalloc(struct inode *ip, s64 hint, s64 * nblocks, s64 * blkno)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nb, nblks, daddr, max;\n\tint rc, nbperpage = sbi->nbperpage;\n\tstruct bmap *bmp = sbi->bmap;\n\tint ag;\n\n\t/* get the number of blocks to initially attempt to allocate.\n\t * we'll first try the number of blocks requested unless this\n\t * number is greater than the maximum number of contiguous free\n\t * blocks in the map. in that case, we'll start off with the\n\t * maximum free.\n\t */\n\tmax = (s64) 1 << bmp->db_maxfreebud;\n\tif (*nblocks >= max && *nblocks > nbperpage)\n\t\tnb = nblks = (max > nbperpage) ? max : nbperpage;\n\telse\n\t\tnb = nblks = *nblocks;\n\n\t/* try to allocate blocks */\n\twhile ((rc = dbAlloc(ip, hint, nb, &daddr)) != 0) {\n\t\t/* if something other than an out of space error,\n\t\t * stop and return this error.\n\t\t */\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\n\t\t/* decrease the allocation request size */\n\t\tnb = min(nblks, extRoundDown(nb));\n\n\t\t/* give up if we cannot cover a page */\n\t\tif (nb < nbperpage)\n\t\t\treturn (rc);\n\t}\n\n\t*nblocks = nb;\n\t*blkno = daddr;\n\n\tif (S_ISREG(ip->i_mode) && (ji->fileset == FILESYSTEM_I)) {\n\t\tag = BLKTOAG(daddr, sbi);\n\t\tspin_lock_irq(&ji->ag_lock);\n\t\tif (ji->active_ag == -1) {\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t} else if (ji->active_ag != ag) {\n\t\t\tatomic_dec(&bmp->db_active[ji->active_ag]);\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t}\n\t\tspin_unlock_irq(&ji->ag_lock);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int extBalloc(struct inode *, s64, s64 *, s64 *);",
            "static s64 extRoundDown(s64 nb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\nstatic s64 extRoundDown(s64 nb);\n\nstatic int\nextBalloc(struct inode *ip, s64 hint, s64 * nblocks, s64 * blkno)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nb, nblks, daddr, max;\n\tint rc, nbperpage = sbi->nbperpage;\n\tstruct bmap *bmp = sbi->bmap;\n\tint ag;\n\n\t/* get the number of blocks to initially attempt to allocate.\n\t * we'll first try the number of blocks requested unless this\n\t * number is greater than the maximum number of contiguous free\n\t * blocks in the map. in that case, we'll start off with the\n\t * maximum free.\n\t */\n\tmax = (s64) 1 << bmp->db_maxfreebud;\n\tif (*nblocks >= max && *nblocks > nbperpage)\n\t\tnb = nblks = (max > nbperpage) ? max : nbperpage;\n\telse\n\t\tnb = nblks = *nblocks;\n\n\t/* try to allocate blocks */\n\twhile ((rc = dbAlloc(ip, hint, nb, &daddr)) != 0) {\n\t\t/* if something other than an out of space error,\n\t\t * stop and return this error.\n\t\t */\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\n\t\t/* decrease the allocation request size */\n\t\tnb = min(nblks, extRoundDown(nb));\n\n\t\t/* give up if we cannot cover a page */\n\t\tif (nb < nbperpage)\n\t\t\treturn (rc);\n\t}\n\n\t*nblocks = nb;\n\t*blkno = daddr;\n\n\tif (S_ISREG(ip->i_mode) && (ji->fileset == FILESYSTEM_I)) {\n\t\tag = BLKTOAG(daddr, sbi);\n\t\tspin_lock_irq(&ji->ag_lock);\n\t\tif (ji->active_ag == -1) {\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t} else if (ji->active_ag != ag) {\n\t\t\tatomic_dec(&bmp->db_active[ji->active_ag]);\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t}\n\t\tspin_unlock_irq(&ji->ag_lock);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbExtend",
          "args": [
            "ip",
            "blkno",
            "nblks",
            "*newnblks - nblks"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "dbExtend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "1026-1103",
          "snippet": "static int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 lblkno, lastblkno, extblkno;\n\tuint rel_block;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint rc;\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct bmap *bmp;\n\n\t/*\n\t * We don't want a non-aligned extent to cross a page boundary\n\t */\n\tif (((rel_block = blkno & (sbi->nbperpage - 1))) &&\n\t    (rel_block + nblocks + addnblocks > sbi->nbperpage))\n\t\treturn -ENOSPC;\n\n\t/* get the last block of the current allocation */\n\tlastblkno = blkno + nblocks - 1;\n\n\t/* determine the block number of the block following\n\t * the existing allocation.\n\t */\n\textblkno = lastblkno + 1;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* better be within the file system */\n\tbmp = sbi->bmap;\n\tif (lastblkno < 0 || lastblkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tjfs_error(ip->i_sb, \"the block is outside the filesystem\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* we'll attempt to extend the current allocation in place by\n\t * allocating the additional blocks as the blocks immediately\n\t * following the current allocation.  we only try to extend the\n\t * current allocation in place if the number of additional blocks\n\t * can fit into a dmap, the last block of the current allocation\n\t * is not the last block of the file system, and the start of the\n\t * inplace extension is not on an allocation group boundary.\n\t */\n\tif (addnblocks > BPERDMAP || extblkno >= bmp->db_mapsize ||\n\t    (extblkno & (bmp->db_agsize - 1)) == 0) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* get the buffer for the dmap containing the first block\n\t * of the extension.\n\t */\n\tlblkno = BLKTODMAP(extblkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\n\tdp = (struct dmap *) mp->data;\n\n\t/* try to allocate the blocks immediately following the\n\t * current allocation.\n\t */\n\trc = dbAllocNext(bmp, dp, extblkno, (int) addnblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\t/* were we successful ? */\n\tif (rc == 0)\n\t\twrite_metapage(mp);\n\telse\n\t\t/* we were not successful */\n\t\trelease_metapage(mp);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 lblkno, lastblkno, extblkno;\n\tuint rel_block;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint rc;\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct bmap *bmp;\n\n\t/*\n\t * We don't want a non-aligned extent to cross a page boundary\n\t */\n\tif (((rel_block = blkno & (sbi->nbperpage - 1))) &&\n\t    (rel_block + nblocks + addnblocks > sbi->nbperpage))\n\t\treturn -ENOSPC;\n\n\t/* get the last block of the current allocation */\n\tlastblkno = blkno + nblocks - 1;\n\n\t/* determine the block number of the block following\n\t * the existing allocation.\n\t */\n\textblkno = lastblkno + 1;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* better be within the file system */\n\tbmp = sbi->bmap;\n\tif (lastblkno < 0 || lastblkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tjfs_error(ip->i_sb, \"the block is outside the filesystem\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* we'll attempt to extend the current allocation in place by\n\t * allocating the additional blocks as the blocks immediately\n\t * following the current allocation.  we only try to extend the\n\t * current allocation in place if the number of additional blocks\n\t * can fit into a dmap, the last block of the current allocation\n\t * is not the last block of the file system, and the start of the\n\t * inplace extension is not on an allocation group boundary.\n\t */\n\tif (addnblocks > BPERDMAP || extblkno >= bmp->db_mapsize ||\n\t    (extblkno & (bmp->db_agsize - 1)) == 0) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* get the buffer for the dmap containing the first block\n\t * of the extension.\n\t */\n\tlblkno = BLKTODMAP(extblkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\n\tdp = (struct dmap *) mp->data;\n\n\t/* try to allocate the blocks immediately following the\n\t * current allocation.\n\t */\n\trc = dbAllocNext(bmp, dp, extblkno, (int) addnblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\t/* were we successful ? */\n\tif (rc == 0)\n\t\twrite_metapage(mp);\n\telse\n\t\t/* we were not successful */\n\t\trelease_metapage(mp);\n\n\treturn (rc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\n\nstatic int\nextBrealloc(struct inode *ip,\n\t    s64 blkno, s64 nblks, s64 * newnblks, s64 * newblkno)\n{\n\tint rc;\n\n\t/* try to extend in place */\n\tif ((rc = dbExtend(ip, blkno, nblks, *newnblks - nblks)) == 0) {\n\t\t*newblkno = blkno;\n\t\treturn (0);\n\t} else {\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* in place extension not possible.\n\t * try to move the extent to a new set of blocks.\n\t */\n\treturn (extBalloc(ip, blkno, newnblks, newblkno));\n}"
  },
  {
    "function_name": "extBalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
    "lines": "508-564",
    "snippet": "static int\nextBalloc(struct inode *ip, s64 hint, s64 * nblocks, s64 * blkno)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nb, nblks, daddr, max;\n\tint rc, nbperpage = sbi->nbperpage;\n\tstruct bmap *bmp = sbi->bmap;\n\tint ag;\n\n\t/* get the number of blocks to initially attempt to allocate.\n\t * we'll first try the number of blocks requested unless this\n\t * number is greater than the maximum number of contiguous free\n\t * blocks in the map. in that case, we'll start off with the\n\t * maximum free.\n\t */\n\tmax = (s64) 1 << bmp->db_maxfreebud;\n\tif (*nblocks >= max && *nblocks > nbperpage)\n\t\tnb = nblks = (max > nbperpage) ? max : nbperpage;\n\telse\n\t\tnb = nblks = *nblocks;\n\n\t/* try to allocate blocks */\n\twhile ((rc = dbAlloc(ip, hint, nb, &daddr)) != 0) {\n\t\t/* if something other than an out of space error,\n\t\t * stop and return this error.\n\t\t */\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\n\t\t/* decrease the allocation request size */\n\t\tnb = min(nblks, extRoundDown(nb));\n\n\t\t/* give up if we cannot cover a page */\n\t\tif (nb < nbperpage)\n\t\t\treturn (rc);\n\t}\n\n\t*nblocks = nb;\n\t*blkno = daddr;\n\n\tif (S_ISREG(ip->i_mode) && (ji->fileset == FILESYSTEM_I)) {\n\t\tag = BLKTOAG(daddr, sbi);\n\t\tspin_lock_irq(&ji->ag_lock);\n\t\tif (ji->active_ag == -1) {\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t} else if (ji->active_ag != ag) {\n\t\t\tatomic_dec(&bmp->db_active[ji->active_ag]);\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t}\n\t\tspin_unlock_irq(&ji->ag_lock);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int extBalloc(struct inode *, s64, s64 *, s64 *);",
      "static s64 extRoundDown(s64 nb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ji->ag_lock"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bmp->db_active[ag]"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&bmp->db_active[ji->active_ag]"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bmp->db_active[ag]"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ji->ag_lock"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLKTOAG",
          "args": [
            "daddr",
            "sbi"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_mode"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nblks",
            "extRoundDown(nb)"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extRoundDown",
          "args": [
            "nb"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "extRoundDown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
          "lines": "636-651",
          "snippet": "static s64 extRoundDown(s64 nb)\n{\n\tint i;\n\tu64 m, k;\n\n\tfor (i = 0, m = (u64) 1 << 63; i < 64; i++, m >>= 1) {\n\t\tif (m & nb)\n\t\t\tbreak;\n\t}\n\n\ti = 63 - i;\n\tk = (u64) 1 << i;\n\tk = ((k - 1) & nb) ? k : k >> 1;\n\n\treturn (k);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int extBalloc(struct inode *, s64, s64 *, s64 *);",
            "static s64 extRoundDown(s64 nb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\nstatic s64 extRoundDown(s64 nb);\n\nstatic s64 extRoundDown(s64 nb)\n{\n\tint i;\n\tu64 m, k;\n\n\tfor (i = 0, m = (u64) 1 << 63; i < 64; i++, m >>= 1) {\n\t\tif (m & nb)\n\t\t\tbreak;\n\t}\n\n\ti = 63 - i;\n\tk = (u64) 1 << i;\n\tk = ((k - 1) & nb) ? k : k >> 1;\n\n\treturn (k);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbAlloc",
          "args": [
            "ip",
            "hint",
            "nb",
            "&daddr"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\nstatic s64 extRoundDown(s64 nb);\n\nstatic int\nextBalloc(struct inode *ip, s64 hint, s64 * nblocks, s64 * blkno)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nb, nblks, daddr, max;\n\tint rc, nbperpage = sbi->nbperpage;\n\tstruct bmap *bmp = sbi->bmap;\n\tint ag;\n\n\t/* get the number of blocks to initially attempt to allocate.\n\t * we'll first try the number of blocks requested unless this\n\t * number is greater than the maximum number of contiguous free\n\t * blocks in the map. in that case, we'll start off with the\n\t * maximum free.\n\t */\n\tmax = (s64) 1 << bmp->db_maxfreebud;\n\tif (*nblocks >= max && *nblocks > nbperpage)\n\t\tnb = nblks = (max > nbperpage) ? max : nbperpage;\n\telse\n\t\tnb = nblks = *nblocks;\n\n\t/* try to allocate blocks */\n\twhile ((rc = dbAlloc(ip, hint, nb, &daddr)) != 0) {\n\t\t/* if something other than an out of space error,\n\t\t * stop and return this error.\n\t\t */\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\n\t\t/* decrease the allocation request size */\n\t\tnb = min(nblks, extRoundDown(nb));\n\n\t\t/* give up if we cannot cover a page */\n\t\tif (nb < nbperpage)\n\t\t\treturn (rc);\n\t}\n\n\t*nblocks = nb;\n\t*blkno = daddr;\n\n\tif (S_ISREG(ip->i_mode) && (ji->fileset == FILESYSTEM_I)) {\n\t\tag = BLKTOAG(daddr, sbi);\n\t\tspin_lock_irq(&ji->ag_lock);\n\t\tif (ji->active_ag == -1) {\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t} else if (ji->active_ag != ag) {\n\t\t\tatomic_dec(&bmp->db_active[ji->active_ag]);\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t}\n\t\tspin_unlock_irq(&ji->ag_lock);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "extFill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
    "lines": "456-473",
    "snippet": "int extFill(struct inode *ip, xad_t * xp)\n{\n\tint rc, nbperpage = JFS_SBI(ip->i_sb)->nbperpage;\n\ts64 blkno = offsetXAD(xp) >> ip->i_blkbits;\n\n//\tassert(ISSPARSE(ip));\n\n\t/* initialize the extent allocation hint */\n\tXADaddress(xp, 0);\n\n\t/* allocate an extent to fill the hole */\n\tif ((rc = extAlloc(ip, nbperpage, blkno, xp, false)))\n\t\treturn (rc);\n\n\tassert(lengthPXD(xp) == nbperpage);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int extBalloc(struct inode *, s64, s64 *, s64 *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "lengthPXD(xp) == nbperpage"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "xp"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extAlloc",
          "args": [
            "ip",
            "nbperpage",
            "blkno",
            "xp",
            "false"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "extAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
          "lines": "85-191",
          "snippet": "int\nextAlloc(struct inode *ip, s64 xlen, s64 pno, xad_t * xp, bool abnr)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nxlen, nxaddr, xoff, hint, xaddr = 0;\n\tint rc;\n\tint xflag;\n\n\t/* This blocks if we are low on resources */\n\ttxBeginAnon(ip->i_sb);\n\n\t/* Avoid race with jfs_commit_inode() */\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t/* validate extent length */\n\tif (xlen > MAXXLEN)\n\t\txlen = MAXXLEN;\n\n\t/* get the page's starting extent offset */\n\txoff = pno << sbi->l2nbperpage;\n\n\t/* check if an allocation hint was provided */\n\tif ((hint = addressXAD(xp))) {\n\t\t/* get the size of the extent described by the hint */\n\t\tnxlen = lengthXAD(xp);\n\n\t\t/* check if the hint is for the portion of the file\n\t\t * immediately previous to the current allocation\n\t\t * request and if hint extent has the same abnr\n\t\t * value as the current request.  if so, we can\n\t\t * extend the hint extent to include the current\n\t\t * extent if we can allocate the blocks immediately\n\t\t * following the hint extent.\n\t\t */\n\t\tif (offsetXAD(xp) + nxlen == xoff &&\n\t\t    abnr == ((xp->flag & XAD_NOTRECORDED) ? true : false))\n\t\t\txaddr = hint + nxlen;\n\n\t\t/* adjust the hint to the last block of the extent */\n\t\thint += (nxlen - 1);\n\t}\n\n\t/* allocate the disk blocks for the extent.  initially, extBalloc()\n\t * will try to allocate disk blocks for the requested size (xlen).\n\t * if this fails (xlen contiguous free blocks not available), it'll\n\t * try to allocate a smaller number of blocks (producing a smaller\n\t * extent), with this smaller number of blocks consisting of the\n\t * requested number of blocks rounded down to the next smaller\n\t * power of 2 number (i.e. 16 -> 8).  it'll continue to round down\n\t * and retry the allocation until the number of blocks to allocate\n\t * is smaller than the number of blocks per page.\n\t */\n\tnxlen = xlen;\n\tif ((rc = extBalloc(ip, hint ? hint : INOHINT(ip), &nxlen, &nxaddr))) {\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, nxlen);\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, (s64) nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn rc;\n\t}\n\n\t/* determine the value of the extent flag */\n\txflag = abnr ? XAD_NOTRECORDED : 0;\n\n\t/* if we can extend the hint extent to cover the current request,\n\t * extend it.  otherwise, insert a new extent to\n\t * cover the current request.\n\t */\n\tif (xaddr && xaddr == nxaddr)\n\t\trc = xtExtend(0, ip, xoff, (int) nxlen, 0);\n\telse\n\t\trc = xtInsert(0, ip, xflag, xoff, (int) nxlen, &nxaddr, 0);\n\n\t/* if the extend or insert failed,\n\t * free the newly allocated blocks and return the error.\n\t */\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, nxlen);\n\t\tdquot_free_block(ip, nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the extent allocation */\n\tXADaddress(xp, nxaddr);\n\tXADlength(xp, nxlen);\n\tXADoffset(xp, xoff);\n\txp->flag = xflag;\n\n\tmark_inode_dirty(ip);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t/*\n\t * COMMIT_SyncList flags an anonymous tlock on page that is on\n\t * sync list.\n\t * We need to commit the inode to get the page written disk.\n\t */\n\tif (test_and_clear_cflag(COMMIT_Synclist,ip))\n\t\tjfs_commit_inode(ip, 0);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int extBalloc(struct inode *, s64, s64 *, s64 *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\n\nint\nextAlloc(struct inode *ip, s64 xlen, s64 pno, xad_t * xp, bool abnr)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nxlen, nxaddr, xoff, hint, xaddr = 0;\n\tint rc;\n\tint xflag;\n\n\t/* This blocks if we are low on resources */\n\ttxBeginAnon(ip->i_sb);\n\n\t/* Avoid race with jfs_commit_inode() */\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t/* validate extent length */\n\tif (xlen > MAXXLEN)\n\t\txlen = MAXXLEN;\n\n\t/* get the page's starting extent offset */\n\txoff = pno << sbi->l2nbperpage;\n\n\t/* check if an allocation hint was provided */\n\tif ((hint = addressXAD(xp))) {\n\t\t/* get the size of the extent described by the hint */\n\t\tnxlen = lengthXAD(xp);\n\n\t\t/* check if the hint is for the portion of the file\n\t\t * immediately previous to the current allocation\n\t\t * request and if hint extent has the same abnr\n\t\t * value as the current request.  if so, we can\n\t\t * extend the hint extent to include the current\n\t\t * extent if we can allocate the blocks immediately\n\t\t * following the hint extent.\n\t\t */\n\t\tif (offsetXAD(xp) + nxlen == xoff &&\n\t\t    abnr == ((xp->flag & XAD_NOTRECORDED) ? true : false))\n\t\t\txaddr = hint + nxlen;\n\n\t\t/* adjust the hint to the last block of the extent */\n\t\thint += (nxlen - 1);\n\t}\n\n\t/* allocate the disk blocks for the extent.  initially, extBalloc()\n\t * will try to allocate disk blocks for the requested size (xlen).\n\t * if this fails (xlen contiguous free blocks not available), it'll\n\t * try to allocate a smaller number of blocks (producing a smaller\n\t * extent), with this smaller number of blocks consisting of the\n\t * requested number of blocks rounded down to the next smaller\n\t * power of 2 number (i.e. 16 -> 8).  it'll continue to round down\n\t * and retry the allocation until the number of blocks to allocate\n\t * is smaller than the number of blocks per page.\n\t */\n\tnxlen = xlen;\n\tif ((rc = extBalloc(ip, hint ? hint : INOHINT(ip), &nxlen, &nxaddr))) {\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, nxlen);\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, (s64) nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn rc;\n\t}\n\n\t/* determine the value of the extent flag */\n\txflag = abnr ? XAD_NOTRECORDED : 0;\n\n\t/* if we can extend the hint extent to cover the current request,\n\t * extend it.  otherwise, insert a new extent to\n\t * cover the current request.\n\t */\n\tif (xaddr && xaddr == nxaddr)\n\t\trc = xtExtend(0, ip, xoff, (int) nxlen, 0);\n\telse\n\t\trc = xtInsert(0, ip, xflag, xoff, (int) nxlen, &nxaddr, 0);\n\n\t/* if the extend or insert failed,\n\t * free the newly allocated blocks and return the error.\n\t */\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, nxlen);\n\t\tdquot_free_block(ip, nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the extent allocation */\n\tXADaddress(xp, nxaddr);\n\tXADlength(xp, nxlen);\n\tXADoffset(xp, xoff);\n\txp->flag = xflag;\n\n\tmark_inode_dirty(ip);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t/*\n\t * COMMIT_SyncList flags an anonymous tlock on page that is on\n\t * sync list.\n\t * We need to commit the inode to get the page written disk.\n\t */\n\tif (test_and_clear_cflag(COMMIT_Synclist,ip))\n\t\tjfs_commit_inode(ip, 0);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XADaddress",
          "args": [
            "xp",
            "0"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xp"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\n\nint extFill(struct inode *ip, xad_t * xp)\n{\n\tint rc, nbperpage = JFS_SBI(ip->i_sb)->nbperpage;\n\ts64 blkno = offsetXAD(xp) >> ip->i_blkbits;\n\n//\tassert(ISSPARSE(ip));\n\n\t/* initialize the extent allocation hint */\n\tXADaddress(xp, 0);\n\n\t/* allocate an extent to fill the hole */\n\tif ((rc = extAlloc(ip, nbperpage, blkno, xp, false)))\n\t\treturn (rc);\n\n\tassert(lengthPXD(xp) == nbperpage);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "extRecord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
    "lines": "424-437",
    "snippet": "int extRecord(struct inode *ip, xad_t * xp)\n{\n\tint rc;\n\n\ttxBeginAnon(ip->i_sb);\n\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t/* update the extent */\n\trc = xtUpdate(0, ip, xp);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtUpdate",
          "args": [
            "0",
            "ip",
            "xp"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "xtUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "1705-2149",
          "snippet": "int xtUpdate(tid_t tid, struct inode *ip, xad_t * nxad)\n{\t\t\t\t/* new XAD */\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index0, index, newindex, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad, *lxad, *rxad;\n\tint xflag;\n\ts64 nxoff, xoff;\n\tint nxlen, xlen, lxlen, rxlen;\n\ts64 nxaddr, xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\tint newpage = 0;\n\n\t/* there must exist extent to be tailgated */\n\tnxoff = offsetXAD(nxad);\n\tnxlen = lengthXAD(nxad);\n\tnxaddr = addressXAD(nxad);\n\n\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"Could not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire tlock of the leaf page containing original entry\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\txad = &p->xad[index0];\n\txflag = xad->flag;\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txaddr = addressXAD(xad);\n\n\t/* nXAD must be completely contained within XAD */\n\tif ((xoff > nxoff) ||\n\t    (nxoff + nxlen > xoff + xlen)) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb,\n\t\t\t  \"nXAD in not completely contained within XAD\\n\");\n\t\treturn -EIO;\n\t}\n\n\tindex = index0;\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n#ifdef  _JFS_WIP_NOCOALESCE\n\tif (xoff < nxoff)\n\t\tgoto updateRight;\n\n\t/*\n\t * replace XAD with nXAD\n\t */\n      replace:\t\t\t/* (nxoff == xoff) */\n\tif (nxlen == xlen) {\n\t\t/* replace XAD with nXAD:recorded */\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto out;\n\t} else\t\t\t/* (nxlen < xlen) */\n\t\tgoto updateLeft;\n#endif\t\t\t\t/* _JFS_WIP_NOCOALESCE */\n\n/* #ifdef _JFS_WIP_COALESCE */\n\tif (xoff < nxoff)\n\t\tgoto coalesceRight;\n\n\t/*\n\t * coalesce with left XAD\n\t */\n//coalesceLeft: /* (xoff == nxoff) */\n\t/* is XAD first entry of page ? */\n\tif (index == XTENTRYSTART)\n\t\tgoto replace;\n\n\t/* is nXAD logically and physically contiguous with lXAD ? */\n\tlxad = &p->xad[index - 1];\n\tlxlen = lengthXAD(lxad);\n\tif (!(lxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff == offsetXAD(lxad) + lxlen) &&\n\t    (nxaddr == addressXAD(lxad) + lxlen) &&\n\t    (lxlen + nxlen < MAXXLEN)) {\n\t\t/* extend right lXAD */\n\t\tindex0 = index - 1;\n\t\tXADlength(lxad, lxlen + nxlen);\n\n\t\t/* If we just merged two extents together, need to make sure the\n\t\t * right extent gets logged.  If the left one is marked XAD_NEW,\n\t\t * then we know it will be logged.  Otherwise, mark as\n\t\t * XAD_EXTENDED\n\t\t */\n\t\tif (!(lxad->flag & XAD_NEW))\n\t\t\tlxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen) {\n\t\t\t/* truncate XAD */\n\t\t\tXADoffset(xad, xoff + nxlen);\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\t\tXADaddress(xad, xaddr + nxlen);\n\t\t\tgoto out;\n\t\t} else {\t/* (xlen == nxlen) */\n\n\t\t\t/* remove XAD */\n\t\t\tif (index < nextindex - 1)\n\t\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t\t(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\n\t\t\tindex = index0;\n\t\t\tnewindex = index + 1;\n\t\t\tnextindex = le16_to_cpu(p->header.nextindex);\n\t\t\txoff = nxoff = offsetXAD(lxad);\n\t\t\txlen = nxlen = lxlen + nxlen;\n\t\t\txaddr = nxaddr = addressXAD(lxad);\n\t\t\tgoto coalesceRight;\n\t\t}\n\t}\n\n\t/*\n\t * replace XAD with nXAD\n\t */\n      replace:\t\t\t/* (nxoff == xoff) */\n\tif (nxlen == xlen) {\n\t\t/* replace XAD with nXAD:recorded */\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto coalesceRight;\n\t} else\t\t\t/* (nxlen < xlen) */\n\t\tgoto updateLeft;\n\n\t/*\n\t * coalesce with right XAD\n\t */\n      coalesceRight:\t\t/* (xoff <= nxoff) */\n\t/* is XAD last entry of page ? */\n\tif (newindex == nextindex) {\n\t\tif (xoff == nxoff)\n\t\t\tgoto out;\n\t\tgoto updateRight;\n\t}\n\n\t/* is nXAD logically and physically contiguous with rXAD ? */\n\trxad = &p->xad[index + 1];\n\trxlen = lengthXAD(rxad);\n\tif (!(rxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff + nxlen == offsetXAD(rxad)) &&\n\t    (nxaddr + nxlen == addressXAD(rxad)) &&\n\t    (rxlen + nxlen < MAXXLEN)) {\n\t\t/* extend left rXAD */\n\t\tXADoffset(rxad, nxoff);\n\t\tXADlength(rxad, rxlen + nxlen);\n\t\tXADaddress(rxad, nxaddr);\n\n\t\t/* If we just merged two extents together, need to make sure\n\t\t * the left extent gets logged.  If the right one is marked\n\t\t * XAD_NEW, then we know it will be logged.  Otherwise, mark as\n\t\t * XAD_EXTENDED\n\t\t */\n\t\tif (!(rxad->flag & XAD_NEW))\n\t\t\trxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen)\n\t\t\t/* truncate XAD */\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\telse {\t\t/* (xlen == nxlen) */\n\n\t\t\t/* remove XAD */\n\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t(nextindex - index - 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\t\t}\n\n\t\tgoto out;\n\t} else if (xoff == nxoff)\n\t\tgoto out;\n\n\tif (xoff >= nxoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xoff >= nxoff\\n\");\n\t\treturn -EIO;\n\t}\n/* #endif _JFS_WIP_COALESCE */\n\n\t/*\n\t * split XAD into (lXAD, nXAD):\n\t *\n\t *          |---nXAD--->\n\t * --|----------XAD----------|--\n\t *   |-lXAD-|\n\t */\n      updateRight:\t\t/* (xoff < nxoff) */\n\t/* truncate old XAD as lXAD:not_recorded */\n\txad = &p->xad[index];\n\tXADlength(xad, nxoff - xoff);\n\n\t/* insert nXAD:recorded */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag & ~XAD_NOTRECORDED;\n\t\tsplit.off = nxoff;\n\t\tsplit.len = nxlen;\n\t\tsplit.addr = nxaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* is nXAD on new page ? */\n\t\t\tif (newindex >\n\t\t\t    (le16_to_cpu(p->header.maxentry) >> 1)) {\n\t\t\t\tnewindex =\n\t\t\t\t    newindex -\n\t\t\t\t    le16_to_cpu(p->header.nextindex) +\n\t\t\t\t    XTENTRYSTART;\n\t\t\t\tnewpage = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if insert into middle, shift right remaining entries */\n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t/* insert the entry */\n\t\txad = &p->xad[newindex];\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\t/* advance next available entry index. */\n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n\t/*\n\t * does nXAD force 3-way split ?\n\t *\n\t *          |---nXAD--->|\n\t * --|----------XAD-------------|--\n\t *   |-lXAD-|           |-rXAD -|\n\t */\n\tif (nxoff + nxlen == xoff + xlen)\n\t\tgoto out;\n\n\t/* reorient nXAD as XAD for further split XAD into (nXAD, rXAD) */\n\tif (newpage) {\n\t\t/* close out old page */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\tbn = le64_to_cpu(p->header.next);\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* get new right page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t}\n\n\t\tindex0 = index = newindex;\n\t} else\n\t\tindex++;\n\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\txlen = xlen - (nxoff - xoff);\n\txoff = nxoff;\n\txaddr = nxaddr;\n\n\t/* recompute split pages */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tXT_PUTPAGE(mp);\n\n\t\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\t\treturn rc;\n\n\t\t/* retrieve search result */\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"xtSearch failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (index0 != index) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"unexpected value of index\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * split XAD into (nXAD, rXAD)\n\t *\n\t *          ---nXAD---|\n\t * --|----------XAD----------|--\n\t *                    |-rXAD-|\n\t */\n      updateLeft:\t\t/* (nxoff == xoff) && (nxlen < xlen) */\n\t/* update old XAD with nXAD:recorded */\n\txad = &p->xad[index];\n\t*xad = *nxad;\n\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t/* insert rXAD:not_recorded */\n\txoff = xoff + nxlen;\n\txlen = xlen - nxlen;\n\txaddr = xaddr + nxlen;\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n/*\nprintf(\"xtUpdate.updateLeft.split p:0x%p\\n\", p);\n*/\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if insert into middle, shift right remaining entries */\n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t/* insert the entry */\n\t\txad = &p->xad[newindex];\n\t\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t\t/* advance next available entry index. */\n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n      out:\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t\t    xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtUpdate(tid_t tid, struct inode *ip, xad_t * nxad)\n{\t\t\t\t/* new XAD */\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index0, index, newindex, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad, *lxad, *rxad;\n\tint xflag;\n\ts64 nxoff, xoff;\n\tint nxlen, xlen, lxlen, rxlen;\n\ts64 nxaddr, xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\tint newpage = 0;\n\n\t/* there must exist extent to be tailgated */\n\tnxoff = offsetXAD(nxad);\n\tnxlen = lengthXAD(nxad);\n\tnxaddr = addressXAD(nxad);\n\n\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"Could not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire tlock of the leaf page containing original entry\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\txad = &p->xad[index0];\n\txflag = xad->flag;\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txaddr = addressXAD(xad);\n\n\t/* nXAD must be completely contained within XAD */\n\tif ((xoff > nxoff) ||\n\t    (nxoff + nxlen > xoff + xlen)) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb,\n\t\t\t  \"nXAD in not completely contained within XAD\\n\");\n\t\treturn -EIO;\n\t}\n\n\tindex = index0;\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n#ifdef  _JFS_WIP_NOCOALESCE\n\tif (xoff < nxoff)\n\t\tgoto updateRight;\n\n\t/*\n\t * replace XAD with nXAD\n\t */\n      replace:\t\t\t/* (nxoff == xoff) */\n\tif (nxlen == xlen) {\n\t\t/* replace XAD with nXAD:recorded */\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto out;\n\t} else\t\t\t/* (nxlen < xlen) */\n\t\tgoto updateLeft;\n#endif\t\t\t\t/* _JFS_WIP_NOCOALESCE */\n\n/* #ifdef _JFS_WIP_COALESCE */\n\tif (xoff < nxoff)\n\t\tgoto coalesceRight;\n\n\t/*\n\t * coalesce with left XAD\n\t */\n//coalesceLeft: /* (xoff == nxoff) */\n\t/* is XAD first entry of page ? */\n\tif (index == XTENTRYSTART)\n\t\tgoto replace;\n\n\t/* is nXAD logically and physically contiguous with lXAD ? */\n\tlxad = &p->xad[index - 1];\n\tlxlen = lengthXAD(lxad);\n\tif (!(lxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff == offsetXAD(lxad) + lxlen) &&\n\t    (nxaddr == addressXAD(lxad) + lxlen) &&\n\t    (lxlen + nxlen < MAXXLEN)) {\n\t\t/* extend right lXAD */\n\t\tindex0 = index - 1;\n\t\tXADlength(lxad, lxlen + nxlen);\n\n\t\t/* If we just merged two extents together, need to make sure the\n\t\t * right extent gets logged.  If the left one is marked XAD_NEW,\n\t\t * then we know it will be logged.  Otherwise, mark as\n\t\t * XAD_EXTENDED\n\t\t */\n\t\tif (!(lxad->flag & XAD_NEW))\n\t\t\tlxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen) {\n\t\t\t/* truncate XAD */\n\t\t\tXADoffset(xad, xoff + nxlen);\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\t\tXADaddress(xad, xaddr + nxlen);\n\t\t\tgoto out;\n\t\t} else {\t/* (xlen == nxlen) */\n\n\t\t\t/* remove XAD */\n\t\t\tif (index < nextindex - 1)\n\t\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t\t(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\n\t\t\tindex = index0;\n\t\t\tnewindex = index + 1;\n\t\t\tnextindex = le16_to_cpu(p->header.nextindex);\n\t\t\txoff = nxoff = offsetXAD(lxad);\n\t\t\txlen = nxlen = lxlen + nxlen;\n\t\t\txaddr = nxaddr = addressXAD(lxad);\n\t\t\tgoto coalesceRight;\n\t\t}\n\t}\n\n\t/*\n\t * replace XAD with nXAD\n\t */\n      replace:\t\t\t/* (nxoff == xoff) */\n\tif (nxlen == xlen) {\n\t\t/* replace XAD with nXAD:recorded */\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto coalesceRight;\n\t} else\t\t\t/* (nxlen < xlen) */\n\t\tgoto updateLeft;\n\n\t/*\n\t * coalesce with right XAD\n\t */\n      coalesceRight:\t\t/* (xoff <= nxoff) */\n\t/* is XAD last entry of page ? */\n\tif (newindex == nextindex) {\n\t\tif (xoff == nxoff)\n\t\t\tgoto out;\n\t\tgoto updateRight;\n\t}\n\n\t/* is nXAD logically and physically contiguous with rXAD ? */\n\trxad = &p->xad[index + 1];\n\trxlen = lengthXAD(rxad);\n\tif (!(rxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff + nxlen == offsetXAD(rxad)) &&\n\t    (nxaddr + nxlen == addressXAD(rxad)) &&\n\t    (rxlen + nxlen < MAXXLEN)) {\n\t\t/* extend left rXAD */\n\t\tXADoffset(rxad, nxoff);\n\t\tXADlength(rxad, rxlen + nxlen);\n\t\tXADaddress(rxad, nxaddr);\n\n\t\t/* If we just merged two extents together, need to make sure\n\t\t * the left extent gets logged.  If the right one is marked\n\t\t * XAD_NEW, then we know it will be logged.  Otherwise, mark as\n\t\t * XAD_EXTENDED\n\t\t */\n\t\tif (!(rxad->flag & XAD_NEW))\n\t\t\trxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen)\n\t\t\t/* truncate XAD */\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\telse {\t\t/* (xlen == nxlen) */\n\n\t\t\t/* remove XAD */\n\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t(nextindex - index - 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\t\t}\n\n\t\tgoto out;\n\t} else if (xoff == nxoff)\n\t\tgoto out;\n\n\tif (xoff >= nxoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xoff >= nxoff\\n\");\n\t\treturn -EIO;\n\t}\n/* #endif _JFS_WIP_COALESCE */\n\n\t/*\n\t * split XAD into (lXAD, nXAD):\n\t *\n\t *          |---nXAD--->\n\t * --|----------XAD----------|--\n\t *   |-lXAD-|\n\t */\n      updateRight:\t\t/* (xoff < nxoff) */\n\t/* truncate old XAD as lXAD:not_recorded */\n\txad = &p->xad[index];\n\tXADlength(xad, nxoff - xoff);\n\n\t/* insert nXAD:recorded */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag & ~XAD_NOTRECORDED;\n\t\tsplit.off = nxoff;\n\t\tsplit.len = nxlen;\n\t\tsplit.addr = nxaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* is nXAD on new page ? */\n\t\t\tif (newindex >\n\t\t\t    (le16_to_cpu(p->header.maxentry) >> 1)) {\n\t\t\t\tnewindex =\n\t\t\t\t    newindex -\n\t\t\t\t    le16_to_cpu(p->header.nextindex) +\n\t\t\t\t    XTENTRYSTART;\n\t\t\t\tnewpage = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if insert into middle, shift right remaining entries */\n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t/* insert the entry */\n\t\txad = &p->xad[newindex];\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\t/* advance next available entry index. */\n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n\t/*\n\t * does nXAD force 3-way split ?\n\t *\n\t *          |---nXAD--->|\n\t * --|----------XAD-------------|--\n\t *   |-lXAD-|           |-rXAD -|\n\t */\n\tif (nxoff + nxlen == xoff + xlen)\n\t\tgoto out;\n\n\t/* reorient nXAD as XAD for further split XAD into (nXAD, rXAD) */\n\tif (newpage) {\n\t\t/* close out old page */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\tbn = le64_to_cpu(p->header.next);\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* get new right page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t}\n\n\t\tindex0 = index = newindex;\n\t} else\n\t\tindex++;\n\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\txlen = xlen - (nxoff - xoff);\n\txoff = nxoff;\n\txaddr = nxaddr;\n\n\t/* recompute split pages */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tXT_PUTPAGE(mp);\n\n\t\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\t\treturn rc;\n\n\t\t/* retrieve search result */\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"xtSearch failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (index0 != index) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"unexpected value of index\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * split XAD into (nXAD, rXAD)\n\t *\n\t *          ---nXAD---|\n\t * --|----------XAD----------|--\n\t *                    |-rXAD-|\n\t */\n      updateLeft:\t\t/* (nxoff == xoff) && (nxlen < xlen) */\n\t/* update old XAD with nXAD:recorded */\n\txad = &p->xad[index];\n\t*xad = *nxad;\n\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t/* insert rXAD:not_recorded */\n\txoff = xoff + nxlen;\n\txlen = xlen - nxlen;\n\txaddr = xaddr + nxlen;\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n/*\nprintf(\"xtUpdate.updateLeft.split p:0x%p\\n\", p);\n*/\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if insert into middle, shift right remaining entries */\n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t/* insert the entry */\n\t\txad = &p->xad[newindex];\n\t\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t\t/* advance next available entry index. */\n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n      out:\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t\t    xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBeginAnon",
          "args": [
            "ip->i_sb"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "txBeginAnon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "460-489",
          "snippet": "void txBeginAnon(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\tINCREMENT(TxStat.txBeginAnon);\n\n      retry:\n\t/*\n\t * synchronize with logsync barrier\n\t */\n\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\tINCREMENT(TxStat.txBeginAnon_barrier);\n\t\tTXN_SLEEP(&log->syncwait);\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Don't begin transaction if we're getting starved for tlocks\n\t */\n\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\tINCREMENT(TxStat.txBeginAnon_lockslow);\n\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\tgoto retry;\n\t}\n\tTXN_UNLOCK();\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\n\nvoid txBeginAnon(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\tINCREMENT(TxStat.txBeginAnon);\n\n      retry:\n\t/*\n\t * synchronize with logsync barrier\n\t */\n\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\tINCREMENT(TxStat.txBeginAnon_barrier);\n\t\tTXN_SLEEP(&log->syncwait);\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Don't begin transaction if we're getting starved for tlocks\n\t */\n\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\tINCREMENT(TxStat.txBeginAnon_lockslow);\n\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\tgoto retry;\n\t}\n\tTXN_UNLOCK();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nint extRecord(struct inode *ip, xad_t * xp)\n{\n\tint rc;\n\n\ttxBeginAnon(ip->i_sb);\n\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t/* update the extent */\n\trc = xtUpdate(0, ip, xp);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "extHint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
    "lines": "364-407",
    "snippet": "int extHint(struct inode *ip, s64 offset, xad_t * xp)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint nbperpage = JFS_SBI(sb)->nbperpage;\n\ts64 prev;\n\tint rc = 0;\n\ts64 xaddr;\n\tint xlen;\n\tint xflag;\n\n\t/* init the hint as \"no hint provided\" */\n\tXADaddress(xp, 0);\n\n\t/* determine the starting extent offset of the page previous\n\t * to the page containing the offset.\n\t */\n\tprev = ((offset & ~POFFSET) >> JFS_SBI(sb)->l2bsize) - nbperpage;\n\n\t/* if the offset is in the first page of the file, no hint provided.\n\t */\n\tif (prev < 0)\n\t\tgoto out;\n\n\trc = xtLookup(ip, prev, nbperpage, &xflag, &xaddr, &xlen, 0);\n\n\tif ((rc == 0) && xlen) {\n\t\tif (xlen != nbperpage) {\n\t\t\tjfs_error(ip->i_sb, \"corrupt xtree\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\tXADaddress(xp, xaddr);\n\t\tXADlength(xp, xlen);\n\t\tXADoffset(xp, prev);\n\t\t/*\n\t\t * only preserve the abnr flag within the xad flags\n\t\t * of the returned hint.\n\t\t */\n\t\txp->flag  = xflag & XAD_NOTRECORDED;\n\t} else\n\t\trc = 0;\n\nout:\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int extBalloc(struct inode *, s64, s64 *, s64 *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XADoffset",
          "args": [
            "xp",
            "prev"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADlength",
          "args": [
            "xp",
            "xlen"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADaddress",
          "args": [
            "xp",
            "xaddr"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"corrupt xtree\\n\""
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtLookup",
          "args": [
            "ip",
            "prev",
            "nbperpage",
            "&xflag",
            "&xaddr",
            "&xlen",
            "0"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "xtLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "146-219",
          "snippet": "int xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t/* is lookup offset beyond eof ? */\n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * search for the xad entry covering the logical extent\n\t */\n//search:\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tcompute the physical extent covering logical extent\n\t *\n\t * N.B. search may have failed (e.g., hole in sparse file),\n\t * and returned the index of the next entry.\n\t */\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* is xad found covering start of logical extent ?\n\t * lstart is a page start address,\n\t * i.e., lstart cannot start in a hole;\n\t */\n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * lxd covered by xad\n\t */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t/* initialize new pxd */\n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t/* a page must be fully covered by an xad */\n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t/* is lookup offset beyond eof ? */\n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * search for the xad entry covering the logical extent\n\t */\n//search:\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tcompute the physical extent covering logical extent\n\t *\n\t * N.B. search may have failed (e.g., hole in sparse file),\n\t * and returned the index of the next entry.\n\t */\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* is xad found covering start of logical extent ?\n\t * lstart is a page start address,\n\t * i.e., lstart cannot start in a hole;\n\t */\n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * lxd covered by xad\n\t */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t/* initialize new pxd */\n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t/* a page must be fully covered by an xad */\n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XADaddress",
          "args": [
            "xp",
            "0"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\n\nint extHint(struct inode *ip, s64 offset, xad_t * xp)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint nbperpage = JFS_SBI(sb)->nbperpage;\n\ts64 prev;\n\tint rc = 0;\n\ts64 xaddr;\n\tint xlen;\n\tint xflag;\n\n\t/* init the hint as \"no hint provided\" */\n\tXADaddress(xp, 0);\n\n\t/* determine the starting extent offset of the page previous\n\t * to the page containing the offset.\n\t */\n\tprev = ((offset & ~POFFSET) >> JFS_SBI(sb)->l2bsize) - nbperpage;\n\n\t/* if the offset is in the first page of the file, no hint provided.\n\t */\n\tif (prev < 0)\n\t\tgoto out;\n\n\trc = xtLookup(ip, prev, nbperpage, &xflag, &xaddr, &xlen, 0);\n\n\tif ((rc == 0) && xlen) {\n\t\tif (xlen != nbperpage) {\n\t\t\tjfs_error(ip->i_sb, \"corrupt xtree\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\tXADaddress(xp, xaddr);\n\t\tXADlength(xp, xlen);\n\t\tXADoffset(xp, prev);\n\t\t/*\n\t\t * only preserve the abnr flag within the xad flags\n\t\t * of the returned hint.\n\t\t */\n\t\txp->flag  = xflag & XAD_NOTRECORDED;\n\t} else\n\t\trc = 0;\n\nout:\n\treturn (rc);\n}"
  },
  {
    "function_name": "extRealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
    "lines": "215-345",
    "snippet": "int extRealloc(struct inode *ip, s64 nxlen, xad_t * xp, bool abnr)\n{\n\tstruct super_block *sb = ip->i_sb;\n\ts64 xaddr, xlen, nxaddr, delta, xoff;\n\ts64 ntail, nextend, ninsert;\n\tint rc, nbperpage = JFS_SBI(sb)->nbperpage;\n\tint xflag;\n\n\t/* This blocks if we are low on resources */\n\ttxBeginAnon(ip->i_sb);\n\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\t/* validate extent length */\n\tif (nxlen > MAXXLEN)\n\t\tnxlen = MAXXLEN;\n\n\t/* get the extend (partial) page's disk block address and\n\t * number of blocks.\n\t */\n\txaddr = addressXAD(xp);\n\txlen = lengthXAD(xp);\n\txoff = offsetXAD(xp);\n\n\t/* if the extend page is abnr and if the request is for\n\t * the extent to be allocated and recorded,\n\t * make the page allocated and recorded.\n\t */\n\tif ((xp->flag & XAD_NOTRECORDED) && !abnr) {\n\t\txp->flag = 0;\n\t\tif ((rc = xtUpdate(0, ip, xp)))\n\t\t\tgoto exit;\n\t}\n\n\t/* try to allocated the request number of blocks for the\n\t * extent.  dbRealloc() first tries to satisfy the request\n\t * by extending the allocation in place. otherwise, it will\n\t * try to allocate a new set of blocks large enough for the\n\t * request.  in satisfying a request, dbReAlloc() may allocate\n\t * less than what was request but will always allocate enough\n\t * space as to satisfy the extend page.\n\t */\n\tif ((rc = extBrealloc(ip, xaddr, xlen, &nxlen, &nxaddr)))\n\t\tgoto exit;\n\n\t/* Allocat blocks to quota. */\n\trc = dquot_alloc_block(ip, nxlen);\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, (s64) nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn rc;\n\t}\n\n\tdelta = nxlen - xlen;\n\n\t/* check if the extend page is not abnr but the request is abnr\n\t * and the allocated disk space is for more than one page.  if this\n\t * is the case, there is a miss match of abnr between the extend page\n\t * and the one or more pages following the extend page.  as a result,\n\t * two extents will have to be manipulated. the first will be that\n\t * of the extent of the extend page and will be manipulated thru\n\t * an xtExtend() or an xtTailgate(), depending upon whether the\n\t * disk allocation occurred as an inplace extension.  the second\n\t * extent will be manipulated (created) through an xtInsert() and\n\t * will be for the pages following the extend page.\n\t */\n\tif (abnr && (!(xp->flag & XAD_NOTRECORDED)) && (nxlen > nbperpage)) {\n\t\tntail = nbperpage;\n\t\tnextend = ntail - xlen;\n\t\tninsert = nxlen - nbperpage;\n\n\t\txflag = XAD_NOTRECORDED;\n\t} else {\n\t\tntail = nxlen;\n\t\tnextend = delta;\n\t\tninsert = 0;\n\n\t\txflag = xp->flag;\n\t}\n\n\t/* if we were able to extend the disk allocation in place,\n\t * extend the extent.  otherwise, move the extent to a\n\t * new disk location.\n\t */\n\tif (xaddr == nxaddr) {\n\t\t/* extend the extent */\n\t\tif ((rc = xtExtend(0, ip, xoff + xlen, (int) nextend, 0))) {\n\t\t\tdbFree(ip, xaddr + xlen, delta);\n\t\t\tdquot_free_block(ip, nxlen);\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * move the extent to a new location:\n\t\t *\n\t\t * xtTailgate() accounts for relocated tail extent;\n\t\t */\n\t\tif ((rc = xtTailgate(0, ip, xoff, (int) ntail, nxaddr, 0))) {\n\t\t\tdbFree(ip, nxaddr, nxlen);\n\t\t\tdquot_free_block(ip, nxlen);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\n\t/* check if we need to also insert a new extent */\n\tif (ninsert) {\n\t\t/* perform the insert.  if it fails, free the blocks\n\t\t * to be inserted and make it appear that we only did\n\t\t * the xtExtend() or xtTailgate() above.\n\t\t */\n\t\txaddr = nxaddr + ntail;\n\t\tif (xtInsert (0, ip, xflag, xoff + ntail, (int) ninsert,\n\t\t\t      &xaddr, 0)) {\n\t\t\tdbFree(ip, xaddr, (s64) ninsert);\n\t\t\tdelta = nextend;\n\t\t\tnxlen = ntail;\n\t\t\txflag = 0;\n\t\t}\n\t}\n\n\t/* set the return results */\n\tXADaddress(xp, nxaddr);\n\tXADlength(xp, nxlen);\n\tXADoffset(xp, xoff);\n\txp->flag = xflag;\n\n\tmark_inode_dirty(ip);\nexit:\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\treturn (rc);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int extBalloc(struct inode *, s64, s64 *, s64 *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "ip"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XADoffset",
          "args": [
            "xp",
            "xoff"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADlength",
          "args": [
            "xp",
            "nxlen"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADaddress",
          "args": [
            "xp",
            "nxaddr"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "ip",
            "xaddr",
            "(s64) ninsert"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtInsert",
          "args": [
            "0",
            "ip",
            "xflag",
            "xoff + ntail",
            "(int) ninsert",
            "&xaddr",
            "0"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "xtInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "537-670",
          "snippet": "int xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "nxlen"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtTailgate",
          "args": [
            "0",
            "ip",
            "xoff",
            "(int) ntail",
            "nxaddr",
            "0"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "xtTailgate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "1522-1689",
          "snippet": "int xtTailgate(tid_t tid,\t\t/* transaction id */\n\t       struct inode *ip, s64 xoff,\t/* split/new extent offset */\n\t       s32 xlen,\t/* new extent length */\n\t       s64 xaddr,\t/* new extent address */\n\t       int flag)\n{\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex, llen, rlen;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = 0;\n\tstruct tlock *mtlck;\n\tstruct maplock *pxdlock;\n\n/*\nprintf(\"xtTailgate: nxoff:0x%lx nxlen:0x%x nxaddr:0x%lx\\n\",\n\t(ulong)xoff, xlen, (ulong)xaddr);\n*/\n\n\t/* there must exist extent to be tailgated */\n\tif ((rc = xtSearch(ip, xoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"couldn't find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* entry found must be last entry */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (index != nextindex - 1) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"the entry found is not the last entry\\n\");\n\t\treturn -EIO;\n\t}\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire tlock of the leaf page containing original entry\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/* completely replace extent ? */\n\txad = &p->xad[index];\n/*\nprintf(\"xtTailgate: xoff:0x%lx xlen:0x%x xaddr:0x%lx\\n\",\n\t(ulong)offsetXAD(xad), lengthXAD(xad), (ulong)addressXAD(xad));\n*/\n\tif ((llen = xoff - offsetXAD(xad)) == 0)\n\t\tgoto updateOld;\n\n\t/*\n\t *\tpartially replace extent: insert entry for new extent\n\t */\n//insertNew:\n\t/*\n\t *\tif the leaf page is full, insert the new entry and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = index + 1;\n\t\tsplit.flag = XAD_NEW;\n\t\tsplit.off = xoff;\t/* split offset */\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\telse {\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &p->xad[index + 1];\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, xlen, xaddr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&p->header.nextindex, 1);\n\t}\n\n\t/* get back old XAD */\n\txad = &p->xad[index];\n\n\t/*\n\t * truncate/relocate old extent at split offset\n\t */\n      updateOld:\n\t/* update dmap for old/committed/truncated extent */\n\trlen = lengthXAD(xad) - llen;\n\tif (!(xad->flag & XAD_NEW)) {\n\t\t/* free from PWMAP at commit */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tmtlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tpxdlock = (struct maplock *) & mtlck->lock;\n\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressXAD(xad) + llen);\n\t\t\tPXDlength(&pxdlock->pxd, rlen);\n\t\t\tpxdlock->index = 1;\n\t\t}\n\t} else\n\t\t/* free from WMAP */\n\t\tdbFree(ip, addressXAD(xad) + llen, (s64) rlen);\n\n\tif (llen)\n\t\t/* truncate */\n\t\tXADlength(xad, llen);\n\telse\n\t\t/* replace */\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, xlen, xaddr);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t\t    xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtTailgate(tid_t tid,\t\t/* transaction id */\n\t       struct inode *ip, s64 xoff,\t/* split/new extent offset */\n\t       s32 xlen,\t/* new extent length */\n\t       s64 xaddr,\t/* new extent address */\n\t       int flag)\n{\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex, llen, rlen;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = 0;\n\tstruct tlock *mtlck;\n\tstruct maplock *pxdlock;\n\n/*\nprintf(\"xtTailgate: nxoff:0x%lx nxlen:0x%x nxaddr:0x%lx\\n\",\n\t(ulong)xoff, xlen, (ulong)xaddr);\n*/\n\n\t/* there must exist extent to be tailgated */\n\tif ((rc = xtSearch(ip, xoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"couldn't find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* entry found must be last entry */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (index != nextindex - 1) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"the entry found is not the last entry\\n\");\n\t\treturn -EIO;\n\t}\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire tlock of the leaf page containing original entry\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/* completely replace extent ? */\n\txad = &p->xad[index];\n/*\nprintf(\"xtTailgate: xoff:0x%lx xlen:0x%x xaddr:0x%lx\\n\",\n\t(ulong)offsetXAD(xad), lengthXAD(xad), (ulong)addressXAD(xad));\n*/\n\tif ((llen = xoff - offsetXAD(xad)) == 0)\n\t\tgoto updateOld;\n\n\t/*\n\t *\tpartially replace extent: insert entry for new extent\n\t */\n//insertNew:\n\t/*\n\t *\tif the leaf page is full, insert the new entry and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = index + 1;\n\t\tsplit.flag = XAD_NEW;\n\t\tsplit.off = xoff;\t/* split offset */\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\telse {\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &p->xad[index + 1];\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, xlen, xaddr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&p->header.nextindex, 1);\n\t}\n\n\t/* get back old XAD */\n\txad = &p->xad[index];\n\n\t/*\n\t * truncate/relocate old extent at split offset\n\t */\n      updateOld:\n\t/* update dmap for old/committed/truncated extent */\n\trlen = lengthXAD(xad) - llen;\n\tif (!(xad->flag & XAD_NEW)) {\n\t\t/* free from PWMAP at commit */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\tmtlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tpxdlock = (struct maplock *) & mtlck->lock;\n\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressXAD(xad) + llen);\n\t\t\tPXDlength(&pxdlock->pxd, rlen);\n\t\t\tpxdlock->index = 1;\n\t\t}\n\t} else\n\t\t/* free from WMAP */\n\t\tdbFree(ip, addressXAD(xad) + llen, (s64) rlen);\n\n\tif (llen)\n\t\t/* truncate */\n\t\tXADlength(xad, llen);\n\telse\n\t\t/* replace */\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, xlen, xaddr);\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t\t    xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "nxlen"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtExtend",
          "args": [
            "0",
            "ip",
            "xoff + xlen",
            "(int) nextend",
            "0"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "xtExtend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "1360-1507",
          "snippet": "int xtExtend(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, s64 xoff,\t/* delta extent offset */\n\t     s32 xlen,\t\t/* delta extent length */\n\t     int flag)\n{\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex, len;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\ts64 xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\n\tjfs_info(\"xtExtend: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/* there must exist extent to be extended */\n\tif ((rc = xtSearch(ip, xoff - 1, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xtSearch did not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* extension must be contiguous */\n\txad = &p->xad[index];\n\tif ((offsetXAD(xad) + lengthXAD(xad)) != xoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"extension is not contiguous\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/* extend will overflow extent ? */\n\txlen = lengthXAD(xad) + xlen;\n\tif ((len = xlen - MAXXLEN) <= 0)\n\t\tgoto extendOld;\n\n\t/*\n\t *\textent overflow: insert entry for new extent\n\t */\n//insertNew:\n\txoff = offsetXAD(xad) + MAXXLEN;\n\txaddr = addressXAD(xad) + MAXXLEN;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n\t/*\n\t *\tif the leaf page is full, insert the new entry and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = index + 1;\n\t\tsplit.flag = XAD_NEW;\n\t\tsplit.off = xoff;\t/* split offset */\n\t\tsplit.len = len;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\telse {\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &p->xad[index + 1];\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, len, xaddr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&p->header.nextindex, 1);\n\t}\n\n\t/* get back old entry */\n\txad = &p->xad[index];\n\txlen = MAXXLEN;\n\n\t/*\n\t * extend old extent\n\t */\n      extendOld:\n\tXADlength(xad, xlen);\n\tif (!(xad->flag & XAD_NEW))\n\t\txad->flag |= XAD_EXTENDED;\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtExtend(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, s64 xoff,\t/* delta extent offset */\n\t     s32 xlen,\t\t/* delta extent length */\n\t     int flag)\n{\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex, len;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\ts64 xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\n\tjfs_info(\"xtExtend: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/* there must exist extent to be extended */\n\tif ((rc = xtSearch(ip, xoff - 1, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xtSearch did not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* extension must be contiguous */\n\txad = &p->xad[index];\n\tif ((offsetXAD(xad) + lengthXAD(xad)) != xoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"extension is not contiguous\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/* extend will overflow extent ? */\n\txlen = lengthXAD(xad) + xlen;\n\tif ((len = xlen - MAXXLEN) <= 0)\n\t\tgoto extendOld;\n\n\t/*\n\t *\textent overflow: insert entry for new extent\n\t */\n//insertNew:\n\txoff = offsetXAD(xad) + MAXXLEN;\n\txaddr = addressXAD(xad) + MAXXLEN;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n\t/*\n\t *\tif the leaf page is full, insert the new entry and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = index + 1;\n\t\tsplit.flag = XAD_NEW;\n\t\tsplit.off = xoff;\t/* split offset */\n\t\tsplit.len = len;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\telse {\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &p->xad[index + 1];\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, len, xaddr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&p->header.nextindex, 1);\n\t}\n\n\t/* get back old entry */\n\txad = &p->xad[index];\n\txlen = MAXXLEN;\n\n\t/*\n\t * extend old extent\n\t */\n      extendOld:\n\tXADlength(xad, xlen);\n\tif (!(xad->flag & XAD_NEW))\n\t\txad->flag |= XAD_EXTENDED;\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "ip",
            "nxlen"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extBrealloc",
          "args": [
            "ip",
            "xaddr",
            "xlen",
            "&nxlen",
            "&nxaddr"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "extBrealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
          "lines": "601-620",
          "snippet": "static int\nextBrealloc(struct inode *ip,\n\t    s64 blkno, s64 nblks, s64 * newnblks, s64 * newblkno)\n{\n\tint rc;\n\n\t/* try to extend in place */\n\tif ((rc = dbExtend(ip, blkno, nblks, *newnblks - nblks)) == 0) {\n\t\t*newblkno = blkno;\n\t\treturn (0);\n\t} else {\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* in place extension not possible.\n\t * try to move the extent to a new set of blocks.\n\t */\n\treturn (extBalloc(ip, blkno, newnblks, newblkno));\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int extBalloc(struct inode *, s64, s64 *, s64 *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\n\nstatic int\nextBrealloc(struct inode *ip,\n\t    s64 blkno, s64 nblks, s64 * newnblks, s64 * newblkno)\n{\n\tint rc;\n\n\t/* try to extend in place */\n\tif ((rc = dbExtend(ip, blkno, nblks, *newnblks - nblks)) == 0) {\n\t\t*newblkno = blkno;\n\t\treturn (0);\n\t} else {\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* in place extension not possible.\n\t * try to move the extent to a new set of blocks.\n\t */\n\treturn (extBalloc(ip, blkno, newnblks, newblkno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtUpdate",
          "args": [
            "0",
            "ip",
            "xp"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "xtUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "1705-2149",
          "snippet": "int xtUpdate(tid_t tid, struct inode *ip, xad_t * nxad)\n{\t\t\t\t/* new XAD */\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index0, index, newindex, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad, *lxad, *rxad;\n\tint xflag;\n\ts64 nxoff, xoff;\n\tint nxlen, xlen, lxlen, rxlen;\n\ts64 nxaddr, xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\tint newpage = 0;\n\n\t/* there must exist extent to be tailgated */\n\tnxoff = offsetXAD(nxad);\n\tnxlen = lengthXAD(nxad);\n\tnxaddr = addressXAD(nxad);\n\n\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"Could not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire tlock of the leaf page containing original entry\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\txad = &p->xad[index0];\n\txflag = xad->flag;\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txaddr = addressXAD(xad);\n\n\t/* nXAD must be completely contained within XAD */\n\tif ((xoff > nxoff) ||\n\t    (nxoff + nxlen > xoff + xlen)) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb,\n\t\t\t  \"nXAD in not completely contained within XAD\\n\");\n\t\treturn -EIO;\n\t}\n\n\tindex = index0;\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n#ifdef  _JFS_WIP_NOCOALESCE\n\tif (xoff < nxoff)\n\t\tgoto updateRight;\n\n\t/*\n\t * replace XAD with nXAD\n\t */\n      replace:\t\t\t/* (nxoff == xoff) */\n\tif (nxlen == xlen) {\n\t\t/* replace XAD with nXAD:recorded */\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto out;\n\t} else\t\t\t/* (nxlen < xlen) */\n\t\tgoto updateLeft;\n#endif\t\t\t\t/* _JFS_WIP_NOCOALESCE */\n\n/* #ifdef _JFS_WIP_COALESCE */\n\tif (xoff < nxoff)\n\t\tgoto coalesceRight;\n\n\t/*\n\t * coalesce with left XAD\n\t */\n//coalesceLeft: /* (xoff == nxoff) */\n\t/* is XAD first entry of page ? */\n\tif (index == XTENTRYSTART)\n\t\tgoto replace;\n\n\t/* is nXAD logically and physically contiguous with lXAD ? */\n\tlxad = &p->xad[index - 1];\n\tlxlen = lengthXAD(lxad);\n\tif (!(lxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff == offsetXAD(lxad) + lxlen) &&\n\t    (nxaddr == addressXAD(lxad) + lxlen) &&\n\t    (lxlen + nxlen < MAXXLEN)) {\n\t\t/* extend right lXAD */\n\t\tindex0 = index - 1;\n\t\tXADlength(lxad, lxlen + nxlen);\n\n\t\t/* If we just merged two extents together, need to make sure the\n\t\t * right extent gets logged.  If the left one is marked XAD_NEW,\n\t\t * then we know it will be logged.  Otherwise, mark as\n\t\t * XAD_EXTENDED\n\t\t */\n\t\tif (!(lxad->flag & XAD_NEW))\n\t\t\tlxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen) {\n\t\t\t/* truncate XAD */\n\t\t\tXADoffset(xad, xoff + nxlen);\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\t\tXADaddress(xad, xaddr + nxlen);\n\t\t\tgoto out;\n\t\t} else {\t/* (xlen == nxlen) */\n\n\t\t\t/* remove XAD */\n\t\t\tif (index < nextindex - 1)\n\t\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t\t(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\n\t\t\tindex = index0;\n\t\t\tnewindex = index + 1;\n\t\t\tnextindex = le16_to_cpu(p->header.nextindex);\n\t\t\txoff = nxoff = offsetXAD(lxad);\n\t\t\txlen = nxlen = lxlen + nxlen;\n\t\t\txaddr = nxaddr = addressXAD(lxad);\n\t\t\tgoto coalesceRight;\n\t\t}\n\t}\n\n\t/*\n\t * replace XAD with nXAD\n\t */\n      replace:\t\t\t/* (nxoff == xoff) */\n\tif (nxlen == xlen) {\n\t\t/* replace XAD with nXAD:recorded */\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto coalesceRight;\n\t} else\t\t\t/* (nxlen < xlen) */\n\t\tgoto updateLeft;\n\n\t/*\n\t * coalesce with right XAD\n\t */\n      coalesceRight:\t\t/* (xoff <= nxoff) */\n\t/* is XAD last entry of page ? */\n\tif (newindex == nextindex) {\n\t\tif (xoff == nxoff)\n\t\t\tgoto out;\n\t\tgoto updateRight;\n\t}\n\n\t/* is nXAD logically and physically contiguous with rXAD ? */\n\trxad = &p->xad[index + 1];\n\trxlen = lengthXAD(rxad);\n\tif (!(rxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff + nxlen == offsetXAD(rxad)) &&\n\t    (nxaddr + nxlen == addressXAD(rxad)) &&\n\t    (rxlen + nxlen < MAXXLEN)) {\n\t\t/* extend left rXAD */\n\t\tXADoffset(rxad, nxoff);\n\t\tXADlength(rxad, rxlen + nxlen);\n\t\tXADaddress(rxad, nxaddr);\n\n\t\t/* If we just merged two extents together, need to make sure\n\t\t * the left extent gets logged.  If the right one is marked\n\t\t * XAD_NEW, then we know it will be logged.  Otherwise, mark as\n\t\t * XAD_EXTENDED\n\t\t */\n\t\tif (!(rxad->flag & XAD_NEW))\n\t\t\trxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen)\n\t\t\t/* truncate XAD */\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\telse {\t\t/* (xlen == nxlen) */\n\n\t\t\t/* remove XAD */\n\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t(nextindex - index - 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\t\t}\n\n\t\tgoto out;\n\t} else if (xoff == nxoff)\n\t\tgoto out;\n\n\tif (xoff >= nxoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xoff >= nxoff\\n\");\n\t\treturn -EIO;\n\t}\n/* #endif _JFS_WIP_COALESCE */\n\n\t/*\n\t * split XAD into (lXAD, nXAD):\n\t *\n\t *          |---nXAD--->\n\t * --|----------XAD----------|--\n\t *   |-lXAD-|\n\t */\n      updateRight:\t\t/* (xoff < nxoff) */\n\t/* truncate old XAD as lXAD:not_recorded */\n\txad = &p->xad[index];\n\tXADlength(xad, nxoff - xoff);\n\n\t/* insert nXAD:recorded */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag & ~XAD_NOTRECORDED;\n\t\tsplit.off = nxoff;\n\t\tsplit.len = nxlen;\n\t\tsplit.addr = nxaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* is nXAD on new page ? */\n\t\t\tif (newindex >\n\t\t\t    (le16_to_cpu(p->header.maxentry) >> 1)) {\n\t\t\t\tnewindex =\n\t\t\t\t    newindex -\n\t\t\t\t    le16_to_cpu(p->header.nextindex) +\n\t\t\t\t    XTENTRYSTART;\n\t\t\t\tnewpage = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if insert into middle, shift right remaining entries */\n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t/* insert the entry */\n\t\txad = &p->xad[newindex];\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\t/* advance next available entry index. */\n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n\t/*\n\t * does nXAD force 3-way split ?\n\t *\n\t *          |---nXAD--->|\n\t * --|----------XAD-------------|--\n\t *   |-lXAD-|           |-rXAD -|\n\t */\n\tif (nxoff + nxlen == xoff + xlen)\n\t\tgoto out;\n\n\t/* reorient nXAD as XAD for further split XAD into (nXAD, rXAD) */\n\tif (newpage) {\n\t\t/* close out old page */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\tbn = le64_to_cpu(p->header.next);\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* get new right page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t}\n\n\t\tindex0 = index = newindex;\n\t} else\n\t\tindex++;\n\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\txlen = xlen - (nxoff - xoff);\n\txoff = nxoff;\n\txaddr = nxaddr;\n\n\t/* recompute split pages */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tXT_PUTPAGE(mp);\n\n\t\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\t\treturn rc;\n\n\t\t/* retrieve search result */\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"xtSearch failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (index0 != index) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"unexpected value of index\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * split XAD into (nXAD, rXAD)\n\t *\n\t *          ---nXAD---|\n\t * --|----------XAD----------|--\n\t *                    |-rXAD-|\n\t */\n      updateLeft:\t\t/* (nxoff == xoff) && (nxlen < xlen) */\n\t/* update old XAD with nXAD:recorded */\n\txad = &p->xad[index];\n\t*xad = *nxad;\n\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t/* insert rXAD:not_recorded */\n\txoff = xoff + nxlen;\n\txlen = xlen - nxlen;\n\txaddr = xaddr + nxlen;\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n/*\nprintf(\"xtUpdate.updateLeft.split p:0x%p\\n\", p);\n*/\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if insert into middle, shift right remaining entries */\n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t/* insert the entry */\n\t\txad = &p->xad[newindex];\n\t\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t\t/* advance next available entry index. */\n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n      out:\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t\t    xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtUpdate(tid_t tid, struct inode *ip, xad_t * nxad)\n{\t\t\t\t/* new XAD */\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index0, index, newindex, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad, *lxad, *rxad;\n\tint xflag;\n\ts64 nxoff, xoff;\n\tint nxlen, xlen, lxlen, rxlen;\n\ts64 nxaddr, xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\tint newpage = 0;\n\n\t/* there must exist extent to be tailgated */\n\tnxoff = offsetXAD(nxad);\n\tnxlen = lengthXAD(nxad);\n\tnxaddr = addressXAD(nxad);\n\n\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"Could not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire tlock of the leaf page containing original entry\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\txad = &p->xad[index0];\n\txflag = xad->flag;\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txaddr = addressXAD(xad);\n\n\t/* nXAD must be completely contained within XAD */\n\tif ((xoff > nxoff) ||\n\t    (nxoff + nxlen > xoff + xlen)) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb,\n\t\t\t  \"nXAD in not completely contained within XAD\\n\");\n\t\treturn -EIO;\n\t}\n\n\tindex = index0;\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n#ifdef  _JFS_WIP_NOCOALESCE\n\tif (xoff < nxoff)\n\t\tgoto updateRight;\n\n\t/*\n\t * replace XAD with nXAD\n\t */\n      replace:\t\t\t/* (nxoff == xoff) */\n\tif (nxlen == xlen) {\n\t\t/* replace XAD with nXAD:recorded */\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto out;\n\t} else\t\t\t/* (nxlen < xlen) */\n\t\tgoto updateLeft;\n#endif\t\t\t\t/* _JFS_WIP_NOCOALESCE */\n\n/* #ifdef _JFS_WIP_COALESCE */\n\tif (xoff < nxoff)\n\t\tgoto coalesceRight;\n\n\t/*\n\t * coalesce with left XAD\n\t */\n//coalesceLeft: /* (xoff == nxoff) */\n\t/* is XAD first entry of page ? */\n\tif (index == XTENTRYSTART)\n\t\tgoto replace;\n\n\t/* is nXAD logically and physically contiguous with lXAD ? */\n\tlxad = &p->xad[index - 1];\n\tlxlen = lengthXAD(lxad);\n\tif (!(lxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff == offsetXAD(lxad) + lxlen) &&\n\t    (nxaddr == addressXAD(lxad) + lxlen) &&\n\t    (lxlen + nxlen < MAXXLEN)) {\n\t\t/* extend right lXAD */\n\t\tindex0 = index - 1;\n\t\tXADlength(lxad, lxlen + nxlen);\n\n\t\t/* If we just merged two extents together, need to make sure the\n\t\t * right extent gets logged.  If the left one is marked XAD_NEW,\n\t\t * then we know it will be logged.  Otherwise, mark as\n\t\t * XAD_EXTENDED\n\t\t */\n\t\tif (!(lxad->flag & XAD_NEW))\n\t\t\tlxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen) {\n\t\t\t/* truncate XAD */\n\t\t\tXADoffset(xad, xoff + nxlen);\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\t\tXADaddress(xad, xaddr + nxlen);\n\t\t\tgoto out;\n\t\t} else {\t/* (xlen == nxlen) */\n\n\t\t\t/* remove XAD */\n\t\t\tif (index < nextindex - 1)\n\t\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t\t(nextindex - index -\n\t\t\t\t\t 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\n\t\t\tindex = index0;\n\t\t\tnewindex = index + 1;\n\t\t\tnextindex = le16_to_cpu(p->header.nextindex);\n\t\t\txoff = nxoff = offsetXAD(lxad);\n\t\t\txlen = nxlen = lxlen + nxlen;\n\t\t\txaddr = nxaddr = addressXAD(lxad);\n\t\t\tgoto coalesceRight;\n\t\t}\n\t}\n\n\t/*\n\t * replace XAD with nXAD\n\t */\n      replace:\t\t\t/* (nxoff == xoff) */\n\tif (nxlen == xlen) {\n\t\t/* replace XAD with nXAD:recorded */\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\tgoto coalesceRight;\n\t} else\t\t\t/* (nxlen < xlen) */\n\t\tgoto updateLeft;\n\n\t/*\n\t * coalesce with right XAD\n\t */\n      coalesceRight:\t\t/* (xoff <= nxoff) */\n\t/* is XAD last entry of page ? */\n\tif (newindex == nextindex) {\n\t\tif (xoff == nxoff)\n\t\t\tgoto out;\n\t\tgoto updateRight;\n\t}\n\n\t/* is nXAD logically and physically contiguous with rXAD ? */\n\trxad = &p->xad[index + 1];\n\trxlen = lengthXAD(rxad);\n\tif (!(rxad->flag & XAD_NOTRECORDED) &&\n\t    (nxoff + nxlen == offsetXAD(rxad)) &&\n\t    (nxaddr + nxlen == addressXAD(rxad)) &&\n\t    (rxlen + nxlen < MAXXLEN)) {\n\t\t/* extend left rXAD */\n\t\tXADoffset(rxad, nxoff);\n\t\tXADlength(rxad, rxlen + nxlen);\n\t\tXADaddress(rxad, nxaddr);\n\n\t\t/* If we just merged two extents together, need to make sure\n\t\t * the left extent gets logged.  If the right one is marked\n\t\t * XAD_NEW, then we know it will be logged.  Otherwise, mark as\n\t\t * XAD_EXTENDED\n\t\t */\n\t\tif (!(rxad->flag & XAD_NEW))\n\t\t\trxad->flag |= XAD_EXTENDED;\n\n\t\tif (xlen > nxlen)\n\t\t\t/* truncate XAD */\n\t\t\tXADlength(xad, xlen - nxlen);\n\t\telse {\t\t/* (xlen == nxlen) */\n\n\t\t\t/* remove XAD */\n\t\t\tmemmove(&p->xad[index], &p->xad[index + 1],\n\t\t\t\t(nextindex - index - 1) << L2XTSLOTSIZE);\n\n\t\t\tp->header.nextindex =\n\t\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) -\n\t\t\t\t\t1);\n\t\t}\n\n\t\tgoto out;\n\t} else if (xoff == nxoff)\n\t\tgoto out;\n\n\tif (xoff >= nxoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xoff >= nxoff\\n\");\n\t\treturn -EIO;\n\t}\n/* #endif _JFS_WIP_COALESCE */\n\n\t/*\n\t * split XAD into (lXAD, nXAD):\n\t *\n\t *          |---nXAD--->\n\t * --|----------XAD----------|--\n\t *   |-lXAD-|\n\t */\n      updateRight:\t\t/* (xoff < nxoff) */\n\t/* truncate old XAD as lXAD:not_recorded */\n\txad = &p->xad[index];\n\tXADlength(xad, nxoff - xoff);\n\n\t/* insert nXAD:recorded */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag & ~XAD_NOTRECORDED;\n\t\tsplit.off = nxoff;\n\t\tsplit.len = nxlen;\n\t\tsplit.addr = nxaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* is nXAD on new page ? */\n\t\t\tif (newindex >\n\t\t\t    (le16_to_cpu(p->header.maxentry) >> 1)) {\n\t\t\t\tnewindex =\n\t\t\t\t    newindex -\n\t\t\t\t    le16_to_cpu(p->header.nextindex) +\n\t\t\t\t    XTENTRYSTART;\n\t\t\t\tnewpage = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if insert into middle, shift right remaining entries */\n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t/* insert the entry */\n\t\txad = &p->xad[newindex];\n\t\t*xad = *nxad;\n\t\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t\t/* advance next available entry index. */\n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n\t/*\n\t * does nXAD force 3-way split ?\n\t *\n\t *          |---nXAD--->|\n\t * --|----------XAD-------------|--\n\t *   |-lXAD-|           |-rXAD -|\n\t */\n\tif (nxoff + nxlen == xoff + xlen)\n\t\tgoto out;\n\n\t/* reorient nXAD as XAD for further split XAD into (nXAD, rXAD) */\n\tif (newpage) {\n\t\t/* close out old page */\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\t\txtlck->lwm.length =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    xtlck->lwm.offset;\n\t\t}\n\n\t\tbn = le64_to_cpu(p->header.next);\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* get new right page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t}\n\n\t\tindex0 = index = newindex;\n\t} else\n\t\tindex++;\n\n\tnewindex = index + 1;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\txlen = xlen - (nxoff - xoff);\n\txoff = nxoff;\n\txaddr = nxaddr;\n\n\t/* recompute split pages */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tXT_PUTPAGE(mp);\n\n\t\tif ((rc = xtSearch(ip, nxoff, NULL, &cmp, &btstack, XT_INSERT)))\n\t\t\treturn rc;\n\n\t\t/* retrieve search result */\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"xtSearch failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (index0 != index) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"unexpected value of index\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * split XAD into (nXAD, rXAD)\n\t *\n\t *          ---nXAD---|\n\t * --|----------XAD----------|--\n\t *                    |-rXAD-|\n\t */\n      updateLeft:\t\t/* (nxoff == xoff) && (nxlen < xlen) */\n\t/* update old XAD with nXAD:recorded */\n\txad = &p->xad[index];\n\t*xad = *nxad;\n\txad->flag = xflag & ~XAD_NOTRECORDED;\n\n\t/* insert rXAD:not_recorded */\n\txoff = xoff + nxlen;\n\txlen = xlen - nxlen;\n\txaddr = xaddr + nxlen;\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n/*\nprintf(\"xtUpdate.updateLeft.split p:0x%p\\n\", p);\n*/\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = newindex;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* if insert into middle, shift right remaining entries */\n\t\tif (newindex < nextindex)\n\t\t\tmemmove(&p->xad[newindex + 1], &p->xad[newindex],\n\t\t\t\t(nextindex - newindex) << L2XTSLOTSIZE);\n\n\t\t/* insert the entry */\n\t\txad = &p->xad[newindex];\n\t\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t\t/* advance next available entry index. */\n\t\tp->header.nextindex =\n\t\t    cpu_to_le16(le16_to_cpu(p->header.nextindex) + 1);\n\t}\n\n      out:\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t    min(index0, (int)xtlck->lwm.offset) : index0;\n\t\txtlck->lwm.length = le16_to_cpu(p->header.nextindex) -\n\t\t    xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xp"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xp"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xp"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBeginAnon",
          "args": [
            "ip->i_sb"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "txBeginAnon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "460-489",
          "snippet": "void txBeginAnon(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\tINCREMENT(TxStat.txBeginAnon);\n\n      retry:\n\t/*\n\t * synchronize with logsync barrier\n\t */\n\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\tINCREMENT(TxStat.txBeginAnon_barrier);\n\t\tTXN_SLEEP(&log->syncwait);\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Don't begin transaction if we're getting starved for tlocks\n\t */\n\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\tINCREMENT(TxStat.txBeginAnon_lockslow);\n\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\tgoto retry;\n\t}\n\tTXN_UNLOCK();\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\n\nvoid txBeginAnon(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\tINCREMENT(TxStat.txBeginAnon);\n\n      retry:\n\t/*\n\t * synchronize with logsync barrier\n\t */\n\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\tINCREMENT(TxStat.txBeginAnon_barrier);\n\t\tTXN_SLEEP(&log->syncwait);\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Don't begin transaction if we're getting starved for tlocks\n\t */\n\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\tINCREMENT(TxStat.txBeginAnon_lockslow);\n\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\tgoto retry;\n\t}\n\tTXN_UNLOCK();\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\n\nint extRealloc(struct inode *ip, s64 nxlen, xad_t * xp, bool abnr)\n{\n\tstruct super_block *sb = ip->i_sb;\n\ts64 xaddr, xlen, nxaddr, delta, xoff;\n\ts64 ntail, nextend, ninsert;\n\tint rc, nbperpage = JFS_SBI(sb)->nbperpage;\n\tint xflag;\n\n\t/* This blocks if we are low on resources */\n\ttxBeginAnon(ip->i_sb);\n\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\t/* validate extent length */\n\tif (nxlen > MAXXLEN)\n\t\tnxlen = MAXXLEN;\n\n\t/* get the extend (partial) page's disk block address and\n\t * number of blocks.\n\t */\n\txaddr = addressXAD(xp);\n\txlen = lengthXAD(xp);\n\txoff = offsetXAD(xp);\n\n\t/* if the extend page is abnr and if the request is for\n\t * the extent to be allocated and recorded,\n\t * make the page allocated and recorded.\n\t */\n\tif ((xp->flag & XAD_NOTRECORDED) && !abnr) {\n\t\txp->flag = 0;\n\t\tif ((rc = xtUpdate(0, ip, xp)))\n\t\t\tgoto exit;\n\t}\n\n\t/* try to allocated the request number of blocks for the\n\t * extent.  dbRealloc() first tries to satisfy the request\n\t * by extending the allocation in place. otherwise, it will\n\t * try to allocate a new set of blocks large enough for the\n\t * request.  in satisfying a request, dbReAlloc() may allocate\n\t * less than what was request but will always allocate enough\n\t * space as to satisfy the extend page.\n\t */\n\tif ((rc = extBrealloc(ip, xaddr, xlen, &nxlen, &nxaddr)))\n\t\tgoto exit;\n\n\t/* Allocat blocks to quota. */\n\trc = dquot_alloc_block(ip, nxlen);\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, (s64) nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn rc;\n\t}\n\n\tdelta = nxlen - xlen;\n\n\t/* check if the extend page is not abnr but the request is abnr\n\t * and the allocated disk space is for more than one page.  if this\n\t * is the case, there is a miss match of abnr between the extend page\n\t * and the one or more pages following the extend page.  as a result,\n\t * two extents will have to be manipulated. the first will be that\n\t * of the extent of the extend page and will be manipulated thru\n\t * an xtExtend() or an xtTailgate(), depending upon whether the\n\t * disk allocation occurred as an inplace extension.  the second\n\t * extent will be manipulated (created) through an xtInsert() and\n\t * will be for the pages following the extend page.\n\t */\n\tif (abnr && (!(xp->flag & XAD_NOTRECORDED)) && (nxlen > nbperpage)) {\n\t\tntail = nbperpage;\n\t\tnextend = ntail - xlen;\n\t\tninsert = nxlen - nbperpage;\n\n\t\txflag = XAD_NOTRECORDED;\n\t} else {\n\t\tntail = nxlen;\n\t\tnextend = delta;\n\t\tninsert = 0;\n\n\t\txflag = xp->flag;\n\t}\n\n\t/* if we were able to extend the disk allocation in place,\n\t * extend the extent.  otherwise, move the extent to a\n\t * new disk location.\n\t */\n\tif (xaddr == nxaddr) {\n\t\t/* extend the extent */\n\t\tif ((rc = xtExtend(0, ip, xoff + xlen, (int) nextend, 0))) {\n\t\t\tdbFree(ip, xaddr + xlen, delta);\n\t\t\tdquot_free_block(ip, nxlen);\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * move the extent to a new location:\n\t\t *\n\t\t * xtTailgate() accounts for relocated tail extent;\n\t\t */\n\t\tif ((rc = xtTailgate(0, ip, xoff, (int) ntail, nxaddr, 0))) {\n\t\t\tdbFree(ip, nxaddr, nxlen);\n\t\t\tdquot_free_block(ip, nxlen);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\n\t/* check if we need to also insert a new extent */\n\tif (ninsert) {\n\t\t/* perform the insert.  if it fails, free the blocks\n\t\t * to be inserted and make it appear that we only did\n\t\t * the xtExtend() or xtTailgate() above.\n\t\t */\n\t\txaddr = nxaddr + ntail;\n\t\tif (xtInsert (0, ip, xflag, xoff + ntail, (int) ninsert,\n\t\t\t      &xaddr, 0)) {\n\t\t\tdbFree(ip, xaddr, (s64) ninsert);\n\t\t\tdelta = nextend;\n\t\t\tnxlen = ntail;\n\t\t\txflag = 0;\n\t\t}\n\t}\n\n\t/* set the return results */\n\tXADaddress(xp, nxaddr);\n\tXADlength(xp, nxlen);\n\tXADoffset(xp, xoff);\n\txp->flag = xflag;\n\n\tmark_inode_dirty(ip);\nexit:\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\treturn (rc);\n}"
  },
  {
    "function_name": "extAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
    "lines": "85-191",
    "snippet": "int\nextAlloc(struct inode *ip, s64 xlen, s64 pno, xad_t * xp, bool abnr)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nxlen, nxaddr, xoff, hint, xaddr = 0;\n\tint rc;\n\tint xflag;\n\n\t/* This blocks if we are low on resources */\n\ttxBeginAnon(ip->i_sb);\n\n\t/* Avoid race with jfs_commit_inode() */\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t/* validate extent length */\n\tif (xlen > MAXXLEN)\n\t\txlen = MAXXLEN;\n\n\t/* get the page's starting extent offset */\n\txoff = pno << sbi->l2nbperpage;\n\n\t/* check if an allocation hint was provided */\n\tif ((hint = addressXAD(xp))) {\n\t\t/* get the size of the extent described by the hint */\n\t\tnxlen = lengthXAD(xp);\n\n\t\t/* check if the hint is for the portion of the file\n\t\t * immediately previous to the current allocation\n\t\t * request and if hint extent has the same abnr\n\t\t * value as the current request.  if so, we can\n\t\t * extend the hint extent to include the current\n\t\t * extent if we can allocate the blocks immediately\n\t\t * following the hint extent.\n\t\t */\n\t\tif (offsetXAD(xp) + nxlen == xoff &&\n\t\t    abnr == ((xp->flag & XAD_NOTRECORDED) ? true : false))\n\t\t\txaddr = hint + nxlen;\n\n\t\t/* adjust the hint to the last block of the extent */\n\t\thint += (nxlen - 1);\n\t}\n\n\t/* allocate the disk blocks for the extent.  initially, extBalloc()\n\t * will try to allocate disk blocks for the requested size (xlen).\n\t * if this fails (xlen contiguous free blocks not available), it'll\n\t * try to allocate a smaller number of blocks (producing a smaller\n\t * extent), with this smaller number of blocks consisting of the\n\t * requested number of blocks rounded down to the next smaller\n\t * power of 2 number (i.e. 16 -> 8).  it'll continue to round down\n\t * and retry the allocation until the number of blocks to allocate\n\t * is smaller than the number of blocks per page.\n\t */\n\tnxlen = xlen;\n\tif ((rc = extBalloc(ip, hint ? hint : INOHINT(ip), &nxlen, &nxaddr))) {\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, nxlen);\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, (s64) nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn rc;\n\t}\n\n\t/* determine the value of the extent flag */\n\txflag = abnr ? XAD_NOTRECORDED : 0;\n\n\t/* if we can extend the hint extent to cover the current request,\n\t * extend it.  otherwise, insert a new extent to\n\t * cover the current request.\n\t */\n\tif (xaddr && xaddr == nxaddr)\n\t\trc = xtExtend(0, ip, xoff, (int) nxlen, 0);\n\telse\n\t\trc = xtInsert(0, ip, xflag, xoff, (int) nxlen, &nxaddr, 0);\n\n\t/* if the extend or insert failed,\n\t * free the newly allocated blocks and return the error.\n\t */\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, nxlen);\n\t\tdquot_free_block(ip, nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the extent allocation */\n\tXADaddress(xp, nxaddr);\n\tXADlength(xp, nxlen);\n\tXADoffset(xp, xoff);\n\txp->flag = xflag;\n\n\tmark_inode_dirty(ip);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t/*\n\t * COMMIT_SyncList flags an anonymous tlock on page that is on\n\t * sync list.\n\t * We need to commit the inode to get the page written disk.\n\t */\n\tif (test_and_clear_cflag(COMMIT_Synclist,ip))\n\t\tjfs_commit_inode(ip, 0);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int extBalloc(struct inode *, s64, s64 *, s64 *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_commit_inode",
          "args": [
            "ip",
            "0"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_commit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "83-123",
          "snippet": "int jfs_commit_inode(struct inode *inode, int wait)\n{\n\tint rc = 0;\n\ttid_t tid;\n\tstatic int noisy = 5;\n\n\tjfs_info(\"In jfs_commit_inode, inode = 0x%p\", inode);\n\n\t/*\n\t * Don't commit if inode has been committed since last being\n\t * marked dirty, or if it has been deleted.\n\t */\n\tif (inode->i_nlink == 0 || !test_cflag(COMMIT_Dirty, inode))\n\t\treturn 0;\n\n\tif (isReadOnly(inode)) {\n\t\t/* kernel allows writes to devices on read-only\n\t\t * partitions and may think inode is dirty\n\t\t */\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\tjfs_err(\"jfs_commit_inode(0x%p) called on \"\n\t\t\t\t   \"read-only volume\", inode);\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn 0;\n\t}\n\n\ttid = txBegin(inode->i_sb, COMMIT_INODE);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\n\t/*\n\t * Retest inode state after taking commit_mutex\n\t */\n\tif (inode->i_nlink && test_cflag(COMMIT_Dirty, inode))\n\t\trc = txCommit(tid, 1, &inode, wait ? COMMIT_SYNC : 0);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nint jfs_commit_inode(struct inode *inode, int wait)\n{\n\tint rc = 0;\n\ttid_t tid;\n\tstatic int noisy = 5;\n\n\tjfs_info(\"In jfs_commit_inode, inode = 0x%p\", inode);\n\n\t/*\n\t * Don't commit if inode has been committed since last being\n\t * marked dirty, or if it has been deleted.\n\t */\n\tif (inode->i_nlink == 0 || !test_cflag(COMMIT_Dirty, inode))\n\t\treturn 0;\n\n\tif (isReadOnly(inode)) {\n\t\t/* kernel allows writes to devices on read-only\n\t\t * partitions and may think inode is dirty\n\t\t */\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\tjfs_err(\"jfs_commit_inode(0x%p) called on \"\n\t\t\t\t   \"read-only volume\", inode);\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn 0;\n\t}\n\n\ttid = txBegin(inode->i_sb, COMMIT_INODE);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\n\t/*\n\t * Retest inode state after taking commit_mutex\n\t */\n\tif (inode->i_nlink && test_cflag(COMMIT_Dirty, inode))\n\t\trc = txCommit(tid, 1, &inode, wait ? COMMIT_SYNC : 0);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_cflag",
          "args": [
            "COMMIT_Synclist",
            "ip"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "ip"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XADoffset",
          "args": [
            "xp",
            "xoff"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADlength",
          "args": [
            "xp",
            "nxlen"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADaddress",
          "args": [
            "xp",
            "nxaddr"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "nxlen"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "ip",
            "nxaddr",
            "nxlen"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtInsert",
          "args": [
            "0",
            "ip",
            "xflag",
            "xoff",
            "(int) nxlen",
            "&nxaddr",
            "0"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "xtInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "537-670",
          "snippet": "int xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtExtend",
          "args": [
            "0",
            "ip",
            "xoff",
            "(int) nxlen",
            "0"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "xtExtend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "1360-1507",
          "snippet": "int xtExtend(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, s64 xoff,\t/* delta extent offset */\n\t     s32 xlen,\t\t/* delta extent length */\n\t     int flag)\n{\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex, len;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\ts64 xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\n\tjfs_info(\"xtExtend: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/* there must exist extent to be extended */\n\tif ((rc = xtSearch(ip, xoff - 1, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xtSearch did not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* extension must be contiguous */\n\txad = &p->xad[index];\n\tif ((offsetXAD(xad) + lengthXAD(xad)) != xoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"extension is not contiguous\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/* extend will overflow extent ? */\n\txlen = lengthXAD(xad) + xlen;\n\tif ((len = xlen - MAXXLEN) <= 0)\n\t\tgoto extendOld;\n\n\t/*\n\t *\textent overflow: insert entry for new extent\n\t */\n//insertNew:\n\txoff = offsetXAD(xad) + MAXXLEN;\n\txaddr = addressXAD(xad) + MAXXLEN;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n\t/*\n\t *\tif the leaf page is full, insert the new entry and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = index + 1;\n\t\tsplit.flag = XAD_NEW;\n\t\tsplit.off = xoff;\t/* split offset */\n\t\tsplit.len = len;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\telse {\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &p->xad[index + 1];\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, len, xaddr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&p->header.nextindex, 1);\n\t}\n\n\t/* get back old entry */\n\txad = &p->xad[index];\n\txlen = MAXXLEN;\n\n\t/*\n\t * extend old extent\n\t */\n      extendOld:\n\tXADlength(xad, xlen);\n\tif (!(xad->flag & XAD_NEW))\n\t\txad->flag |= XAD_EXTENDED;\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtExtend(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, s64 xoff,\t/* delta extent offset */\n\t     s32 xlen,\t\t/* delta extent length */\n\t     int flag)\n{\n\tint rc = 0;\n\tint cmp;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex, len;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\ts64 xaddr;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck = NULL;\n\n\tjfs_info(\"xtExtend: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/* there must exist extent to be extended */\n\tif ((rc = xtSearch(ip, xoff - 1, NULL, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tif (cmp != 0) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"xtSearch did not find extent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* extension must be contiguous */\n\txad = &p->xad[index];\n\tif ((offsetXAD(xad) + lengthXAD(xad)) != xoff) {\n\t\tXT_PUTPAGE(mp);\n\t\tjfs_error(ip->i_sb, \"extension is not contiguous\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t}\n\n\t/* extend will overflow extent ? */\n\txlen = lengthXAD(xad) + xlen;\n\tif ((len = xlen - MAXXLEN) <= 0)\n\t\tgoto extendOld;\n\n\t/*\n\t *\textent overflow: insert entry for new extent\n\t */\n//insertNew:\n\txoff = offsetXAD(xad) + MAXXLEN;\n\txaddr = addressXAD(xad) + MAXXLEN;\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\n\t/*\n\t *\tif the leaf page is full, insert the new entry and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\t/* xtSpliUp() unpins leaf pages */\n\t\tsplit.mp = mp;\n\t\tsplit.index = index + 1;\n\t\tsplit.flag = XAD_NEW;\n\t\tsplit.off = xoff;\t/* split offset */\n\t\tsplit.len = len;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack)))\n\t\t\treturn rc;\n\n\t\t/* get back old page */\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t/*\n\t\t * if leaf root has been split, original root has been\n\t\t * copied to new child page, i.e., original entry now\n\t\t * resides on the new child page;\n\t\t */\n\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\tASSERT(p->header.nextindex ==\n\t\t\t       cpu_to_le16(XTENTRYSTART + 1));\n\t\t\txad = &p->xad[XTENTRYSTART];\n\t\t\tbn = addressXAD(xad);\n\t\t\tXT_PUTPAGE(mp);\n\n\t\t\t/* get new child page */\n\t\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\t\t\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\telse {\n\t\t/* insert the new entry: mark the entry NEW */\n\t\txad = &p->xad[index + 1];\n\t\tXT_PUTENTRY(xad, XAD_NEW, xoff, len, xaddr);\n\n\t\t/* advance next available entry index */\n\t\tle16_add_cpu(&p->header.nextindex, 1);\n\t}\n\n\t/* get back old entry */\n\txad = &p->xad[index];\n\txlen = MAXXLEN;\n\n\t/*\n\t * extend old extent\n\t */\n      extendOld:\n\tXADlength(xad, xlen);\n\tif (!(xad->flag & XAD_NEW))\n\t\txad->flag |= XAD_EXTENDED;\n\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "ip",
            "nxlen"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extBalloc",
          "args": [
            "ip",
            "hint ? hint : INOHINT(ip)",
            "&nxlen",
            "&nxaddr"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "extBalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
          "lines": "508-564",
          "snippet": "static int\nextBalloc(struct inode *ip, s64 hint, s64 * nblocks, s64 * blkno)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nb, nblks, daddr, max;\n\tint rc, nbperpage = sbi->nbperpage;\n\tstruct bmap *bmp = sbi->bmap;\n\tint ag;\n\n\t/* get the number of blocks to initially attempt to allocate.\n\t * we'll first try the number of blocks requested unless this\n\t * number is greater than the maximum number of contiguous free\n\t * blocks in the map. in that case, we'll start off with the\n\t * maximum free.\n\t */\n\tmax = (s64) 1 << bmp->db_maxfreebud;\n\tif (*nblocks >= max && *nblocks > nbperpage)\n\t\tnb = nblks = (max > nbperpage) ? max : nbperpage;\n\telse\n\t\tnb = nblks = *nblocks;\n\n\t/* try to allocate blocks */\n\twhile ((rc = dbAlloc(ip, hint, nb, &daddr)) != 0) {\n\t\t/* if something other than an out of space error,\n\t\t * stop and return this error.\n\t\t */\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\n\t\t/* decrease the allocation request size */\n\t\tnb = min(nblks, extRoundDown(nb));\n\n\t\t/* give up if we cannot cover a page */\n\t\tif (nb < nbperpage)\n\t\t\treturn (rc);\n\t}\n\n\t*nblocks = nb;\n\t*blkno = daddr;\n\n\tif (S_ISREG(ip->i_mode) && (ji->fileset == FILESYSTEM_I)) {\n\t\tag = BLKTOAG(daddr, sbi);\n\t\tspin_lock_irq(&ji->ag_lock);\n\t\tif (ji->active_ag == -1) {\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t} else if (ji->active_ag != ag) {\n\t\t\tatomic_dec(&bmp->db_active[ji->active_ag]);\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t}\n\t\tspin_unlock_irq(&ji->ag_lock);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int extBalloc(struct inode *, s64, s64 *, s64 *);",
            "static s64 extRoundDown(s64 nb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\nstatic s64 extRoundDown(s64 nb);\n\nstatic int\nextBalloc(struct inode *ip, s64 hint, s64 * nblocks, s64 * blkno)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(ip);\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nb, nblks, daddr, max;\n\tint rc, nbperpage = sbi->nbperpage;\n\tstruct bmap *bmp = sbi->bmap;\n\tint ag;\n\n\t/* get the number of blocks to initially attempt to allocate.\n\t * we'll first try the number of blocks requested unless this\n\t * number is greater than the maximum number of contiguous free\n\t * blocks in the map. in that case, we'll start off with the\n\t * maximum free.\n\t */\n\tmax = (s64) 1 << bmp->db_maxfreebud;\n\tif (*nblocks >= max && *nblocks > nbperpage)\n\t\tnb = nblks = (max > nbperpage) ? max : nbperpage;\n\telse\n\t\tnb = nblks = *nblocks;\n\n\t/* try to allocate blocks */\n\twhile ((rc = dbAlloc(ip, hint, nb, &daddr)) != 0) {\n\t\t/* if something other than an out of space error,\n\t\t * stop and return this error.\n\t\t */\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\n\t\t/* decrease the allocation request size */\n\t\tnb = min(nblks, extRoundDown(nb));\n\n\t\t/* give up if we cannot cover a page */\n\t\tif (nb < nbperpage)\n\t\t\treturn (rc);\n\t}\n\n\t*nblocks = nb;\n\t*blkno = daddr;\n\n\tif (S_ISREG(ip->i_mode) && (ji->fileset == FILESYSTEM_I)) {\n\t\tag = BLKTOAG(daddr, sbi);\n\t\tspin_lock_irq(&ji->ag_lock);\n\t\tif (ji->active_ag == -1) {\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t} else if (ji->active_ag != ag) {\n\t\t\tatomic_dec(&bmp->db_active[ji->active_ag]);\n\t\t\tatomic_inc(&bmp->db_active[ag]);\n\t\t\tji->active_ag = ag;\n\t\t}\n\t\tspin_unlock_irq(&ji->ag_lock);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INOHINT",
          "args": [
            "ip"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetXAD",
          "args": [
            "xp"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "xp"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "xp"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBeginAnon",
          "args": [
            "ip->i_sb"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "txBeginAnon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "460-489",
          "snippet": "void txBeginAnon(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\tINCREMENT(TxStat.txBeginAnon);\n\n      retry:\n\t/*\n\t * synchronize with logsync barrier\n\t */\n\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\tINCREMENT(TxStat.txBeginAnon_barrier);\n\t\tTXN_SLEEP(&log->syncwait);\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Don't begin transaction if we're getting starved for tlocks\n\t */\n\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\tINCREMENT(TxStat.txBeginAnon_lockslow);\n\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\tgoto retry;\n\t}\n\tTXN_UNLOCK();\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\n\nvoid txBeginAnon(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\tINCREMENT(TxStat.txBeginAnon);\n\n      retry:\n\t/*\n\t * synchronize with logsync barrier\n\t */\n\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\tINCREMENT(TxStat.txBeginAnon_barrier);\n\t\tTXN_SLEEP(&log->syncwait);\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Don't begin transaction if we're getting starved for tlocks\n\t */\n\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\tINCREMENT(TxStat.txBeginAnon_lockslow);\n\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\tgoto retry;\n\t}\n\tTXN_UNLOCK();\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\n\nint\nextAlloc(struct inode *ip, s64 xlen, s64 pno, xad_t * xp, bool abnr)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nxlen, nxaddr, xoff, hint, xaddr = 0;\n\tint rc;\n\tint xflag;\n\n\t/* This blocks if we are low on resources */\n\ttxBeginAnon(ip->i_sb);\n\n\t/* Avoid race with jfs_commit_inode() */\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t/* validate extent length */\n\tif (xlen > MAXXLEN)\n\t\txlen = MAXXLEN;\n\n\t/* get the page's starting extent offset */\n\txoff = pno << sbi->l2nbperpage;\n\n\t/* check if an allocation hint was provided */\n\tif ((hint = addressXAD(xp))) {\n\t\t/* get the size of the extent described by the hint */\n\t\tnxlen = lengthXAD(xp);\n\n\t\t/* check if the hint is for the portion of the file\n\t\t * immediately previous to the current allocation\n\t\t * request and if hint extent has the same abnr\n\t\t * value as the current request.  if so, we can\n\t\t * extend the hint extent to include the current\n\t\t * extent if we can allocate the blocks immediately\n\t\t * following the hint extent.\n\t\t */\n\t\tif (offsetXAD(xp) + nxlen == xoff &&\n\t\t    abnr == ((xp->flag & XAD_NOTRECORDED) ? true : false))\n\t\t\txaddr = hint + nxlen;\n\n\t\t/* adjust the hint to the last block of the extent */\n\t\thint += (nxlen - 1);\n\t}\n\n\t/* allocate the disk blocks for the extent.  initially, extBalloc()\n\t * will try to allocate disk blocks for the requested size (xlen).\n\t * if this fails (xlen contiguous free blocks not available), it'll\n\t * try to allocate a smaller number of blocks (producing a smaller\n\t * extent), with this smaller number of blocks consisting of the\n\t * requested number of blocks rounded down to the next smaller\n\t * power of 2 number (i.e. 16 -> 8).  it'll continue to round down\n\t * and retry the allocation until the number of blocks to allocate\n\t * is smaller than the number of blocks per page.\n\t */\n\tnxlen = xlen;\n\tif ((rc = extBalloc(ip, hint ? hint : INOHINT(ip), &nxlen, &nxaddr))) {\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, nxlen);\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, (s64) nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn rc;\n\t}\n\n\t/* determine the value of the extent flag */\n\txflag = abnr ? XAD_NOTRECORDED : 0;\n\n\t/* if we can extend the hint extent to cover the current request,\n\t * extend it.  otherwise, insert a new extent to\n\t * cover the current request.\n\t */\n\tif (xaddr && xaddr == nxaddr)\n\t\trc = xtExtend(0, ip, xoff, (int) nxlen, 0);\n\telse\n\t\trc = xtInsert(0, ip, xflag, xoff, (int) nxlen, &nxaddr, 0);\n\n\t/* if the extend or insert failed,\n\t * free the newly allocated blocks and return the error.\n\t */\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, nxlen);\n\t\tdquot_free_block(ip, nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the extent allocation */\n\tXADaddress(xp, nxaddr);\n\tXADlength(xp, nxlen);\n\tXADoffset(xp, xoff);\n\txp->flag = xflag;\n\n\tmark_inode_dirty(ip);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t/*\n\t * COMMIT_SyncList flags an anonymous tlock on page that is on\n\t * sync list.\n\t * We need to commit the inode to get the page written disk.\n\t */\n\tif (test_and_clear_cflag(COMMIT_Synclist,ip))\n\t\tjfs_commit_inode(ip, 0);\n\n\treturn (0);\n}"
  }
]