[
  {
    "function_name": "nfs_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/symlink.c",
    "lines": "46-67",
    "snippet": "static void *nfs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct page *page;\n\tvoid *err;\n\n\terr = ERR_PTR(nfs_revalidate_mapping(inode, inode->i_mapping));\n\tif (err)\n\t\tgoto read_failed;\n\tpage = read_cache_page(&inode->i_data, 0,\n\t\t\t\t(filler_t *)nfs_symlink_filler, inode);\n\tif (IS_ERR(page)) {\n\t\terr = page;\n\t\tgoto read_failed;\n\t}\n\tnd_set_link(nd, kmap(page));\n\treturn page;\n\nread_failed:\n\tnd_set_link(nd, err);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/namei.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs2.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "err"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "&inode->i_data",
            "0",
            "(filler_t *)nfs_symlink_filler",
            "inode"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "nfs_revalidate_mapping(inode, inode->i_mapping)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_revalidate_mapping",
          "args": [
            "inode",
            "inode->i_mapping"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_revalidate_mapping_protected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1160-1163",
          "snippet": "int nfs_revalidate_mapping_protected(struct inode *inode, struct address_space *mapping)\n{\n\treturn __nfs_revalidate_mapping(inode, mapping, true);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_revalidate_mapping_protected(struct inode *inode, struct address_space *mapping)\n{\n\treturn __nfs_revalidate_mapping(inode, mapping, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/namei.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void *nfs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct page *page;\n\tvoid *err;\n\n\terr = ERR_PTR(nfs_revalidate_mapping(inode, inode->i_mapping));\n\tif (err)\n\t\tgoto read_failed;\n\tpage = read_cache_page(&inode->i_data, 0,\n\t\t\t\t(filler_t *)nfs_symlink_filler, inode);\n\tif (IS_ERR(page)) {\n\t\terr = page;\n\t\tgoto read_failed;\n\t}\n\tnd_set_link(nd, kmap(page));\n\treturn page;\n\nread_failed:\n\tnd_set_link(nd, err);\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs_symlink_filler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/symlink.c",
    "lines": "29-44",
    "snippet": "static int nfs_symlink_filler(struct inode *inode, struct page *page)\n{\n\tint error;\n\n\terror = NFS_PROTO(inode)->readlink(inode, page, 0, PAGE_SIZE);\n\tif (error < 0)\n\t\tgoto error;\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n\nerror:\n\tSetPageError(page);\n\tunlock_page(page);\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/namei.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs2.h>",
      "#include <linux/nfs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode",
            "page",
            "0",
            "PAGE_SIZE"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/namei.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int nfs_symlink_filler(struct inode *inode, struct page *page)\n{\n\tint error;\n\n\terror = NFS_PROTO(inode)->readlink(inode, page, 0, PAGE_SIZE);\n\tif (error < 0)\n\t\tgoto error;\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n\nerror:\n\tSetPageError(page);\n\tunlock_page(page);\n\treturn -EIO;\n}"
  }
]