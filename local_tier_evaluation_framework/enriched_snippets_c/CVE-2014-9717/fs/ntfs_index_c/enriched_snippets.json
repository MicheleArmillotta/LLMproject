[
  {
    "function_name": "ntfs_index_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.c",
    "lines": "119-454",
    "snippet": "int ntfs_index_lookup(const void *key, const int key_len,\n\t\tntfs_index_context *ictx)\n{\n\tVCN vcn, old_vcn;\n\tntfs_inode *idx_ni = ictx->idx_ni;\n\tntfs_volume *vol = idx_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tntfs_inode *base_ni = idx_ni->ext.base_ntfs_ino;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end, *kaddr;\n\tntfs_attr_search_ctx *actx;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tint rc, err = 0;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(!NInoAttr(idx_ni));\n\tBUG_ON(idx_ni->type != AT_INDEX_ALLOCATION);\n\tBUG_ON(idx_ni->nr_extents != -1);\n\tBUG_ON(!base_ni);\n\tBUG_ON(!key);\n\tBUG_ON(key_len <= 0);\n\tif (!ntfs_is_collation_rule_supported(\n\t\t\tidx_ni->itype.index.collation_rule)) {\n\t\tntfs_error(sb, \"Index uses unsupported collation rule 0x%x.  \"\n\t\t\t\t\"Aborting lookup.\", le32_to_cpu(\n\t\t\t\tidx_ni->itype.index.collation_rule));\n\t\treturn -EOPNOTSUPP;\n\t}\n\t/* Get hold of the mft record for the index inode. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn PTR_ERR(m);\n\t}\n\tactx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!actx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, idx_ni->name, idx_ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, actx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it has been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)actx->attr +\n\t\t\tle16_to_cpu(actx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)actx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->length) > index_end)\n\t\t\tgoto idx_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a key.  It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/* Further bounds checks. */\n\t\tif ((u32)sizeof(INDEX_ENTRY_HEADER) +\n\t\t\t\tle16_to_cpu(ie->key_length) >\n\t\t\t\tle16_to_cpu(ie->data.vi.data_offset) ||\n\t\t\t\t(u32)le16_to_cpu(ie->data.vi.data_offset) +\n\t\t\t\tle16_to_cpu(ie->data.vi.data_length) >\n\t\t\t\tle16_to_cpu(ie->length))\n\t\t\tgoto idx_err_out;\n\t\t/* If the keys match perfectly, we setup @ictx and return 0. */\n\t\tif ((key_len == le16_to_cpu(ie->key_length)) && !memcmp(key,\n\t\t\t\t&ie->key, key_len)) {\nir_done:\n\t\t\tictx->is_in_root = true;\n\t\t\tictx->ir = ir;\n\t\t\tictx->actx = actx;\n\t\t\tictx->base_ni = base_ni;\n\t\t\tictx->ia = NULL;\n\t\t\tictx->page = NULL;\ndone:\n\t\t\tictx->entry = ie;\n\t\t\tictx->data = (u8*)ie +\n\t\t\t\t\tle16_to_cpu(ie->data.vi.data_offset);\n\t\t\tictx->data_len = le16_to_cpu(ie->data.vi.data_length);\n\t\t\tntfs_debug(\"Done.\");\n\t\t\treturn err;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate(vol, idx_ni->itype.index.collation_rule, key,\n\t\t\t\tkey_len, &ie->key, le16_to_cpu(ie->key_length));\n\t\t/*\n\t\t * If @key collates before the key of the current entry, there\n\t\t * is definitely no such key in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/*\n\t\t * A match should never happen as the memcmp() call should have\n\t\t * cought it, but we still treat it correctly.\n\t\t */\n\t\tif (!rc)\n\t\t\tgoto ir_done;\n\t\t/* The keys are not equal, continue the search. */\n\t}\n\t/*\n\t * We have finished with this index without success.  Check for the\n\t * presence of a child node and if not present setup @ictx and return\n\t * -ENOENT.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto ir_done;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(idx_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one.  Inode 0x%lx is corrupt or \"\n\t\t\t\t\"driver bug.\", idx_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(idx_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record.  Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(actx);\n\tunmap_mft_record(base_ni);\n\tm = NULL;\n\tactx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tidx_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tidx_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed.  Corrupt inode \"\n\t\t\t\t\"0x%lx or driver bug.\", idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Index record with vcn 0x%llx is corrupt.  \"\n\t\t\t\t\"Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx).  Inode \"\n\t\t\t\t\"0x%lx is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tidx_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of inode 0x%lx has \"\n\t\t\t\t\"a size (%u) differing from the index \"\n\t\t\t\t\"specified size (%u).  Inode is corrupt or \"\n\t\t\t\t\"driver bug.\", (unsigned long long)vcn,\n\t\t\t\tidx_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tidx_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + idx_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of inode 0x%lx \"\n\t\t\t\t\"crosses page boundary.  Impossible!  Cannot \"\n\t\t\t\t\"access!  This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tidx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + idx_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of inode \"\n\t\t\t\t\"0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->length) > index_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a key.  It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/* Further bounds checks. */\n\t\tif ((u32)sizeof(INDEX_ENTRY_HEADER) +\n\t\t\t\tle16_to_cpu(ie->key_length) >\n\t\t\t\tle16_to_cpu(ie->data.vi.data_offset) ||\n\t\t\t\t(u32)le16_to_cpu(ie->data.vi.data_offset) +\n\t\t\t\tle16_to_cpu(ie->data.vi.data_length) >\n\t\t\t\tle16_to_cpu(ie->length)) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* If the keys match perfectly, we setup @ictx and return 0. */\n\t\tif ((key_len == le16_to_cpu(ie->key_length)) && !memcmp(key,\n\t\t\t\t&ie->key, key_len)) {\nia_done:\n\t\t\tictx->is_in_root = false;\n\t\t\tictx->actx = NULL;\n\t\t\tictx->base_ni = NULL;\n\t\t\tictx->ia = ia;\n\t\t\tictx->page = page;\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate(vol, idx_ni->itype.index.collation_rule, key,\n\t\t\t\tkey_len, &ie->key, le16_to_cpu(ie->key_length));\n\t\t/*\n\t\t * If @key collates before the key of the current entry, there\n\t\t * is definitely no such key in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/*\n\t\t * A match should never happen as the memcmp() call should have\n\t\t * cought it, but we still treat it correctly.\n\t\t */\n\t\tif (!rc)\n\t\t\tgoto ia_done;\n\t\t/* The keys are not equal, continue the search. */\n\t}\n\t/*\n\t * We have finished with this index buffer without success.  Check for\n\t * the presence of a child node and if not present return -ENOENT.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto ia_done;\n\t}\n\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\tntfs_error(sb, \"Index entry with child node found in a leaf \"\n\t\t\t\t\"node in inode 0x%lx.\", idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Child node present, descend into it. */\n\told_vcn = vcn;\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tif (vcn >= 0) {\n\t\t/*\n\t\t * If vcn is in the same page cache page as old_vcn we recycle\n\t\t * the mapped page.\n\t\t */\n\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\tgoto fast_descend_into_child_node;\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\tgoto descend_into_child_node;\n\t}\n\tntfs_error(sb, \"Negative child node vcn in inode 0x%lx.\",\n\t\t\tidx_ni->mft_no);\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (actx)\n\t\tntfs_attr_put_search_ctx(actx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\nidx_err_out:\n\tntfs_error(sb, \"Corrupt index.  Aborting lookup.\");\n\tgoto err_out;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"collate.h\"",
      "#include \"aops.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Corrupt index.  Aborting lookup.\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "base_ni"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "actx"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Negative child node vcn in inode 0x%lx.\"",
            "idx_ni->mft_no"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sle64_to_cpup",
          "args": [
            "(sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8)"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ie->length"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entry not found.\""
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_collate",
          "args": [
            "vol",
            "idx_ni->itype.index.collation_rule",
            "key",
            "key_len",
            "&ie->key",
            "le16_to_cpu(ie->key_length)"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_collate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/collate.c",
          "lines": "101-124",
          "snippet": "int ntfs_collate(ntfs_volume *vol, COLLATION_RULE cr,\n\t\tconst void *data1, const int data1_len,\n\t\tconst void *data2, const int data2_len) {\n\tint i;\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * FIXME:  At the moment we only support COLLATION_BINARY and\n\t * COLLATION_NTOFS_ULONG, so we BUG() for everything else for now.\n\t */\n\tBUG_ON(cr != COLLATION_BINARY && cr != COLLATION_NTOFS_ULONG);\n\ti = le32_to_cpu(cr);\n\tBUG_ON(i < 0);\n\tif (i <= 0x02)\n\t\treturn ntfs_do_collate0x0[i](vol, data1, data1_len,\n\t\t\t\tdata2, data2_len);\n\tBUG_ON(i < 0x10);\n\ti -= 0x10;\n\tif (likely(i <= 3))\n\t\treturn ntfs_do_collate0x1[i](vol, data1, data1_len,\n\t\t\t\tdata2, data2_len);\n\tBUG();\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"collate.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ntfs_collate_func_t ntfs_do_collate0x0[3] = {\n\tntfs_collate_binary,\n\tNULL/*ntfs_collate_file_name*/,\n\tNULL/*ntfs_collate_unicode_string*/,\n};",
            "static ntfs_collate_func_t ntfs_do_collate0x1[4] = {\n\tntfs_collate_ntofs_ulong,\n\tNULL/*ntfs_collate_ntofs_sid*/,\n\tNULL/*ntfs_collate_ntofs_security_hash*/,\n\tNULL/*ntfs_collate_ntofs_ulongs*/,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"collate.h\"\n\nstatic ntfs_collate_func_t ntfs_do_collate0x0[3] = {\n\tntfs_collate_binary,\n\tNULL/*ntfs_collate_file_name*/,\n\tNULL/*ntfs_collate_unicode_string*/,\n};\nstatic ntfs_collate_func_t ntfs_do_collate0x1[4] = {\n\tntfs_collate_ntofs_ulong,\n\tNULL/*ntfs_collate_ntofs_sid*/,\n\tNULL/*ntfs_collate_ntofs_security_hash*/,\n\tNULL/*ntfs_collate_ntofs_ulongs*/,\n};\n\nint ntfs_collate(ntfs_volume *vol, COLLATION_RULE cr,\n\t\tconst void *data1, const int data1_len,\n\t\tconst void *data2, const int data2_len) {\n\tint i;\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * FIXME:  At the moment we only support COLLATION_BINARY and\n\t * COLLATION_NTOFS_ULONG, so we BUG() for everything else for now.\n\t */\n\tBUG_ON(cr != COLLATION_BINARY && cr != COLLATION_NTOFS_ULONG);\n\ti = le32_to_cpu(cr);\n\tBUG_ON(i < 0);\n\tif (i <= 0x02)\n\t\treturn ntfs_do_collate0x0[i](vol, data1, data1_len,\n\t\t\t\tdata2, data2_len);\n\tBUG_ON(i < 0x10);\n\ti -= 0x10;\n\tif (likely(i <= 3))\n\t\treturn ntfs_do_collate0x1[i](vol, data1, data1_len,\n\t\t\t\tdata2, data2_len);\n\tBUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "key",
            "&ie->key",
            "key_len"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ia->index.entries_offset"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ntfs_is_indx_record(ia->magic)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_indx_record",
          "args": [
            "ia->magic"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "ia_mapping",
            "vcn <<\n\t\t\tidx_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "idx_ni"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoIndexAllocPresent",
          "args": [
            "idx_ni"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "key",
            "&ie->key",
            "key_len"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "AT_INDEX_ROOT",
            "idx_ni->name",
            "idx_ni->name_len",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "actx"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!actx"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "m"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_collation_rule_supported",
          "args": [
            "idx_ni->itype.index.collation_rule"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_is_collation_rule_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/collate.h",
          "lines": "29-44",
          "snippet": "static inline bool ntfs_is_collation_rule_supported(COLLATION_RULE cr) {\n\tint i;\n\n\t/*\n\t * FIXME:  At the moment we only support COLLATION_BINARY and\n\t * COLLATION_NTOFS_ULONG, so we return false for everything else for\n\t * now.\n\t */\n\tif (unlikely(cr != COLLATION_BINARY && cr != COLLATION_NTOFS_ULONG))\n\t\treturn false;\n\ti = le32_to_cpu(cr);\n\tif (likely(((i >= 0) && (i <= 0x02)) ||\n\t\t\t((i >= 0x10) && (i <= 0x13))))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"types.h\"\n\nstatic inline bool ntfs_is_collation_rule_supported(COLLATION_RULE cr) {\n\tint i;\n\n\t/*\n\t * FIXME:  At the moment we only support COLLATION_BINARY and\n\t * COLLATION_NTOFS_ULONG, so we return false for everything else for\n\t * now.\n\t */\n\tif (unlikely(cr != COLLATION_BINARY && cr != COLLATION_NTOFS_ULONG))\n\t\treturn false;\n\ti = le32_to_cpu(cr);\n\tif (likely(((i >= 0) && (i <= 0x02)) ||\n\t\t\t((i >= 0x10) && (i <= 0x13))))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "key_len <= 0"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!key"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!base_ni"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "idx_ni->nr_extents != -1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "idx_ni->type != AT_INDEX_ALLOCATION"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!NInoAttr(idx_ni)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "idx_ni"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"collate.h\"\n#include \"aops.h\"\n#include <linux/slab.h>\n\nint ntfs_index_lookup(const void *key, const int key_len,\n\t\tntfs_index_context *ictx)\n{\n\tVCN vcn, old_vcn;\n\tntfs_inode *idx_ni = ictx->idx_ni;\n\tntfs_volume *vol = idx_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tntfs_inode *base_ni = idx_ni->ext.base_ntfs_ino;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end, *kaddr;\n\tntfs_attr_search_ctx *actx;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tint rc, err = 0;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(!NInoAttr(idx_ni));\n\tBUG_ON(idx_ni->type != AT_INDEX_ALLOCATION);\n\tBUG_ON(idx_ni->nr_extents != -1);\n\tBUG_ON(!base_ni);\n\tBUG_ON(!key);\n\tBUG_ON(key_len <= 0);\n\tif (!ntfs_is_collation_rule_supported(\n\t\t\tidx_ni->itype.index.collation_rule)) {\n\t\tntfs_error(sb, \"Index uses unsupported collation rule 0x%x.  \"\n\t\t\t\t\"Aborting lookup.\", le32_to_cpu(\n\t\t\t\tidx_ni->itype.index.collation_rule));\n\t\treturn -EOPNOTSUPP;\n\t}\n\t/* Get hold of the mft record for the index inode. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn PTR_ERR(m);\n\t}\n\tactx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!actx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, idx_ni->name, idx_ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, actx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it has been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)actx->attr +\n\t\t\tle16_to_cpu(actx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)actx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->length) > index_end)\n\t\t\tgoto idx_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a key.  It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/* Further bounds checks. */\n\t\tif ((u32)sizeof(INDEX_ENTRY_HEADER) +\n\t\t\t\tle16_to_cpu(ie->key_length) >\n\t\t\t\tle16_to_cpu(ie->data.vi.data_offset) ||\n\t\t\t\t(u32)le16_to_cpu(ie->data.vi.data_offset) +\n\t\t\t\tle16_to_cpu(ie->data.vi.data_length) >\n\t\t\t\tle16_to_cpu(ie->length))\n\t\t\tgoto idx_err_out;\n\t\t/* If the keys match perfectly, we setup @ictx and return 0. */\n\t\tif ((key_len == le16_to_cpu(ie->key_length)) && !memcmp(key,\n\t\t\t\t&ie->key, key_len)) {\nir_done:\n\t\t\tictx->is_in_root = true;\n\t\t\tictx->ir = ir;\n\t\t\tictx->actx = actx;\n\t\t\tictx->base_ni = base_ni;\n\t\t\tictx->ia = NULL;\n\t\t\tictx->page = NULL;\ndone:\n\t\t\tictx->entry = ie;\n\t\t\tictx->data = (u8*)ie +\n\t\t\t\t\tle16_to_cpu(ie->data.vi.data_offset);\n\t\t\tictx->data_len = le16_to_cpu(ie->data.vi.data_length);\n\t\t\tntfs_debug(\"Done.\");\n\t\t\treturn err;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate(vol, idx_ni->itype.index.collation_rule, key,\n\t\t\t\tkey_len, &ie->key, le16_to_cpu(ie->key_length));\n\t\t/*\n\t\t * If @key collates before the key of the current entry, there\n\t\t * is definitely no such key in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/*\n\t\t * A match should never happen as the memcmp() call should have\n\t\t * cought it, but we still treat it correctly.\n\t\t */\n\t\tif (!rc)\n\t\t\tgoto ir_done;\n\t\t/* The keys are not equal, continue the search. */\n\t}\n\t/*\n\t * We have finished with this index without success.  Check for the\n\t * presence of a child node and if not present setup @ictx and return\n\t * -ENOENT.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto ir_done;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(idx_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one.  Inode 0x%lx is corrupt or \"\n\t\t\t\t\"driver bug.\", idx_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(idx_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record.  Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(actx);\n\tunmap_mft_record(base_ni);\n\tm = NULL;\n\tactx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tidx_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tidx_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed.  Corrupt inode \"\n\t\t\t\t\"0x%lx or driver bug.\", idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Index record with vcn 0x%llx is corrupt.  \"\n\t\t\t\t\"Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx).  Inode \"\n\t\t\t\t\"0x%lx is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tidx_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of inode 0x%lx has \"\n\t\t\t\t\"a size (%u) differing from the index \"\n\t\t\t\t\"specified size (%u).  Inode is corrupt or \"\n\t\t\t\t\"driver bug.\", (unsigned long long)vcn,\n\t\t\t\tidx_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tidx_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + idx_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of inode 0x%lx \"\n\t\t\t\t\"crosses page boundary.  Impossible!  Cannot \"\n\t\t\t\t\"access!  This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tidx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + idx_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of inode \"\n\t\t\t\t\"0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->length) > index_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a key.  It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/* Further bounds checks. */\n\t\tif ((u32)sizeof(INDEX_ENTRY_HEADER) +\n\t\t\t\tle16_to_cpu(ie->key_length) >\n\t\t\t\tle16_to_cpu(ie->data.vi.data_offset) ||\n\t\t\t\t(u32)le16_to_cpu(ie->data.vi.data_offset) +\n\t\t\t\tle16_to_cpu(ie->data.vi.data_length) >\n\t\t\t\tle16_to_cpu(ie->length)) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in inode \"\n\t\t\t\t\t\"0x%lx.\", idx_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* If the keys match perfectly, we setup @ictx and return 0. */\n\t\tif ((key_len == le16_to_cpu(ie->key_length)) && !memcmp(key,\n\t\t\t\t&ie->key, key_len)) {\nia_done:\n\t\t\tictx->is_in_root = false;\n\t\t\tictx->actx = NULL;\n\t\t\tictx->base_ni = NULL;\n\t\t\tictx->ia = ia;\n\t\t\tictx->page = page;\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate(vol, idx_ni->itype.index.collation_rule, key,\n\t\t\t\tkey_len, &ie->key, le16_to_cpu(ie->key_length));\n\t\t/*\n\t\t * If @key collates before the key of the current entry, there\n\t\t * is definitely no such key in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/*\n\t\t * A match should never happen as the memcmp() call should have\n\t\t * cought it, but we still treat it correctly.\n\t\t */\n\t\tif (!rc)\n\t\t\tgoto ia_done;\n\t\t/* The keys are not equal, continue the search. */\n\t}\n\t/*\n\t * We have finished with this index buffer without success.  Check for\n\t * the presence of a child node and if not present return -ENOENT.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto ia_done;\n\t}\n\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\tntfs_error(sb, \"Index entry with child node found in a leaf \"\n\t\t\t\t\"node in inode 0x%lx.\", idx_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Child node present, descend into it. */\n\told_vcn = vcn;\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tif (vcn >= 0) {\n\t\t/*\n\t\t * If vcn is in the same page cache page as old_vcn we recycle\n\t\t * the mapped page.\n\t\t */\n\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\tgoto fast_descend_into_child_node;\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\tgoto descend_into_child_node;\n\t}\n\tntfs_error(sb, \"Negative child node vcn in inode 0x%lx.\",\n\t\t\tidx_ni->mft_no);\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (actx)\n\t\tntfs_attr_put_search_ctx(actx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\nidx_err_out:\n\tntfs_error(sb, \"Corrupt index.  Aborting lookup.\");\n\tgoto err_out;\n}"
  },
  {
    "function_name": "ntfs_index_ctx_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.c",
    "lines": "57-76",
    "snippet": "void ntfs_index_ctx_put(ntfs_index_context *ictx)\n{\n\tif (ictx->entry) {\n\t\tif (ictx->is_in_root) {\n\t\t\tif (ictx->actx)\n\t\t\t\tntfs_attr_put_search_ctx(ictx->actx);\n\t\t\tif (ictx->base_ni)\n\t\t\t\tunmap_mft_record(ictx->base_ni);\n\t\t} else {\n\t\t\tstruct page *page = ictx->page;\n\t\t\tif (page) {\n\t\t\t\tBUG_ON(!PageLocked(page));\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t}\n\t\t}\n\t}\n\tkmem_cache_free(ntfs_index_ctx_cache, ictx);\n\treturn;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"collate.h\"",
      "#include \"aops.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ntfs_index_ctx_cache",
            "ictx"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "ictx->base_ni"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ictx->actx"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"collate.h\"\n#include \"aops.h\"\n#include <linux/slab.h>\n\nvoid ntfs_index_ctx_put(ntfs_index_context *ictx)\n{\n\tif (ictx->entry) {\n\t\tif (ictx->is_in_root) {\n\t\t\tif (ictx->actx)\n\t\t\t\tntfs_attr_put_search_ctx(ictx->actx);\n\t\t\tif (ictx->base_ni)\n\t\t\t\tunmap_mft_record(ictx->base_ni);\n\t\t} else {\n\t\t\tstruct page *page = ictx->page;\n\t\t\tif (page) {\n\t\t\t\tBUG_ON(!PageLocked(page));\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t}\n\t\t}\n\t}\n\tkmem_cache_free(ntfs_index_ctx_cache, ictx);\n\treturn;\n}"
  },
  {
    "function_name": "ntfs_index_ctx_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.c",
    "lines": "39-47",
    "snippet": "ntfs_index_context *ntfs_index_ctx_get(ntfs_inode *idx_ni)\n{\n\tntfs_index_context *ictx;\n\n\tictx = kmem_cache_alloc(ntfs_index_ctx_cache, GFP_NOFS);\n\tif (ictx)\n\t\t*ictx = (ntfs_index_context){ .idx_ni = idx_ni };\n\treturn ictx;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"index.h\"",
      "#include \"debug.h\"",
      "#include \"collate.h\"",
      "#include \"aops.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ntfs_index_ctx_cache",
            "GFP_NOFS"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#include \"collate.h\"\n#include \"aops.h\"\n#include <linux/slab.h>\n\nntfs_index_context *ntfs_index_ctx_get(ntfs_inode *idx_ni)\n{\n\tntfs_index_context *ictx;\n\n\tictx = kmem_cache_alloc(ntfs_index_ctx_cache, GFP_NOFS);\n\tif (ictx)\n\t\t*ictx = (ntfs_index_context){ .idx_ni = idx_ni };\n\treturn ictx;\n}"
  }
]