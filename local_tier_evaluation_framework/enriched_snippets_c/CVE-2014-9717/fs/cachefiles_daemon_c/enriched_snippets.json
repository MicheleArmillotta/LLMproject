[
  {
    "function_name": "cachefiles_has_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "674-751",
    "snippet": "int cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_state_changed",
          "args": [
            "cache"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_state_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "128-132",
          "snippet": "static inline void cachefiles_state_changed(struct cachefiles_cache *cache)\n{\n\tset_bit(CACHEFILES_STATE_CHANGED, &cache->flags);\n\twake_up_all(&cache->daemon_pollwq);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_STATE_CHANGED\t3\t/* T if state changed (poll trigger) */"
          ],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\n#define CACHEFILES_STATE_CHANGED\t3\t/* T if state changed (poll trigger) */\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\n\nstatic inline void cachefiles_state_changed(struct cachefiles_cache *cache)\n{\n\tset_bit(CACHEFILES_STATE_CHANGED, &cache->flags);\n\twake_up_all(&cache->daemon_pollwq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"### CULL CACHE ###\""
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "CACHEFILES_CULLING",
            "&cache->flags"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "CACHEFILES_CULLING",
            "&cache->flags"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHEFILES_CULLING",
            "&cache->flags"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"statfs failed\""
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_statfs",
          "args": [
            "&path",
            "&stats"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/statfs.c",
          "lines": "66-74",
          "snippet": "int vfs_statfs(struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint vfs_statfs(struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&stats",
            "0",
            "sizeof(stats)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nint cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_daemon_inuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "625-668",
    "snippet": "static int cachefiles_daemon_inuse(struct cachefiles_cache *cache, char *args)\n{\n\tstruct path path;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t//_enter(\",%s\", args);\n\n\tif (strchr(args, '/'))\n\t\tgoto inval;\n\n\tif (!test_bit(CACHEFILES_READY, &cache->flags)) {\n\t\tpr_err(\"inuse applied to unready cache\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (test_bit(CACHEFILES_DEAD, &cache->flags)) {\n\t\tpr_err(\"inuse applied to dead cache\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* extract the directory dentry from the cwd */\n\tget_fs_pwd(current->fs, &path);\n\n\tif (!d_can_lookup(path.dentry))\n\t\tgoto notdir;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = cachefiles_check_in_use(cache, path.dentry, args);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tpath_put(&path);\n\t//_leave(\" = %d\", ret);\n\treturn ret;\n\nnotdir:\n\tpath_put(&path);\n\tpr_err(\"inuse command requires dirfd to be a directory\\n\");\n\treturn -ENOTDIR;\n\ninval:\n\tpr_err(\"inuse command requires dirfd and filename\\n\");\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"inuse command requires dirfd and filename\\n\""
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"inuse command requires dirfd to be a directory\\n\""
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_end_secure",
          "args": [
            "cache",
            "saved_cred"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_end_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "231-235",
          "snippet": "static inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\n\nstatic inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_check_in_use",
          "args": [
            "cache",
            "path.dentry",
            "args"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_check_in_use",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "962-978",
          "snippet": "int cachefiles_check_in_use(struct cachefiles_cache *cache, struct dentry *dir,\n\t\t\t    char *filename)\n{\n\tstruct dentry *victim;\n\n\t//_enter(\",%pd/,%s\",\n\t//       dir, filename);\n\n\tvictim = cachefiles_check_active(cache, dir, filename);\n\tif (IS_ERR(victim))\n\t\treturn PTR_ERR(victim);\n\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(victim);\n\t//_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint cachefiles_check_in_use(struct cachefiles_cache *cache, struct dentry *dir,\n\t\t\t    char *filename)\n{\n\tstruct dentry *victim;\n\n\t//_enter(\",%pd/,%s\",\n\t//       dir, filename);\n\n\tvictim = cachefiles_check_active(cache, dir, filename);\n\tif (IS_ERR(victim))\n\t\treturn PTR_ERR(victim);\n\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(victim);\n\t//_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_begin_secure",
          "args": [
            "cache",
            "&saved_cred"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_begin_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "225-229",
          "snippet": "static inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);",
            "extern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\nextern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);\n\nstatic inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_can_lookup",
          "args": [
            "path.dentry"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_pwd",
          "args": [
            "current->fs",
            "&path"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"inuse applied to dead cache\\n\""
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHEFILES_DEAD",
            "&cache->flags"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"inuse applied to unready cache\\n\""
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "args",
            "'/'"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *cache, char *args)\n{\n\tstruct path path;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t//_enter(\",%s\", args);\n\n\tif (strchr(args, '/'))\n\t\tgoto inval;\n\n\tif (!test_bit(CACHEFILES_READY, &cache->flags)) {\n\t\tpr_err(\"inuse applied to unready cache\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (test_bit(CACHEFILES_DEAD, &cache->flags)) {\n\t\tpr_err(\"inuse applied to dead cache\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* extract the directory dentry from the cwd */\n\tget_fs_pwd(current->fs, &path);\n\n\tif (!d_can_lookup(path.dentry))\n\t\tgoto notdir;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = cachefiles_check_in_use(cache, path.dentry, args);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tpath_put(&path);\n\t//_leave(\" = %d\", ret);\n\treturn ret;\n\nnotdir:\n\tpath_put(&path);\n\tpr_err(\"inuse command requires dirfd to be a directory\\n\");\n\treturn -ENOTDIR;\n\ninval:\n\tpr_err(\"inuse command requires dirfd and filename\\n\");\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "cachefiles_daemon_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "602-619",
    "snippet": "static int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"debug command requires mask\\n\""
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "args",
            "&args",
            "0"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%s\"",
            "args"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "cachefiles_daemon_cull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "553-596",
    "snippet": "static int cachefiles_daemon_cull(struct cachefiles_cache *cache, char *args)\n{\n\tstruct path path;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\",%s\", args);\n\n\tif (strchr(args, '/'))\n\t\tgoto inval;\n\n\tif (!test_bit(CACHEFILES_READY, &cache->flags)) {\n\t\tpr_err(\"cull applied to unready cache\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (test_bit(CACHEFILES_DEAD, &cache->flags)) {\n\t\tpr_err(\"cull applied to dead cache\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* extract the directory dentry from the cwd */\n\tget_fs_pwd(current->fs, &path);\n\n\tif (!d_can_lookup(path.dentry))\n\t\tgoto notdir;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = cachefiles_cull(cache, path.dentry, args);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tpath_put(&path);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnotdir:\n\tpath_put(&path);\n\tpr_err(\"cull command requires dirfd to be a directory\\n\");\n\treturn -ENOTDIR;\n\ninval:\n\tpr_err(\"cull command requires dirfd and filename\\n\");\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cull command requires dirfd and filename\\n\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cull command requires dirfd to be a directory\\n\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_end_secure",
          "args": [
            "cache",
            "saved_cred"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_end_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "231-235",
          "snippet": "static inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\n\nstatic inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_cull",
          "args": [
            "cache",
            "path.dentry",
            "args"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_cull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "903-955",
          "snippet": "int cachefiles_cull(struct cachefiles_cache *cache, struct dentry *dir,\n\t\t    char *filename)\n{\n\tstruct dentry *victim;\n\tint ret;\n\n\t_enter(\",%pd/,%s\", dir, filename);\n\n\tvictim = cachefiles_check_active(cache, dir, filename);\n\tif (IS_ERR(victim))\n\t\treturn PTR_ERR(victim);\n\n\t_debug(\"victim -> %p %s\",\n\t       victim, victim->d_inode ? \"positive\" : \"negative\");\n\n\t/* okay... the victim is not being used so we can cull it\n\t * - start by marking it as stale\n\t */\n\t_debug(\"victim is cullable\");\n\n\tret = cachefiles_remove_object_xattr(cache, victim);\n\tif (ret < 0)\n\t\tgoto error_unlock;\n\n\t/*  actually remove the victim (drops the dir mutex) */\n\t_debug(\"bury\");\n\n\tret = cachefiles_bury_object(cache, dir, victim, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdput(victim);\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\nerror:\n\tdput(victim);\n\tif (ret == -ENOENT) {\n\t\t/* file or dir now absent - probably retired by netfs */\n\t\t_leave(\" = -ESTALE [absent]\");\n\t\treturn -ESTALE;\n\t}\n\n\tif (ret != -ENOMEM) {\n\t\tpr_err(\"Internal error: %d\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint cachefiles_cull(struct cachefiles_cache *cache, struct dentry *dir,\n\t\t    char *filename)\n{\n\tstruct dentry *victim;\n\tint ret;\n\n\t_enter(\",%pd/,%s\", dir, filename);\n\n\tvictim = cachefiles_check_active(cache, dir, filename);\n\tif (IS_ERR(victim))\n\t\treturn PTR_ERR(victim);\n\n\t_debug(\"victim -> %p %s\",\n\t       victim, victim->d_inode ? \"positive\" : \"negative\");\n\n\t/* okay... the victim is not being used so we can cull it\n\t * - start by marking it as stale\n\t */\n\t_debug(\"victim is cullable\");\n\n\tret = cachefiles_remove_object_xattr(cache, victim);\n\tif (ret < 0)\n\t\tgoto error_unlock;\n\n\t/*  actually remove the victim (drops the dir mutex) */\n\t_debug(\"bury\");\n\n\tret = cachefiles_bury_object(cache, dir, victim, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdput(victim);\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\nerror:\n\tdput(victim);\n\tif (ret == -ENOENT) {\n\t\t/* file or dir now absent - probably retired by netfs */\n\t\t_leave(\" = -ESTALE [absent]\");\n\t\treturn -ESTALE;\n\t}\n\n\tif (ret != -ENOMEM) {\n\t\tpr_err(\"Internal error: %d\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_begin_secure",
          "args": [
            "cache",
            "&saved_cred"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_begin_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "225-229",
          "snippet": "static inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);",
            "extern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\nextern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);\n\nstatic inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_can_lookup",
          "args": [
            "path.dentry"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_pwd",
          "args": [
            "current->fs",
            "&path"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cull applied to dead cache\\n\""
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHEFILES_DEAD",
            "&cache->flags"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cull applied to unready cache\\n\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "args",
            "'/'"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%s\"",
            "args"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *cache, char *args)\n{\n\tstruct path path;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\",%s\", args);\n\n\tif (strchr(args, '/'))\n\t\tgoto inval;\n\n\tif (!test_bit(CACHEFILES_READY, &cache->flags)) {\n\t\tpr_err(\"cull applied to unready cache\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (test_bit(CACHEFILES_DEAD, &cache->flags)) {\n\t\tpr_err(\"cull applied to dead cache\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* extract the directory dentry from the cwd */\n\tget_fs_pwd(current->fs, &path);\n\n\tif (!d_can_lookup(path.dentry))\n\t\tgoto notdir;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = cachefiles_cull(cache, path.dentry, args);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tpath_put(&path);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnotdir:\n\tpath_put(&path);\n\tpr_err(\"cull command requires dirfd to be a directory\\n\");\n\treturn -ENOTDIR;\n\ninval:\n\tpr_err(\"cull command requires dirfd and filename\\n\");\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "cachefiles_daemon_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "527-547",
    "snippet": "static int cachefiles_daemon_tag(struct cachefiles_cache *cache, char *args)\n{\n\tchar *tag;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args) {\n\t\tpr_err(\"Empty tag specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cache->tag)\n\t\treturn -EEXIST;\n\n\ttag = kstrdup(args, GFP_KERNEL);\n\tif (!tag)\n\t\treturn -ENOMEM;\n\n\tcache->tag = tag;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "args",
            "GFP_KERNEL"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Empty tag specified\\n\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%s\"",
            "args"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *cache, char *args)\n{\n\tchar *tag;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args) {\n\t\tpr_err(\"Empty tag specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cache->tag)\n\t\treturn -EEXIST;\n\n\ttag = kstrdup(args, GFP_KERNEL);\n\tif (!tag)\n\t\treturn -ENOMEM;\n\n\tcache->tag = tag;\n\treturn 0;\n}"
  },
  {
    "function_name": "cachefiles_daemon_secctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "499-521",
    "snippet": "static int cachefiles_daemon_secctx(struct cachefiles_cache *cache, char *args)\n{\n\tchar *secctx;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args) {\n\t\tpr_err(\"Empty security context specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cache->secctx) {\n\t\tpr_err(\"Second security context specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsecctx = kstrdup(args, GFP_KERNEL);\n\tif (!secctx)\n\t\treturn -ENOMEM;\n\n\tcache->secctx = secctx;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "args",
            "GFP_KERNEL"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Second security context specified\\n\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Empty security context specified\\n\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%s\"",
            "args"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *cache, char *args)\n{\n\tchar *secctx;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args) {\n\t\tpr_err(\"Empty security context specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cache->secctx) {\n\t\tpr_err(\"Second security context specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsecctx = kstrdup(args, GFP_KERNEL);\n\tif (!secctx)\n\t\treturn -ENOMEM;\n\n\tcache->secctx = secctx;\n\treturn 0;\n}"
  },
  {
    "function_name": "cachefiles_daemon_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "471-493",
    "snippet": "static int cachefiles_daemon_dir(struct cachefiles_cache *cache, char *args)\n{\n\tchar *dir;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args) {\n\t\tpr_err(\"Empty directory specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cache->rootdirname) {\n\t\tpr_err(\"Second cache directory specified\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\tdir = kstrdup(args, GFP_KERNEL);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tcache->rootdirname = dir;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "args",
            "GFP_KERNEL"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Second cache directory specified\\n\""
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Empty directory specified\\n\""
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%s\"",
            "args"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *cache, char *args)\n{\n\tchar *dir;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args) {\n\t\tpr_err(\"Empty directory specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cache->rootdirname) {\n\t\tpr_err(\"Second cache directory specified\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\tdir = kstrdup(args, GFP_KERNEL);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tcache->rootdirname = dir;\n\treturn 0;\n}"
  },
  {
    "function_name": "cachefiles_daemon_bstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "447-465",
    "snippet": "static int cachefiles_daemon_bstop(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long bstop;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tbstop = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (bstop < 0 || bstop >= cache->bcull_percent)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->bstop_percent = bstop;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cachefiles_daemon_range_error",
          "args": [
            "cache",
            "args"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_range_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "315-321",
          "snippet": "static int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "args",
            "&args",
            "10"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%s\"",
            "args"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long bstop;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tbstop = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (bstop < 0 || bstop >= cache->bcull_percent)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->bstop_percent = bstop;\n\treturn 0;\n}"
  },
  {
    "function_name": "cachefiles_daemon_bcull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "423-441",
    "snippet": "static int cachefiles_daemon_bcull(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long bcull;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tbcull = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (bcull <= cache->bstop_percent || bcull >= cache->brun_percent)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->bcull_percent = bcull;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cachefiles_daemon_range_error",
          "args": [
            "cache",
            "args"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_range_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "315-321",
          "snippet": "static int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "args",
            "&args",
            "10"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%s\"",
            "args"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long bcull;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tbcull = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (bcull <= cache->bstop_percent || bcull >= cache->brun_percent)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->bcull_percent = bcull;\n\treturn 0;\n}"
  },
  {
    "function_name": "cachefiles_daemon_brun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "399-417",
    "snippet": "static int cachefiles_daemon_brun(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long brun;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tbrun = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (brun <= cache->bcull_percent || brun >= 100)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->brun_percent = brun;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cachefiles_daemon_range_error",
          "args": [
            "cache",
            "args"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_range_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "315-321",
          "snippet": "static int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "args",
            "&args",
            "10"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%s\"",
            "args"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long brun;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tbrun = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (brun <= cache->bcull_percent || brun >= 100)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->brun_percent = brun;\n\treturn 0;\n}"
  },
  {
    "function_name": "cachefiles_daemon_fstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "375-393",
    "snippet": "static int cachefiles_daemon_fstop(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long fstop;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tfstop = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (fstop < 0 || fstop >= cache->fcull_percent)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->fstop_percent = fstop;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cachefiles_daemon_range_error",
          "args": [
            "cache",
            "args"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_range_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "315-321",
          "snippet": "static int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "args",
            "&args",
            "10"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%s\"",
            "args"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long fstop;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tfstop = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (fstop < 0 || fstop >= cache->fcull_percent)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->fstop_percent = fstop;\n\treturn 0;\n}"
  },
  {
    "function_name": "cachefiles_daemon_fcull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "351-369",
    "snippet": "static int cachefiles_daemon_fcull(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long fcull;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tfcull = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (fcull <= cache->fstop_percent || fcull >= cache->frun_percent)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->fcull_percent = fcull;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cachefiles_daemon_range_error",
          "args": [
            "cache",
            "args"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_range_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "315-321",
          "snippet": "static int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "args",
            "&args",
            "10"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%s\"",
            "args"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long fcull;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tfcull = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (fcull <= cache->fstop_percent || fcull >= cache->frun_percent)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->fcull_percent = fcull;\n\treturn 0;\n}"
  },
  {
    "function_name": "cachefiles_daemon_frun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "327-345",
    "snippet": "static int cachefiles_daemon_frun(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long frun;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tfrun = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (frun <= cache->fcull_percent || frun >= 100)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->frun_percent = frun;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cachefiles_daemon_range_error",
          "args": [
            "cache",
            "args"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_range_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "315-321",
          "snippet": "static int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "args",
            "&args",
            "10"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%s\"",
            "args"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long frun;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tfrun = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (frun <= cache->fcull_percent || frun >= 100)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->frun_percent = frun;\n\treturn 0;\n}"
  },
  {
    "function_name": "cachefiles_daemon_range_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "315-321",
    "snippet": "static int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\""
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "cachefiles_daemon_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "293-309",
    "snippet": "static unsigned int cachefiles_daemon_poll(struct file *file,\n\t\t\t\t\t   struct poll_table_struct *poll)\n{\n\tstruct cachefiles_cache *cache = file->private_data;\n\tunsigned int mask;\n\n\tpoll_wait(file, &cache->daemon_pollwq, poll);\n\tmask = 0;\n\n\tif (test_bit(CACHEFILES_STATE_CHANGED, &cache->flags))\n\t\tmask |= POLLIN;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags))\n\t\tmask |= POLLOUT;\n\n\treturn mask;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_open(struct inode *, struct file *);",
      "static int cachefiles_daemon_release(struct inode *, struct file *);",
      "static unsigned int cachefiles_daemon_poll(struct file *,\n\t\t\t\t\t   struct poll_table_struct *);",
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHEFILES_CULLING",
            "&cache->flags"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&cache->daemon_pollwq",
            "poll"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_open(struct inode *, struct file *);\nstatic int cachefiles_daemon_release(struct inode *, struct file *);\nstatic unsigned int cachefiles_daemon_poll(struct file *,\n\t\t\t\t\t   struct poll_table_struct *);\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic unsigned int cachefiles_daemon_poll(struct file *file,\n\t\t\t\t\t   struct poll_table_struct *poll)\n{\n\tstruct cachefiles_cache *cache = file->private_data;\n\tunsigned int mask;\n\n\tpoll_wait(file, &cache->daemon_pollwq, poll);\n\tmask = 0;\n\n\tif (test_bit(CACHEFILES_STATE_CHANGED, &cache->flags))\n\t\tmask |= POLLIN;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags))\n\t\tmask |= POLLOUT;\n\n\treturn mask;\n}"
  },
  {
    "function_name": "cachefiles_daemon_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "208-287",
    "snippet": "static ssize_t cachefiles_daemon_write(struct file *file,\n\t\t\t\t       const char __user *_data,\n\t\t\t\t       size_t datalen,\n\t\t\t\t       loff_t *pos)\n{\n\tconst struct cachefiles_daemon_cmd *cmd;\n\tstruct cachefiles_cache *cache = file->private_data;\n\tssize_t ret;\n\tchar *data, *args, *cp;\n\n\t//_enter(\",,%zu,\", datalen);\n\n\tASSERT(cache);\n\n\tif (test_bit(CACHEFILES_DEAD, &cache->flags))\n\t\treturn -EIO;\n\n\tif (datalen < 0 || datalen > PAGE_SIZE - 1)\n\t\treturn -EOPNOTSUPP;\n\n\t/* drag the command string into the kernel so we can parse it */\n\tdata = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = -EFAULT;\n\tif (copy_from_user(data, _data, datalen) != 0)\n\t\tgoto error;\n\n\tdata[datalen] = '\\0';\n\n\tret = -EINVAL;\n\tif (memchr(data, '\\0', datalen))\n\t\tgoto error;\n\n\t/* strip any newline */\n\tcp = memchr(data, '\\n', datalen);\n\tif (cp) {\n\t\tif (cp == data)\n\t\t\tgoto error;\n\n\t\t*cp = '\\0';\n\t}\n\n\t/* parse the command */\n\tret = -EOPNOTSUPP;\n\n\tfor (args = data; *args; args++)\n\t\tif (isspace(*args))\n\t\t\tbreak;\n\tif (*args) {\n\t\tif (args == data)\n\t\t\tgoto error;\n\t\t*args = '\\0';\n\t\targs = skip_spaces(++args);\n\t}\n\n\t/* run the appropriate command handler */\n\tfor (cmd = cachefiles_daemon_cmds; cmd->name[0]; cmd++)\n\t\tif (strcmp(cmd->name, data) == 0)\n\t\t\tgoto found_command;\n\nerror:\n\tkfree(data);\n\t//_leave(\" = %zd\", ret);\n\treturn ret;\n\nfound_command:\n\tmutex_lock(&cache->daemon_mutex);\n\n\tret = -EIO;\n\tif (!test_bit(CACHEFILES_DEAD, &cache->flags))\n\t\tret = cmd->handler(cache, args);\n\n\tmutex_unlock(&cache->daemon_mutex);\n\n\tif (ret == 0)\n\t\tret = datalen;\n\tgoto error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_open(struct inode *, struct file *);",
      "static int cachefiles_daemon_release(struct inode *, struct file *);",
      "static ssize_t cachefiles_daemon_read(struct file *, char __user *, size_t,\n\t\t\t\t      loff_t *);",
      "static ssize_t cachefiles_daemon_write(struct file *, const char __user *,\n\t\t\t\t       size_t, loff_t *);",
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);",
      "static const struct cachefiles_daemon_cmd cachefiles_daemon_cmds[] = {\n\t{ \"bind\",\tcachefiles_daemon_bind\t\t},\n\t{ \"brun\",\tcachefiles_daemon_brun\t\t},\n\t{ \"bcull\",\tcachefiles_daemon_bcull\t\t},\n\t{ \"bstop\",\tcachefiles_daemon_bstop\t\t},\n\t{ \"cull\",\tcachefiles_daemon_cull\t\t},\n\t{ \"debug\",\tcachefiles_daemon_debug\t\t},\n\t{ \"dir\",\tcachefiles_daemon_dir\t\t},\n\t{ \"frun\",\tcachefiles_daemon_frun\t\t},\n\t{ \"fcull\",\tcachefiles_daemon_fcull\t\t},\n\t{ \"fstop\",\tcachefiles_daemon_fstop\t\t},\n\t{ \"inuse\",\tcachefiles_daemon_inuse\t\t},\n\t{ \"secctx\",\tcachefiles_daemon_secctx\t},\n\t{ \"tag\",\tcachefiles_daemon_tag\t\t},\n\t{ \"\",\t\tNULL\t\t\t\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cache->daemon_mutex"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd->handler",
          "args": [
            "cache",
            "args"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHEFILES_DEAD",
            "&cache->flags"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cache->daemon_mutex"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd->name",
            "data"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "++args"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*args"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "data",
            "'\\n'",
            "datalen"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "data",
            "'\\0'",
            "datalen"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "data",
            "_data",
            "datalen"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "datalen + 1",
            "GFP_KERNEL"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cache"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_open(struct inode *, struct file *);\nstatic int cachefiles_daemon_release(struct inode *, struct file *);\nstatic ssize_t cachefiles_daemon_read(struct file *, char __user *, size_t,\n\t\t\t\t      loff_t *);\nstatic ssize_t cachefiles_daemon_write(struct file *, const char __user *,\n\t\t\t\t       size_t, loff_t *);\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\nstatic const struct cachefiles_daemon_cmd cachefiles_daemon_cmds[] = {\n\t{ \"bind\",\tcachefiles_daemon_bind\t\t},\n\t{ \"brun\",\tcachefiles_daemon_brun\t\t},\n\t{ \"bcull\",\tcachefiles_daemon_bcull\t\t},\n\t{ \"bstop\",\tcachefiles_daemon_bstop\t\t},\n\t{ \"cull\",\tcachefiles_daemon_cull\t\t},\n\t{ \"debug\",\tcachefiles_daemon_debug\t\t},\n\t{ \"dir\",\tcachefiles_daemon_dir\t\t},\n\t{ \"frun\",\tcachefiles_daemon_frun\t\t},\n\t{ \"fcull\",\tcachefiles_daemon_fcull\t\t},\n\t{ \"fstop\",\tcachefiles_daemon_fstop\t\t},\n\t{ \"inuse\",\tcachefiles_daemon_inuse\t\t},\n\t{ \"secctx\",\tcachefiles_daemon_secctx\t},\n\t{ \"tag\",\tcachefiles_daemon_tag\t\t},\n\t{ \"\",\t\tNULL\t\t\t\t}\n};\n\nstatic ssize_t cachefiles_daemon_write(struct file *file,\n\t\t\t\t       const char __user *_data,\n\t\t\t\t       size_t datalen,\n\t\t\t\t       loff_t *pos)\n{\n\tconst struct cachefiles_daemon_cmd *cmd;\n\tstruct cachefiles_cache *cache = file->private_data;\n\tssize_t ret;\n\tchar *data, *args, *cp;\n\n\t//_enter(\",,%zu,\", datalen);\n\n\tASSERT(cache);\n\n\tif (test_bit(CACHEFILES_DEAD, &cache->flags))\n\t\treturn -EIO;\n\n\tif (datalen < 0 || datalen > PAGE_SIZE - 1)\n\t\treturn -EOPNOTSUPP;\n\n\t/* drag the command string into the kernel so we can parse it */\n\tdata = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = -EFAULT;\n\tif (copy_from_user(data, _data, datalen) != 0)\n\t\tgoto error;\n\n\tdata[datalen] = '\\0';\n\n\tret = -EINVAL;\n\tif (memchr(data, '\\0', datalen))\n\t\tgoto error;\n\n\t/* strip any newline */\n\tcp = memchr(data, '\\n', datalen);\n\tif (cp) {\n\t\tif (cp == data)\n\t\t\tgoto error;\n\n\t\t*cp = '\\0';\n\t}\n\n\t/* parse the command */\n\tret = -EOPNOTSUPP;\n\n\tfor (args = data; *args; args++)\n\t\tif (isspace(*args))\n\t\t\tbreak;\n\tif (*args) {\n\t\tif (args == data)\n\t\t\tgoto error;\n\t\t*args = '\\0';\n\t\targs = skip_spaces(++args);\n\t}\n\n\t/* run the appropriate command handler */\n\tfor (cmd = cachefiles_daemon_cmds; cmd->name[0]; cmd++)\n\t\tif (strcmp(cmd->name, data) == 0)\n\t\t\tgoto found_command;\n\nerror:\n\tkfree(data);\n\t//_leave(\" = %zd\", ret);\n\treturn ret;\n\nfound_command:\n\tmutex_lock(&cache->daemon_mutex);\n\n\tret = -EIO;\n\tif (!test_bit(CACHEFILES_DEAD, &cache->flags))\n\t\tret = cmd->handler(cache, args);\n\n\tmutex_unlock(&cache->daemon_mutex);\n\n\tif (ret == 0)\n\t\tret = datalen;\n\tgoto error;\n}"
  },
  {
    "function_name": "cachefiles_daemon_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "161-203",
    "snippet": "static ssize_t cachefiles_daemon_read(struct file *file, char __user *_buffer,\n\t\t\t\t      size_t buflen, loff_t *pos)\n{\n\tstruct cachefiles_cache *cache = file->private_data;\n\tchar buffer[256];\n\tint n;\n\n\t//_enter(\",,%zu,\", buflen);\n\n\tif (!test_bit(CACHEFILES_READY, &cache->flags))\n\t\treturn 0;\n\n\t/* check how much space the cache has */\n\tcachefiles_has_space(cache, 0, 0);\n\n\t/* summarise */\n\tclear_bit(CACHEFILES_STATE_CHANGED, &cache->flags);\n\n\tn = snprintf(buffer, sizeof(buffer),\n\t\t     \"cull=%c\"\n\t\t     \" frun=%llx\"\n\t\t     \" fcull=%llx\"\n\t\t     \" fstop=%llx\"\n\t\t     \" brun=%llx\"\n\t\t     \" bcull=%llx\"\n\t\t     \" bstop=%llx\",\n\t\t     test_bit(CACHEFILES_CULLING, &cache->flags) ? '1' : '0',\n\t\t     (unsigned long long) cache->frun,\n\t\t     (unsigned long long) cache->fcull,\n\t\t     (unsigned long long) cache->fstop,\n\t\t     (unsigned long long) cache->brun,\n\t\t     (unsigned long long) cache->bcull,\n\t\t     (unsigned long long) cache->bstop\n\t\t     );\n\n\tif (n > buflen)\n\t\treturn -EMSGSIZE;\n\n\tif (copy_to_user(_buffer, buffer, n) != 0)\n\t\treturn -EFAULT;\n\n\treturn n;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_open(struct inode *, struct file *);",
      "static int cachefiles_daemon_release(struct inode *, struct file *);",
      "static ssize_t cachefiles_daemon_read(struct file *, char __user *, size_t,\n\t\t\t\t      loff_t *);",
      "static ssize_t cachefiles_daemon_write(struct file *, const char __user *,\n\t\t\t\t       size_t, loff_t *);",
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "_buffer",
            "buffer",
            "n"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"cull=%c\"\n\t\t     \" frun=%llx\"\n\t\t     \" fcull=%llx\"\n\t\t     \" fstop=%llx\"\n\t\t     \" brun=%llx\"\n\t\t     \" bcull=%llx\"\n\t\t     \" bstop=%llx\"",
            "test_bit(CACHEFILES_CULLING, &cache->flags) ? '1' : '0'",
            "(unsigned long long) cache->frun",
            "(unsigned long long) cache->fcull",
            "(unsigned long long) cache->fstop",
            "(unsigned long long) cache->brun",
            "(unsigned long long) cache->bcull",
            "(unsigned long long) cache->bstop"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHEFILES_CULLING",
            "&cache->flags"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CACHEFILES_STATE_CHANGED",
            "&cache->flags"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_has_space",
          "args": [
            "cache",
            "0",
            "0"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_has_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "674-751",
          "snippet": "int cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nint cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr)\n{\n\tstruct kstatfs stats;\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\tint ret;\n\n\t//_enter(\"{%llu,%llu,%llu,%llu,%llu,%llu},%u,%u\",\n\t//       (unsigned long long) cache->frun,\n\t//       (unsigned long long) cache->fcull,\n\t//       (unsigned long long) cache->fstop,\n\t//       (unsigned long long) cache->brun,\n\t//       (unsigned long long) cache->bcull,\n\t//       (unsigned long long) cache->bstop,\n\t//       fnr, bnr);\n\n\t/* find out how many pages of blockdev are available */\n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tstats.f_bavail >>= cache->bshift;\n\n\t//_debug(\"avail %llu,%llu\",\n\t//       (unsigned long long) stats.f_ffree,\n\t//       (unsigned long long) stats.f_bavail);\n\n\t/* see if there is sufficient space */\n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (stats.f_bavail > bnr)\n\t\tstats.f_bavail -= bnr;\n\telse\n\t\tstats.f_bavail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    stats.f_bavail < cache->bstop)\n\t\tgoto begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    stats.f_bavail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    stats.f_bavail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t//_leave(\" = 0\");\n\treturn 0;\n\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_open(struct inode *, struct file *);\nstatic int cachefiles_daemon_release(struct inode *, struct file *);\nstatic ssize_t cachefiles_daemon_read(struct file *, char __user *, size_t,\n\t\t\t\t      loff_t *);\nstatic ssize_t cachefiles_daemon_write(struct file *, const char __user *,\n\t\t\t\t       size_t, loff_t *);\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic ssize_t cachefiles_daemon_read(struct file *file, char __user *_buffer,\n\t\t\t\t      size_t buflen, loff_t *pos)\n{\n\tstruct cachefiles_cache *cache = file->private_data;\n\tchar buffer[256];\n\tint n;\n\n\t//_enter(\",,%zu,\", buflen);\n\n\tif (!test_bit(CACHEFILES_READY, &cache->flags))\n\t\treturn 0;\n\n\t/* check how much space the cache has */\n\tcachefiles_has_space(cache, 0, 0);\n\n\t/* summarise */\n\tclear_bit(CACHEFILES_STATE_CHANGED, &cache->flags);\n\n\tn = snprintf(buffer, sizeof(buffer),\n\t\t     \"cull=%c\"\n\t\t     \" frun=%llx\"\n\t\t     \" fcull=%llx\"\n\t\t     \" fstop=%llx\"\n\t\t     \" brun=%llx\"\n\t\t     \" bcull=%llx\"\n\t\t     \" bstop=%llx\",\n\t\t     test_bit(CACHEFILES_CULLING, &cache->flags) ? '1' : '0',\n\t\t     (unsigned long long) cache->frun,\n\t\t     (unsigned long long) cache->fcull,\n\t\t     (unsigned long long) cache->fstop,\n\t\t     (unsigned long long) cache->brun,\n\t\t     (unsigned long long) cache->bcull,\n\t\t     (unsigned long long) cache->bstop\n\t\t     );\n\n\tif (n > buflen)\n\t\treturn -EMSGSIZE;\n\n\tif (copy_to_user(_buffer, buffer, n) != 0)\n\t\treturn -EFAULT;\n\n\treturn n;\n}"
  },
  {
    "function_name": "cachefiles_daemon_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "133-156",
    "snippet": "static int cachefiles_daemon_release(struct inode *inode, struct file *file)\n{\n\tstruct cachefiles_cache *cache = file->private_data;\n\n\t_enter(\"\");\n\n\tASSERT(cache);\n\n\tset_bit(CACHEFILES_DEAD, &cache->flags);\n\n\tcachefiles_daemon_unbind(cache);\n\n\tASSERT(!cache->active_nodes.rb_node);\n\n\t/* clean up the control file interface */\n\tcache->cachefilesd = NULL;\n\tfile->private_data = NULL;\n\tcachefiles_open = 0;\n\n\tkfree(cache);\n\n\t_leave(\"\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_open(struct inode *, struct file *);",
      "static int cachefiles_daemon_release(struct inode *, struct file *);",
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);",
      "static unsigned long cachefiles_open;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cache"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!cache->active_nodes.rb_node"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_daemon_unbind",
          "args": [
            "cache"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_unbind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/bind.c",
          "lines": "258-277",
          "snippet": "void cachefiles_daemon_unbind(struct cachefiles_cache *cache)\n{\n\t_enter(\"\");\n\n\tif (test_bit(CACHEFILES_READY, &cache->flags)) {\n\t\tpr_info(\"File cache on %s unregistering\\n\",\n\t\t\tcache->cache.identifier);\n\n\t\tfscache_withdraw_cache(&cache->cache);\n\t}\n\n\tdput(cache->graveyard);\n\tmntput(cache->mnt);\n\n\tkfree(cache->rootdirname);\n\tkfree(cache->secctx);\n\tkfree(cache->tag);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid cachefiles_daemon_unbind(struct cachefiles_cache *cache)\n{\n\t_enter(\"\");\n\n\tif (test_bit(CACHEFILES_READY, &cache->flags)) {\n\t\tpr_info(\"File cache on %s unregistering\\n\",\n\t\t\tcache->cache.identifier);\n\n\t\tfscache_withdraw_cache(&cache->cache);\n\t}\n\n\tdput(cache->graveyard);\n\tmntput(cache->mnt);\n\n\tkfree(cache->rootdirname);\n\tkfree(cache->secctx);\n\tkfree(cache->tag);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CACHEFILES_DEAD",
            "&cache->flags"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cache"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_open(struct inode *, struct file *);\nstatic int cachefiles_daemon_release(struct inode *, struct file *);\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\nstatic unsigned long cachefiles_open;\n\nstatic int cachefiles_daemon_release(struct inode *inode, struct file *file)\n{\n\tstruct cachefiles_cache *cache = file->private_data;\n\n\t_enter(\"\");\n\n\tASSERT(cache);\n\n\tset_bit(CACHEFILES_DEAD, &cache->flags);\n\n\tcachefiles_daemon_unbind(cache);\n\n\tASSERT(!cache->active_nodes.rb_node);\n\n\t/* clean up the control file interface */\n\tcache->cachefilesd = NULL;\n\tfile->private_data = NULL;\n\tcachefiles_open = 0;\n\n\tkfree(cache);\n\n\t_leave(\"\");\n\treturn 0;\n}"
  },
  {
    "function_name": "cachefiles_daemon_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
    "lines": "87-128",
    "snippet": "static int cachefiles_daemon_open(struct inode *inode, struct file *file)\n{\n\tstruct cachefiles_cache *cache;\n\n\t_enter(\"\");\n\n\t/* only the superuser may do this */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* the cachefiles device may only be open once at a time */\n\tif (xchg(&cachefiles_open, 1) == 1)\n\t\treturn -EBUSY;\n\n\t/* allocate a cache record */\n\tcache = kzalloc(sizeof(struct cachefiles_cache), GFP_KERNEL);\n\tif (!cache) {\n\t\tcachefiles_open = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&cache->daemon_mutex);\n\tcache->active_nodes = RB_ROOT;\n\trwlock_init(&cache->active_lock);\n\tinit_waitqueue_head(&cache->daemon_pollwq);\n\n\t/* set default caching limits\n\t * - limit at 1% free space and/or free files\n\t * - cull below 5% free space and/or free files\n\t * - cease culling above 7% free space and/or free files\n\t */\n\tcache->frun_percent = 7;\n\tcache->fcull_percent = 5;\n\tcache->fstop_percent = 1;\n\tcache->brun_percent = 7;\n\tcache->bcull_percent = 5;\n\tcache->bstop_percent = 1;\n\n\tfile->private_data = cache;\n\tcache->cachefilesd = file;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/completion.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_daemon_open(struct inode *, struct file *);",
      "static int cachefiles_daemon_release(struct inode *, struct file *);",
      "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
      "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);",
      "static unsigned long cachefiles_open;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&cache->daemon_pollwq"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&cache->active_lock"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&cache->daemon_mutex"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cachefiles_cache)",
            "GFP_KERNEL"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&cachefiles_open",
            "1"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_open(struct inode *, struct file *);\nstatic int cachefiles_daemon_release(struct inode *, struct file *);\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\nstatic unsigned long cachefiles_open;\n\nstatic int cachefiles_daemon_open(struct inode *inode, struct file *file)\n{\n\tstruct cachefiles_cache *cache;\n\n\t_enter(\"\");\n\n\t/* only the superuser may do this */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* the cachefiles device may only be open once at a time */\n\tif (xchg(&cachefiles_open, 1) == 1)\n\t\treturn -EBUSY;\n\n\t/* allocate a cache record */\n\tcache = kzalloc(sizeof(struct cachefiles_cache), GFP_KERNEL);\n\tif (!cache) {\n\t\tcachefiles_open = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&cache->daemon_mutex);\n\tcache->active_nodes = RB_ROOT;\n\trwlock_init(&cache->active_lock);\n\tinit_waitqueue_head(&cache->daemon_pollwq);\n\n\t/* set default caching limits\n\t * - limit at 1% free space and/or free files\n\t * - cull below 5% free space and/or free files\n\t * - cease culling above 7% free space and/or free files\n\t */\n\tcache->frun_percent = 7;\n\tcache->fcull_percent = 5;\n\tcache->fstop_percent = 1;\n\tcache->brun_percent = 7;\n\tcache->bcull_percent = 5;\n\tcache->bstop_percent = 1;\n\n\tfile->private_data = cache;\n\tcache->cachefilesd = file;\n\treturn 0;\n}"
  }
]