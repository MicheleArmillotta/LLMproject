[
  {
    "function_name": "exit_nilfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1478-1483",
    "snippet": "static void __exit exit_nilfs_fs(void)\n{\n\tnilfs_destroy_cachep();\n\tnilfs_sysfs_exit();\n\tunregister_filesystem(&nilfs_fs_type);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct file_system_type nilfs_fs_type = {\n\t.owner    = THIS_MODULE,\n\t.name     = \"nilfs2\",\n\t.mount    = nilfs_mount,\n\t.kill_sb  = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&nilfs_fs_type"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sysfs_exit",
          "args": [],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sysfs_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sysfs.c",
          "lines": "1133-1137",
          "snippet": "void nilfs_sysfs_exit(void)\n{\n\tsysfs_remove_group(&nilfs_kset->kobj, &nilfs_feature_attr_group);\n\tkset_unregister(nilfs_kset);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *nilfs_kset;",
            "static const struct attribute_group nilfs_feature_attr_group = {\n\t.name = \"features\",\n\t.attrs = nilfs_feature_attrs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/kobject.h>\n\nstatic struct kset *nilfs_kset;\nstatic const struct attribute_group nilfs_feature_attr_group = {\n\t.name = \"features\",\n\t.attrs = nilfs_feature_attrs,\n};\n\nvoid nilfs_sysfs_exit(void)\n{\n\tsysfs_remove_group(&nilfs_kset->kobj, &nilfs_feature_attr_group);\n\tkset_unregister(nilfs_kset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_destroy_cachep",
          "args": [],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_destroy_cachep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "1400-1416",
          "snippet": "static void nilfs_destroy_cachep(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tif (nilfs_inode_cachep)\n\t\tkmem_cache_destroy(nilfs_inode_cachep);\n\tif (nilfs_transaction_cachep)\n\t\tkmem_cache_destroy(nilfs_transaction_cachep);\n\tif (nilfs_segbuf_cachep)\n\t\tkmem_cache_destroy(nilfs_segbuf_cachep);\n\tif (nilfs_btree_path_cache)\n\t\tkmem_cache_destroy(nilfs_btree_path_cache);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nilfs_inode_cachep;",
            "struct kmem_cache *nilfs_transaction_cachep;",
            "struct kmem_cache *nilfs_segbuf_cachep;",
            "struct kmem_cache *nilfs_btree_path_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *nilfs_inode_cachep;\nstruct kmem_cache *nilfs_transaction_cachep;\nstruct kmem_cache *nilfs_segbuf_cachep;\nstruct kmem_cache *nilfs_btree_path_cache;\n\nstatic void nilfs_destroy_cachep(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tif (nilfs_inode_cachep)\n\t\tkmem_cache_destroy(nilfs_inode_cachep);\n\tif (nilfs_transaction_cachep)\n\t\tkmem_cache_destroy(nilfs_transaction_cachep);\n\tif (nilfs_segbuf_cachep)\n\t\tkmem_cache_destroy(nilfs_segbuf_cachep);\n\tif (nilfs_btree_path_cache)\n\t\tkmem_cache_destroy(nilfs_btree_path_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstruct file_system_type nilfs_fs_type = {\n\t.owner    = THIS_MODULE,\n\t.name     = \"nilfs2\",\n\t.mount    = nilfs_mount,\n\t.kill_sb  = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_nilfs_fs(void)\n{\n\tnilfs_destroy_cachep();\n\tnilfs_sysfs_exit();\n\tunregister_filesystem(&nilfs_fs_type);\n}"
  },
  {
    "function_name": "init_nilfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1451-1476",
    "snippet": "static int __init init_nilfs_fs(void)\n{\n\tint err;\n\n\terr = nilfs_init_cachep();\n\tif (err)\n\t\tgoto fail;\n\n\terr = nilfs_sysfs_init();\n\tif (err)\n\t\tgoto free_cachep;\n\n\terr = register_filesystem(&nilfs_fs_type);\n\tif (err)\n\t\tgoto deinit_sysfs_entry;\n\n\tprintk(KERN_INFO \"NILFS version 2 loaded\\n\");\n\treturn 0;\n\ndeinit_sysfs_entry:\n\tnilfs_sysfs_exit();\nfree_cachep:\n\tnilfs_destroy_cachep();\nfail:\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct file_system_type nilfs_fs_type = {\n\t.owner    = THIS_MODULE,\n\t.name     = \"nilfs2\",\n\t.mount    = nilfs_mount,\n\t.kill_sb  = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_destroy_cachep",
          "args": [],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_destroy_cachep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "1400-1416",
          "snippet": "static void nilfs_destroy_cachep(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tif (nilfs_inode_cachep)\n\t\tkmem_cache_destroy(nilfs_inode_cachep);\n\tif (nilfs_transaction_cachep)\n\t\tkmem_cache_destroy(nilfs_transaction_cachep);\n\tif (nilfs_segbuf_cachep)\n\t\tkmem_cache_destroy(nilfs_segbuf_cachep);\n\tif (nilfs_btree_path_cache)\n\t\tkmem_cache_destroy(nilfs_btree_path_cache);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nilfs_inode_cachep;",
            "struct kmem_cache *nilfs_transaction_cachep;",
            "struct kmem_cache *nilfs_segbuf_cachep;",
            "struct kmem_cache *nilfs_btree_path_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *nilfs_inode_cachep;\nstruct kmem_cache *nilfs_transaction_cachep;\nstruct kmem_cache *nilfs_segbuf_cachep;\nstruct kmem_cache *nilfs_btree_path_cache;\n\nstatic void nilfs_destroy_cachep(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tif (nilfs_inode_cachep)\n\t\tkmem_cache_destroy(nilfs_inode_cachep);\n\tif (nilfs_transaction_cachep)\n\t\tkmem_cache_destroy(nilfs_transaction_cachep);\n\tif (nilfs_segbuf_cachep)\n\t\tkmem_cache_destroy(nilfs_segbuf_cachep);\n\tif (nilfs_btree_path_cache)\n\t\tkmem_cache_destroy(nilfs_btree_path_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sysfs_exit",
          "args": [],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sysfs_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sysfs.c",
          "lines": "1133-1137",
          "snippet": "void nilfs_sysfs_exit(void)\n{\n\tsysfs_remove_group(&nilfs_kset->kobj, &nilfs_feature_attr_group);\n\tkset_unregister(nilfs_kset);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *nilfs_kset;",
            "static const struct attribute_group nilfs_feature_attr_group = {\n\t.name = \"features\",\n\t.attrs = nilfs_feature_attrs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/kobject.h>\n\nstatic struct kset *nilfs_kset;\nstatic const struct attribute_group nilfs_feature_attr_group = {\n\t.name = \"features\",\n\t.attrs = nilfs_feature_attrs,\n};\n\nvoid nilfs_sysfs_exit(void)\n{\n\tsysfs_remove_group(&nilfs_kset->kobj, &nilfs_feature_attr_group);\n\tkset_unregister(nilfs_kset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"NILFS version 2 loaded\\n\""
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&nilfs_fs_type"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sysfs_init",
          "args": [],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sysfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sysfs.c",
          "lines": "1105-1131",
          "snippet": "int __init nilfs_sysfs_init(void)\n{\n\tint err;\n\n\tnilfs_kset = kset_create_and_add(NILFS_ROOT_GROUP_NAME, NULL, fs_kobj);\n\tif (!nilfs_kset) {\n\t\terr = -ENOMEM;\n\t\tprintk(KERN_ERR \"NILFS: unable to create sysfs entry: err %d\\n\",\n\t\t\terr);\n\t\tgoto failed_sysfs_init;\n\t}\n\n\terr = sysfs_create_group(&nilfs_kset->kobj, &nilfs_feature_attr_group);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR \"NILFS: unable to create feature group: err %d\\n\",\n\t\t\terr);\n\t\tgoto cleanup_sysfs_init;\n\t}\n\n\treturn 0;\n\ncleanup_sysfs_init:\n\tkset_unregister(nilfs_kset);\n\nfailed_sysfs_init:\n\treturn err;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *nilfs_kset;",
            "static const struct attribute_group nilfs_feature_attr_group = {\n\t.name = \"features\",\n\t.attrs = nilfs_feature_attrs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/kobject.h>\n\nstatic struct kset *nilfs_kset;\nstatic const struct attribute_group nilfs_feature_attr_group = {\n\t.name = \"features\",\n\t.attrs = nilfs_feature_attrs,\n};\n\nint __init nilfs_sysfs_init(void)\n{\n\tint err;\n\n\tnilfs_kset = kset_create_and_add(NILFS_ROOT_GROUP_NAME, NULL, fs_kobj);\n\tif (!nilfs_kset) {\n\t\terr = -ENOMEM;\n\t\tprintk(KERN_ERR \"NILFS: unable to create sysfs entry: err %d\\n\",\n\t\t\terr);\n\t\tgoto failed_sysfs_init;\n\t}\n\n\terr = sysfs_create_group(&nilfs_kset->kobj, &nilfs_feature_attr_group);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR \"NILFS: unable to create feature group: err %d\\n\",\n\t\t\terr);\n\t\tgoto cleanup_sysfs_init;\n\t}\n\n\treturn 0;\n\ncleanup_sysfs_init:\n\tkset_unregister(nilfs_kset);\n\nfailed_sysfs_init:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_init_cachep",
          "args": [],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_init_cachep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "1418-1449",
          "snippet": "static int __init nilfs_init_cachep(void)\n{\n\tnilfs_inode_cachep = kmem_cache_create(\"nilfs2_inode_cache\",\n\t\t\tsizeof(struct nilfs_inode_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, nilfs_inode_init_once);\n\tif (!nilfs_inode_cachep)\n\t\tgoto fail;\n\n\tnilfs_transaction_cachep = kmem_cache_create(\"nilfs2_transaction_cache\",\n\t\t\tsizeof(struct nilfs_transaction_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, NULL);\n\tif (!nilfs_transaction_cachep)\n\t\tgoto fail;\n\n\tnilfs_segbuf_cachep = kmem_cache_create(\"nilfs2_segbuf_cache\",\n\t\t\tsizeof(struct nilfs_segment_buffer), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, nilfs_segbuf_init_once);\n\tif (!nilfs_segbuf_cachep)\n\t\tgoto fail;\n\n\tnilfs_btree_path_cache = kmem_cache_create(\"nilfs2_btree_path_cache\",\n\t\t\tsizeof(struct nilfs_btree_path) * NILFS_BTREE_LEVEL_MAX,\n\t\t\t0, 0, NULL);\n\tif (!nilfs_btree_path_cache)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tnilfs_destroy_cachep();\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nilfs_inode_cachep;",
            "struct kmem_cache *nilfs_transaction_cachep;",
            "struct kmem_cache *nilfs_segbuf_cachep;",
            "struct kmem_cache *nilfs_btree_path_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *nilfs_inode_cachep;\nstruct kmem_cache *nilfs_transaction_cachep;\nstruct kmem_cache *nilfs_segbuf_cachep;\nstruct kmem_cache *nilfs_btree_path_cache;\n\nstatic int __init nilfs_init_cachep(void)\n{\n\tnilfs_inode_cachep = kmem_cache_create(\"nilfs2_inode_cache\",\n\t\t\tsizeof(struct nilfs_inode_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, nilfs_inode_init_once);\n\tif (!nilfs_inode_cachep)\n\t\tgoto fail;\n\n\tnilfs_transaction_cachep = kmem_cache_create(\"nilfs2_transaction_cache\",\n\t\t\tsizeof(struct nilfs_transaction_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, NULL);\n\tif (!nilfs_transaction_cachep)\n\t\tgoto fail;\n\n\tnilfs_segbuf_cachep = kmem_cache_create(\"nilfs2_segbuf_cache\",\n\t\t\tsizeof(struct nilfs_segment_buffer), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, nilfs_segbuf_init_once);\n\tif (!nilfs_segbuf_cachep)\n\t\tgoto fail;\n\n\tnilfs_btree_path_cache = kmem_cache_create(\"nilfs2_btree_path_cache\",\n\t\t\tsizeof(struct nilfs_btree_path) * NILFS_BTREE_LEVEL_MAX,\n\t\t\t0, 0, NULL);\n\tif (!nilfs_btree_path_cache)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tnilfs_destroy_cachep();\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstruct file_system_type nilfs_fs_type = {\n\t.owner    = THIS_MODULE,\n\t.name     = \"nilfs2\",\n\t.mount    = nilfs_mount,\n\t.kill_sb  = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV,\n};\n\nstatic int __init init_nilfs_fs(void)\n{\n\tint err;\n\n\terr = nilfs_init_cachep();\n\tif (err)\n\t\tgoto fail;\n\n\terr = nilfs_sysfs_init();\n\tif (err)\n\t\tgoto free_cachep;\n\n\terr = register_filesystem(&nilfs_fs_type);\n\tif (err)\n\t\tgoto deinit_sysfs_entry;\n\n\tprintk(KERN_INFO \"NILFS version 2 loaded\\n\");\n\treturn 0;\n\ndeinit_sysfs_entry:\n\tnilfs_sysfs_exit();\nfree_cachep:\n\tnilfs_destroy_cachep();\nfail:\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_init_cachep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1418-1449",
    "snippet": "static int __init nilfs_init_cachep(void)\n{\n\tnilfs_inode_cachep = kmem_cache_create(\"nilfs2_inode_cache\",\n\t\t\tsizeof(struct nilfs_inode_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, nilfs_inode_init_once);\n\tif (!nilfs_inode_cachep)\n\t\tgoto fail;\n\n\tnilfs_transaction_cachep = kmem_cache_create(\"nilfs2_transaction_cache\",\n\t\t\tsizeof(struct nilfs_transaction_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, NULL);\n\tif (!nilfs_transaction_cachep)\n\t\tgoto fail;\n\n\tnilfs_segbuf_cachep = kmem_cache_create(\"nilfs2_segbuf_cache\",\n\t\t\tsizeof(struct nilfs_segment_buffer), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, nilfs_segbuf_init_once);\n\tif (!nilfs_segbuf_cachep)\n\t\tgoto fail;\n\n\tnilfs_btree_path_cache = kmem_cache_create(\"nilfs2_btree_path_cache\",\n\t\t\tsizeof(struct nilfs_btree_path) * NILFS_BTREE_LEVEL_MAX,\n\t\t\t0, 0, NULL);\n\tif (!nilfs_btree_path_cache)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tnilfs_destroy_cachep();\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nilfs_inode_cachep;",
      "struct kmem_cache *nilfs_transaction_cachep;",
      "struct kmem_cache *nilfs_segbuf_cachep;",
      "struct kmem_cache *nilfs_btree_path_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_destroy_cachep",
          "args": [],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_destroy_cachep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "1400-1416",
          "snippet": "static void nilfs_destroy_cachep(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tif (nilfs_inode_cachep)\n\t\tkmem_cache_destroy(nilfs_inode_cachep);\n\tif (nilfs_transaction_cachep)\n\t\tkmem_cache_destroy(nilfs_transaction_cachep);\n\tif (nilfs_segbuf_cachep)\n\t\tkmem_cache_destroy(nilfs_segbuf_cachep);\n\tif (nilfs_btree_path_cache)\n\t\tkmem_cache_destroy(nilfs_btree_path_cache);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nilfs_inode_cachep;",
            "struct kmem_cache *nilfs_transaction_cachep;",
            "struct kmem_cache *nilfs_segbuf_cachep;",
            "struct kmem_cache *nilfs_btree_path_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *nilfs_inode_cachep;\nstruct kmem_cache *nilfs_transaction_cachep;\nstruct kmem_cache *nilfs_segbuf_cachep;\nstruct kmem_cache *nilfs_btree_path_cache;\n\nstatic void nilfs_destroy_cachep(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tif (nilfs_inode_cachep)\n\t\tkmem_cache_destroy(nilfs_inode_cachep);\n\tif (nilfs_transaction_cachep)\n\t\tkmem_cache_destroy(nilfs_transaction_cachep);\n\tif (nilfs_segbuf_cachep)\n\t\tkmem_cache_destroy(nilfs_segbuf_cachep);\n\tif (nilfs_btree_path_cache)\n\t\tkmem_cache_destroy(nilfs_btree_path_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nilfs2_btree_path_cache\"",
            "sizeof(struct nilfs_btree_path) * NILFS_BTREE_LEVEL_MAX",
            "0",
            "0",
            "NULL"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nilfs2_segbuf_cache\"",
            "sizeof(struct nilfs_segment_buffer)",
            "0",
            "SLAB_RECLAIM_ACCOUNT",
            "nilfs_segbuf_init_once"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nilfs2_transaction_cache\"",
            "sizeof(struct nilfs_transaction_info)",
            "0",
            "SLAB_RECLAIM_ACCOUNT",
            "NULL"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nilfs2_inode_cache\"",
            "sizeof(struct nilfs_inode_info)",
            "0",
            "SLAB_RECLAIM_ACCOUNT",
            "nilfs_inode_init_once"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *nilfs_inode_cachep;\nstruct kmem_cache *nilfs_transaction_cachep;\nstruct kmem_cache *nilfs_segbuf_cachep;\nstruct kmem_cache *nilfs_btree_path_cache;\n\nstatic int __init nilfs_init_cachep(void)\n{\n\tnilfs_inode_cachep = kmem_cache_create(\"nilfs2_inode_cache\",\n\t\t\tsizeof(struct nilfs_inode_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, nilfs_inode_init_once);\n\tif (!nilfs_inode_cachep)\n\t\tgoto fail;\n\n\tnilfs_transaction_cachep = kmem_cache_create(\"nilfs2_transaction_cache\",\n\t\t\tsizeof(struct nilfs_transaction_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, NULL);\n\tif (!nilfs_transaction_cachep)\n\t\tgoto fail;\n\n\tnilfs_segbuf_cachep = kmem_cache_create(\"nilfs2_segbuf_cache\",\n\t\t\tsizeof(struct nilfs_segment_buffer), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, nilfs_segbuf_init_once);\n\tif (!nilfs_segbuf_cachep)\n\t\tgoto fail;\n\n\tnilfs_btree_path_cache = kmem_cache_create(\"nilfs2_btree_path_cache\",\n\t\t\tsizeof(struct nilfs_btree_path) * NILFS_BTREE_LEVEL_MAX,\n\t\t\t0, 0, NULL);\n\tif (!nilfs_btree_path_cache)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tnilfs_destroy_cachep();\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "nilfs_destroy_cachep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1400-1416",
    "snippet": "static void nilfs_destroy_cachep(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tif (nilfs_inode_cachep)\n\t\tkmem_cache_destroy(nilfs_inode_cachep);\n\tif (nilfs_transaction_cachep)\n\t\tkmem_cache_destroy(nilfs_transaction_cachep);\n\tif (nilfs_segbuf_cachep)\n\t\tkmem_cache_destroy(nilfs_segbuf_cachep);\n\tif (nilfs_btree_path_cache)\n\t\tkmem_cache_destroy(nilfs_btree_path_cache);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nilfs_inode_cachep;",
      "struct kmem_cache *nilfs_transaction_cachep;",
      "struct kmem_cache *nilfs_segbuf_cachep;",
      "struct kmem_cache *nilfs_btree_path_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nilfs_btree_path_cache"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nilfs_segbuf_cachep"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nilfs_transaction_cachep"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nilfs_inode_cachep"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *nilfs_inode_cachep;\nstruct kmem_cache *nilfs_transaction_cachep;\nstruct kmem_cache *nilfs_segbuf_cachep;\nstruct kmem_cache *nilfs_btree_path_cache;\n\nstatic void nilfs_destroy_cachep(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tif (nilfs_inode_cachep)\n\t\tkmem_cache_destroy(nilfs_inode_cachep);\n\tif (nilfs_transaction_cachep)\n\t\tkmem_cache_destroy(nilfs_transaction_cachep);\n\tif (nilfs_segbuf_cachep)\n\t\tkmem_cache_destroy(nilfs_segbuf_cachep);\n\tif (nilfs_btree_path_cache)\n\t\tkmem_cache_destroy(nilfs_btree_path_cache);\n}"
  },
  {
    "function_name": "nilfs_segbuf_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1395-1398",
    "snippet": "static void nilfs_segbuf_init_once(void *obj)\n{\n\tmemset(obj, 0, sizeof(struct nilfs_segment_buffer));\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "obj",
            "0",
            "sizeof(struct nilfs_segment_buffer)"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void nilfs_segbuf_init_once(void *obj)\n{\n\tmemset(obj, 0, sizeof(struct nilfs_segment_buffer));\n}"
  },
  {
    "function_name": "nilfs_inode_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1382-1393",
    "snippet": "static void nilfs_inode_init_once(void *obj)\n{\n\tstruct nilfs_inode_info *ii = obj;\n\n\tINIT_LIST_HEAD(&ii->i_dirty);\n#ifdef CONFIG_NILFS_XATTR\n\tinit_rwsem(&ii->xattr_sem);\n#endif\n\taddress_space_init_once(&ii->i_btnode_cache);\n\tii->i_bmap = &ii->i_bmap_data;\n\tinode_init_once(&ii->vfs_inode);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ii->vfs_inode"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "1382-1393",
          "snippet": "static void nilfs_inode_init_once(void *obj)\n{\n\tstruct nilfs_inode_info *ii = obj;\n\n\tINIT_LIST_HEAD(&ii->i_dirty);\n#ifdef CONFIG_NILFS_XATTR\n\tinit_rwsem(&ii->xattr_sem);\n#endif\n\taddress_space_init_once(&ii->i_btnode_cache);\n\tii->i_bmap = &ii->i_bmap_data;\n\tinode_init_once(&ii->vfs_inode);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "address_space_init_once",
          "args": [
            "&ii->i_btnode_cache"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "address_space_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "338-347",
          "snippet": "void address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\tINIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);\n\tspin_lock_init(&mapping->tree_lock);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\tINIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);\n\tspin_lock_init(&mapping->tree_lock);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&ii->xattr_sem"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ii->i_dirty"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void nilfs_inode_init_once(void *obj)\n{\n\tstruct nilfs_inode_info *ii = obj;\n\n\tINIT_LIST_HEAD(&ii->i_dirty);\n#ifdef CONFIG_NILFS_XATTR\n\tinit_rwsem(&ii->xattr_sem);\n#endif\n\taddress_space_init_once(&ii->i_btnode_cache);\n\tii->i_bmap = &ii->i_bmap_data;\n\tinode_init_once(&ii->vfs_inode);\n}"
  },
  {
    "function_name": "nilfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1272-1371",
    "snippet": "static struct dentry *\nnilfs_mount(struct file_system_type *fs_type, int flags,\n\t     const char *dev_name, void *data)\n{\n\tstruct nilfs_super_data sd;\n\tstruct super_block *s;\n\tfmode_t mode = FMODE_READ | FMODE_EXCL;\n\tstruct dentry *root_dentry;\n\tint err, s_new = false;\n\n\tif (!(flags & MS_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\tsd.bdev = blkdev_get_by_path(dev_name, mode, fs_type);\n\tif (IS_ERR(sd.bdev))\n\t\treturn ERR_CAST(sd.bdev);\n\n\tsd.cno = 0;\n\tsd.flags = flags;\n\tif (nilfs_identify((char *)data, &sd)) {\n\t\terr = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\t/*\n\t * once the super is inserted into the list by sget, s_umount\n\t * will protect the lockfs code from trying to start a snapshot\n\t * while we are mounting\n\t */\n\tmutex_lock(&sd.bdev->bd_fsfreeze_mutex);\n\tif (sd.bdev->bd_fsfreeze_count > 0) {\n\t\tmutex_unlock(&sd.bdev->bd_fsfreeze_mutex);\n\t\terr = -EBUSY;\n\t\tgoto failed;\n\t}\n\ts = sget(fs_type, nilfs_test_bdev_super, nilfs_set_bdev_super, flags,\n\t\t sd.bdev);\n\tmutex_unlock(&sd.bdev->bd_fsfreeze_mutex);\n\tif (IS_ERR(s)) {\n\t\terr = PTR_ERR(s);\n\t\tgoto failed;\n\t}\n\n\tif (!s->s_root) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\ts_new = true;\n\n\t\t/* New superblock instance created */\n\t\ts->s_mode = mode;\n\t\tstrlcpy(s->s_id, bdevname(sd.bdev, b), sizeof(s->s_id));\n\t\tsb_set_blocksize(s, block_size(sd.bdev));\n\n\t\terr = nilfs_fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (err)\n\t\t\tgoto failed_super;\n\n\t\ts->s_flags |= MS_ACTIVE;\n\t} else if (!sd.cno) {\n\t\tif (nilfs_tree_is_busy(s->s_root)) {\n\t\t\tif ((flags ^ s->s_flags) & MS_RDONLY) {\n\t\t\t\tprintk(KERN_ERR \"NILFS: the device already \"\n\t\t\t\t       \"has a %s mount.\\n\",\n\t\t\t\t       (s->s_flags & MS_RDONLY) ?\n\t\t\t\t       \"read-only\" : \"read/write\");\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto failed_super;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Try remount to setup mount states if the current\n\t\t\t * tree is not mounted and only snapshots use this sb.\n\t\t\t */\n\t\t\terr = nilfs_remount(s, &flags, data);\n\t\t\tif (err)\n\t\t\t\tgoto failed_super;\n\t\t}\n\t}\n\n\tif (sd.cno) {\n\t\terr = nilfs_attach_snapshot(s, sd.cno, &root_dentry);\n\t\tif (err)\n\t\t\tgoto failed_super;\n\t} else {\n\t\troot_dentry = dget(s->s_root);\n\t}\n\n\tif (!s_new)\n\t\tblkdev_put(sd.bdev, mode);\n\n\treturn root_dentry;\n\n failed_super:\n\tdeactivate_locked_super(s);\n\n failed:\n\tif (!s_new)\n\t\tblkdev_put(sd.bdev, mode);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "sd.bdev",
            "mode"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "s->s_root"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_attach_snapshot",
          "args": [
            "s",
            "sd.cno",
            "&root_dentry"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_attach_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "966-1001",
          "snippet": "static int nilfs_attach_snapshot(struct super_block *s, __u64 cno,\n\t\t\t\t struct dentry **root_dentry)\n{\n\tstruct the_nilfs *nilfs = s->s_fs_info;\n\tstruct nilfs_root *root;\n\tint ret;\n\n\tmutex_lock(&nilfs->ns_snapshot_mount_mutex);\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_is_snapshot(nilfs->ns_cpfile, cno);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0) {\n\t\tret = (ret == -ENOENT) ? -EINVAL : ret;\n\t\tgoto out;\n\t} else if (!ret) {\n\t\tprintk(KERN_ERR \"NILFS: The specified checkpoint is \"\n\t\t       \"not a snapshot (checkpoint number=%llu).\\n\",\n\t\t       (unsigned long long)cno);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = nilfs_attach_checkpoint(s, cno, false, &root);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"NILFS: error loading snapshot \"\n\t\t       \"(checkpoint number=%llu).\\n\",\n\t       (unsigned long long)cno);\n\t\tgoto out;\n\t}\n\tret = nilfs_get_root_dentry(s, root, root_dentry);\n\tnilfs_put_root(root);\n out:\n\tmutex_unlock(&nilfs->ns_snapshot_mount_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_attach_snapshot(struct super_block *s, __u64 cno,\n\t\t\t\t struct dentry **root_dentry)\n{\n\tstruct the_nilfs *nilfs = s->s_fs_info;\n\tstruct nilfs_root *root;\n\tint ret;\n\n\tmutex_lock(&nilfs->ns_snapshot_mount_mutex);\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_is_snapshot(nilfs->ns_cpfile, cno);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0) {\n\t\tret = (ret == -ENOENT) ? -EINVAL : ret;\n\t\tgoto out;\n\t} else if (!ret) {\n\t\tprintk(KERN_ERR \"NILFS: The specified checkpoint is \"\n\t\t       \"not a snapshot (checkpoint number=%llu).\\n\",\n\t\t       (unsigned long long)cno);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = nilfs_attach_checkpoint(s, cno, false, &root);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"NILFS: error loading snapshot \"\n\t\t       \"(checkpoint number=%llu).\\n\",\n\t       (unsigned long long)cno);\n\t\tgoto out;\n\t}\n\tret = nilfs_get_root_dentry(s, root, root_dentry);\n\tnilfs_put_root(root);\n out:\n\tmutex_unlock(&nilfs->ns_snapshot_mount_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_remount",
          "args": [
            "s",
            "&flags",
            "data"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_remount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "1129-1209",
          "snippet": "static int nilfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tunsigned long old_sb_flags;\n\tunsigned long old_mount_opt;\n\tint err;\n\n\tsync_filesystem(sb);\n\told_sb_flags = sb->s_flags;\n\told_mount_opt = nilfs->ns_mount_opt;\n\n\tif (!parse_options(data, sb, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL);\n\n\terr = -EINVAL;\n\n\tif (!nilfs_valid_fs(nilfs)) {\n\t\tprintk(KERN_WARNING \"NILFS (device %s): couldn't \"\n\t\t       \"remount because the filesystem is in an \"\n\t\t       \"incomplete recovery state.\\n\", sb->s_id);\n\t\tgoto restore_opts;\n\t}\n\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\tgoto out;\n\tif (*flags & MS_RDONLY) {\n\t\t/* Shutting down log writer */\n\t\tnilfs_detach_log_writer(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t\t/*\n\t\t * Remounting a valid RW partition RDONLY, so set\n\t\t * the RDONLY flag and then mark the partition as valid again.\n\t\t */\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_cleanup_super(sb);\n\t\tup_write(&nilfs->ns_sem);\n\t} else {\n\t\t__u64 features;\n\t\tstruct nilfs_root *root;\n\n\t\t/*\n\t\t * Mounting a RDONLY partition read-write, so reread and\n\t\t * store the current valid flag.  (It may have been changed\n\t\t * by fsck since we originally mounted the partition.)\n\t\t */\n\t\tdown_read(&nilfs->ns_sem);\n\t\tfeatures = le64_to_cpu(nilfs->ns_sbp[0]->s_feature_compat_ro) &\n\t\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\t\tup_read(&nilfs->ns_sem);\n\t\tif (features) {\n\t\t\tprintk(KERN_WARNING \"NILFS (device %s): couldn't \"\n\t\t\t       \"remount RDWR because of unsupported optional \"\n\t\t\t       \"features (%llx)\\n\",\n\t\t\t       sb->s_id, (unsigned long long)features);\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tsb->s_flags &= ~MS_RDONLY;\n\n\t\troot = NILFS_I(sb->s_root->d_inode)->i_root;\n\t\terr = nilfs_attach_log_writer(sb, root);\n\t\tif (err)\n\t\t\tgoto restore_opts;\n\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_setup_super(sb, true);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n out:\n\treturn 0;\n\n restore_opts:\n\tsb->s_flags = old_sb_flags;\n\tnilfs->ns_mount_opt = old_mount_opt;\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tunsigned long old_sb_flags;\n\tunsigned long old_mount_opt;\n\tint err;\n\n\tsync_filesystem(sb);\n\told_sb_flags = sb->s_flags;\n\told_mount_opt = nilfs->ns_mount_opt;\n\n\tif (!parse_options(data, sb, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL);\n\n\terr = -EINVAL;\n\n\tif (!nilfs_valid_fs(nilfs)) {\n\t\tprintk(KERN_WARNING \"NILFS (device %s): couldn't \"\n\t\t       \"remount because the filesystem is in an \"\n\t\t       \"incomplete recovery state.\\n\", sb->s_id);\n\t\tgoto restore_opts;\n\t}\n\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\tgoto out;\n\tif (*flags & MS_RDONLY) {\n\t\t/* Shutting down log writer */\n\t\tnilfs_detach_log_writer(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t\t/*\n\t\t * Remounting a valid RW partition RDONLY, so set\n\t\t * the RDONLY flag and then mark the partition as valid again.\n\t\t */\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_cleanup_super(sb);\n\t\tup_write(&nilfs->ns_sem);\n\t} else {\n\t\t__u64 features;\n\t\tstruct nilfs_root *root;\n\n\t\t/*\n\t\t * Mounting a RDONLY partition read-write, so reread and\n\t\t * store the current valid flag.  (It may have been changed\n\t\t * by fsck since we originally mounted the partition.)\n\t\t */\n\t\tdown_read(&nilfs->ns_sem);\n\t\tfeatures = le64_to_cpu(nilfs->ns_sbp[0]->s_feature_compat_ro) &\n\t\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\t\tup_read(&nilfs->ns_sem);\n\t\tif (features) {\n\t\t\tprintk(KERN_WARNING \"NILFS (device %s): couldn't \"\n\t\t\t       \"remount RDWR because of unsupported optional \"\n\t\t\t       \"features (%llx)\\n\",\n\t\t\t       sb->s_id, (unsigned long long)features);\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tsb->s_flags &= ~MS_RDONLY;\n\n\t\troot = NILFS_I(sb->s_root->d_inode)->i_root;\n\t\terr = nilfs_attach_log_writer(sb, root);\n\t\tif (err)\n\t\t\tgoto restore_opts;\n\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_setup_super(sb, true);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n out:\n\treturn 0;\n\n restore_opts:\n\tsb->s_flags = old_sb_flags;\n\tnilfs->ns_mount_opt = old_mount_opt;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NILFS: the device already \"\n\t\t\t\t       \"has a %s mount.\\n\"",
            "(s->s_flags & MS_RDONLY) ?\n\t\t\t\t       \"read-only\" : \"read/write\""
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_tree_is_busy",
          "args": [
            "s->s_root"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_tree_is_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "1009-1013",
          "snippet": "static bool nilfs_tree_is_busy(struct dentry *root_dentry)\n{\n\tshrink_dcache_parent(root_dentry);\n\treturn d_count(root_dentry) > 1;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic bool nilfs_tree_is_busy(struct dentry *root_dentry)\n{\n\tshrink_dcache_parent(root_dentry);\n\treturn d_count(root_dentry) > 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_fill_super",
          "args": [
            "s",
            "data",
            "flags & MS_SILENT ? 1 : 0"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "1055-1127",
          "snippet": "static int\nnilfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct the_nilfs *nilfs;\n\tstruct nilfs_root *fsroot;\n\t__u64 cno;\n\tint err;\n\n\tnilfs = alloc_nilfs(sb->s_bdev);\n\tif (!nilfs)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = nilfs;\n\n\terr = init_nilfs(nilfs, sb, (char *)data);\n\tif (err)\n\t\tgoto failed_nilfs;\n\n\tsb->s_op = &nilfs_sops;\n\tsb->s_export_op = &nilfs_export_ops;\n\tsb->s_root = NULL;\n\tsb->s_time_gran = 1;\n\tsb->s_max_links = NILFS_LINK_MAX;\n\n\tsb->s_bdi = &bdev_get_queue(sb->s_bdev)->backing_dev_info;\n\n\terr = load_nilfs(nilfs, sb);\n\tif (err)\n\t\tgoto failed_nilfs;\n\n\tcno = nilfs_last_cno(nilfs);\n\terr = nilfs_attach_checkpoint(sb, cno, true, &fsroot);\n\tif (err) {\n\t\tprintk(KERN_ERR \"NILFS: error loading last checkpoint \"\n\t\t       \"(checkpoint number=%llu).\\n\", (unsigned long long)cno);\n\t\tgoto failed_unload;\n\t}\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\terr = nilfs_attach_log_writer(sb, fsroot);\n\t\tif (err)\n\t\t\tgoto failed_checkpoint;\n\t}\n\n\terr = nilfs_get_root_dentry(sb, fsroot, &sb->s_root);\n\tif (err)\n\t\tgoto failed_segctor;\n\n\tnilfs_put_root(fsroot);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_setup_super(sb, true);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n\n\treturn 0;\n\n failed_segctor:\n\tnilfs_detach_log_writer(sb);\n\n failed_checkpoint:\n\tnilfs_put_root(fsroot);\n\n failed_unload:\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_dat);\n\n failed_nilfs:\n\tdestroy_nilfs(nilfs);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_remount(struct super_block *sb, int *flags, char *data);",
            "static const struct super_operations nilfs_sops = {\n\t.alloc_inode    = nilfs_alloc_inode,\n\t.destroy_inode  = nilfs_destroy_inode,\n\t.dirty_inode    = nilfs_dirty_inode,\n\t.evict_inode    = nilfs_evict_inode,\n\t.put_super      = nilfs_put_super,\n\t.sync_fs        = nilfs_sync_fs,\n\t.freeze_fs\t= nilfs_freeze,\n\t.unfreeze_fs\t= nilfs_unfreeze,\n\t.statfs         = nilfs_statfs,\n\t.remount_fs     = nilfs_remount,\n\t.show_options = nilfs_show_options\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\nstatic const struct super_operations nilfs_sops = {\n\t.alloc_inode    = nilfs_alloc_inode,\n\t.destroy_inode  = nilfs_destroy_inode,\n\t.dirty_inode    = nilfs_dirty_inode,\n\t.evict_inode    = nilfs_evict_inode,\n\t.put_super      = nilfs_put_super,\n\t.sync_fs        = nilfs_sync_fs,\n\t.freeze_fs\t= nilfs_freeze,\n\t.unfreeze_fs\t= nilfs_unfreeze,\n\t.statfs         = nilfs_statfs,\n\t.remount_fs     = nilfs_remount,\n\t.show_options = nilfs_show_options\n};\n\nstatic int\nnilfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct the_nilfs *nilfs;\n\tstruct nilfs_root *fsroot;\n\t__u64 cno;\n\tint err;\n\n\tnilfs = alloc_nilfs(sb->s_bdev);\n\tif (!nilfs)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = nilfs;\n\n\terr = init_nilfs(nilfs, sb, (char *)data);\n\tif (err)\n\t\tgoto failed_nilfs;\n\n\tsb->s_op = &nilfs_sops;\n\tsb->s_export_op = &nilfs_export_ops;\n\tsb->s_root = NULL;\n\tsb->s_time_gran = 1;\n\tsb->s_max_links = NILFS_LINK_MAX;\n\n\tsb->s_bdi = &bdev_get_queue(sb->s_bdev)->backing_dev_info;\n\n\terr = load_nilfs(nilfs, sb);\n\tif (err)\n\t\tgoto failed_nilfs;\n\n\tcno = nilfs_last_cno(nilfs);\n\terr = nilfs_attach_checkpoint(sb, cno, true, &fsroot);\n\tif (err) {\n\t\tprintk(KERN_ERR \"NILFS: error loading last checkpoint \"\n\t\t       \"(checkpoint number=%llu).\\n\", (unsigned long long)cno);\n\t\tgoto failed_unload;\n\t}\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\terr = nilfs_attach_log_writer(sb, fsroot);\n\t\tif (err)\n\t\t\tgoto failed_checkpoint;\n\t}\n\n\terr = nilfs_get_root_dentry(sb, fsroot, &sb->s_root);\n\tif (err)\n\t\tgoto failed_segctor;\n\n\tnilfs_put_root(fsroot);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_setup_super(sb, true);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n\n\treturn 0;\n\n failed_segctor:\n\tnilfs_detach_log_writer(sb);\n\n failed_checkpoint:\n\tnilfs_put_root(fsroot);\n\n failed_unload:\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_dat);\n\n failed_nilfs:\n\tdestroy_nilfs(nilfs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "s",
            "block_size(sd.bdev)"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_size",
          "args": [
            "sd.bdev"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "block_size_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1634-1637",
          "snippet": "static inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "s->s_id",
            "bdevname(sd.bdev, b)",
            "sizeof(s->s_id)"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "sd.bdev",
            "b"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "s"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sd.bdev->bd_fsfreeze_mutex"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "nilfs_test_bdev_super",
            "nilfs_set_bdev_super",
            "flags",
            "sd.bdev"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sd.bdev->bd_fsfreeze_mutex"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sd.bdev->bd_fsfreeze_mutex"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_identify",
          "args": [
            "(char *)data",
            "&sd"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_identify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "1222-1258",
          "snippet": "static int nilfs_identify(char *data, struct nilfs_super_data *sd)\n{\n\tchar *p, *options = data;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tint ret = 0;\n\n\tdo {\n\t\tp = strsep(&options, \",\");\n\t\tif (p != NULL && *p) {\n\t\t\ttoken = match_token(p, tokens, args);\n\t\t\tif (token == Opt_snapshot) {\n\t\t\t\tif (!(sd->flags & MS_RDONLY)) {\n\t\t\t\t\tret++;\n\t\t\t\t} else {\n\t\t\t\t\tsd->cno = simple_strtoull(args[0].from,\n\t\t\t\t\t\t\t\t  NULL, 0);\n\t\t\t\t\t/*\n\t\t\t\t\t * No need to see the end pointer;\n\t\t\t\t\t * match_token() has done syntax\n\t\t\t\t\t * checking.\n\t\t\t\t\t */\n\t\t\t\t\tif (sd->cno == 0)\n\t\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"NILFS: invalid mount option: %s\\n\", p);\n\t\t}\n\t\tif (!options)\n\t\t\tbreak;\n\t\tBUG_ON(options == data);\n\t\t*(options - 1) = ',';\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_remount(struct super_block *sb, int *flags, char *data);",
            "static match_table_t tokens = {\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_snapshot, \"cp=%u\"},\n\t{Opt_order, \"order=%s\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\nstatic match_table_t tokens = {\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_snapshot, \"cp=%u\"},\n\t{Opt_order, \"order=%s\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_err, NULL}\n};\n\nstatic int nilfs_identify(char *data, struct nilfs_super_data *sd)\n{\n\tchar *p, *options = data;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tint ret = 0;\n\n\tdo {\n\t\tp = strsep(&options, \",\");\n\t\tif (p != NULL && *p) {\n\t\t\ttoken = match_token(p, tokens, args);\n\t\t\tif (token == Opt_snapshot) {\n\t\t\t\tif (!(sd->flags & MS_RDONLY)) {\n\t\t\t\t\tret++;\n\t\t\t\t} else {\n\t\t\t\t\tsd->cno = simple_strtoull(args[0].from,\n\t\t\t\t\t\t\t\t  NULL, 0);\n\t\t\t\t\t/*\n\t\t\t\t\t * No need to see the end pointer;\n\t\t\t\t\t * match_token() has done syntax\n\t\t\t\t\t * checking.\n\t\t\t\t\t */\n\t\t\t\t\tif (sd->cno == 0)\n\t\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"NILFS: invalid mount option: %s\\n\", p);\n\t\t}\n\t\tif (!options)\n\t\t\tbreak;\n\t\tBUG_ON(options == data);\n\t\t*(options - 1) = ',';\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "sd.bdev"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sd.bdev"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_path",
          "args": [
            "dev_name",
            "mode",
            "fs_type"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1387-1407",
          "snippet": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic struct dentry *\nnilfs_mount(struct file_system_type *fs_type, int flags,\n\t     const char *dev_name, void *data)\n{\n\tstruct nilfs_super_data sd;\n\tstruct super_block *s;\n\tfmode_t mode = FMODE_READ | FMODE_EXCL;\n\tstruct dentry *root_dentry;\n\tint err, s_new = false;\n\n\tif (!(flags & MS_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\tsd.bdev = blkdev_get_by_path(dev_name, mode, fs_type);\n\tif (IS_ERR(sd.bdev))\n\t\treturn ERR_CAST(sd.bdev);\n\n\tsd.cno = 0;\n\tsd.flags = flags;\n\tif (nilfs_identify((char *)data, &sd)) {\n\t\terr = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\t/*\n\t * once the super is inserted into the list by sget, s_umount\n\t * will protect the lockfs code from trying to start a snapshot\n\t * while we are mounting\n\t */\n\tmutex_lock(&sd.bdev->bd_fsfreeze_mutex);\n\tif (sd.bdev->bd_fsfreeze_count > 0) {\n\t\tmutex_unlock(&sd.bdev->bd_fsfreeze_mutex);\n\t\terr = -EBUSY;\n\t\tgoto failed;\n\t}\n\ts = sget(fs_type, nilfs_test_bdev_super, nilfs_set_bdev_super, flags,\n\t\t sd.bdev);\n\tmutex_unlock(&sd.bdev->bd_fsfreeze_mutex);\n\tif (IS_ERR(s)) {\n\t\terr = PTR_ERR(s);\n\t\tgoto failed;\n\t}\n\n\tif (!s->s_root) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\ts_new = true;\n\n\t\t/* New superblock instance created */\n\t\ts->s_mode = mode;\n\t\tstrlcpy(s->s_id, bdevname(sd.bdev, b), sizeof(s->s_id));\n\t\tsb_set_blocksize(s, block_size(sd.bdev));\n\n\t\terr = nilfs_fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (err)\n\t\t\tgoto failed_super;\n\n\t\ts->s_flags |= MS_ACTIVE;\n\t} else if (!sd.cno) {\n\t\tif (nilfs_tree_is_busy(s->s_root)) {\n\t\t\tif ((flags ^ s->s_flags) & MS_RDONLY) {\n\t\t\t\tprintk(KERN_ERR \"NILFS: the device already \"\n\t\t\t\t       \"has a %s mount.\\n\",\n\t\t\t\t       (s->s_flags & MS_RDONLY) ?\n\t\t\t\t       \"read-only\" : \"read/write\");\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto failed_super;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Try remount to setup mount states if the current\n\t\t\t * tree is not mounted and only snapshots use this sb.\n\t\t\t */\n\t\t\terr = nilfs_remount(s, &flags, data);\n\t\t\tif (err)\n\t\t\t\tgoto failed_super;\n\t\t}\n\t}\n\n\tif (sd.cno) {\n\t\terr = nilfs_attach_snapshot(s, sd.cno, &root_dentry);\n\t\tif (err)\n\t\t\tgoto failed_super;\n\t} else {\n\t\troot_dentry = dget(s->s_root);\n\t}\n\n\tif (!s_new)\n\t\tblkdev_put(sd.bdev, mode);\n\n\treturn root_dentry;\n\n failed_super:\n\tdeactivate_locked_super(s);\n\n failed:\n\tif (!s_new)\n\t\tblkdev_put(sd.bdev, mode);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "nilfs_test_bdev_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1267-1270",
    "snippet": "static int nilfs_test_bdev_super(struct super_block *s, void *data)\n{\n\treturn (void *)s->s_bdev == data;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int nilfs_test_bdev_super(struct super_block *s, void *data)\n{\n\treturn (void *)s->s_bdev == data;\n}"
  },
  {
    "function_name": "nilfs_set_bdev_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1260-1265",
    "snippet": "static int nilfs_set_bdev_super(struct super_block *s, void *data)\n{\n\ts->s_bdev = data;\n\ts->s_dev = s->s_bdev->bd_dev;\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int nilfs_set_bdev_super(struct super_block *s, void *data)\n{\n\ts->s_bdev = data;\n\ts->s_dev = s->s_bdev->bd_dev;\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_identify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1222-1258",
    "snippet": "static int nilfs_identify(char *data, struct nilfs_super_data *sd)\n{\n\tchar *p, *options = data;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tint ret = 0;\n\n\tdo {\n\t\tp = strsep(&options, \",\");\n\t\tif (p != NULL && *p) {\n\t\t\ttoken = match_token(p, tokens, args);\n\t\t\tif (token == Opt_snapshot) {\n\t\t\t\tif (!(sd->flags & MS_RDONLY)) {\n\t\t\t\t\tret++;\n\t\t\t\t} else {\n\t\t\t\t\tsd->cno = simple_strtoull(args[0].from,\n\t\t\t\t\t\t\t\t  NULL, 0);\n\t\t\t\t\t/*\n\t\t\t\t\t * No need to see the end pointer;\n\t\t\t\t\t * match_token() has done syntax\n\t\t\t\t\t * checking.\n\t\t\t\t\t */\n\t\t\t\t\tif (sd->cno == 0)\n\t\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"NILFS: invalid mount option: %s\\n\", p);\n\t\t}\n\t\tif (!options)\n\t\t\tbreak;\n\t\tBUG_ON(options == data);\n\t\t*(options - 1) = ',';\n\t} while (!ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_remount(struct super_block *sb, int *flags, char *data);",
      "static match_table_t tokens = {\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_snapshot, \"cp=%u\"},\n\t{Opt_order, \"order=%s\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "options == data"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t\t       \"NILFS: invalid mount option: %s\\n\"",
            "p"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoull",
          "args": [
            "args[0].from",
            "NULL",
            "0"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\nstatic match_table_t tokens = {\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_snapshot, \"cp=%u\"},\n\t{Opt_order, \"order=%s\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_err, NULL}\n};\n\nstatic int nilfs_identify(char *data, struct nilfs_super_data *sd)\n{\n\tchar *p, *options = data;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tint ret = 0;\n\n\tdo {\n\t\tp = strsep(&options, \",\");\n\t\tif (p != NULL && *p) {\n\t\t\ttoken = match_token(p, tokens, args);\n\t\t\tif (token == Opt_snapshot) {\n\t\t\t\tif (!(sd->flags & MS_RDONLY)) {\n\t\t\t\t\tret++;\n\t\t\t\t} else {\n\t\t\t\t\tsd->cno = simple_strtoull(args[0].from,\n\t\t\t\t\t\t\t\t  NULL, 0);\n\t\t\t\t\t/*\n\t\t\t\t\t * No need to see the end pointer;\n\t\t\t\t\t * match_token() has done syntax\n\t\t\t\t\t * checking.\n\t\t\t\t\t */\n\t\t\t\t\tif (sd->cno == 0)\n\t\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"NILFS: invalid mount option: %s\\n\", p);\n\t\t}\n\t\tif (!options)\n\t\t\tbreak;\n\t\tBUG_ON(options == data);\n\t\t*(options - 1) = ',';\n\t} while (!ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1129-1209",
    "snippet": "static int nilfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tunsigned long old_sb_flags;\n\tunsigned long old_mount_opt;\n\tint err;\n\n\tsync_filesystem(sb);\n\told_sb_flags = sb->s_flags;\n\told_mount_opt = nilfs->ns_mount_opt;\n\n\tif (!parse_options(data, sb, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL);\n\n\terr = -EINVAL;\n\n\tif (!nilfs_valid_fs(nilfs)) {\n\t\tprintk(KERN_WARNING \"NILFS (device %s): couldn't \"\n\t\t       \"remount because the filesystem is in an \"\n\t\t       \"incomplete recovery state.\\n\", sb->s_id);\n\t\tgoto restore_opts;\n\t}\n\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\tgoto out;\n\tif (*flags & MS_RDONLY) {\n\t\t/* Shutting down log writer */\n\t\tnilfs_detach_log_writer(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t\t/*\n\t\t * Remounting a valid RW partition RDONLY, so set\n\t\t * the RDONLY flag and then mark the partition as valid again.\n\t\t */\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_cleanup_super(sb);\n\t\tup_write(&nilfs->ns_sem);\n\t} else {\n\t\t__u64 features;\n\t\tstruct nilfs_root *root;\n\n\t\t/*\n\t\t * Mounting a RDONLY partition read-write, so reread and\n\t\t * store the current valid flag.  (It may have been changed\n\t\t * by fsck since we originally mounted the partition.)\n\t\t */\n\t\tdown_read(&nilfs->ns_sem);\n\t\tfeatures = le64_to_cpu(nilfs->ns_sbp[0]->s_feature_compat_ro) &\n\t\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\t\tup_read(&nilfs->ns_sem);\n\t\tif (features) {\n\t\t\tprintk(KERN_WARNING \"NILFS (device %s): couldn't \"\n\t\t\t       \"remount RDWR because of unsupported optional \"\n\t\t\t       \"features (%llx)\\n\",\n\t\t\t       sb->s_id, (unsigned long long)features);\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tsb->s_flags &= ~MS_RDONLY;\n\n\t\troot = NILFS_I(sb->s_root->d_inode)->i_root;\n\t\terr = nilfs_attach_log_writer(sb, root);\n\t\tif (err)\n\t\t\tgoto restore_opts;\n\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_setup_super(sb, true);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n out:\n\treturn 0;\n\n restore_opts:\n\tsb->s_flags = old_sb_flags;\n\tnilfs->ns_mount_opt = old_mount_opt;\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_setup_super",
          "args": [
            "sb",
            "true"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_setup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "815-855",
          "snippet": "static int nilfs_setup_super(struct super_block *sb, int is_mount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint max_mnt_count;\n\tint mnt_count;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (!sbp)\n\t\treturn -EIO;\n\n\tif (!is_mount)\n\t\tgoto skip_mount_setup;\n\n\tmax_mnt_count = le16_to_cpu(sbp[0]->s_max_mnt_count);\n\tmnt_count = le16_to_cpu(sbp[0]->s_mnt_count);\n\n\tif (nilfs->ns_mount_state & NILFS_ERROR_FS) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: mounting fs with errors\\n\");\n#if 0\n\t} else if (max_mnt_count >= 0 && mnt_count >= max_mnt_count) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: maximal mount count reached\\n\");\n#endif\n\t}\n\tif (!max_mnt_count)\n\t\tsbp[0]->s_max_mnt_count = cpu_to_le16(NILFS_DFL_MAX_MNT_COUNT);\n\n\tsbp[0]->s_mnt_count = cpu_to_le16(mnt_count + 1);\n\tsbp[0]->s_mtime = cpu_to_le64(get_seconds());\n\nskip_mount_setup:\n\tsbp[0]->s_state =\n\t\tcpu_to_le16(le16_to_cpu(sbp[0]->s_state) & ~NILFS_VALID_FS);\n\t/* synchronize sbp[1] with sbp[0] */\n\tif (sbp[1])\n\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\treturn nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_setup_super(struct super_block *sb, int is_mount);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_setup_super(struct super_block *sb, int is_mount);\n\nstatic int nilfs_setup_super(struct super_block *sb, int is_mount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint max_mnt_count;\n\tint mnt_count;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (!sbp)\n\t\treturn -EIO;\n\n\tif (!is_mount)\n\t\tgoto skip_mount_setup;\n\n\tmax_mnt_count = le16_to_cpu(sbp[0]->s_max_mnt_count);\n\tmnt_count = le16_to_cpu(sbp[0]->s_mnt_count);\n\n\tif (nilfs->ns_mount_state & NILFS_ERROR_FS) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: mounting fs with errors\\n\");\n#if 0\n\t} else if (max_mnt_count >= 0 && mnt_count >= max_mnt_count) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: maximal mount count reached\\n\");\n#endif\n\t}\n\tif (!max_mnt_count)\n\t\tsbp[0]->s_max_mnt_count = cpu_to_le16(NILFS_DFL_MAX_MNT_COUNT);\n\n\tsbp[0]->s_mnt_count = cpu_to_le16(mnt_count + 1);\n\tsbp[0]->s_mtime = cpu_to_le64(get_seconds());\n\nskip_mount_setup:\n\tsbp[0]->s_state =\n\t\tcpu_to_le16(le16_to_cpu(sbp[0]->s_state) & ~NILFS_VALID_FS);\n\t/* synchronize sbp[1] with sbp[0] */\n\tif (sbp[1])\n\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\treturn nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_attach_log_writer",
          "args": [
            "sb",
            "root"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_attach_log_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2704-2728",
          "snippet": "int nilfs_attach_log_writer(struct super_block *sb, struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (nilfs->ns_writer) {\n\t\t/*\n\t\t * This happens if the filesystem was remounted\n\t\t * read/write after nilfs_error degenerated it into a\n\t\t * read-only mount.\n\t\t */\n\t\tnilfs_detach_log_writer(sb);\n\t}\n\n\tnilfs->ns_writer = nilfs_segctor_new(sb, root);\n\tif (!nilfs->ns_writer)\n\t\treturn -ENOMEM;\n\n\terr = nilfs_segctor_start_thread(nilfs->ns_writer);\n\tif (err) {\n\t\tkfree(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_attach_log_writer(struct super_block *sb, struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (nilfs->ns_writer) {\n\t\t/*\n\t\t * This happens if the filesystem was remounted\n\t\t * read/write after nilfs_error degenerated it into a\n\t\t * read-only mount.\n\t\t */\n\t\tnilfs_detach_log_writer(sb);\n\t}\n\n\tnilfs->ns_writer = nilfs_segctor_new(sb, root);\n\tif (!nilfs->ns_writer)\n\t\treturn -ENOMEM;\n\n\terr = nilfs_segctor_start_thread(nilfs->ns_writer);\n\tif (err) {\n\t\tkfree(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "sb->s_root->d_inode"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"NILFS (device %s): couldn't \"\n\t\t\t       \"remount RDWR because of unsupported optional \"\n\t\t\t       \"features (%llx)\\n\"",
            "sb->s_id",
            "(unsigned long long)features"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "nilfs->ns_sbp[0]->s_feature_compat_ro"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cleanup_super",
          "args": [
            "sb"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cleanup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "327-350",
          "snippet": "int nilfs_cleanup_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint flag = NILFS_SB_COMMIT;\n\tint ret = -EIO;\n\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (sbp) {\n\t\tsbp[0]->s_state = cpu_to_le16(nilfs->ns_mount_state);\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\tif (sbp[1] && sbp[0]->s_last_cno == sbp[1]->s_last_cno) {\n\t\t\t/*\n\t\t\t * make the \"clean\" flag also to the opposite\n\t\t\t * super block if both super blocks point to\n\t\t\t * the same checkpoint.\n\t\t\t */\n\t\t\tsbp[1]->s_state = sbp[0]->s_state;\n\t\t\tflag = NILFS_SB_COMMIT_ALL;\n\t\t}\n\t\tret = nilfs_commit_super(sb, flag);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_cleanup_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint flag = NILFS_SB_COMMIT;\n\tint ret = -EIO;\n\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (sbp) {\n\t\tsbp[0]->s_state = cpu_to_le16(nilfs->ns_mount_state);\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\tif (sbp[1] && sbp[0]->s_last_cno == sbp[1]->s_last_cno) {\n\t\t\t/*\n\t\t\t * make the \"clean\" flag also to the opposite\n\t\t\t * super block if both super blocks point to\n\t\t\t * the same checkpoint.\n\t\t\t */\n\t\t\tsbp[1]->s_state = sbp[0]->s_state;\n\t\t\tflag = NILFS_SB_COMMIT_ALL;\n\t\t}\n\t\tret = nilfs_commit_super(sb, flag);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_detach_log_writer",
          "args": [
            "sb"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_detach_log_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2737-2759",
          "snippet": "void nilfs_detach_log_writer(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tLIST_HEAD(garbage_list);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (nilfs->ns_writer) {\n\t\tnilfs_segctor_destroy(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\n\t/* Force to free the list of dirty files */\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!list_empty(&nilfs->ns_dirty_files)) {\n\t\tlist_splice_init(&nilfs->ns_dirty_files, &garbage_list);\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"Hit dirty file after stopped log writer\\n\");\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tnilfs_dispose_list(nilfs, &garbage_list, 1);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_detach_log_writer(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tLIST_HEAD(garbage_list);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (nilfs->ns_writer) {\n\t\tnilfs_segctor_destroy(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\n\t/* Force to free the list of dirty files */\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!list_empty(&nilfs->ns_dirty_files)) {\n\t\tlist_splice_init(&nilfs->ns_dirty_files, &garbage_list);\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"Hit dirty file after stopped log writer\\n\");\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tnilfs_dispose_list(nilfs, &garbage_list, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_valid_fs",
          "args": [
            "nilfs"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_valid_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "309-317",
          "snippet": "static inline int nilfs_valid_fs(struct the_nilfs *nilfs)\n{\n\tunsigned valid_fs;\n\n\tdown_read(&nilfs->ns_sem);\n\tvalid_fs = (nilfs->ns_mount_state & NILFS_VALID_FS);\n\tup_read(&nilfs->ns_sem);\n\treturn valid_fs;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline int nilfs_valid_fs(struct the_nilfs *nilfs)\n{\n\tunsigned valid_fs;\n\n\tdown_read(&nilfs->ns_sem);\n\tvalid_fs = (nilfs->ns_mount_state & NILFS_VALID_FS);\n\tup_read(&nilfs->ns_sem);\n\treturn valid_fs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "data",
            "sb",
            "1"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "738-803",
          "snippet": "static int parse_options(char *options, struct super_block *sb, int is_remount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_barrier:\n\t\t\tnilfs_set_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tnilfs_clear_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_order:\n\t\t\tif (strcmp(args[0].from, \"relaxed\") == 0)\n\t\t\t\t/* Ordered data semantics */\n\t\t\t\tnilfs_clear_opt(nilfs, STRICT_ORDER);\n\t\t\telse if (strcmp(args[0].from, \"strict\") == 0)\n\t\t\t\t/* Strict in-order semantics */\n\t\t\t\tnilfs_set_opt(nilfs, STRICT_ORDER);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_snapshot:\n\t\t\tif (is_remount) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"NILFS: \\\"%s\\\" option is invalid \"\n\t\t\t\t       \"for remount.\\n\", p);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\tnilfs_set_opt(nilfs, NORECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tnilfs_set_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tnilfs_clear_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Unrecognized mount option \\\"%s\\\"\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_remount(struct super_block *sb, int *flags, char *data);",
            "static match_table_t tokens = {\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_snapshot, \"cp=%u\"},\n\t{Opt_order, \"order=%s\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\nstatic match_table_t tokens = {\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_snapshot, \"cp=%u\"},\n\t{Opt_order, \"order=%s\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb, int is_remount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_barrier:\n\t\t\tnilfs_set_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tnilfs_clear_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_order:\n\t\t\tif (strcmp(args[0].from, \"relaxed\") == 0)\n\t\t\t\t/* Ordered data semantics */\n\t\t\t\tnilfs_clear_opt(nilfs, STRICT_ORDER);\n\t\t\telse if (strcmp(args[0].from, \"strict\") == 0)\n\t\t\t\t/* Strict in-order semantics */\n\t\t\t\tnilfs_set_opt(nilfs, STRICT_ORDER);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_snapshot:\n\t\t\tif (is_remount) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"NILFS: \\\"%s\\\" option is invalid \"\n\t\t\t\t       \"for remount.\\n\", p);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\tnilfs_set_opt(nilfs, NORECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tnilfs_set_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tnilfs_clear_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Unrecognized mount option \\\"%s\\\"\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tunsigned long old_sb_flags;\n\tunsigned long old_mount_opt;\n\tint err;\n\n\tsync_filesystem(sb);\n\told_sb_flags = sb->s_flags;\n\told_mount_opt = nilfs->ns_mount_opt;\n\n\tif (!parse_options(data, sb, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL);\n\n\terr = -EINVAL;\n\n\tif (!nilfs_valid_fs(nilfs)) {\n\t\tprintk(KERN_WARNING \"NILFS (device %s): couldn't \"\n\t\t       \"remount because the filesystem is in an \"\n\t\t       \"incomplete recovery state.\\n\", sb->s_id);\n\t\tgoto restore_opts;\n\t}\n\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\tgoto out;\n\tif (*flags & MS_RDONLY) {\n\t\t/* Shutting down log writer */\n\t\tnilfs_detach_log_writer(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t\t/*\n\t\t * Remounting a valid RW partition RDONLY, so set\n\t\t * the RDONLY flag and then mark the partition as valid again.\n\t\t */\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_cleanup_super(sb);\n\t\tup_write(&nilfs->ns_sem);\n\t} else {\n\t\t__u64 features;\n\t\tstruct nilfs_root *root;\n\n\t\t/*\n\t\t * Mounting a RDONLY partition read-write, so reread and\n\t\t * store the current valid flag.  (It may have been changed\n\t\t * by fsck since we originally mounted the partition.)\n\t\t */\n\t\tdown_read(&nilfs->ns_sem);\n\t\tfeatures = le64_to_cpu(nilfs->ns_sbp[0]->s_feature_compat_ro) &\n\t\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\t\tup_read(&nilfs->ns_sem);\n\t\tif (features) {\n\t\t\tprintk(KERN_WARNING \"NILFS (device %s): couldn't \"\n\t\t\t       \"remount RDWR because of unsupported optional \"\n\t\t\t       \"features (%llx)\\n\",\n\t\t\t       sb->s_id, (unsigned long long)features);\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tsb->s_flags &= ~MS_RDONLY;\n\n\t\troot = NILFS_I(sb->s_root->d_inode)->i_root;\n\t\terr = nilfs_attach_log_writer(sb, root);\n\t\tif (err)\n\t\t\tgoto restore_opts;\n\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_setup_super(sb, true);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n out:\n\treturn 0;\n\n restore_opts:\n\tsb->s_flags = old_sb_flags;\n\tnilfs->ns_mount_opt = old_mount_opt;\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1055-1127",
    "snippet": "static int\nnilfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct the_nilfs *nilfs;\n\tstruct nilfs_root *fsroot;\n\t__u64 cno;\n\tint err;\n\n\tnilfs = alloc_nilfs(sb->s_bdev);\n\tif (!nilfs)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = nilfs;\n\n\terr = init_nilfs(nilfs, sb, (char *)data);\n\tif (err)\n\t\tgoto failed_nilfs;\n\n\tsb->s_op = &nilfs_sops;\n\tsb->s_export_op = &nilfs_export_ops;\n\tsb->s_root = NULL;\n\tsb->s_time_gran = 1;\n\tsb->s_max_links = NILFS_LINK_MAX;\n\n\tsb->s_bdi = &bdev_get_queue(sb->s_bdev)->backing_dev_info;\n\n\terr = load_nilfs(nilfs, sb);\n\tif (err)\n\t\tgoto failed_nilfs;\n\n\tcno = nilfs_last_cno(nilfs);\n\terr = nilfs_attach_checkpoint(sb, cno, true, &fsroot);\n\tif (err) {\n\t\tprintk(KERN_ERR \"NILFS: error loading last checkpoint \"\n\t\t       \"(checkpoint number=%llu).\\n\", (unsigned long long)cno);\n\t\tgoto failed_unload;\n\t}\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\terr = nilfs_attach_log_writer(sb, fsroot);\n\t\tif (err)\n\t\t\tgoto failed_checkpoint;\n\t}\n\n\terr = nilfs_get_root_dentry(sb, fsroot, &sb->s_root);\n\tif (err)\n\t\tgoto failed_segctor;\n\n\tnilfs_put_root(fsroot);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_setup_super(sb, true);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n\n\treturn 0;\n\n failed_segctor:\n\tnilfs_detach_log_writer(sb);\n\n failed_checkpoint:\n\tnilfs_put_root(fsroot);\n\n failed_unload:\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_dat);\n\n failed_nilfs:\n\tdestroy_nilfs(nilfs);\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_remount(struct super_block *sb, int *flags, char *data);",
      "static const struct super_operations nilfs_sops = {\n\t.alloc_inode    = nilfs_alloc_inode,\n\t.destroy_inode  = nilfs_destroy_inode,\n\t.dirty_inode    = nilfs_dirty_inode,\n\t.evict_inode    = nilfs_evict_inode,\n\t.put_super      = nilfs_put_super,\n\t.sync_fs        = nilfs_sync_fs,\n\t.freeze_fs\t= nilfs_freeze,\n\t.unfreeze_fs\t= nilfs_unfreeze,\n\t.statfs         = nilfs_statfs,\n\t.remount_fs     = nilfs_remount,\n\t.show_options = nilfs_show_options\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_nilfs",
          "args": [
            "nilfs"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_nilfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "97-106",
          "snippet": "void destroy_nilfs(struct the_nilfs *nilfs)\n{\n\tmight_sleep();\n\tif (nilfs_init(nilfs)) {\n\t\tnilfs_sysfs_delete_device_group(nilfs);\n\t\tbrelse(nilfs->ns_sbh[0]);\n\t\tbrelse(nilfs->ns_sbh[1]);\n\t}\n\tkfree(nilfs);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid destroy_nilfs(struct the_nilfs *nilfs)\n{\n\tmight_sleep();\n\tif (nilfs_init(nilfs)) {\n\t\tnilfs_sysfs_delete_device_group(nilfs);\n\t\tbrelse(nilfs->ns_sbh[0]);\n\t\tbrelse(nilfs->ns_sbh[1]);\n\t}\n\tkfree(nilfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_put_root",
          "args": [
            "fsroot"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "801-815",
          "snippet": "void nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_detach_log_writer",
          "args": [
            "sb"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_detach_log_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2737-2759",
          "snippet": "void nilfs_detach_log_writer(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tLIST_HEAD(garbage_list);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (nilfs->ns_writer) {\n\t\tnilfs_segctor_destroy(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\n\t/* Force to free the list of dirty files */\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!list_empty(&nilfs->ns_dirty_files)) {\n\t\tlist_splice_init(&nilfs->ns_dirty_files, &garbage_list);\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"Hit dirty file after stopped log writer\\n\");\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tnilfs_dispose_list(nilfs, &garbage_list, 1);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_detach_log_writer(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tLIST_HEAD(garbage_list);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (nilfs->ns_writer) {\n\t\tnilfs_segctor_destroy(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\n\t/* Force to free the list of dirty files */\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!list_empty(&nilfs->ns_dirty_files)) {\n\t\tlist_splice_init(&nilfs->ns_dirty_files, &garbage_list);\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"Hit dirty file after stopped log writer\\n\");\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tnilfs_dispose_list(nilfs, &garbage_list, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_setup_super",
          "args": [
            "sb",
            "true"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_setup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "815-855",
          "snippet": "static int nilfs_setup_super(struct super_block *sb, int is_mount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint max_mnt_count;\n\tint mnt_count;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (!sbp)\n\t\treturn -EIO;\n\n\tif (!is_mount)\n\t\tgoto skip_mount_setup;\n\n\tmax_mnt_count = le16_to_cpu(sbp[0]->s_max_mnt_count);\n\tmnt_count = le16_to_cpu(sbp[0]->s_mnt_count);\n\n\tif (nilfs->ns_mount_state & NILFS_ERROR_FS) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: mounting fs with errors\\n\");\n#if 0\n\t} else if (max_mnt_count >= 0 && mnt_count >= max_mnt_count) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: maximal mount count reached\\n\");\n#endif\n\t}\n\tif (!max_mnt_count)\n\t\tsbp[0]->s_max_mnt_count = cpu_to_le16(NILFS_DFL_MAX_MNT_COUNT);\n\n\tsbp[0]->s_mnt_count = cpu_to_le16(mnt_count + 1);\n\tsbp[0]->s_mtime = cpu_to_le64(get_seconds());\n\nskip_mount_setup:\n\tsbp[0]->s_state =\n\t\tcpu_to_le16(le16_to_cpu(sbp[0]->s_state) & ~NILFS_VALID_FS);\n\t/* synchronize sbp[1] with sbp[0] */\n\tif (sbp[1])\n\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\treturn nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_setup_super(struct super_block *sb, int is_mount);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_setup_super(struct super_block *sb, int is_mount);\n\nstatic int nilfs_setup_super(struct super_block *sb, int is_mount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint max_mnt_count;\n\tint mnt_count;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (!sbp)\n\t\treturn -EIO;\n\n\tif (!is_mount)\n\t\tgoto skip_mount_setup;\n\n\tmax_mnt_count = le16_to_cpu(sbp[0]->s_max_mnt_count);\n\tmnt_count = le16_to_cpu(sbp[0]->s_mnt_count);\n\n\tif (nilfs->ns_mount_state & NILFS_ERROR_FS) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: mounting fs with errors\\n\");\n#if 0\n\t} else if (max_mnt_count >= 0 && mnt_count >= max_mnt_count) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: maximal mount count reached\\n\");\n#endif\n\t}\n\tif (!max_mnt_count)\n\t\tsbp[0]->s_max_mnt_count = cpu_to_le16(NILFS_DFL_MAX_MNT_COUNT);\n\n\tsbp[0]->s_mnt_count = cpu_to_le16(mnt_count + 1);\n\tsbp[0]->s_mtime = cpu_to_le64(get_seconds());\n\nskip_mount_setup:\n\tsbp[0]->s_state =\n\t\tcpu_to_le16(le16_to_cpu(sbp[0]->s_state) & ~NILFS_VALID_FS);\n\t/* synchronize sbp[1] with sbp[0] */\n\tif (sbp[1])\n\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\treturn nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_get_root_dentry",
          "args": [
            "sb",
            "fsroot",
            "&sb->s_root"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_get_root_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "918-964",
          "snippet": "static int nilfs_get_root_dentry(struct super_block *sb,\n\t\t\t\t struct nilfs_root *root,\n\t\t\t\t struct dentry **root_dentry)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tinode = nilfs_iget(sb, root, NILFS_ROOT_INO);\n\tif (IS_ERR(inode)) {\n\t\tprintk(KERN_ERR \"NILFS: get root inode failed\\n\");\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tif (!S_ISDIR(inode->i_mode) || !inode->i_blocks || !inode->i_size) {\n\t\tiput(inode);\n\t\tprintk(KERN_ERR \"NILFS: corrupt root inode.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (root->cno == NILFS_CPTREE_CURRENT_CNO) {\n\t\tdentry = d_find_alias(inode);\n\t\tif (!dentry) {\n\t\t\tdentry = d_make_root(inode);\n\t\t\tif (!dentry) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto failed_dentry;\n\t\t\t}\n\t\t} else {\n\t\t\tiput(inode);\n\t\t}\n\t} else {\n\t\tdentry = d_obtain_root(inode);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tgoto failed_dentry;\n\t\t}\n\t}\n\t*root_dentry = dentry;\n out:\n\treturn ret;\n\n failed_dentry:\n\tprintk(KERN_ERR \"NILFS: get root dentry failed\\n\");\n\tgoto out;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_get_root_dentry(struct super_block *sb,\n\t\t\t\t struct nilfs_root *root,\n\t\t\t\t struct dentry **root_dentry)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tinode = nilfs_iget(sb, root, NILFS_ROOT_INO);\n\tif (IS_ERR(inode)) {\n\t\tprintk(KERN_ERR \"NILFS: get root inode failed\\n\");\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tif (!S_ISDIR(inode->i_mode) || !inode->i_blocks || !inode->i_size) {\n\t\tiput(inode);\n\t\tprintk(KERN_ERR \"NILFS: corrupt root inode.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (root->cno == NILFS_CPTREE_CURRENT_CNO) {\n\t\tdentry = d_find_alias(inode);\n\t\tif (!dentry) {\n\t\t\tdentry = d_make_root(inode);\n\t\t\tif (!dentry) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto failed_dentry;\n\t\t\t}\n\t\t} else {\n\t\t\tiput(inode);\n\t\t}\n\t} else {\n\t\tdentry = d_obtain_root(inode);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tgoto failed_dentry;\n\t\t}\n\t}\n\t*root_dentry = dentry;\n out:\n\treturn ret;\n\n failed_dentry:\n\tprintk(KERN_ERR \"NILFS: get root dentry failed\\n\");\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_attach_log_writer",
          "args": [
            "sb",
            "fsroot"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_attach_log_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2704-2728",
          "snippet": "int nilfs_attach_log_writer(struct super_block *sb, struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (nilfs->ns_writer) {\n\t\t/*\n\t\t * This happens if the filesystem was remounted\n\t\t * read/write after nilfs_error degenerated it into a\n\t\t * read-only mount.\n\t\t */\n\t\tnilfs_detach_log_writer(sb);\n\t}\n\n\tnilfs->ns_writer = nilfs_segctor_new(sb, root);\n\tif (!nilfs->ns_writer)\n\t\treturn -ENOMEM;\n\n\terr = nilfs_segctor_start_thread(nilfs->ns_writer);\n\tif (err) {\n\t\tkfree(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_attach_log_writer(struct super_block *sb, struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (nilfs->ns_writer) {\n\t\t/*\n\t\t * This happens if the filesystem was remounted\n\t\t * read/write after nilfs_error degenerated it into a\n\t\t * read-only mount.\n\t\t */\n\t\tnilfs_detach_log_writer(sb);\n\t}\n\n\tnilfs->ns_writer = nilfs_segctor_new(sb, root);\n\tif (!nilfs->ns_writer)\n\t\treturn -ENOMEM;\n\n\terr = nilfs_segctor_start_thread(nilfs->ns_writer);\n\tif (err) {\n\t\tkfree(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NILFS: error loading last checkpoint \"\n\t\t       \"(checkpoint number=%llu).\\n\"",
            "(unsigned long long)cno"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_attach_checkpoint",
          "args": [
            "sb",
            "cno",
            "true",
            "&fsroot"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_attach_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "526-580",
          "snippet": "int nilfs_attach_checkpoint(struct super_block *sb, __u64 cno, int curr_mnt,\n\t\t\t    struct nilfs_root **rootp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct nilfs_checkpoint *raw_cp;\n\tstruct buffer_head *bh_cp;\n\tint err = -ENOMEM;\n\n\troot = nilfs_find_or_create_root(\n\t\tnilfs, curr_mnt ? NILFS_CPTREE_CURRENT_CNO : cno);\n\tif (!root)\n\t\treturn err;\n\n\tif (root->ifile)\n\t\tgoto reuse; /* already attached checkpoint */\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, cno, 0, &raw_cp,\n\t\t\t\t\t  &bh_cp);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT || err == -EINVAL) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Invalid checkpoint \"\n\t\t\t       \"(checkpoint number=%llu)\\n\",\n\t\t\t       (unsigned long long)cno);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tgoto failed;\n\t}\n\n\terr = nilfs_ifile_read(sb, root, nilfs->ns_inode_size,\n\t\t\t       &raw_cp->cp_ifile_inode, &root->ifile);\n\tif (err)\n\t\tgoto failed_bh;\n\n\tatomic64_set(&root->inodes_count,\n\t\t\tle64_to_cpu(raw_cp->cp_inodes_count));\n\tatomic64_set(&root->blocks_count,\n\t\t\tle64_to_cpu(raw_cp->cp_blocks_count));\n\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n\n reuse:\n\t*rootp = root;\n\treturn 0;\n\n failed_bh:\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n failed:\n\tnilfs_put_root(root);\n\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_attach_checkpoint(struct super_block *sb, __u64 cno, int curr_mnt,\n\t\t\t    struct nilfs_root **rootp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct nilfs_checkpoint *raw_cp;\n\tstruct buffer_head *bh_cp;\n\tint err = -ENOMEM;\n\n\troot = nilfs_find_or_create_root(\n\t\tnilfs, curr_mnt ? NILFS_CPTREE_CURRENT_CNO : cno);\n\tif (!root)\n\t\treturn err;\n\n\tif (root->ifile)\n\t\tgoto reuse; /* already attached checkpoint */\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, cno, 0, &raw_cp,\n\t\t\t\t\t  &bh_cp);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT || err == -EINVAL) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Invalid checkpoint \"\n\t\t\t       \"(checkpoint number=%llu)\\n\",\n\t\t\t       (unsigned long long)cno);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tgoto failed;\n\t}\n\n\terr = nilfs_ifile_read(sb, root, nilfs->ns_inode_size,\n\t\t\t       &raw_cp->cp_ifile_inode, &root->ifile);\n\tif (err)\n\t\tgoto failed_bh;\n\n\tatomic64_set(&root->inodes_count,\n\t\t\tle64_to_cpu(raw_cp->cp_inodes_count));\n\tatomic64_set(&root->blocks_count,\n\t\t\tle64_to_cpu(raw_cp->cp_blocks_count));\n\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n\n reuse:\n\t*rootp = root;\n\treturn 0;\n\n failed_bh:\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n failed:\n\tnilfs_put_root(root);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_last_cno",
          "args": [
            "nilfs"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_last_cno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "361-369",
          "snippet": "static inline __u64 nilfs_last_cno(struct the_nilfs *nilfs)\n{\n\t__u64 cno;\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tcno = nilfs->ns_last_cno;\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n\treturn cno;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline __u64 nilfs_last_cno(struct the_nilfs *nilfs)\n{\n\t__u64 cno;\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tcno = nilfs->ns_last_cno;\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n\treturn cno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_nilfs",
          "args": [
            "nilfs",
            "sb"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "load_nilfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "213-356",
          "snippet": "int load_nilfs(struct the_nilfs *nilfs, struct super_block *sb)\n{\n\tstruct nilfs_recovery_info ri;\n\tunsigned int s_flags = sb->s_flags;\n\tint really_read_only = bdev_read_only(nilfs->ns_bdev);\n\tint valid_fs = nilfs_valid_fs(nilfs);\n\tint err;\n\n\tif (!valid_fs) {\n\t\tprintk(KERN_WARNING \"NILFS warning: mounting unchecked fs\\n\");\n\t\tif (s_flags & MS_RDONLY) {\n\t\t\tprintk(KERN_INFO \"NILFS: INFO: recovery \"\n\t\t\t       \"required for readonly filesystem.\\n\");\n\t\t\tprintk(KERN_INFO \"NILFS: write access will \"\n\t\t\t       \"be enabled during recovery.\\n\");\n\t\t}\n\t}\n\n\tnilfs_init_recovery_info(&ri);\n\n\terr = nilfs_search_super_root(nilfs, &ri);\n\tif (unlikely(err)) {\n\t\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\t\tint blocksize;\n\n\t\tif (err != -EINVAL)\n\t\t\tgoto scan_error;\n\n\t\tif (!nilfs_valid_sb(sbp[1])) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: unable to fall back to spare\"\n\t\t\t       \"super block\\n\");\n\t\t\tgoto scan_error;\n\t\t}\n\t\tprintk(KERN_INFO\n\t\t       \"NILFS: try rollback from an earlier position\\n\");\n\n\t\t/*\n\t\t * restore super block with its spare and reconfigure\n\t\t * relevant states of the nilfs object.\n\t\t */\n\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\tnilfs->ns_crc_seed = le32_to_cpu(sbp[0]->s_crc_seed);\n\t\tnilfs->ns_sbwtime = le64_to_cpu(sbp[0]->s_wtime);\n\n\t\t/* verify consistency between two super blocks */\n\t\tblocksize = BLOCK_SIZE << le32_to_cpu(sbp[0]->s_log_block_size);\n\t\tif (blocksize != nilfs->ns_blocksize) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: blocksize differs between \"\n\t\t\t       \"two super blocks (%d != %d)\\n\",\n\t\t\t       blocksize, nilfs->ns_blocksize);\n\t\t\tgoto scan_error;\n\t\t}\n\n\t\terr = nilfs_store_log_cursor(nilfs, sbp[0]);\n\t\tif (err)\n\t\t\tgoto scan_error;\n\n\t\t/* drop clean flag to allow roll-forward and recovery */\n\t\tnilfs->ns_mount_state &= ~NILFS_VALID_FS;\n\t\tvalid_fs = 0;\n\n\t\terr = nilfs_search_super_root(nilfs, &ri);\n\t\tif (err)\n\t\t\tgoto scan_error;\n\t}\n\n\terr = nilfs_load_super_root(nilfs, sb, ri.ri_super_root);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR \"NILFS: error loading super root.\\n\");\n\t\tgoto failed;\n\t}\n\n\tif (valid_fs)\n\t\tgoto skip_recovery;\n\n\tif (s_flags & MS_RDONLY) {\n\t\t__u64 features;\n\n\t\tif (nilfs_test_opt(nilfs, NORECOVERY)) {\n\t\t\tprintk(KERN_INFO \"NILFS: norecovery option specified. \"\n\t\t\t       \"skipping roll-forward recovery\\n\");\n\t\t\tgoto skip_recovery;\n\t\t}\n\t\tfeatures = le64_to_cpu(nilfs->ns_sbp[0]->s_feature_compat_ro) &\n\t\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\t\tif (features) {\n\t\t\tprintk(KERN_ERR \"NILFS: couldn't proceed with \"\n\t\t\t       \"recovery because of unsupported optional \"\n\t\t\t       \"features (%llx)\\n\",\n\t\t\t       (unsigned long long)features);\n\t\t\terr = -EROFS;\n\t\t\tgoto failed_unload;\n\t\t}\n\t\tif (really_read_only) {\n\t\t\tprintk(KERN_ERR \"NILFS: write access \"\n\t\t\t       \"unavailable, cannot proceed.\\n\");\n\t\t\terr = -EROFS;\n\t\t\tgoto failed_unload;\n\t\t}\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t} else if (nilfs_test_opt(nilfs, NORECOVERY)) {\n\t\tprintk(KERN_ERR \"NILFS: recovery cancelled because norecovery \"\n\t\t       \"option was specified for a read/write mount\\n\");\n\t\terr = -EINVAL;\n\t\tgoto failed_unload;\n\t}\n\n\terr = nilfs_salvage_orphan_logs(nilfs, sb, &ri);\n\tif (err)\n\t\tgoto failed_unload;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs->ns_mount_state |= NILFS_VALID_FS; /* set \"clean\" flag */\n\terr = nilfs_cleanup_super(sb);\n\tup_write(&nilfs->ns_sem);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"NILFS: failed to update super block. \"\n\t\t       \"recovery unfinished.\\n\");\n\t\tgoto failed_unload;\n\t}\n\tprintk(KERN_INFO \"NILFS: recovery complete.\\n\");\n\n skip_recovery:\n\tnilfs_clear_recovery_info(&ri);\n\tsb->s_flags = s_flags;\n\treturn 0;\n\n scan_error:\n\tprintk(KERN_ERR \"NILFS: error searching super root.\\n\");\n\tgoto failed;\n\n failed_unload:\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_dat);\n\n failed:\n\tnilfs_clear_recovery_info(&ri);\n\tsb->s_flags = s_flags;\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nint load_nilfs(struct the_nilfs *nilfs, struct super_block *sb)\n{\n\tstruct nilfs_recovery_info ri;\n\tunsigned int s_flags = sb->s_flags;\n\tint really_read_only = bdev_read_only(nilfs->ns_bdev);\n\tint valid_fs = nilfs_valid_fs(nilfs);\n\tint err;\n\n\tif (!valid_fs) {\n\t\tprintk(KERN_WARNING \"NILFS warning: mounting unchecked fs\\n\");\n\t\tif (s_flags & MS_RDONLY) {\n\t\t\tprintk(KERN_INFO \"NILFS: INFO: recovery \"\n\t\t\t       \"required for readonly filesystem.\\n\");\n\t\t\tprintk(KERN_INFO \"NILFS: write access will \"\n\t\t\t       \"be enabled during recovery.\\n\");\n\t\t}\n\t}\n\n\tnilfs_init_recovery_info(&ri);\n\n\terr = nilfs_search_super_root(nilfs, &ri);\n\tif (unlikely(err)) {\n\t\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\t\tint blocksize;\n\n\t\tif (err != -EINVAL)\n\t\t\tgoto scan_error;\n\n\t\tif (!nilfs_valid_sb(sbp[1])) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: unable to fall back to spare\"\n\t\t\t       \"super block\\n\");\n\t\t\tgoto scan_error;\n\t\t}\n\t\tprintk(KERN_INFO\n\t\t       \"NILFS: try rollback from an earlier position\\n\");\n\n\t\t/*\n\t\t * restore super block with its spare and reconfigure\n\t\t * relevant states of the nilfs object.\n\t\t */\n\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\tnilfs->ns_crc_seed = le32_to_cpu(sbp[0]->s_crc_seed);\n\t\tnilfs->ns_sbwtime = le64_to_cpu(sbp[0]->s_wtime);\n\n\t\t/* verify consistency between two super blocks */\n\t\tblocksize = BLOCK_SIZE << le32_to_cpu(sbp[0]->s_log_block_size);\n\t\tif (blocksize != nilfs->ns_blocksize) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: blocksize differs between \"\n\t\t\t       \"two super blocks (%d != %d)\\n\",\n\t\t\t       blocksize, nilfs->ns_blocksize);\n\t\t\tgoto scan_error;\n\t\t}\n\n\t\terr = nilfs_store_log_cursor(nilfs, sbp[0]);\n\t\tif (err)\n\t\t\tgoto scan_error;\n\n\t\t/* drop clean flag to allow roll-forward and recovery */\n\t\tnilfs->ns_mount_state &= ~NILFS_VALID_FS;\n\t\tvalid_fs = 0;\n\n\t\terr = nilfs_search_super_root(nilfs, &ri);\n\t\tif (err)\n\t\t\tgoto scan_error;\n\t}\n\n\terr = nilfs_load_super_root(nilfs, sb, ri.ri_super_root);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR \"NILFS: error loading super root.\\n\");\n\t\tgoto failed;\n\t}\n\n\tif (valid_fs)\n\t\tgoto skip_recovery;\n\n\tif (s_flags & MS_RDONLY) {\n\t\t__u64 features;\n\n\t\tif (nilfs_test_opt(nilfs, NORECOVERY)) {\n\t\t\tprintk(KERN_INFO \"NILFS: norecovery option specified. \"\n\t\t\t       \"skipping roll-forward recovery\\n\");\n\t\t\tgoto skip_recovery;\n\t\t}\n\t\tfeatures = le64_to_cpu(nilfs->ns_sbp[0]->s_feature_compat_ro) &\n\t\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\t\tif (features) {\n\t\t\tprintk(KERN_ERR \"NILFS: couldn't proceed with \"\n\t\t\t       \"recovery because of unsupported optional \"\n\t\t\t       \"features (%llx)\\n\",\n\t\t\t       (unsigned long long)features);\n\t\t\terr = -EROFS;\n\t\t\tgoto failed_unload;\n\t\t}\n\t\tif (really_read_only) {\n\t\t\tprintk(KERN_ERR \"NILFS: write access \"\n\t\t\t       \"unavailable, cannot proceed.\\n\");\n\t\t\terr = -EROFS;\n\t\t\tgoto failed_unload;\n\t\t}\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t} else if (nilfs_test_opt(nilfs, NORECOVERY)) {\n\t\tprintk(KERN_ERR \"NILFS: recovery cancelled because norecovery \"\n\t\t       \"option was specified for a read/write mount\\n\");\n\t\terr = -EINVAL;\n\t\tgoto failed_unload;\n\t}\n\n\terr = nilfs_salvage_orphan_logs(nilfs, sb, &ri);\n\tif (err)\n\t\tgoto failed_unload;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs->ns_mount_state |= NILFS_VALID_FS; /* set \"clean\" flag */\n\terr = nilfs_cleanup_super(sb);\n\tup_write(&nilfs->ns_sem);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"NILFS: failed to update super block. \"\n\t\t       \"recovery unfinished.\\n\");\n\t\tgoto failed_unload;\n\t}\n\tprintk(KERN_INFO \"NILFS: recovery complete.\\n\");\n\n skip_recovery:\n\tnilfs_clear_recovery_info(&ri);\n\tsb->s_flags = s_flags;\n\treturn 0;\n\n scan_error:\n\tprintk(KERN_ERR \"NILFS: error searching super root.\\n\");\n\tgoto failed;\n\n failed_unload:\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_dat);\n\n failed:\n\tnilfs_clear_recovery_info(&ri);\n\tsb->s_flags = s_flags;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "sb->s_bdev"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_nilfs",
          "args": [
            "nilfs",
            "sb",
            "(char *)data"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "init_nilfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "573-658",
          "snippet": "int init_nilfs(struct the_nilfs *nilfs, struct super_block *sb, char *data)\n{\n\tstruct nilfs_super_block *sbp;\n\tint blocksize;\n\tint err;\n\n\tdown_write(&nilfs->ns_sem);\n\n\tblocksize = sb_min_blocksize(sb, NILFS_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\tprintk(KERN_ERR \"NILFS: unable to set blocksize\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\terr = nilfs_load_super_block(nilfs, sb, blocksize, &sbp);\n\tif (err)\n\t\tgoto out;\n\n\terr = nilfs_store_magic_and_option(sb, sbp, data);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\terr = nilfs_check_feature_compatibility(sb, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(sbp->s_log_block_size);\n\tif (blocksize < NILFS_MIN_BLOCK_SIZE ||\n\t    blocksize > NILFS_MAX_BLOCK_SIZE) {\n\t\tprintk(KERN_ERR \"NILFS: couldn't mount because of unsupported \"\n\t\t       \"filesystem blocksize %d\\n\", blocksize);\n\t\terr = -EINVAL;\n\t\tgoto failed_sbh;\n\t}\n\tif (sb->s_blocksize != blocksize) {\n\t\tint hw_blocksize = bdev_logical_block_size(sb->s_bdev);\n\n\t\tif (blocksize < hw_blocksize) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: blocksize %d too small for device \"\n\t\t\t       \"(sector-size = %d).\\n\",\n\t\t\t       blocksize, hw_blocksize);\n\t\t\terr = -EINVAL;\n\t\t\tgoto failed_sbh;\n\t\t}\n\t\tnilfs_release_super_block(nilfs);\n\t\tsb_set_blocksize(sb, blocksize);\n\n\t\terr = nilfs_load_super_block(nilfs, sb, blocksize, &sbp);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t\t/* not failed_sbh; sbh is released automatically\n\t\t\t   when reloading fails. */\n\t}\n\tnilfs->ns_blocksize_bits = sb->s_blocksize_bits;\n\tnilfs->ns_blocksize = blocksize;\n\n\tget_random_bytes(&nilfs->ns_next_generation,\n\t\t\t sizeof(nilfs->ns_next_generation));\n\n\terr = nilfs_store_disk_layout(nilfs, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tsb->s_maxbytes = nilfs_max_size(sb->s_blocksize_bits);\n\n\tnilfs->ns_mount_state = le16_to_cpu(sbp->s_state);\n\n\terr = nilfs_store_log_cursor(nilfs, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\terr = nilfs_sysfs_create_device_group(sb);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tset_nilfs_init(nilfs);\n\terr = 0;\n out:\n\tup_write(&nilfs->ns_sem);\n\treturn err;\n\n failed_sbh:\n\tnilfs_release_super_block(nilfs);\n\tgoto out;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nint init_nilfs(struct the_nilfs *nilfs, struct super_block *sb, char *data)\n{\n\tstruct nilfs_super_block *sbp;\n\tint blocksize;\n\tint err;\n\n\tdown_write(&nilfs->ns_sem);\n\n\tblocksize = sb_min_blocksize(sb, NILFS_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\tprintk(KERN_ERR \"NILFS: unable to set blocksize\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\terr = nilfs_load_super_block(nilfs, sb, blocksize, &sbp);\n\tif (err)\n\t\tgoto out;\n\n\terr = nilfs_store_magic_and_option(sb, sbp, data);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\terr = nilfs_check_feature_compatibility(sb, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(sbp->s_log_block_size);\n\tif (blocksize < NILFS_MIN_BLOCK_SIZE ||\n\t    blocksize > NILFS_MAX_BLOCK_SIZE) {\n\t\tprintk(KERN_ERR \"NILFS: couldn't mount because of unsupported \"\n\t\t       \"filesystem blocksize %d\\n\", blocksize);\n\t\terr = -EINVAL;\n\t\tgoto failed_sbh;\n\t}\n\tif (sb->s_blocksize != blocksize) {\n\t\tint hw_blocksize = bdev_logical_block_size(sb->s_bdev);\n\n\t\tif (blocksize < hw_blocksize) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: blocksize %d too small for device \"\n\t\t\t       \"(sector-size = %d).\\n\",\n\t\t\t       blocksize, hw_blocksize);\n\t\t\terr = -EINVAL;\n\t\t\tgoto failed_sbh;\n\t\t}\n\t\tnilfs_release_super_block(nilfs);\n\t\tsb_set_blocksize(sb, blocksize);\n\n\t\terr = nilfs_load_super_block(nilfs, sb, blocksize, &sbp);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t\t/* not failed_sbh; sbh is released automatically\n\t\t\t   when reloading fails. */\n\t}\n\tnilfs->ns_blocksize_bits = sb->s_blocksize_bits;\n\tnilfs->ns_blocksize = blocksize;\n\n\tget_random_bytes(&nilfs->ns_next_generation,\n\t\t\t sizeof(nilfs->ns_next_generation));\n\n\terr = nilfs_store_disk_layout(nilfs, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tsb->s_maxbytes = nilfs_max_size(sb->s_blocksize_bits);\n\n\tnilfs->ns_mount_state = le16_to_cpu(sbp->s_state);\n\n\terr = nilfs_store_log_cursor(nilfs, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\terr = nilfs_sysfs_create_device_group(sb);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tset_nilfs_init(nilfs);\n\terr = 0;\n out:\n\tup_write(&nilfs->ns_sem);\n\treturn err;\n\n failed_sbh:\n\tnilfs_release_super_block(nilfs);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_nilfs",
          "args": [
            "sb->s_bdev"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nilfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "68-91",
          "snippet": "struct the_nilfs *alloc_nilfs(struct block_device *bdev)\n{\n\tstruct the_nilfs *nilfs;\n\n\tnilfs = kzalloc(sizeof(*nilfs), GFP_KERNEL);\n\tif (!nilfs)\n\t\treturn NULL;\n\n\tnilfs->ns_bdev = bdev;\n\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\tinit_rwsem(&nilfs->ns_sem);\n\tmutex_init(&nilfs->ns_snapshot_mount_mutex);\n\tINIT_LIST_HEAD(&nilfs->ns_dirty_files);\n\tINIT_LIST_HEAD(&nilfs->ns_gc_inodes);\n\tspin_lock_init(&nilfs->ns_inode_lock);\n\tspin_lock_init(&nilfs->ns_next_gen_lock);\n\tspin_lock_init(&nilfs->ns_last_segment_lock);\n\tnilfs->ns_cptree = RB_ROOT;\n\tspin_lock_init(&nilfs->ns_cptree_lock);\n\tinit_rwsem(&nilfs->ns_segctor_sem);\n\tnilfs->ns_sb_update_freq = NILFS_SB_FREQ;\n\n\treturn nilfs;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstruct the_nilfs *alloc_nilfs(struct block_device *bdev)\n{\n\tstruct the_nilfs *nilfs;\n\n\tnilfs = kzalloc(sizeof(*nilfs), GFP_KERNEL);\n\tif (!nilfs)\n\t\treturn NULL;\n\n\tnilfs->ns_bdev = bdev;\n\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\tinit_rwsem(&nilfs->ns_sem);\n\tmutex_init(&nilfs->ns_snapshot_mount_mutex);\n\tINIT_LIST_HEAD(&nilfs->ns_dirty_files);\n\tINIT_LIST_HEAD(&nilfs->ns_gc_inodes);\n\tspin_lock_init(&nilfs->ns_inode_lock);\n\tspin_lock_init(&nilfs->ns_next_gen_lock);\n\tspin_lock_init(&nilfs->ns_last_segment_lock);\n\tnilfs->ns_cptree = RB_ROOT;\n\tspin_lock_init(&nilfs->ns_cptree_lock);\n\tinit_rwsem(&nilfs->ns_segctor_sem);\n\tnilfs->ns_sb_update_freq = NILFS_SB_FREQ;\n\n\treturn nilfs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\nstatic const struct super_operations nilfs_sops = {\n\t.alloc_inode    = nilfs_alloc_inode,\n\t.destroy_inode  = nilfs_destroy_inode,\n\t.dirty_inode    = nilfs_dirty_inode,\n\t.evict_inode    = nilfs_evict_inode,\n\t.put_super      = nilfs_put_super,\n\t.sync_fs        = nilfs_sync_fs,\n\t.freeze_fs\t= nilfs_freeze,\n\t.unfreeze_fs\t= nilfs_unfreeze,\n\t.statfs         = nilfs_statfs,\n\t.remount_fs     = nilfs_remount,\n\t.show_options = nilfs_show_options\n};\n\nstatic int\nnilfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct the_nilfs *nilfs;\n\tstruct nilfs_root *fsroot;\n\t__u64 cno;\n\tint err;\n\n\tnilfs = alloc_nilfs(sb->s_bdev);\n\tif (!nilfs)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = nilfs;\n\n\terr = init_nilfs(nilfs, sb, (char *)data);\n\tif (err)\n\t\tgoto failed_nilfs;\n\n\tsb->s_op = &nilfs_sops;\n\tsb->s_export_op = &nilfs_export_ops;\n\tsb->s_root = NULL;\n\tsb->s_time_gran = 1;\n\tsb->s_max_links = NILFS_LINK_MAX;\n\n\tsb->s_bdi = &bdev_get_queue(sb->s_bdev)->backing_dev_info;\n\n\terr = load_nilfs(nilfs, sb);\n\tif (err)\n\t\tgoto failed_nilfs;\n\n\tcno = nilfs_last_cno(nilfs);\n\terr = nilfs_attach_checkpoint(sb, cno, true, &fsroot);\n\tif (err) {\n\t\tprintk(KERN_ERR \"NILFS: error loading last checkpoint \"\n\t\t       \"(checkpoint number=%llu).\\n\", (unsigned long long)cno);\n\t\tgoto failed_unload;\n\t}\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\terr = nilfs_attach_log_writer(sb, fsroot);\n\t\tif (err)\n\t\t\tgoto failed_checkpoint;\n\t}\n\n\terr = nilfs_get_root_dentry(sb, fsroot, &sb->s_root);\n\tif (err)\n\t\tgoto failed_segctor;\n\n\tnilfs_put_root(fsroot);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_setup_super(sb, true);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n\n\treturn 0;\n\n failed_segctor:\n\tnilfs_detach_log_writer(sb);\n\n failed_checkpoint:\n\tnilfs_put_root(fsroot);\n\n failed_unload:\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_dat);\n\n failed_nilfs:\n\tdestroy_nilfs(nilfs);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_checkpoint_is_mounted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1015-1044",
    "snippet": "int nilfs_checkpoint_is_mounted(struct super_block *sb, __u64 cno)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint ret;\n\n\tif (cno < 0 || cno > nilfs->ns_cno)\n\t\treturn false;\n\n\tif (cno >= nilfs_last_cno(nilfs))\n\t\treturn true;\t/* protect recent checkpoints */\n\n\tret = false;\n\troot = nilfs_lookup_root(nilfs, cno);\n\tif (root) {\n\t\tinode = nilfs_ilookup(sb, root, NILFS_ROOT_INO);\n\t\tif (inode) {\n\t\t\tdentry = d_find_alias(inode);\n\t\t\tif (dentry) {\n\t\t\t\tret = nilfs_tree_is_busy(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t}\n\t\tnilfs_put_root(root);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_put_root",
          "args": [
            "root"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "801-815",
          "snippet": "void nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_tree_is_busy",
          "args": [
            "dentry"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_tree_is_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "1009-1013",
          "snippet": "static bool nilfs_tree_is_busy(struct dentry *root_dentry)\n{\n\tshrink_dcache_parent(root_dentry);\n\treturn d_count(root_dentry) > 1;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic bool nilfs_tree_is_busy(struct dentry *root_dentry)\n{\n\tshrink_dcache_parent(root_dentry);\n\treturn d_count(root_dentry) > 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ilookup",
          "args": [
            "sb",
            "root",
            "NILFS_ROOT_INO"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ilookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "588-596",
          "snippet": "struct inode *nilfs_ilookup(struct super_block *sb, struct nilfs_root *root,\n\t\t\t    unsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn ilookup5(sb, ino, nilfs_iget_test, &args);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstruct inode *nilfs_ilookup(struct super_block *sb, struct nilfs_root *root,\n\t\t\t    unsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn ilookup5(sb, ino, nilfs_iget_test, &args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_lookup_root",
          "args": [
            "nilfs",
            "cno"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_lookup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "719-742",
          "snippet": "struct nilfs_root *nilfs_lookup_root(struct the_nilfs *nilfs, __u64 cno)\n{\n\tstruct rb_node *n;\n\tstruct nilfs_root *root;\n\n\tspin_lock(&nilfs->ns_cptree_lock);\n\tn = nilfs->ns_cptree.rb_node;\n\twhile (n) {\n\t\troot = rb_entry(n, struct nilfs_root, rb_node);\n\n\t\tif (cno < root->cno) {\n\t\t\tn = n->rb_left;\n\t\t} else if (cno > root->cno) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tatomic_inc(&root->count);\n\t\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\t\treturn root;\n\t\t}\n\t}\n\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstruct nilfs_root *nilfs_lookup_root(struct the_nilfs *nilfs, __u64 cno)\n{\n\tstruct rb_node *n;\n\tstruct nilfs_root *root;\n\n\tspin_lock(&nilfs->ns_cptree_lock);\n\tn = nilfs->ns_cptree.rb_node;\n\twhile (n) {\n\t\troot = rb_entry(n, struct nilfs_root, rb_node);\n\n\t\tif (cno < root->cno) {\n\t\t\tn = n->rb_left;\n\t\t} else if (cno > root->cno) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tatomic_inc(&root->count);\n\t\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\t\treturn root;\n\t\t}\n\t}\n\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_last_cno",
          "args": [
            "nilfs"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_last_cno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "361-369",
          "snippet": "static inline __u64 nilfs_last_cno(struct the_nilfs *nilfs)\n{\n\t__u64 cno;\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tcno = nilfs->ns_last_cno;\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n\treturn cno;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline __u64 nilfs_last_cno(struct the_nilfs *nilfs)\n{\n\t__u64 cno;\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tcno = nilfs->ns_last_cno;\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n\treturn cno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_checkpoint_is_mounted(struct super_block *sb, __u64 cno)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint ret;\n\n\tif (cno < 0 || cno > nilfs->ns_cno)\n\t\treturn false;\n\n\tif (cno >= nilfs_last_cno(nilfs))\n\t\treturn true;\t/* protect recent checkpoints */\n\n\tret = false;\n\troot = nilfs_lookup_root(nilfs, cno);\n\tif (root) {\n\t\tinode = nilfs_ilookup(sb, root, NILFS_ROOT_INO);\n\t\tif (inode) {\n\t\t\tdentry = d_find_alias(inode);\n\t\t\tif (dentry) {\n\t\t\t\tret = nilfs_tree_is_busy(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t}\n\t\tnilfs_put_root(root);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_tree_is_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "1009-1013",
    "snippet": "static bool nilfs_tree_is_busy(struct dentry *root_dentry)\n{\n\tshrink_dcache_parent(root_dentry);\n\treturn d_count(root_dentry) > 1;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "root_dentry"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_parent",
          "args": [
            "root_dentry"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1361-1377",
          "snippet": "void shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic bool nilfs_tree_is_busy(struct dentry *root_dentry)\n{\n\tshrink_dcache_parent(root_dentry);\n\treturn d_count(root_dentry) > 1;\n}"
  },
  {
    "function_name": "nilfs_attach_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "966-1001",
    "snippet": "static int nilfs_attach_snapshot(struct super_block *s, __u64 cno,\n\t\t\t\t struct dentry **root_dentry)\n{\n\tstruct the_nilfs *nilfs = s->s_fs_info;\n\tstruct nilfs_root *root;\n\tint ret;\n\n\tmutex_lock(&nilfs->ns_snapshot_mount_mutex);\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_is_snapshot(nilfs->ns_cpfile, cno);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0) {\n\t\tret = (ret == -ENOENT) ? -EINVAL : ret;\n\t\tgoto out;\n\t} else if (!ret) {\n\t\tprintk(KERN_ERR \"NILFS: The specified checkpoint is \"\n\t\t       \"not a snapshot (checkpoint number=%llu).\\n\",\n\t\t       (unsigned long long)cno);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = nilfs_attach_checkpoint(s, cno, false, &root);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"NILFS: error loading snapshot \"\n\t\t       \"(checkpoint number=%llu).\\n\",\n\t       (unsigned long long)cno);\n\t\tgoto out;\n\t}\n\tret = nilfs_get_root_dentry(s, root, root_dentry);\n\tnilfs_put_root(root);\n out:\n\tmutex_unlock(&nilfs->ns_snapshot_mount_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nilfs->ns_snapshot_mount_mutex"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_put_root",
          "args": [
            "root"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "801-815",
          "snippet": "void nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_get_root_dentry",
          "args": [
            "s",
            "root",
            "root_dentry"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_get_root_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "918-964",
          "snippet": "static int nilfs_get_root_dentry(struct super_block *sb,\n\t\t\t\t struct nilfs_root *root,\n\t\t\t\t struct dentry **root_dentry)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tinode = nilfs_iget(sb, root, NILFS_ROOT_INO);\n\tif (IS_ERR(inode)) {\n\t\tprintk(KERN_ERR \"NILFS: get root inode failed\\n\");\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tif (!S_ISDIR(inode->i_mode) || !inode->i_blocks || !inode->i_size) {\n\t\tiput(inode);\n\t\tprintk(KERN_ERR \"NILFS: corrupt root inode.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (root->cno == NILFS_CPTREE_CURRENT_CNO) {\n\t\tdentry = d_find_alias(inode);\n\t\tif (!dentry) {\n\t\t\tdentry = d_make_root(inode);\n\t\t\tif (!dentry) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto failed_dentry;\n\t\t\t}\n\t\t} else {\n\t\t\tiput(inode);\n\t\t}\n\t} else {\n\t\tdentry = d_obtain_root(inode);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tgoto failed_dentry;\n\t\t}\n\t}\n\t*root_dentry = dentry;\n out:\n\treturn ret;\n\n failed_dentry:\n\tprintk(KERN_ERR \"NILFS: get root dentry failed\\n\");\n\tgoto out;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_get_root_dentry(struct super_block *sb,\n\t\t\t\t struct nilfs_root *root,\n\t\t\t\t struct dentry **root_dentry)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tinode = nilfs_iget(sb, root, NILFS_ROOT_INO);\n\tif (IS_ERR(inode)) {\n\t\tprintk(KERN_ERR \"NILFS: get root inode failed\\n\");\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tif (!S_ISDIR(inode->i_mode) || !inode->i_blocks || !inode->i_size) {\n\t\tiput(inode);\n\t\tprintk(KERN_ERR \"NILFS: corrupt root inode.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (root->cno == NILFS_CPTREE_CURRENT_CNO) {\n\t\tdentry = d_find_alias(inode);\n\t\tif (!dentry) {\n\t\t\tdentry = d_make_root(inode);\n\t\t\tif (!dentry) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto failed_dentry;\n\t\t\t}\n\t\t} else {\n\t\t\tiput(inode);\n\t\t}\n\t} else {\n\t\tdentry = d_obtain_root(inode);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tgoto failed_dentry;\n\t\t}\n\t}\n\t*root_dentry = dentry;\n out:\n\treturn ret;\n\n failed_dentry:\n\tprintk(KERN_ERR \"NILFS: get root dentry failed\\n\");\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NILFS: error loading snapshot \"\n\t\t       \"(checkpoint number=%llu).\\n\"",
            "(unsigned long long)cno"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_attach_checkpoint",
          "args": [
            "s",
            "cno",
            "false",
            "&root"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_attach_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "526-580",
          "snippet": "int nilfs_attach_checkpoint(struct super_block *sb, __u64 cno, int curr_mnt,\n\t\t\t    struct nilfs_root **rootp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct nilfs_checkpoint *raw_cp;\n\tstruct buffer_head *bh_cp;\n\tint err = -ENOMEM;\n\n\troot = nilfs_find_or_create_root(\n\t\tnilfs, curr_mnt ? NILFS_CPTREE_CURRENT_CNO : cno);\n\tif (!root)\n\t\treturn err;\n\n\tif (root->ifile)\n\t\tgoto reuse; /* already attached checkpoint */\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, cno, 0, &raw_cp,\n\t\t\t\t\t  &bh_cp);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT || err == -EINVAL) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Invalid checkpoint \"\n\t\t\t       \"(checkpoint number=%llu)\\n\",\n\t\t\t       (unsigned long long)cno);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tgoto failed;\n\t}\n\n\terr = nilfs_ifile_read(sb, root, nilfs->ns_inode_size,\n\t\t\t       &raw_cp->cp_ifile_inode, &root->ifile);\n\tif (err)\n\t\tgoto failed_bh;\n\n\tatomic64_set(&root->inodes_count,\n\t\t\tle64_to_cpu(raw_cp->cp_inodes_count));\n\tatomic64_set(&root->blocks_count,\n\t\t\tle64_to_cpu(raw_cp->cp_blocks_count));\n\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n\n reuse:\n\t*rootp = root;\n\treturn 0;\n\n failed_bh:\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n failed:\n\tnilfs_put_root(root);\n\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_attach_checkpoint(struct super_block *sb, __u64 cno, int curr_mnt,\n\t\t\t    struct nilfs_root **rootp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct nilfs_checkpoint *raw_cp;\n\tstruct buffer_head *bh_cp;\n\tint err = -ENOMEM;\n\n\troot = nilfs_find_or_create_root(\n\t\tnilfs, curr_mnt ? NILFS_CPTREE_CURRENT_CNO : cno);\n\tif (!root)\n\t\treturn err;\n\n\tif (root->ifile)\n\t\tgoto reuse; /* already attached checkpoint */\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, cno, 0, &raw_cp,\n\t\t\t\t\t  &bh_cp);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT || err == -EINVAL) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Invalid checkpoint \"\n\t\t\t       \"(checkpoint number=%llu)\\n\",\n\t\t\t       (unsigned long long)cno);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tgoto failed;\n\t}\n\n\terr = nilfs_ifile_read(sb, root, nilfs->ns_inode_size,\n\t\t\t       &raw_cp->cp_ifile_inode, &root->ifile);\n\tif (err)\n\t\tgoto failed_bh;\n\n\tatomic64_set(&root->inodes_count,\n\t\t\tle64_to_cpu(raw_cp->cp_inodes_count));\n\tatomic64_set(&root->blocks_count,\n\t\t\tle64_to_cpu(raw_cp->cp_blocks_count));\n\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n\n reuse:\n\t*rootp = root;\n\treturn 0;\n\n failed_bh:\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n failed:\n\tnilfs_put_root(root);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_is_snapshot",
          "args": [
            "nilfs->ns_cpfile",
            "cno"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_is_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "820-848",
          "snippet": "int nilfs_cpfile_is_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\t/* CP number is invalid if it's zero or larger than the\n\tlargest\texist one.*/\n\tif (cno == 0 || cno >= nilfs_mdt_cno(cpfile))\n\t\treturn -ENOENT;\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\n\tif (ret < 0)\n\t\tgoto out;\n\tkaddr = kmap_atomic(bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp))\n\t\tret = -ENOENT;\n\telse\n\t\tret = nilfs_checkpoint_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_is_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\t/* CP number is invalid if it's zero or larger than the\n\tlargest\texist one.*/\n\tif (cno == 0 || cno >= nilfs_mdt_cno(cpfile))\n\t\treturn -ENOENT;\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\n\tif (ret < 0)\n\t\tgoto out;\n\tkaddr = kmap_atomic(bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp))\n\t\tret = -ENOENT;\n\telse\n\t\tret = nilfs_checkpoint_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nilfs->ns_snapshot_mount_mutex"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_attach_snapshot(struct super_block *s, __u64 cno,\n\t\t\t\t struct dentry **root_dentry)\n{\n\tstruct the_nilfs *nilfs = s->s_fs_info;\n\tstruct nilfs_root *root;\n\tint ret;\n\n\tmutex_lock(&nilfs->ns_snapshot_mount_mutex);\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_is_snapshot(nilfs->ns_cpfile, cno);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0) {\n\t\tret = (ret == -ENOENT) ? -EINVAL : ret;\n\t\tgoto out;\n\t} else if (!ret) {\n\t\tprintk(KERN_ERR \"NILFS: The specified checkpoint is \"\n\t\t       \"not a snapshot (checkpoint number=%llu).\\n\",\n\t\t       (unsigned long long)cno);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = nilfs_attach_checkpoint(s, cno, false, &root);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"NILFS: error loading snapshot \"\n\t\t       \"(checkpoint number=%llu).\\n\",\n\t       (unsigned long long)cno);\n\t\tgoto out;\n\t}\n\tret = nilfs_get_root_dentry(s, root, root_dentry);\n\tnilfs_put_root(root);\n out:\n\tmutex_unlock(&nilfs->ns_snapshot_mount_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_get_root_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "918-964",
    "snippet": "static int nilfs_get_root_dentry(struct super_block *sb,\n\t\t\t\t struct nilfs_root *root,\n\t\t\t\t struct dentry **root_dentry)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tinode = nilfs_iget(sb, root, NILFS_ROOT_INO);\n\tif (IS_ERR(inode)) {\n\t\tprintk(KERN_ERR \"NILFS: get root inode failed\\n\");\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tif (!S_ISDIR(inode->i_mode) || !inode->i_blocks || !inode->i_size) {\n\t\tiput(inode);\n\t\tprintk(KERN_ERR \"NILFS: corrupt root inode.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (root->cno == NILFS_CPTREE_CURRENT_CNO) {\n\t\tdentry = d_find_alias(inode);\n\t\tif (!dentry) {\n\t\t\tdentry = d_make_root(inode);\n\t\t\tif (!dentry) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto failed_dentry;\n\t\t\t}\n\t\t} else {\n\t\t\tiput(inode);\n\t\t}\n\t} else {\n\t\tdentry = d_obtain_root(inode);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tgoto failed_dentry;\n\t\t}\n\t}\n\t*root_dentry = dentry;\n out:\n\treturn ret;\n\n failed_dentry:\n\tprintk(KERN_ERR \"NILFS: get root dentry failed\\n\");\n\tgoto out;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NILFS: get root dentry failed\\n\""
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_obtain_root",
          "args": [
            "inode"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1998-2001",
          "snippet": "struct dentry *d_obtain_root(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_root(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_iget",
          "args": [
            "sb",
            "root",
            "NILFS_ROOT_INO"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iget_for_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "629-651",
          "snippet": "struct inode *nilfs_iget_for_gc(struct super_block *sb, unsigned long ino,\n\t\t\t\t__u64 cno)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = NULL, .cno = cno, .for_gc = 1\n\t};\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = nilfs_init_gcinode(inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstruct inode *nilfs_iget_for_gc(struct super_block *sb, unsigned long ino,\n\t\t\t\t__u64 cno)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = NULL, .cno = cno, .for_gc = 1\n\t};\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = nilfs_init_gcinode(inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_get_root_dentry(struct super_block *sb,\n\t\t\t\t struct nilfs_root *root,\n\t\t\t\t struct dentry **root_dentry)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tinode = nilfs_iget(sb, root, NILFS_ROOT_INO);\n\tif (IS_ERR(inode)) {\n\t\tprintk(KERN_ERR \"NILFS: get root inode failed\\n\");\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tif (!S_ISDIR(inode->i_mode) || !inode->i_blocks || !inode->i_size) {\n\t\tiput(inode);\n\t\tprintk(KERN_ERR \"NILFS: corrupt root inode.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (root->cno == NILFS_CPTREE_CURRENT_CNO) {\n\t\tdentry = d_find_alias(inode);\n\t\tif (!dentry) {\n\t\t\tdentry = d_make_root(inode);\n\t\t\tif (!dentry) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto failed_dentry;\n\t\t\t}\n\t\t} else {\n\t\t\tiput(inode);\n\t\t}\n\t} else {\n\t\tdentry = d_obtain_root(inode);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tgoto failed_dentry;\n\t\t}\n\t}\n\t*root_dentry = dentry;\n out:\n\treturn ret;\n\n failed_dentry:\n\tprintk(KERN_ERR \"NILFS: get root dentry failed\\n\");\n\tgoto out;\n}"
  },
  {
    "function_name": "nilfs_check_feature_compatibility",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "894-916",
    "snippet": "int nilfs_check_feature_compatibility(struct super_block *sb,\n\t\t\t\t      struct nilfs_super_block *sbp)\n{\n\t__u64 features;\n\n\tfeatures = le64_to_cpu(sbp->s_feature_incompat) &\n\t\t~NILFS_FEATURE_INCOMPAT_SUPP;\n\tif (features) {\n\t\tprintk(KERN_ERR \"NILFS: couldn't mount because of unsupported \"\n\t\t       \"optional features (%llx)\\n\",\n\t\t       (unsigned long long)features);\n\t\treturn -EINVAL;\n\t}\n\tfeatures = le64_to_cpu(sbp->s_feature_compat_ro) &\n\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\tprintk(KERN_ERR \"NILFS: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%llx)\\n\",\n\t\t       (unsigned long long)features);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NILFS: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%llx)\\n\"",
            "(unsigned long long)features"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sbp->s_feature_compat_ro"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_check_feature_compatibility(struct super_block *sb,\n\t\t\t\t      struct nilfs_super_block *sbp)\n{\n\t__u64 features;\n\n\tfeatures = le64_to_cpu(sbp->s_feature_incompat) &\n\t\t~NILFS_FEATURE_INCOMPAT_SUPP;\n\tif (features) {\n\t\tprintk(KERN_ERR \"NILFS: couldn't mount because of unsupported \"\n\t\t       \"optional features (%llx)\\n\",\n\t\t       (unsigned long long)features);\n\t\treturn -EINVAL;\n\t}\n\tfeatures = le64_to_cpu(sbp->s_feature_compat_ro) &\n\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\tprintk(KERN_ERR \"NILFS: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%llx)\\n\",\n\t\t       (unsigned long long)features);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_store_magic_and_option",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "871-892",
    "snippet": "int nilfs_store_magic_and_option(struct super_block *sb,\n\t\t\t\t struct nilfs_super_block *sbp,\n\t\t\t\t char *data)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tsb->s_magic = le16_to_cpu(sbp->s_magic);\n\n\t/* FS independent flags */\n#ifdef NILFS_ATIME_DISABLE\n\tsb->s_flags |= MS_NOATIME;\n#endif\n\n\tnilfs_set_default_options(sb, sbp);\n\n\tnilfs->ns_resuid = le16_to_cpu(sbp->s_def_resuid);\n\tnilfs->ns_resgid = le16_to_cpu(sbp->s_def_resgid);\n\tnilfs->ns_interval = le32_to_cpu(sbp->s_c_interval);\n\tnilfs->ns_watermark = le32_to_cpu(sbp->s_c_block_max);\n\n\treturn !parse_options(data, sb, 0) ? -EINVAL : 0 ;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "data",
            "sb",
            "0"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "738-803",
          "snippet": "static int parse_options(char *options, struct super_block *sb, int is_remount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_barrier:\n\t\t\tnilfs_set_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tnilfs_clear_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_order:\n\t\t\tif (strcmp(args[0].from, \"relaxed\") == 0)\n\t\t\t\t/* Ordered data semantics */\n\t\t\t\tnilfs_clear_opt(nilfs, STRICT_ORDER);\n\t\t\telse if (strcmp(args[0].from, \"strict\") == 0)\n\t\t\t\t/* Strict in-order semantics */\n\t\t\t\tnilfs_set_opt(nilfs, STRICT_ORDER);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_snapshot:\n\t\t\tif (is_remount) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"NILFS: \\\"%s\\\" option is invalid \"\n\t\t\t\t       \"for remount.\\n\", p);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\tnilfs_set_opt(nilfs, NORECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tnilfs_set_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tnilfs_clear_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Unrecognized mount option \\\"%s\\\"\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_remount(struct super_block *sb, int *flags, char *data);",
            "static match_table_t tokens = {\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_snapshot, \"cp=%u\"},\n\t{Opt_order, \"order=%s\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\nstatic match_table_t tokens = {\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_snapshot, \"cp=%u\"},\n\t{Opt_order, \"order=%s\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb, int is_remount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_barrier:\n\t\t\tnilfs_set_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tnilfs_clear_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_order:\n\t\t\tif (strcmp(args[0].from, \"relaxed\") == 0)\n\t\t\t\t/* Ordered data semantics */\n\t\t\t\tnilfs_clear_opt(nilfs, STRICT_ORDER);\n\t\t\telse if (strcmp(args[0].from, \"strict\") == 0)\n\t\t\t\t/* Strict in-order semantics */\n\t\t\t\tnilfs_set_opt(nilfs, STRICT_ORDER);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_snapshot:\n\t\t\tif (is_remount) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"NILFS: \\\"%s\\\" option is invalid \"\n\t\t\t\t       \"for remount.\\n\", p);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\tnilfs_set_opt(nilfs, NORECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tnilfs_set_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tnilfs_clear_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Unrecognized mount option \\\"%s\\\"\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbp->s_c_block_max"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sbp->s_def_resgid"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_default_options",
          "args": [
            "sb",
            "sbp"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_default_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "805-813",
          "snippet": "static inline void\nnilfs_set_default_options(struct super_block *sb,\n\t\t\t  struct nilfs_super_block *sbp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tnilfs->ns_mount_opt =\n\t\tNILFS_MOUNT_ERRORS_RO | NILFS_MOUNT_BARRIER;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void\nnilfs_set_default_options(struct super_block *sb,\n\t\t\t  struct nilfs_super_block *sbp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tnilfs->ns_mount_opt =\n\t\tNILFS_MOUNT_ERRORS_RO | NILFS_MOUNT_BARRIER;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\n\nint nilfs_store_magic_and_option(struct super_block *sb,\n\t\t\t\t struct nilfs_super_block *sbp,\n\t\t\t\t char *data)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tsb->s_magic = le16_to_cpu(sbp->s_magic);\n\n\t/* FS independent flags */\n#ifdef NILFS_ATIME_DISABLE\n\tsb->s_flags |= MS_NOATIME;\n#endif\n\n\tnilfs_set_default_options(sb, sbp);\n\n\tnilfs->ns_resuid = le16_to_cpu(sbp->s_def_resuid);\n\tnilfs->ns_resgid = le16_to_cpu(sbp->s_def_resgid);\n\tnilfs->ns_interval = le32_to_cpu(sbp->s_c_interval);\n\tnilfs->ns_watermark = le32_to_cpu(sbp->s_c_block_max);\n\n\treturn !parse_options(data, sb, 0) ? -EINVAL : 0 ;\n}"
  },
  {
    "function_name": "nilfs_read_super_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "857-869",
    "snippet": "struct nilfs_super_block *nilfs_read_super_block(struct super_block *sb,\n\t\t\t\t\t\t u64 pos, int blocksize,\n\t\t\t\t\t\t struct buffer_head **pbh)\n{\n\tunsigned long long sb_index = pos;\n\tunsigned long offset;\n\n\toffset = do_div(sb_index, blocksize);\n\t*pbh = sb_bread(sb, sb_index);\n\tif (!*pbh)\n\t\treturn NULL;\n\treturn (struct nilfs_super_block *)((char *)(*pbh)->b_data + offset);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "sb_index"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "sb_index",
            "blocksize"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstruct nilfs_super_block *nilfs_read_super_block(struct super_block *sb,\n\t\t\t\t\t\t u64 pos, int blocksize,\n\t\t\t\t\t\t struct buffer_head **pbh)\n{\n\tunsigned long long sb_index = pos;\n\tunsigned long offset;\n\n\toffset = do_div(sb_index, blocksize);\n\t*pbh = sb_bread(sb, sb_index);\n\tif (!*pbh)\n\t\treturn NULL;\n\treturn (struct nilfs_super_block *)((char *)(*pbh)->b_data + offset);\n}"
  },
  {
    "function_name": "nilfs_setup_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "815-855",
    "snippet": "static int nilfs_setup_super(struct super_block *sb, int is_mount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint max_mnt_count;\n\tint mnt_count;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (!sbp)\n\t\treturn -EIO;\n\n\tif (!is_mount)\n\t\tgoto skip_mount_setup;\n\n\tmax_mnt_count = le16_to_cpu(sbp[0]->s_max_mnt_count);\n\tmnt_count = le16_to_cpu(sbp[0]->s_mnt_count);\n\n\tif (nilfs->ns_mount_state & NILFS_ERROR_FS) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: mounting fs with errors\\n\");\n#if 0\n\t} else if (max_mnt_count >= 0 && mnt_count >= max_mnt_count) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: maximal mount count reached\\n\");\n#endif\n\t}\n\tif (!max_mnt_count)\n\t\tsbp[0]->s_max_mnt_count = cpu_to_le16(NILFS_DFL_MAX_MNT_COUNT);\n\n\tsbp[0]->s_mnt_count = cpu_to_le16(mnt_count + 1);\n\tsbp[0]->s_mtime = cpu_to_le64(get_seconds());\n\nskip_mount_setup:\n\tsbp[0]->s_state =\n\t\tcpu_to_le16(le16_to_cpu(sbp[0]->s_state) & ~NILFS_VALID_FS);\n\t/* synchronize sbp[1] with sbp[0] */\n\tif (sbp[1])\n\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\treturn nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_setup_super(struct super_block *sb, int is_mount);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_commit_super",
          "args": [
            "sb",
            "NILFS_SB_COMMIT_ALL"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "291-317",
          "snippet": "int nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sbp[1]",
            "sbp[0]",
            "nilfs->ns_sbsize"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "le16_to_cpu(sbp[0]->s_state) & ~NILFS_VALID_FS"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sbp[0]->s_state"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "get_seconds()"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "mnt_count + 1"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "NILFS_DFL_MAX_MNT_COUNT"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t       \"NILFS warning: maximal mount count reached\\n\""
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_prepare_super",
          "args": [
            "sb",
            "0"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_prepare_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "264-289",
          "snippet": "struct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstruct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_setup_super(struct super_block *sb, int is_mount);\n\nstatic int nilfs_setup_super(struct super_block *sb, int is_mount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint max_mnt_count;\n\tint mnt_count;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (!sbp)\n\t\treturn -EIO;\n\n\tif (!is_mount)\n\t\tgoto skip_mount_setup;\n\n\tmax_mnt_count = le16_to_cpu(sbp[0]->s_max_mnt_count);\n\tmnt_count = le16_to_cpu(sbp[0]->s_mnt_count);\n\n\tif (nilfs->ns_mount_state & NILFS_ERROR_FS) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: mounting fs with errors\\n\");\n#if 0\n\t} else if (max_mnt_count >= 0 && mnt_count >= max_mnt_count) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: maximal mount count reached\\n\");\n#endif\n\t}\n\tif (!max_mnt_count)\n\t\tsbp[0]->s_max_mnt_count = cpu_to_le16(NILFS_DFL_MAX_MNT_COUNT);\n\n\tsbp[0]->s_mnt_count = cpu_to_le16(mnt_count + 1);\n\tsbp[0]->s_mtime = cpu_to_le64(get_seconds());\n\nskip_mount_setup:\n\tsbp[0]->s_state =\n\t\tcpu_to_le16(le16_to_cpu(sbp[0]->s_state) & ~NILFS_VALID_FS);\n\t/* synchronize sbp[1] with sbp[0] */\n\tif (sbp[1])\n\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\treturn nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n}"
  },
  {
    "function_name": "nilfs_set_default_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "805-813",
    "snippet": "static inline void\nnilfs_set_default_options(struct super_block *sb,\n\t\t\t  struct nilfs_super_block *sbp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tnilfs->ns_mount_opt =\n\t\tNILFS_MOUNT_ERRORS_RO | NILFS_MOUNT_BARRIER;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic inline void\nnilfs_set_default_options(struct super_block *sb,\n\t\t\t  struct nilfs_super_block *sbp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tnilfs->ns_mount_opt =\n\t\tNILFS_MOUNT_ERRORS_RO | NILFS_MOUNT_BARRIER;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "738-803",
    "snippet": "static int parse_options(char *options, struct super_block *sb, int is_remount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_barrier:\n\t\t\tnilfs_set_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tnilfs_clear_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_order:\n\t\t\tif (strcmp(args[0].from, \"relaxed\") == 0)\n\t\t\t\t/* Ordered data semantics */\n\t\t\t\tnilfs_clear_opt(nilfs, STRICT_ORDER);\n\t\t\telse if (strcmp(args[0].from, \"strict\") == 0)\n\t\t\t\t/* Strict in-order semantics */\n\t\t\t\tnilfs_set_opt(nilfs, STRICT_ORDER);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_snapshot:\n\t\t\tif (is_remount) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"NILFS: \\\"%s\\\" option is invalid \"\n\t\t\t\t       \"for remount.\\n\", p);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\tnilfs_set_opt(nilfs, NORECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tnilfs_set_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tnilfs_clear_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Unrecognized mount option \\\"%s\\\"\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_remount(struct super_block *sb, int *flags, char *data);",
      "static match_table_t tokens = {\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_snapshot, \"cp=%u\"},\n\t{Opt_order, \"order=%s\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t       \"NILFS: Unrecognized mount option \\\"%s\\\"\\n\"",
            "p"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_clear_opt",
          "args": [
            "nilfs",
            "DISCARD"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_set_opt",
          "args": [
            "nilfs",
            "DISCARD"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_set_opt",
          "args": [
            "nilfs",
            "NORECOVERY"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_write_opt",
          "args": [
            "nilfs",
            "ERROR_MODE",
            "ERRORS_CONT"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_write_opt",
          "args": [
            "nilfs",
            "ERROR_MODE",
            "ERRORS_RO"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_write_opt",
          "args": [
            "nilfs",
            "ERROR_MODE",
            "ERRORS_PANIC"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_set_opt",
          "args": [
            "nilfs",
            "STRICT_ORDER"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"strict\""
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_clear_opt",
          "args": [
            "nilfs",
            "STRICT_ORDER"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_clear_opt",
          "args": [
            "nilfs",
            "BARRIER"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_set_opt",
          "args": [
            "nilfs",
            "BARRIER"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\nstatic match_table_t tokens = {\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_snapshot, \"cp=%u\"},\n\t{Opt_order, \"order=%s\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb, int is_remount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_barrier:\n\t\t\tnilfs_set_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tnilfs_clear_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_order:\n\t\t\tif (strcmp(args[0].from, \"relaxed\") == 0)\n\t\t\t\t/* Ordered data semantics */\n\t\t\t\tnilfs_clear_opt(nilfs, STRICT_ORDER);\n\t\t\telse if (strcmp(args[0].from, \"strict\") == 0)\n\t\t\t\t/* Strict in-order semantics */\n\t\t\t\tnilfs_set_opt(nilfs, STRICT_ORDER);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_snapshot:\n\t\t\tif (is_remount) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"NILFS: \\\"%s\\\" option is invalid \"\n\t\t\t\t       \"for remount.\\n\", p);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\tnilfs_set_opt(nilfs, NORECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tnilfs_set_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tnilfs_clear_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Unrecognized mount option \\\"%s\\\"\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "nilfs_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "680-702",
    "snippet": "static int nilfs_show_options(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root = NILFS_I(dentry->d_inode)->i_root;\n\n\tif (!nilfs_test_opt(nilfs, BARRIER))\n\t\tseq_puts(seq, \",nobarrier\");\n\tif (root->cno != NILFS_CPTREE_CURRENT_CNO)\n\t\tseq_printf(seq, \",cp=%llu\", (unsigned long long)root->cno);\n\tif (nilfs_test_opt(nilfs, ERRORS_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (nilfs_test_opt(nilfs, ERRORS_CONT))\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (nilfs_test_opt(nilfs, STRICT_ORDER))\n\t\tseq_puts(seq, \",order=strict\");\n\tif (nilfs_test_opt(nilfs, NORECOVERY))\n\t\tseq_puts(seq, \",norecovery\");\n\tif (nilfs_test_opt(nilfs, DISCARD))\n\t\tseq_puts(seq, \",discard\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",discard\""
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "DISCARD"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "NORECOVERY"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "STRICT_ORDER"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "ERRORS_CONT"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "ERRORS_PANIC"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",cp=%llu\"",
            "(unsigned long long)root->cno"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "BARRIER"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_show_options(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root = NILFS_I(dentry->d_inode)->i_root;\n\n\tif (!nilfs_test_opt(nilfs, BARRIER))\n\t\tseq_puts(seq, \",nobarrier\");\n\tif (root->cno != NILFS_CPTREE_CURRENT_CNO)\n\t\tseq_printf(seq, \",cp=%llu\", (unsigned long long)root->cno);\n\tif (nilfs_test_opt(nilfs, ERRORS_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (nilfs_test_opt(nilfs, ERRORS_CONT))\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (nilfs_test_opt(nilfs, STRICT_ORDER))\n\t\tseq_puts(seq, \",order=strict\");\n\tif (nilfs_test_opt(nilfs, NORECOVERY))\n\t\tseq_puts(seq, \",norecovery\");\n\tif (nilfs_test_opt(nilfs, DISCARD))\n\t\tseq_puts(seq, \",discard\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "610-678",
    "snippet": "static int nilfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct nilfs_root *root = NILFS_I(dentry->d_inode)->i_root;\n\tstruct the_nilfs *nilfs = root->nilfs;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\tunsigned long long blocks;\n\tunsigned long overhead;\n\tunsigned long nrsvblocks;\n\tsector_t nfreeblocks;\n\tu64 nmaxinodes, nfreeinodes;\n\tint err;\n\n\t/*\n\t * Compute all of the segment blocks\n\t *\n\t * The blocks before first segment and after last segment\n\t * are excluded.\n\t */\n\tblocks = nilfs->ns_blocks_per_segment * nilfs->ns_nsegments\n\t\t- nilfs->ns_first_data_block;\n\tnrsvblocks = nilfs->ns_nrsvsegs * nilfs->ns_blocks_per_segment;\n\n\t/*\n\t * Compute the overhead\n\t *\n\t * When distributing meta data blocks outside segment structure,\n\t * We must count them as the overhead.\n\t */\n\toverhead = 0;\n\n\terr = nilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = nilfs_ifile_count_free_inodes(root->ifile,\n\t\t\t\t\t    &nmaxinodes, &nfreeinodes);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"NILFS warning: fail to count free inodes: err %d.\\n\",\n\t\t\terr);\n\t\tif (err == -ERANGE) {\n\t\t\t/*\n\t\t\t * If nilfs_palloc_count_max_entries() returns\n\t\t\t * -ERANGE error code then we simply treat\n\t\t\t * curent inodes count as maximum possible and\n\t\t\t * zero as free inodes value.\n\t\t\t */\n\t\t\tnmaxinodes = atomic64_read(&root->inodes_count);\n\t\t\tnfreeinodes = 0;\n\t\t\terr = 0;\n\t\t} else\n\t\t\treturn err;\n\t}\n\n\tbuf->f_type = NILFS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = blocks - overhead;\n\tbuf->f_bfree = nfreeblocks;\n\tbuf->f_bavail = (buf->f_bfree >= nrsvblocks) ?\n\t\t(buf->f_bfree - nrsvblocks) : 0;\n\tbuf->f_files = nmaxinodes;\n\tbuf->f_ffree = nfreeinodes;\n\tbuf->f_namelen = NILFS_NAME_LEN;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nilfs_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&root->inodes_count"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\"NILFS warning: fail to count free inodes: err %d.\\n\"",
            "err"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_ifile_count_free_inodes",
          "args": [
            "root->ifile",
            "&nmaxinodes",
            "&nfreeinodes"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_count_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
          "lines": "168-182",
          "snippet": "int nilfs_ifile_count_free_inodes(struct inode *ifile,\n\t\t\t\t    u64 *nmaxinodes, u64 *nfreeinodes)\n{\n\tu64 nused;\n\tint err;\n\n\t*nmaxinodes = 0;\n\t*nfreeinodes = 0;\n\n\tnused = atomic64_read(&NILFS_I(ifile)->i_root->inodes_count);\n\terr = nilfs_palloc_count_max_entries(ifile, nused, nmaxinodes);\n\tif (likely(!err))\n\t\t*nfreeinodes = *nmaxinodes - nused;\n\treturn err;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_ifile_count_free_inodes(struct inode *ifile,\n\t\t\t\t    u64 *nmaxinodes, u64 *nfreeinodes)\n{\n\tu64 nused;\n\tint err;\n\n\t*nmaxinodes = 0;\n\t*nfreeinodes = 0;\n\n\tnused = atomic64_read(&NILFS_I(ifile)->i_root->inodes_count);\n\terr = nilfs_palloc_count_max_entries(ifile, nused, nmaxinodes);\n\tif (likely(!err))\n\t\t*nfreeinodes = *nmaxinodes - nused;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_count_free_blocks",
          "args": [
            "nilfs",
            "&nfreeblocks"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_count_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "697-706",
          "snippet": "int nilfs_count_free_blocks(struct the_nilfs *nilfs, sector_t *nblocks)\n{\n\tunsigned long ncleansegs;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\t*nblocks = (sector_t)ncleansegs * nilfs->ns_blocks_per_segment;\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint nilfs_count_free_blocks(struct the_nilfs *nilfs, sector_t *nblocks)\n{\n\tunsigned long ncleansegs;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\t*nblocks = (sector_t)ncleansegs * nilfs->ns_blocks_per_segment;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int nilfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct nilfs_root *root = NILFS_I(dentry->d_inode)->i_root;\n\tstruct the_nilfs *nilfs = root->nilfs;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\tunsigned long long blocks;\n\tunsigned long overhead;\n\tunsigned long nrsvblocks;\n\tsector_t nfreeblocks;\n\tu64 nmaxinodes, nfreeinodes;\n\tint err;\n\n\t/*\n\t * Compute all of the segment blocks\n\t *\n\t * The blocks before first segment and after last segment\n\t * are excluded.\n\t */\n\tblocks = nilfs->ns_blocks_per_segment * nilfs->ns_nsegments\n\t\t- nilfs->ns_first_data_block;\n\tnrsvblocks = nilfs->ns_nrsvsegs * nilfs->ns_blocks_per_segment;\n\n\t/*\n\t * Compute the overhead\n\t *\n\t * When distributing meta data blocks outside segment structure,\n\t * We must count them as the overhead.\n\t */\n\toverhead = 0;\n\n\terr = nilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = nilfs_ifile_count_free_inodes(root->ifile,\n\t\t\t\t\t    &nmaxinodes, &nfreeinodes);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"NILFS warning: fail to count free inodes: err %d.\\n\",\n\t\t\terr);\n\t\tif (err == -ERANGE) {\n\t\t\t/*\n\t\t\t * If nilfs_palloc_count_max_entries() returns\n\t\t\t * -ERANGE error code then we simply treat\n\t\t\t * curent inodes count as maximum possible and\n\t\t\t * zero as free inodes value.\n\t\t\t */\n\t\t\tnmaxinodes = atomic64_read(&root->inodes_count);\n\t\t\tnfreeinodes = 0;\n\t\t\terr = 0;\n\t\t} else\n\t\t\treturn err;\n\t}\n\n\tbuf->f_type = NILFS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = blocks - overhead;\n\tbuf->f_bfree = nfreeblocks;\n\tbuf->f_bavail = (buf->f_bfree >= nrsvblocks) ?\n\t\t(buf->f_bfree - nrsvblocks) : 0;\n\tbuf->f_files = nmaxinodes;\n\tbuf->f_ffree = nfreeinodes;\n\tbuf->f_namelen = NILFS_NAME_LEN;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "597-608",
    "snippet": "static int nilfs_unfreeze(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs_setup_super(sb, false);\n\tup_write(&nilfs->ns_sem);\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_setup_super",
          "args": [
            "sb",
            "false"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_setup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "815-855",
          "snippet": "static int nilfs_setup_super(struct super_block *sb, int is_mount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint max_mnt_count;\n\tint mnt_count;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (!sbp)\n\t\treturn -EIO;\n\n\tif (!is_mount)\n\t\tgoto skip_mount_setup;\n\n\tmax_mnt_count = le16_to_cpu(sbp[0]->s_max_mnt_count);\n\tmnt_count = le16_to_cpu(sbp[0]->s_mnt_count);\n\n\tif (nilfs->ns_mount_state & NILFS_ERROR_FS) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: mounting fs with errors\\n\");\n#if 0\n\t} else if (max_mnt_count >= 0 && mnt_count >= max_mnt_count) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: maximal mount count reached\\n\");\n#endif\n\t}\n\tif (!max_mnt_count)\n\t\tsbp[0]->s_max_mnt_count = cpu_to_le16(NILFS_DFL_MAX_MNT_COUNT);\n\n\tsbp[0]->s_mnt_count = cpu_to_le16(mnt_count + 1);\n\tsbp[0]->s_mtime = cpu_to_le64(get_seconds());\n\nskip_mount_setup:\n\tsbp[0]->s_state =\n\t\tcpu_to_le16(le16_to_cpu(sbp[0]->s_state) & ~NILFS_VALID_FS);\n\t/* synchronize sbp[1] with sbp[0] */\n\tif (sbp[1])\n\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\treturn nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_setup_super(struct super_block *sb, int is_mount);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_setup_super(struct super_block *sb, int is_mount);\n\nstatic int nilfs_setup_super(struct super_block *sb, int is_mount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint max_mnt_count;\n\tint mnt_count;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (!sbp)\n\t\treturn -EIO;\n\n\tif (!is_mount)\n\t\tgoto skip_mount_setup;\n\n\tmax_mnt_count = le16_to_cpu(sbp[0]->s_max_mnt_count);\n\tmnt_count = le16_to_cpu(sbp[0]->s_mnt_count);\n\n\tif (nilfs->ns_mount_state & NILFS_ERROR_FS) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: mounting fs with errors\\n\");\n#if 0\n\t} else if (max_mnt_count >= 0 && mnt_count >= max_mnt_count) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: maximal mount count reached\\n\");\n#endif\n\t}\n\tif (!max_mnt_count)\n\t\tsbp[0]->s_max_mnt_count = cpu_to_le16(NILFS_DFL_MAX_MNT_COUNT);\n\n\tsbp[0]->s_mnt_count = cpu_to_le16(mnt_count + 1);\n\tsbp[0]->s_mtime = cpu_to_le64(get_seconds());\n\nskip_mount_setup:\n\tsbp[0]->s_state =\n\t\tcpu_to_le16(le16_to_cpu(sbp[0]->s_state) & ~NILFS_VALID_FS);\n\t/* synchronize sbp[1] with sbp[0] */\n\tif (sbp[1])\n\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\treturn nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_unfreeze(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs_setup_super(sb, false);\n\tup_write(&nilfs->ns_sem);\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "582-595",
    "snippet": "static int nilfs_freeze(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\t/* Mark super block clean */\n\tdown_write(&nilfs->ns_sem);\n\terr = nilfs_cleanup_super(sb);\n\tup_write(&nilfs->ns_sem);\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cleanup_super",
          "args": [
            "sb"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cleanup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "327-350",
          "snippet": "int nilfs_cleanup_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint flag = NILFS_SB_COMMIT;\n\tint ret = -EIO;\n\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (sbp) {\n\t\tsbp[0]->s_state = cpu_to_le16(nilfs->ns_mount_state);\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\tif (sbp[1] && sbp[0]->s_last_cno == sbp[1]->s_last_cno) {\n\t\t\t/*\n\t\t\t * make the \"clean\" flag also to the opposite\n\t\t\t * super block if both super blocks point to\n\t\t\t * the same checkpoint.\n\t\t\t */\n\t\t\tsbp[1]->s_state = sbp[0]->s_state;\n\t\t\tflag = NILFS_SB_COMMIT_ALL;\n\t\t}\n\t\tret = nilfs_commit_super(sb, flag);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_cleanup_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint flag = NILFS_SB_COMMIT;\n\tint ret = -EIO;\n\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (sbp) {\n\t\tsbp[0]->s_state = cpu_to_le16(nilfs->ns_mount_state);\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\tif (sbp[1] && sbp[0]->s_last_cno == sbp[1]->s_last_cno) {\n\t\t\t/*\n\t\t\t * make the \"clean\" flag also to the opposite\n\t\t\t * super block if both super blocks point to\n\t\t\t * the same checkpoint.\n\t\t\t */\n\t\t\tsbp[1]->s_state = sbp[0]->s_state;\n\t\t\tflag = NILFS_SB_COMMIT_ALL;\n\t\t}\n\t\tret = nilfs_commit_super(sb, flag);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_freeze(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\t/* Mark super block clean */\n\tdown_write(&nilfs->ns_sem);\n\terr = nilfs_cleanup_super(sb);\n\tup_write(&nilfs->ns_sem);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_attach_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "526-580",
    "snippet": "int nilfs_attach_checkpoint(struct super_block *sb, __u64 cno, int curr_mnt,\n\t\t\t    struct nilfs_root **rootp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct nilfs_checkpoint *raw_cp;\n\tstruct buffer_head *bh_cp;\n\tint err = -ENOMEM;\n\n\troot = nilfs_find_or_create_root(\n\t\tnilfs, curr_mnt ? NILFS_CPTREE_CURRENT_CNO : cno);\n\tif (!root)\n\t\treturn err;\n\n\tif (root->ifile)\n\t\tgoto reuse; /* already attached checkpoint */\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, cno, 0, &raw_cp,\n\t\t\t\t\t  &bh_cp);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT || err == -EINVAL) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Invalid checkpoint \"\n\t\t\t       \"(checkpoint number=%llu)\\n\",\n\t\t\t       (unsigned long long)cno);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tgoto failed;\n\t}\n\n\terr = nilfs_ifile_read(sb, root, nilfs->ns_inode_size,\n\t\t\t       &raw_cp->cp_ifile_inode, &root->ifile);\n\tif (err)\n\t\tgoto failed_bh;\n\n\tatomic64_set(&root->inodes_count,\n\t\t\tle64_to_cpu(raw_cp->cp_inodes_count));\n\tatomic64_set(&root->blocks_count,\n\t\t\tle64_to_cpu(raw_cp->cp_blocks_count));\n\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n\n reuse:\n\t*rootp = root;\n\treturn 0;\n\n failed_bh:\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n failed:\n\tnilfs_put_root(root);\n\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_put_root",
          "args": [
            "root"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "801-815",
          "snippet": "void nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_put_checkpoint",
          "args": [
            "nilfs->ns_cpfile",
            "cno",
            "bh_cp"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_put_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "252-257",
          "snippet": "void nilfs_cpfile_put_checkpoint(struct inode *cpfile, __u64 cno,\n\t\t\t\t struct buffer_head *bh)\n{\n\tkunmap(bh->b_page);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nvoid nilfs_cpfile_put_checkpoint(struct inode *cpfile, __u64 cno,\n\t\t\t\t struct buffer_head *bh)\n{\n\tkunmap(bh->b_page);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&root->blocks_count",
            "le64_to_cpu(raw_cp->cp_blocks_count)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "raw_cp->cp_blocks_count"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&root->inodes_count",
            "le64_to_cpu(raw_cp->cp_inodes_count)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_ifile_read",
          "args": [
            "sb",
            "root",
            "nilfs->ns_inode_size",
            "&raw_cp->cp_ifile_inode",
            "&root->ifile"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
          "lines": "192-227",
          "snippet": "int nilfs_ifile_read(struct super_block *sb, struct nilfs_root *root,\n\t\t     size_t inode_size, struct nilfs_inode *raw_inode,\n\t\t     struct inode **inodep)\n{\n\tstruct inode *ifile;\n\tint err;\n\n\tifile = nilfs_iget_locked(sb, root, NILFS_IFILE_INO);\n\tif (unlikely(!ifile))\n\t\treturn -ENOMEM;\n\tif (!(ifile->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(ifile, NILFS_MDT_GFP,\n\t\t\t     sizeof(struct nilfs_ifile_info));\n\tif (err)\n\t\tgoto failed;\n\n\terr = nilfs_palloc_init_blockgroup(ifile, inode_size);\n\tif (err)\n\t\tgoto failed;\n\n\tnilfs_palloc_setup_cache(ifile, &NILFS_IFILE_I(ifile)->palloc_cache);\n\n\terr = nilfs_read_inode_common(ifile, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\tunlock_new_inode(ifile);\n out:\n\t*inodep = ifile;\n\treturn 0;\n failed:\n\tiget_failed(ifile);\n\treturn err;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_ifile_read(struct super_block *sb, struct nilfs_root *root,\n\t\t     size_t inode_size, struct nilfs_inode *raw_inode,\n\t\t     struct inode **inodep)\n{\n\tstruct inode *ifile;\n\tint err;\n\n\tifile = nilfs_iget_locked(sb, root, NILFS_IFILE_INO);\n\tif (unlikely(!ifile))\n\t\treturn -ENOMEM;\n\tif (!(ifile->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(ifile, NILFS_MDT_GFP,\n\t\t\t     sizeof(struct nilfs_ifile_info));\n\tif (err)\n\t\tgoto failed;\n\n\terr = nilfs_palloc_init_blockgroup(ifile, inode_size);\n\tif (err)\n\t\tgoto failed;\n\n\tnilfs_palloc_setup_cache(ifile, &NILFS_IFILE_I(ifile)->palloc_cache);\n\n\terr = nilfs_read_inode_common(ifile, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\tunlock_new_inode(ifile);\n out:\n\t*inodep = ifile;\n\treturn 0;\n failed:\n\tiget_failed(ifile);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t       \"NILFS: Invalid checkpoint \"\n\t\t\t       \"(checkpoint number=%llu)\\n\"",
            "(unsigned long long)cno"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_checkpoint",
          "args": [
            "nilfs->ns_cpfile",
            "cno",
            "0",
            "&raw_cp",
            "&bh_cp"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "181-240",
          "snippet": "int nilfs_cpfile_get_checkpoint(struct inode *cpfile,\n\t\t\t\t__u64 cno,\n\t\t\t\tint create,\n\t\t\t\tstruct nilfs_checkpoint **cpp,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (unlikely(cno < 1 || cno > nilfs_mdt_cno(cpfile) ||\n\t\t     (cno < nilfs_mdt_cno(cpfile) && create)))\n\t\treturn -EINVAL;\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, create, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_header;\n\tkaddr = kmap(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tif (!create) {\n\t\t\tkunmap(cp_bh->b_page);\n\t\t\tbrelse(cp_bh);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_header;\n\t\t}\n\t\t/* a newly-created checkpoint */\n\t\tnilfs_checkpoint_clear_invalid(cp);\n\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno))\n\t\t\tnilfs_cpfile_block_add_valid_checkpoints(cpfile, cp_bh,\n\t\t\t\t\t\t\t\t kaddr, 1);\n\t\tmark_buffer_dirty(cp_bh);\n\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, 1);\n\t\tkunmap_atomic(kaddr);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t}\n\n\tif (cpp != NULL)\n\t\t*cpp = cp;\n\t*bhp = cp_bh;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_get_checkpoint(struct inode *cpfile,\n\t\t\t\t__u64 cno,\n\t\t\t\tint create,\n\t\t\t\tstruct nilfs_checkpoint **cpp,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (unlikely(cno < 1 || cno > nilfs_mdt_cno(cpfile) ||\n\t\t     (cno < nilfs_mdt_cno(cpfile) && create)))\n\t\treturn -EINVAL;\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, create, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_header;\n\tkaddr = kmap(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tif (!create) {\n\t\t\tkunmap(cp_bh->b_page);\n\t\t\tbrelse(cp_bh);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_header;\n\t\t}\n\t\t/* a newly-created checkpoint */\n\t\tnilfs_checkpoint_clear_invalid(cp);\n\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno))\n\t\t\tnilfs_cpfile_block_add_valid_checkpoints(cpfile, cp_bh,\n\t\t\t\t\t\t\t\t kaddr, 1);\n\t\tmark_buffer_dirty(cp_bh);\n\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, 1);\n\t\tkunmap_atomic(kaddr);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t}\n\n\tif (cpp != NULL)\n\t\t*cpp = cp;\n\t*bhp = cp_bh;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_find_or_create_root",
          "args": [
            "nilfs",
            "curr_mnt ? NILFS_CPTREE_CURRENT_CNO : cno"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_find_or_create_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "744-799",
          "snippet": "struct nilfs_root *\nnilfs_find_or_create_root(struct the_nilfs *nilfs, __u64 cno)\n{\n\tstruct rb_node **p, *parent;\n\tstruct nilfs_root *root, *new;\n\tint err;\n\n\troot = nilfs_lookup_root(nilfs, cno);\n\tif (root)\n\t\treturn root;\n\n\tnew = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tspin_lock(&nilfs->ns_cptree_lock);\n\n\tp = &nilfs->ns_cptree.rb_node;\n\tparent = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\troot = rb_entry(parent, struct nilfs_root, rb_node);\n\n\t\tif (cno < root->cno) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (cno > root->cno) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tatomic_inc(&root->count);\n\t\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\t\tkfree(new);\n\t\t\treturn root;\n\t\t}\n\t}\n\n\tnew->cno = cno;\n\tnew->ifile = NULL;\n\tnew->nilfs = nilfs;\n\tatomic_set(&new->count, 1);\n\tatomic64_set(&new->inodes_count, 0);\n\tatomic64_set(&new->blocks_count, 0);\n\n\trb_link_node(&new->rb_node, parent, p);\n\trb_insert_color(&new->rb_node, &nilfs->ns_cptree);\n\n\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\terr = nilfs_sysfs_create_snapshot_group(new);\n\tif (err) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t}\n\n\treturn new;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstruct nilfs_root *\nnilfs_find_or_create_root(struct the_nilfs *nilfs, __u64 cno)\n{\n\tstruct rb_node **p, *parent;\n\tstruct nilfs_root *root, *new;\n\tint err;\n\n\troot = nilfs_lookup_root(nilfs, cno);\n\tif (root)\n\t\treturn root;\n\n\tnew = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tspin_lock(&nilfs->ns_cptree_lock);\n\n\tp = &nilfs->ns_cptree.rb_node;\n\tparent = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\troot = rb_entry(parent, struct nilfs_root, rb_node);\n\n\t\tif (cno < root->cno) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (cno > root->cno) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tatomic_inc(&root->count);\n\t\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\t\tkfree(new);\n\t\t\treturn root;\n\t\t}\n\t}\n\n\tnew->cno = cno;\n\tnew->ifile = NULL;\n\tnew->nilfs = nilfs;\n\tatomic_set(&new->count, 1);\n\tatomic64_set(&new->inodes_count, 0);\n\tatomic64_set(&new->blocks_count, 0);\n\n\trb_link_node(&new->rb_node, parent, p);\n\trb_insert_color(&new->rb_node, &nilfs->ns_cptree);\n\n\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\terr = nilfs_sysfs_create_snapshot_group(new);\n\tif (err) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t}\n\n\treturn new;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_attach_checkpoint(struct super_block *sb, __u64 cno, int curr_mnt,\n\t\t\t    struct nilfs_root **rootp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct nilfs_checkpoint *raw_cp;\n\tstruct buffer_head *bh_cp;\n\tint err = -ENOMEM;\n\n\troot = nilfs_find_or_create_root(\n\t\tnilfs, curr_mnt ? NILFS_CPTREE_CURRENT_CNO : cno);\n\tif (!root)\n\t\treturn err;\n\n\tif (root->ifile)\n\t\tgoto reuse; /* already attached checkpoint */\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, cno, 0, &raw_cp,\n\t\t\t\t\t  &bh_cp);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT || err == -EINVAL) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"NILFS: Invalid checkpoint \"\n\t\t\t       \"(checkpoint number=%llu)\\n\",\n\t\t\t       (unsigned long long)cno);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tgoto failed;\n\t}\n\n\terr = nilfs_ifile_read(sb, root, nilfs->ns_inode_size,\n\t\t\t       &raw_cp->cp_ifile_inode, &root->ifile);\n\tif (err)\n\t\tgoto failed_bh;\n\n\tatomic64_set(&root->inodes_count,\n\t\t\tle64_to_cpu(raw_cp->cp_inodes_count));\n\tatomic64_set(&root->blocks_count,\n\t\t\tle64_to_cpu(raw_cp->cp_blocks_count));\n\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n\n reuse:\n\t*rootp = root;\n\treturn 0;\n\n failed_bh:\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n failed:\n\tnilfs_put_root(root);\n\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "500-524",
    "snippet": "static int nilfs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint err = 0;\n\n\t/* This function is called when super block should be written back */\n\tif (wait)\n\t\terr = nilfs_construct_segment(sb);\n\n\tdown_write(&nilfs->ns_sem);\n\tif (nilfs_sb_dirty(nilfs)) {\n\t\tsbp = nilfs_prepare_super(sb, nilfs_sb_will_flip(nilfs));\n\t\tif (likely(sbp)) {\n\t\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t\tnilfs_commit_super(sb, NILFS_SB_COMMIT);\n\t\t}\n\t}\n\tup_write(&nilfs->ns_sem);\n\n\tif (!err)\n\t\terr = nilfs_flush_device(nilfs);\n\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_flush_device",
          "args": [
            "nilfs"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_flush_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "376-394",
          "snippet": "static inline int nilfs_flush_device(struct the_nilfs *nilfs)\n{\n\tint err;\n\n\tif (!nilfs_test_opt(nilfs, BARRIER) || nilfs->ns_flushed_device)\n\t\treturn 0;\n\n\tnilfs->ns_flushed_device = 1;\n\t/*\n\t * the store to ns_flushed_device must not be reordered after\n\t * blkdev_issue_flush().\n\t */\n\tsmp_wmb();\n\n\terr = blkdev_issue_flush(nilfs->ns_bdev, GFP_KERNEL, NULL);\n\tif (err != -EIO)\n\t\terr = 0;\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline int nilfs_flush_device(struct the_nilfs *nilfs)\n{\n\tint err;\n\n\tif (!nilfs_test_opt(nilfs, BARRIER) || nilfs->ns_flushed_device)\n\t\treturn 0;\n\n\tnilfs->ns_flushed_device = 1;\n\t/*\n\t * the store to ns_flushed_device must not be reordered after\n\t * blkdev_issue_flush().\n\t */\n\tsmp_wmb();\n\n\terr = blkdev_issue_flush(nilfs->ns_bdev, GFP_KERNEL, NULL);\n\tif (err != -EIO)\n\t\terr = 0;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_commit_super",
          "args": [
            "sb",
            "NILFS_SB_COMMIT"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "291-317",
          "snippet": "int nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_log_cursor",
          "args": [
            "sbp[0]",
            "nilfs"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_log_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "248-262",
          "snippet": "void nilfs_set_log_cursor(struct nilfs_super_block *sbp,\n\t\t\t  struct the_nilfs *nilfs)\n{\n\tsector_t nfreeblocks;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tnilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tsbp->s_free_blocks_count = cpu_to_le64(nfreeblocks);\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsbp->s_last_seq = cpu_to_le64(nilfs->ns_last_seq);\n\tsbp->s_last_pseg = cpu_to_le64(nilfs->ns_last_pseg);\n\tsbp->s_last_cno = cpu_to_le64(nilfs->ns_last_cno);\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_set_log_cursor(struct nilfs_super_block *sbp,\n\t\t\t  struct the_nilfs *nilfs)\n{\n\tsector_t nfreeblocks;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tnilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tsbp->s_free_blocks_count = cpu_to_le64(nfreeblocks);\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsbp->s_last_seq = cpu_to_le64(nilfs->ns_last_seq);\n\tsbp->s_last_pseg = cpu_to_le64(nilfs->ns_last_pseg);\n\tsbp->s_last_cno = cpu_to_le64(nilfs->ns_last_cno);\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sbp"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_prepare_super",
          "args": [
            "sb",
            "nilfs_sb_will_flip(nilfs)"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_prepare_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "264-289",
          "snippet": "struct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstruct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sb_will_flip",
          "args": [
            "nilfs"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sb_will_flip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "280-284",
          "snippet": "static inline int nilfs_sb_will_flip(struct the_nilfs *nilfs)\n{\n\tint flip_bits = nilfs->ns_sbwcount & 0x0FL;\n\treturn (flip_bits != 0x08 && flip_bits != 0x0F);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline int nilfs_sb_will_flip(struct the_nilfs *nilfs)\n{\n\tint flip_bits = nilfs->ns_sbwcount & 0x0FL;\n\treturn (flip_bits != 0x08 && flip_bits != 0x0F);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sb_dirty",
          "args": [
            "nilfs"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_construct_segment",
          "args": [
            "sb"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_construct_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2168-2183",
          "snippet": "int nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint err = 0;\n\n\t/* This function is called when super block should be written back */\n\tif (wait)\n\t\terr = nilfs_construct_segment(sb);\n\n\tdown_write(&nilfs->ns_sem);\n\tif (nilfs_sb_dirty(nilfs)) {\n\t\tsbp = nilfs_prepare_super(sb, nilfs_sb_will_flip(nilfs));\n\t\tif (likely(sbp)) {\n\t\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t\tnilfs_commit_super(sb, NILFS_SB_COMMIT);\n\t\t}\n\t}\n\tup_write(&nilfs->ns_sem);\n\n\tif (!err)\n\t\terr = nilfs_flush_device(nilfs);\n\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "480-498",
    "snippet": "static void nilfs_put_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tnilfs_detach_log_writer(sb);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_cleanup_super(sb);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_dat);\n\n\tdestroy_nilfs(nilfs);\n\tsb->s_fs_info = NULL;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_nilfs",
          "args": [
            "nilfs"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_nilfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "97-106",
          "snippet": "void destroy_nilfs(struct the_nilfs *nilfs)\n{\n\tmight_sleep();\n\tif (nilfs_init(nilfs)) {\n\t\tnilfs_sysfs_delete_device_group(nilfs);\n\t\tbrelse(nilfs->ns_sbh[0]);\n\t\tbrelse(nilfs->ns_sbh[1]);\n\t}\n\tkfree(nilfs);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid destroy_nilfs(struct the_nilfs *nilfs)\n{\n\tmight_sleep();\n\tif (nilfs_init(nilfs)) {\n\t\tnilfs_sysfs_delete_device_group(nilfs);\n\t\tbrelse(nilfs->ns_sbh[0]);\n\t\tbrelse(nilfs->ns_sbh[1]);\n\t}\n\tkfree(nilfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cleanup_super",
          "args": [
            "sb"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cleanup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "327-350",
          "snippet": "int nilfs_cleanup_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint flag = NILFS_SB_COMMIT;\n\tint ret = -EIO;\n\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (sbp) {\n\t\tsbp[0]->s_state = cpu_to_le16(nilfs->ns_mount_state);\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\tif (sbp[1] && sbp[0]->s_last_cno == sbp[1]->s_last_cno) {\n\t\t\t/*\n\t\t\t * make the \"clean\" flag also to the opposite\n\t\t\t * super block if both super blocks point to\n\t\t\t * the same checkpoint.\n\t\t\t */\n\t\t\tsbp[1]->s_state = sbp[0]->s_state;\n\t\t\tflag = NILFS_SB_COMMIT_ALL;\n\t\t}\n\t\tret = nilfs_commit_super(sb, flag);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_cleanup_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint flag = NILFS_SB_COMMIT;\n\tint ret = -EIO;\n\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (sbp) {\n\t\tsbp[0]->s_state = cpu_to_le16(nilfs->ns_mount_state);\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\tif (sbp[1] && sbp[0]->s_last_cno == sbp[1]->s_last_cno) {\n\t\t\t/*\n\t\t\t * make the \"clean\" flag also to the opposite\n\t\t\t * super block if both super blocks point to\n\t\t\t * the same checkpoint.\n\t\t\t */\n\t\t\tsbp[1]->s_state = sbp[0]->s_state;\n\t\t\tflag = NILFS_SB_COMMIT_ALL;\n\t\t}\n\t\tret = nilfs_commit_super(sb, flag);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_detach_log_writer",
          "args": [
            "sb"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_detach_log_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2737-2759",
          "snippet": "void nilfs_detach_log_writer(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tLIST_HEAD(garbage_list);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (nilfs->ns_writer) {\n\t\tnilfs_segctor_destroy(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\n\t/* Force to free the list of dirty files */\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!list_empty(&nilfs->ns_dirty_files)) {\n\t\tlist_splice_init(&nilfs->ns_dirty_files, &garbage_list);\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"Hit dirty file after stopped log writer\\n\");\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tnilfs_dispose_list(nilfs, &garbage_list, 1);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_detach_log_writer(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tLIST_HEAD(garbage_list);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (nilfs->ns_writer) {\n\t\tnilfs_segctor_destroy(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\n\t/* Force to free the list of dirty files */\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!list_empty(&nilfs->ns_dirty_files)) {\n\t\tlist_splice_init(&nilfs->ns_dirty_files, &garbage_list);\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"Hit dirty file after stopped log writer\\n\");\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tnilfs_dispose_list(nilfs, &garbage_list, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void nilfs_put_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tnilfs_detach_log_writer(sb);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_cleanup_super(sb);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_dat);\n\n\tdestroy_nilfs(nilfs);\n\tsb->s_fs_info = NULL;\n}"
  },
  {
    "function_name": "nilfs_resize_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "414-478",
    "snippet": "int nilfs_resize_fs(struct super_block *sb, __u64 newsize)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\t__u64 devsize, newnsegs;\n\tloff_t sb2off;\n\tint ret;\n\n\tret = -ERANGE;\n\tdevsize = i_size_read(sb->s_bdev->bd_inode);\n\tif (newsize > devsize)\n\t\tgoto out;\n\n\t/*\n\t * Write lock is required to protect some functions depending\n\t * on the number of segments, the number of reserved segments,\n\t * and so forth.\n\t */\n\tdown_write(&nilfs->ns_segctor_sem);\n\n\tsb2off = NILFS_SB2_OFFSET_BYTES(newsize);\n\tnewnsegs = sb2off >> nilfs->ns_blocksize_bits;\n\tdo_div(newnsegs, nilfs->ns_blocks_per_segment);\n\n\tret = nilfs_sufile_resize(nilfs->ns_sufile, newnsegs);\n\tup_write(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = nilfs_construct_segment(sb);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs_move_2nd_super(sb, sb2off);\n\tret = -EIO;\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (likely(sbp)) {\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t/*\n\t\t * Drop NILFS_RESIZE_FS flag for compatibility with\n\t\t * mount-time resize which may be implemented in a\n\t\t * future release.\n\t\t */\n\t\tsbp[0]->s_state = cpu_to_le16(le16_to_cpu(sbp[0]->s_state) &\n\t\t\t\t\t      ~NILFS_RESIZE_FS);\n\t\tsbp[0]->s_dev_size = cpu_to_le64(newsize);\n\t\tsbp[0]->s_nsegments = cpu_to_le64(nilfs->ns_nsegments);\n\t\tif (sbp[1])\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t\tret = nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n\t}\n\tup_write(&nilfs->ns_sem);\n\n\t/*\n\t * Reset the range of allocatable segments last.  This order\n\t * is important in the case of expansion because the secondary\n\t * superblock must be protected from log write until migration\n\t * completes.\n\t */\n\tif (!ret)\n\t\tnilfs_sufile_set_alloc_range(nilfs->ns_sufile, 0, newnsegs - 1);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_sufile_set_alloc_range",
          "args": [
            "nilfs->ns_sufile",
            "0",
            "newnsegs - 1"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_set_alloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "276-292",
          "snippet": "int nilfs_sufile_set_alloc_range(struct inode *sufile, __u64 start, __u64 end)\n{\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\t__u64 nsegs;\n\tint ret = -ERANGE;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\tnsegs = nilfs_sufile_get_nsegments(sufile);\n\n\tif (start <= end && end < nsegs) {\n\t\tsui->allocmin = start;\n\t\tsui->allocmax = end;\n\t\tret = 0;\n\t}\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_set_alloc_range(struct inode *sufile, __u64 start, __u64 end)\n{\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\t__u64 nsegs;\n\tint ret = -ERANGE;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\tnsegs = nilfs_sufile_get_nsegments(sufile);\n\n\tif (start <= end && end < nsegs) {\n\t\tsui->allocmin = start;\n\t\tsui->allocmax = end;\n\t\tret = 0;\n\t}\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_commit_super",
          "args": [
            "sb",
            "NILFS_SB_COMMIT_ALL"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "291-317",
          "snippet": "int nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sbp[1]",
            "sbp[0]",
            "nilfs->ns_sbsize"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nilfs->ns_nsegments"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "newsize"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "le16_to_cpu(sbp[0]->s_state) &\n\t\t\t\t\t      ~NILFS_RESIZE_FS"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sbp[0]->s_state"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_log_cursor",
          "args": [
            "sbp[0]",
            "nilfs"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_log_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "248-262",
          "snippet": "void nilfs_set_log_cursor(struct nilfs_super_block *sbp,\n\t\t\t  struct the_nilfs *nilfs)\n{\n\tsector_t nfreeblocks;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tnilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tsbp->s_free_blocks_count = cpu_to_le64(nfreeblocks);\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsbp->s_last_seq = cpu_to_le64(nilfs->ns_last_seq);\n\tsbp->s_last_pseg = cpu_to_le64(nilfs->ns_last_pseg);\n\tsbp->s_last_cno = cpu_to_le64(nilfs->ns_last_cno);\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_set_log_cursor(struct nilfs_super_block *sbp,\n\t\t\t  struct the_nilfs *nilfs)\n{\n\tsector_t nfreeblocks;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tnilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tsbp->s_free_blocks_count = cpu_to_le64(nfreeblocks);\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsbp->s_last_seq = cpu_to_le64(nilfs->ns_last_seq);\n\tsbp->s_last_pseg = cpu_to_le64(nilfs->ns_last_pseg);\n\tsbp->s_last_cno = cpu_to_le64(nilfs->ns_last_cno);\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sbp"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_prepare_super",
          "args": [
            "sb",
            "0"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_prepare_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "264-289",
          "snippet": "struct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstruct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_move_2nd_super",
          "args": [
            "sb",
            "sb2off"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_move_2nd_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "357-407",
          "snippet": "static int nilfs_move_2nd_super(struct super_block *sb, loff_t sb2off)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct buffer_head *nsbh;\n\tstruct nilfs_super_block *nsbp;\n\tsector_t blocknr, newblocknr;\n\tunsigned long offset;\n\tint sb2i = -1;  /* array index of the secondary superblock */\n\tint ret = 0;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (nilfs->ns_sbh[1] &&\n\t    nilfs->ns_sbh[1]->b_blocknr > nilfs->ns_first_data_block) {\n\t\tsb2i = 1;\n\t\tblocknr = nilfs->ns_sbh[1]->b_blocknr;\n\t} else if (nilfs->ns_sbh[0]->b_blocknr > nilfs->ns_first_data_block) {\n\t\tsb2i = 0;\n\t\tblocknr = nilfs->ns_sbh[0]->b_blocknr;\n\t}\n\tif (sb2i >= 0 && (u64)blocknr << nilfs->ns_blocksize_bits == sb2off)\n\t\tgoto out;  /* super block location is unchanged */\n\n\t/* Get new super block buffer */\n\tnewblocknr = sb2off >> nilfs->ns_blocksize_bits;\n\toffset = sb2off & (nilfs->ns_blocksize - 1);\n\tnsbh = sb_getblk(sb, newblocknr);\n\tif (!nsbh) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: unable to move secondary superblock \"\n\t\t       \"to block %llu\\n\", (unsigned long long)newblocknr);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tnsbp = (void *)nsbh->b_data + offset;\n\tmemset(nsbp, 0, nilfs->ns_blocksize);\n\n\tif (sb2i >= 0) {\n\t\tmemcpy(nsbp, nilfs->ns_sbp[sb2i], nilfs->ns_sbsize);\n\t\tbrelse(nilfs->ns_sbh[sb2i]);\n\t\tnilfs->ns_sbh[sb2i] = nsbh;\n\t\tnilfs->ns_sbp[sb2i] = nsbp;\n\t} else if (nilfs->ns_sbh[0]->b_blocknr < nilfs->ns_first_data_block) {\n\t\t/* secondary super block will be restored to index 1 */\n\t\tnilfs->ns_sbh[1] = nsbh;\n\t\tnilfs->ns_sbp[1] = nsbp;\n\t} else {\n\t\tbrelse(nsbh);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_move_2nd_super(struct super_block *sb, loff_t sb2off)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct buffer_head *nsbh;\n\tstruct nilfs_super_block *nsbp;\n\tsector_t blocknr, newblocknr;\n\tunsigned long offset;\n\tint sb2i = -1;  /* array index of the secondary superblock */\n\tint ret = 0;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (nilfs->ns_sbh[1] &&\n\t    nilfs->ns_sbh[1]->b_blocknr > nilfs->ns_first_data_block) {\n\t\tsb2i = 1;\n\t\tblocknr = nilfs->ns_sbh[1]->b_blocknr;\n\t} else if (nilfs->ns_sbh[0]->b_blocknr > nilfs->ns_first_data_block) {\n\t\tsb2i = 0;\n\t\tblocknr = nilfs->ns_sbh[0]->b_blocknr;\n\t}\n\tif (sb2i >= 0 && (u64)blocknr << nilfs->ns_blocksize_bits == sb2off)\n\t\tgoto out;  /* super block location is unchanged */\n\n\t/* Get new super block buffer */\n\tnewblocknr = sb2off >> nilfs->ns_blocksize_bits;\n\toffset = sb2off & (nilfs->ns_blocksize - 1);\n\tnsbh = sb_getblk(sb, newblocknr);\n\tif (!nsbh) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: unable to move secondary superblock \"\n\t\t       \"to block %llu\\n\", (unsigned long long)newblocknr);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tnsbp = (void *)nsbh->b_data + offset;\n\tmemset(nsbp, 0, nilfs->ns_blocksize);\n\n\tif (sb2i >= 0) {\n\t\tmemcpy(nsbp, nilfs->ns_sbp[sb2i], nilfs->ns_sbsize);\n\t\tbrelse(nilfs->ns_sbh[sb2i]);\n\t\tnilfs->ns_sbh[sb2i] = nsbh;\n\t\tnilfs->ns_sbp[sb2i] = nsbp;\n\t} else if (nilfs->ns_sbh[0]->b_blocknr < nilfs->ns_first_data_block) {\n\t\t/* secondary super block will be restored to index 1 */\n\t\tnilfs->ns_sbh[1] = nsbh;\n\t\tnilfs->ns_sbp[1] = nsbp;\n\t} else {\n\t\tbrelse(nsbh);\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_construct_segment",
          "args": [
            "sb"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_construct_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2168-2183",
          "snippet": "int nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_resize",
          "args": [
            "nilfs->ns_sufile",
            "newnsegs"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "746-795",
          "snippet": "int nilfs_sufile_resize(struct inode *sufile, __u64 newnsegs)\n{\n\tstruct the_nilfs *nilfs = sufile->i_sb->s_fs_info;\n\tstruct buffer_head *header_bh;\n\tstruct nilfs_sufile_header *header;\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\tvoid *kaddr;\n\tunsigned long nsegs, nrsvsegs;\n\tint ret = 0;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\n\tnsegs = nilfs_sufile_get_nsegments(sufile);\n\tif (nsegs == newnsegs)\n\t\tgoto out;\n\n\tret = -ENOSPC;\n\tnrsvsegs = nilfs_nrsvsegs(nilfs, newnsegs);\n\tif (newnsegs < nsegs && nsegs - newnsegs + nrsvsegs > sui->ncleansegs)\n\t\tgoto out;\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (newnsegs > nsegs) {\n\t\tsui->ncleansegs += newnsegs - nsegs;\n\t} else /* newnsegs < nsegs */ {\n\t\tret = nilfs_sufile_truncate_range(sufile, newnsegs, nsegs - 1);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\n\t\tsui->ncleansegs -= nsegs - newnsegs;\n\t}\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\theader->sh_ncleansegs = cpu_to_le64(sui->ncleansegs);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(header_bh);\n\tnilfs_mdt_mark_dirty(sufile);\n\tnilfs_set_nsegments(nilfs, newnsegs);\n\nout_header:\n\tbrelse(header_bh);\nout:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_resize(struct inode *sufile, __u64 newnsegs)\n{\n\tstruct the_nilfs *nilfs = sufile->i_sb->s_fs_info;\n\tstruct buffer_head *header_bh;\n\tstruct nilfs_sufile_header *header;\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\tvoid *kaddr;\n\tunsigned long nsegs, nrsvsegs;\n\tint ret = 0;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\n\tnsegs = nilfs_sufile_get_nsegments(sufile);\n\tif (nsegs == newnsegs)\n\t\tgoto out;\n\n\tret = -ENOSPC;\n\tnrsvsegs = nilfs_nrsvsegs(nilfs, newnsegs);\n\tif (newnsegs < nsegs && nsegs - newnsegs + nrsvsegs > sui->ncleansegs)\n\t\tgoto out;\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (newnsegs > nsegs) {\n\t\tsui->ncleansegs += newnsegs - nsegs;\n\t} else /* newnsegs < nsegs */ {\n\t\tret = nilfs_sufile_truncate_range(sufile, newnsegs, nsegs - 1);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\n\t\tsui->ncleansegs -= nsegs - newnsegs;\n\t}\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\theader->sh_ncleansegs = cpu_to_le64(sui->ncleansegs);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(header_bh);\n\tnilfs_mdt_mark_dirty(sufile);\n\tnilfs_set_nsegments(nilfs, newnsegs);\n\nout_header:\n\tbrelse(header_bh);\nout:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "newnsegs",
            "nilfs->ns_blocks_per_segment"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_SB2_OFFSET_BYTES",
          "args": [
            "newsize"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "sb->s_bdev->bd_inode"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_resize_fs(struct super_block *sb, __u64 newsize)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\t__u64 devsize, newnsegs;\n\tloff_t sb2off;\n\tint ret;\n\n\tret = -ERANGE;\n\tdevsize = i_size_read(sb->s_bdev->bd_inode);\n\tif (newsize > devsize)\n\t\tgoto out;\n\n\t/*\n\t * Write lock is required to protect some functions depending\n\t * on the number of segments, the number of reserved segments,\n\t * and so forth.\n\t */\n\tdown_write(&nilfs->ns_segctor_sem);\n\n\tsb2off = NILFS_SB2_OFFSET_BYTES(newsize);\n\tnewnsegs = sb2off >> nilfs->ns_blocksize_bits;\n\tdo_div(newnsegs, nilfs->ns_blocks_per_segment);\n\n\tret = nilfs_sufile_resize(nilfs->ns_sufile, newnsegs);\n\tup_write(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = nilfs_construct_segment(sb);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs_move_2nd_super(sb, sb2off);\n\tret = -EIO;\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (likely(sbp)) {\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t/*\n\t\t * Drop NILFS_RESIZE_FS flag for compatibility with\n\t\t * mount-time resize which may be implemented in a\n\t\t * future release.\n\t\t */\n\t\tsbp[0]->s_state = cpu_to_le16(le16_to_cpu(sbp[0]->s_state) &\n\t\t\t\t\t      ~NILFS_RESIZE_FS);\n\t\tsbp[0]->s_dev_size = cpu_to_le64(newsize);\n\t\tsbp[0]->s_nsegments = cpu_to_le64(nilfs->ns_nsegments);\n\t\tif (sbp[1])\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t\tret = nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n\t}\n\tup_write(&nilfs->ns_sem);\n\n\t/*\n\t * Reset the range of allocatable segments last.  This order\n\t * is important in the case of expansion because the secondary\n\t * superblock must be protected from log write until migration\n\t * completes.\n\t */\n\tif (!ret)\n\t\tnilfs_sufile_set_alloc_range(nilfs->ns_sufile, 0, newnsegs - 1);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_move_2nd_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "357-407",
    "snippet": "static int nilfs_move_2nd_super(struct super_block *sb, loff_t sb2off)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct buffer_head *nsbh;\n\tstruct nilfs_super_block *nsbp;\n\tsector_t blocknr, newblocknr;\n\tunsigned long offset;\n\tint sb2i = -1;  /* array index of the secondary superblock */\n\tint ret = 0;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (nilfs->ns_sbh[1] &&\n\t    nilfs->ns_sbh[1]->b_blocknr > nilfs->ns_first_data_block) {\n\t\tsb2i = 1;\n\t\tblocknr = nilfs->ns_sbh[1]->b_blocknr;\n\t} else if (nilfs->ns_sbh[0]->b_blocknr > nilfs->ns_first_data_block) {\n\t\tsb2i = 0;\n\t\tblocknr = nilfs->ns_sbh[0]->b_blocknr;\n\t}\n\tif (sb2i >= 0 && (u64)blocknr << nilfs->ns_blocksize_bits == sb2off)\n\t\tgoto out;  /* super block location is unchanged */\n\n\t/* Get new super block buffer */\n\tnewblocknr = sb2off >> nilfs->ns_blocksize_bits;\n\toffset = sb2off & (nilfs->ns_blocksize - 1);\n\tnsbh = sb_getblk(sb, newblocknr);\n\tif (!nsbh) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: unable to move secondary superblock \"\n\t\t       \"to block %llu\\n\", (unsigned long long)newblocknr);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tnsbp = (void *)nsbh->b_data + offset;\n\tmemset(nsbp, 0, nilfs->ns_blocksize);\n\n\tif (sb2i >= 0) {\n\t\tmemcpy(nsbp, nilfs->ns_sbp[sb2i], nilfs->ns_sbsize);\n\t\tbrelse(nilfs->ns_sbh[sb2i]);\n\t\tnilfs->ns_sbh[sb2i] = nsbh;\n\t\tnilfs->ns_sbp[sb2i] = nsbp;\n\t} else if (nilfs->ns_sbh[0]->b_blocknr < nilfs->ns_first_data_block) {\n\t\t/* secondary super block will be restored to index 1 */\n\t\tnilfs->ns_sbh[1] = nsbh;\n\t\tnilfs->ns_sbp[1] = nsbp;\n\t} else {\n\t\tbrelse(nsbh);\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "nsbh"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nsbp",
            "nilfs->ns_sbp[sb2i]",
            "nilfs->ns_sbsize"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "nsbp",
            "0",
            "nilfs->ns_blocksize"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t       \"NILFS warning: unable to move secondary superblock \"\n\t\t       \"to block %llu\\n\"",
            "(unsigned long long)newblocknr"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "newblocknr"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_move_2nd_super(struct super_block *sb, loff_t sb2off)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct buffer_head *nsbh;\n\tstruct nilfs_super_block *nsbp;\n\tsector_t blocknr, newblocknr;\n\tunsigned long offset;\n\tint sb2i = -1;  /* array index of the secondary superblock */\n\tint ret = 0;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (nilfs->ns_sbh[1] &&\n\t    nilfs->ns_sbh[1]->b_blocknr > nilfs->ns_first_data_block) {\n\t\tsb2i = 1;\n\t\tblocknr = nilfs->ns_sbh[1]->b_blocknr;\n\t} else if (nilfs->ns_sbh[0]->b_blocknr > nilfs->ns_first_data_block) {\n\t\tsb2i = 0;\n\t\tblocknr = nilfs->ns_sbh[0]->b_blocknr;\n\t}\n\tif (sb2i >= 0 && (u64)blocknr << nilfs->ns_blocksize_bits == sb2off)\n\t\tgoto out;  /* super block location is unchanged */\n\n\t/* Get new super block buffer */\n\tnewblocknr = sb2off >> nilfs->ns_blocksize_bits;\n\toffset = sb2off & (nilfs->ns_blocksize - 1);\n\tnsbh = sb_getblk(sb, newblocknr);\n\tif (!nsbh) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NILFS warning: unable to move secondary superblock \"\n\t\t       \"to block %llu\\n\", (unsigned long long)newblocknr);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tnsbp = (void *)nsbh->b_data + offset;\n\tmemset(nsbp, 0, nilfs->ns_blocksize);\n\n\tif (sb2i >= 0) {\n\t\tmemcpy(nsbp, nilfs->ns_sbp[sb2i], nilfs->ns_sbsize);\n\t\tbrelse(nilfs->ns_sbh[sb2i]);\n\t\tnilfs->ns_sbh[sb2i] = nsbh;\n\t\tnilfs->ns_sbp[sb2i] = nsbp;\n\t} else if (nilfs->ns_sbh[0]->b_blocknr < nilfs->ns_first_data_block) {\n\t\t/* secondary super block will be restored to index 1 */\n\t\tnilfs->ns_sbh[1] = nsbh;\n\t\tnilfs->ns_sbp[1] = nsbp;\n\t} else {\n\t\tbrelse(nsbh);\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_cleanup_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "327-350",
    "snippet": "int nilfs_cleanup_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint flag = NILFS_SB_COMMIT;\n\tint ret = -EIO;\n\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (sbp) {\n\t\tsbp[0]->s_state = cpu_to_le16(nilfs->ns_mount_state);\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\tif (sbp[1] && sbp[0]->s_last_cno == sbp[1]->s_last_cno) {\n\t\t\t/*\n\t\t\t * make the \"clean\" flag also to the opposite\n\t\t\t * super block if both super blocks point to\n\t\t\t * the same checkpoint.\n\t\t\t */\n\t\t\tsbp[1]->s_state = sbp[0]->s_state;\n\t\t\tflag = NILFS_SB_COMMIT_ALL;\n\t\t}\n\t\tret = nilfs_commit_super(sb, flag);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_commit_super",
          "args": [
            "sb",
            "flag"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "291-317",
          "snippet": "int nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_log_cursor",
          "args": [
            "sbp[0]",
            "nilfs"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_log_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "248-262",
          "snippet": "void nilfs_set_log_cursor(struct nilfs_super_block *sbp,\n\t\t\t  struct the_nilfs *nilfs)\n{\n\tsector_t nfreeblocks;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tnilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tsbp->s_free_blocks_count = cpu_to_le64(nfreeblocks);\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsbp->s_last_seq = cpu_to_le64(nilfs->ns_last_seq);\n\tsbp->s_last_pseg = cpu_to_le64(nilfs->ns_last_pseg);\n\tsbp->s_last_cno = cpu_to_le64(nilfs->ns_last_cno);\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_set_log_cursor(struct nilfs_super_block *sbp,\n\t\t\t  struct the_nilfs *nilfs)\n{\n\tsector_t nfreeblocks;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tnilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tsbp->s_free_blocks_count = cpu_to_le64(nfreeblocks);\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsbp->s_last_seq = cpu_to_le64(nilfs->ns_last_seq);\n\tsbp->s_last_pseg = cpu_to_le64(nilfs->ns_last_pseg);\n\tsbp->s_last_cno = cpu_to_le64(nilfs->ns_last_cno);\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "nilfs->ns_mount_state"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_prepare_super",
          "args": [
            "sb",
            "0"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_prepare_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "264-289",
          "snippet": "struct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstruct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_cleanup_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint flag = NILFS_SB_COMMIT;\n\tint ret = -EIO;\n\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (sbp) {\n\t\tsbp[0]->s_state = cpu_to_le16(nilfs->ns_mount_state);\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\tif (sbp[1] && sbp[0]->s_last_cno == sbp[1]->s_last_cno) {\n\t\t\t/*\n\t\t\t * make the \"clean\" flag also to the opposite\n\t\t\t * super block if both super blocks point to\n\t\t\t * the same checkpoint.\n\t\t\t */\n\t\t\tsbp[1]->s_state = sbp[0]->s_state;\n\t\t\tflag = NILFS_SB_COMMIT_ALL;\n\t\t}\n\t\tret = nilfs_commit_super(sb, flag);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_commit_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "291-317",
    "snippet": "int nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_sync_super",
          "args": [
            "sb",
            "flag"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sync_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "190-246",
          "snippet": "static int nilfs_sync_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n retry:\n\tset_buffer_dirty(nilfs->ns_sbh[0]);\n\tif (nilfs_test_opt(nilfs, BARRIER)) {\n\t\terr = __sync_dirty_buffer(nilfs->ns_sbh[0],\n\t\t\t\t\t  WRITE_SYNC | WRITE_FLUSH_FUA);\n\t} else {\n\t\terr = sync_dirty_buffer(nilfs->ns_sbh[0]);\n\t}\n\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: unable to write superblock (err=%d)\\n\", err);\n\t\tif (err == -EIO && nilfs->ns_sbh[1]) {\n\t\t\t/*\n\t\t\t * sbp[0] points to newer log than sbp[1],\n\t\t\t * so copy sbp[0] to sbp[1] to take over sbp[0].\n\t\t\t */\n\t\t\tmemcpy(nilfs->ns_sbp[1], nilfs->ns_sbp[0],\n\t\t\t       nilfs->ns_sbsize);\n\t\t\tnilfs_fall_back_super_block(nilfs);\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\tstruct nilfs_super_block *sbp = nilfs->ns_sbp[0];\n\n\t\tnilfs->ns_sbwcount++;\n\n\t\t/*\n\t\t * The latest segment becomes trailable from the position\n\t\t * written in superblock.\n\t\t */\n\t\tclear_nilfs_discontinued(nilfs);\n\n\t\t/* update GC protection for recent segments */\n\t\tif (nilfs->ns_sbh[1]) {\n\t\t\tif (flag == NILFS_SB_COMMIT_ALL) {\n\t\t\t\tset_buffer_dirty(nilfs->ns_sbh[1]);\n\t\t\t\tif (sync_dirty_buffer(nilfs->ns_sbh[1]) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (le64_to_cpu(nilfs->ns_sbp[1]->s_last_cno) <\n\t\t\t    le64_to_cpu(nilfs->ns_sbp[0]->s_last_cno))\n\t\t\t\tsbp = nilfs->ns_sbp[1];\n\t\t}\n\n\t\tspin_lock(&nilfs->ns_last_segment_lock);\n\t\tnilfs->ns_prot_seq = le64_to_cpu(sbp->s_last_seq);\n\t\tspin_unlock(&nilfs->ns_last_segment_lock);\n\t}\n out:\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_sync_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n retry:\n\tset_buffer_dirty(nilfs->ns_sbh[0]);\n\tif (nilfs_test_opt(nilfs, BARRIER)) {\n\t\terr = __sync_dirty_buffer(nilfs->ns_sbh[0],\n\t\t\t\t\t  WRITE_SYNC | WRITE_FLUSH_FUA);\n\t} else {\n\t\terr = sync_dirty_buffer(nilfs->ns_sbh[0]);\n\t}\n\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: unable to write superblock (err=%d)\\n\", err);\n\t\tif (err == -EIO && nilfs->ns_sbh[1]) {\n\t\t\t/*\n\t\t\t * sbp[0] points to newer log than sbp[1],\n\t\t\t * so copy sbp[0] to sbp[1] to take over sbp[0].\n\t\t\t */\n\t\t\tmemcpy(nilfs->ns_sbp[1], nilfs->ns_sbp[0],\n\t\t\t       nilfs->ns_sbsize);\n\t\t\tnilfs_fall_back_super_block(nilfs);\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\tstruct nilfs_super_block *sbp = nilfs->ns_sbp[0];\n\n\t\tnilfs->ns_sbwcount++;\n\n\t\t/*\n\t\t * The latest segment becomes trailable from the position\n\t\t * written in superblock.\n\t\t */\n\t\tclear_nilfs_discontinued(nilfs);\n\n\t\t/* update GC protection for recent segments */\n\t\tif (nilfs->ns_sbh[1]) {\n\t\t\tif (flag == NILFS_SB_COMMIT_ALL) {\n\t\t\t\tset_buffer_dirty(nilfs->ns_sbh[1]);\n\t\t\t\tif (sync_dirty_buffer(nilfs->ns_sbh[1]) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (le64_to_cpu(nilfs->ns_sbp[1]->s_last_cno) <\n\t\t\t    le64_to_cpu(nilfs->ns_sbp[0]->s_last_cno))\n\t\t\t\tsbp = nilfs->ns_sbp[1];\n\t\t}\n\n\t\tspin_lock(&nilfs->ns_last_segment_lock);\n\t\tnilfs->ns_prot_seq = le64_to_cpu(sbp->s_last_seq);\n\t\tspin_unlock(&nilfs->ns_last_segment_lock);\n\t}\n out:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nilfs_sb_dirty",
          "args": [
            "nilfs"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "nilfs->ns_crc_seed",
            "(unsigned char *)sbp[1]",
            "nilfs->ns_sbsize"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "nilfs->ns_crc_seed",
            "(unsigned char *)sbp[0]",
            "nilfs->ns_sbsize"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "t"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}"
  },
  {
    "function_name": "nilfs_prepare_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "264-289",
    "snippet": "struct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_swap_super_block",
          "args": [
            "nilfs"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_swap_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "485-494",
          "snippet": "void nilfs_swap_super_block(struct the_nilfs *nilfs)\n{\n\tstruct buffer_head *tsbh = nilfs->ns_sbh[0];\n\tstruct nilfs_super_block *tsbp = nilfs->ns_sbp[0];\n\n\tnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\n\tnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\n\tnilfs->ns_sbh[1] = tsbh;\n\tnilfs->ns_sbp[1] = tsbp;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_swap_super_block(struct the_nilfs *nilfs)\n{\n\tstruct buffer_head *tsbh = nilfs->ns_sbh[0];\n\tstruct nilfs_super_block *tsbp = nilfs->ns_sbp[0];\n\n\tnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\n\tnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\n\tnilfs->ns_sbh[1] = tsbh;\n\tnilfs->ns_sbp[1] = tsbp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sbp[1]",
            "sbp[0]",
            "nilfs->ns_sbsize"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "NILFS_SUPER_MAGIC"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"NILFS: superblock broke on dev %s\\n\"",
            "sb->s_id"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sbp[0]",
            "sbp[1]",
            "nilfs->ns_sbsize"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "NILFS_SUPER_MAGIC"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "NILFS_SUPER_MAGIC"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstruct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}"
  },
  {
    "function_name": "nilfs_set_log_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "248-262",
    "snippet": "void nilfs_set_log_cursor(struct nilfs_super_block *sbp,\n\t\t\t  struct the_nilfs *nilfs)\n{\n\tsector_t nfreeblocks;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tnilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tsbp->s_free_blocks_count = cpu_to_le64(nfreeblocks);\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsbp->s_last_seq = cpu_to_le64(nilfs->ns_last_seq);\n\tsbp->s_last_pseg = cpu_to_le64(nilfs->ns_last_pseg);\n\tsbp->s_last_cno = cpu_to_le64(nilfs->ns_last_cno);\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_last_segment_lock"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nilfs->ns_last_cno"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nilfs->ns_last_pseg"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nilfs->ns_last_seq"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_last_segment_lock"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nfreeblocks"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_count_free_blocks",
          "args": [
            "nilfs",
            "&nfreeblocks"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_count_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "697-706",
          "snippet": "int nilfs_count_free_blocks(struct the_nilfs *nilfs, sector_t *nblocks)\n{\n\tunsigned long ncleansegs;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\t*nblocks = (sector_t)ncleansegs * nilfs->ns_blocks_per_segment;\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint nilfs_count_free_blocks(struct the_nilfs *nilfs, sector_t *nblocks)\n{\n\tunsigned long ncleansegs;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\t*nblocks = (sector_t)ncleansegs * nilfs->ns_blocks_per_segment;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_set_log_cursor(struct nilfs_super_block *sbp,\n\t\t\t  struct the_nilfs *nilfs)\n{\n\tsector_t nfreeblocks;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tnilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tsbp->s_free_blocks_count = cpu_to_le64(nfreeblocks);\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsbp->s_last_seq = cpu_to_le64(nilfs->ns_last_seq);\n\tsbp->s_last_pseg = cpu_to_le64(nilfs->ns_last_pseg);\n\tsbp->s_last_cno = cpu_to_le64(nilfs->ns_last_cno);\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}"
  },
  {
    "function_name": "nilfs_sync_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "190-246",
    "snippet": "static int nilfs_sync_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n retry:\n\tset_buffer_dirty(nilfs->ns_sbh[0]);\n\tif (nilfs_test_opt(nilfs, BARRIER)) {\n\t\terr = __sync_dirty_buffer(nilfs->ns_sbh[0],\n\t\t\t\t\t  WRITE_SYNC | WRITE_FLUSH_FUA);\n\t} else {\n\t\terr = sync_dirty_buffer(nilfs->ns_sbh[0]);\n\t}\n\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: unable to write superblock (err=%d)\\n\", err);\n\t\tif (err == -EIO && nilfs->ns_sbh[1]) {\n\t\t\t/*\n\t\t\t * sbp[0] points to newer log than sbp[1],\n\t\t\t * so copy sbp[0] to sbp[1] to take over sbp[0].\n\t\t\t */\n\t\t\tmemcpy(nilfs->ns_sbp[1], nilfs->ns_sbp[0],\n\t\t\t       nilfs->ns_sbsize);\n\t\t\tnilfs_fall_back_super_block(nilfs);\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\tstruct nilfs_super_block *sbp = nilfs->ns_sbp[0];\n\n\t\tnilfs->ns_sbwcount++;\n\n\t\t/*\n\t\t * The latest segment becomes trailable from the position\n\t\t * written in superblock.\n\t\t */\n\t\tclear_nilfs_discontinued(nilfs);\n\n\t\t/* update GC protection for recent segments */\n\t\tif (nilfs->ns_sbh[1]) {\n\t\t\tif (flag == NILFS_SB_COMMIT_ALL) {\n\t\t\t\tset_buffer_dirty(nilfs->ns_sbh[1]);\n\t\t\t\tif (sync_dirty_buffer(nilfs->ns_sbh[1]) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (le64_to_cpu(nilfs->ns_sbp[1]->s_last_cno) <\n\t\t\t    le64_to_cpu(nilfs->ns_sbp[0]->s_last_cno))\n\t\t\t\tsbp = nilfs->ns_sbp[1];\n\t\t}\n\n\t\tspin_lock(&nilfs->ns_last_segment_lock);\n\t\tnilfs->ns_prot_seq = le64_to_cpu(sbp->s_last_seq);\n\t\tspin_unlock(&nilfs->ns_last_segment_lock);\n\t}\n out:\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_last_segment_lock"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sbp->s_last_seq"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_last_segment_lock"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "nilfs->ns_sbh[1]"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "nilfs->ns_sbh[1]"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nilfs_discontinued",
          "args": [
            "nilfs"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_fall_back_super_block",
          "args": [
            "nilfs"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_fall_back_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "476-483",
          "snippet": "void nilfs_fall_back_super_block(struct the_nilfs *nilfs)\n{\n\tbrelse(nilfs->ns_sbh[0]);\n\tnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\n\tnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\n\tnilfs->ns_sbh[1] = NULL;\n\tnilfs->ns_sbp[1] = NULL;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_fall_back_super_block(struct the_nilfs *nilfs)\n{\n\tbrelse(nilfs->ns_sbh[0]);\n\tnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\n\tnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\n\tnilfs->ns_sbh[1] = NULL;\n\tnilfs->ns_sbp[1] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nilfs->ns_sbp[1]",
            "nilfs->ns_sbp[0]",
            "nilfs->ns_sbsize"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"NILFS: unable to write superblock (err=%d)\\n\"",
            "err"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sync_dirty_buffer",
          "args": [
            "nilfs->ns_sbh[0]",
            "WRITE_SYNC | WRITE_FLUSH_FUA"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "__sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3133-3150",
          "snippet": "int __sync_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(rw, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __sync_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(rw, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "BARRIER"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "nilfs->ns_sbh[0]"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int nilfs_sync_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n retry:\n\tset_buffer_dirty(nilfs->ns_sbh[0]);\n\tif (nilfs_test_opt(nilfs, BARRIER)) {\n\t\terr = __sync_dirty_buffer(nilfs->ns_sbh[0],\n\t\t\t\t\t  WRITE_SYNC | WRITE_FLUSH_FUA);\n\t} else {\n\t\terr = sync_dirty_buffer(nilfs->ns_sbh[0]);\n\t}\n\n\tif (unlikely(err)) {\n\t\tprintk(KERN_ERR\n\t\t       \"NILFS: unable to write superblock (err=%d)\\n\", err);\n\t\tif (err == -EIO && nilfs->ns_sbh[1]) {\n\t\t\t/*\n\t\t\t * sbp[0] points to newer log than sbp[1],\n\t\t\t * so copy sbp[0] to sbp[1] to take over sbp[0].\n\t\t\t */\n\t\t\tmemcpy(nilfs->ns_sbp[1], nilfs->ns_sbp[0],\n\t\t\t       nilfs->ns_sbsize);\n\t\t\tnilfs_fall_back_super_block(nilfs);\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\tstruct nilfs_super_block *sbp = nilfs->ns_sbp[0];\n\n\t\tnilfs->ns_sbwcount++;\n\n\t\t/*\n\t\t * The latest segment becomes trailable from the position\n\t\t * written in superblock.\n\t\t */\n\t\tclear_nilfs_discontinued(nilfs);\n\n\t\t/* update GC protection for recent segments */\n\t\tif (nilfs->ns_sbh[1]) {\n\t\t\tif (flag == NILFS_SB_COMMIT_ALL) {\n\t\t\t\tset_buffer_dirty(nilfs->ns_sbh[1]);\n\t\t\t\tif (sync_dirty_buffer(nilfs->ns_sbh[1]) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (le64_to_cpu(nilfs->ns_sbp[1]->s_last_cno) <\n\t\t\t    le64_to_cpu(nilfs->ns_sbp[0]->s_last_cno))\n\t\t\t\tsbp = nilfs->ns_sbp[1];\n\t\t}\n\n\t\tspin_lock(&nilfs->ns_last_segment_lock);\n\t\tnilfs->ns_prot_seq = le64_to_cpu(sbp->s_last_seq);\n\t\tspin_unlock(&nilfs->ns_last_segment_lock);\n\t}\n out:\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "185-188",
    "snippet": "void nilfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, nilfs_i_callback);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "nilfs_i_callback"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, nilfs_i_callback);\n}"
  },
  {
    "function_name": "nilfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "173-183",
    "snippet": "static void nilfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct nilfs_mdt_info *mdi = NILFS_MDT(inode);\n\n\tif (mdi) {\n\t\tkfree(mdi->mi_bgl); /* kfree(NULL) is safe */\n\t\tkfree(mdi);\n\t}\n\tkmem_cache_free(nilfs_inode_cachep, NILFS_I(inode));\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nilfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nilfs_inode_cachep",
            "NILFS_I(inode)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mdi"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mdi->mi_bgl"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "inode"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *nilfs_inode_cachep;\n\nstatic void nilfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct nilfs_mdt_info *mdi = NILFS_MDT(inode);\n\n\tif (mdi) {\n\t\tkfree(mdi->mi_bgl); /* kfree(NULL) is safe */\n\t\tkfree(mdi);\n\t}\n\tkmem_cache_free(nilfs_inode_cachep, NILFS_I(inode));\n}"
  },
  {
    "function_name": "nilfs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "158-171",
    "snippet": "struct inode *nilfs_alloc_inode(struct super_block *sb)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tii = kmem_cache_alloc(nilfs_inode_cachep, GFP_NOFS);\n\tif (!ii)\n\t\treturn NULL;\n\tii->i_bh = NULL;\n\tii->i_state = 0;\n\tii->i_cno = 0;\n\tii->vfs_inode.i_version = 1;\n\tnilfs_mapping_init(&ii->i_btnode_cache, &ii->vfs_inode);\n\treturn &ii->vfs_inode;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nilfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_mapping_init",
          "args": [
            "&ii->i_btnode_cache",
            "&ii->vfs_inode"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mapping_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "464-471",
          "snippet": "void nilfs_mapping_init(struct address_space *mapping, struct inode *inode)\n{\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tmapping->private_data = NULL;\n\tmapping->a_ops = &empty_aops;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_mapping_init(struct address_space *mapping, struct inode *inode)\n{\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tmapping->private_data = NULL;\n\tmapping->a_ops = &empty_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "nilfs_inode_cachep",
            "GFP_NOFS"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *nilfs_inode_cachep;\n\nstruct inode *nilfs_alloc_inode(struct super_block *sb)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tii = kmem_cache_alloc(nilfs_inode_cachep, GFP_NOFS);\n\tif (!ii)\n\t\treturn NULL;\n\tii->i_bh = NULL;\n\tii->i_state = 0;\n\tii->i_cno = 0;\n\tii->vfs_inode.i_version = 1;\n\tnilfs_mapping_init(&ii->i_btnode_cache, &ii->vfs_inode);\n\treturn &ii->vfs_inode;\n}"
  },
  {
    "function_name": "nilfs_warning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "140-155",
    "snippet": "void nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
  },
  {
    "function_name": "nilfs_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "109-138",
    "snippet": "void nilfs_error(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"NILFS error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tnilfs_set_error(sb);\n\n\t\tif (nilfs_test_opt(nilfs, ERRORS_RO)) {\n\t\t\tprintk(KERN_CRIT \"Remounting filesystem read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t}\n\t}\n\n\tif (nilfs_test_opt(nilfs, ERRORS_PANIC))\n\t\tpanic(\"NILFS (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"NILFS (device %s): panic forced after error\\n\"",
            "sb->s_id"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "553-558",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "ERRORS_PANIC"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"Remounting filesystem read-only\\n\""
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "ERRORS_RO"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_set_error",
          "args": [
            "sb"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "78-95",
          "snippet": "static void nilfs_set_error(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\n\tdown_write(&nilfs->ns_sem);\n\tif (!(nilfs->ns_mount_state & NILFS_ERROR_FS)) {\n\t\tnilfs->ns_mount_state |= NILFS_ERROR_FS;\n\t\tsbp = nilfs_prepare_super(sb, 0);\n\t\tif (likely(sbp)) {\n\t\t\tsbp[0]->s_state |= cpu_to_le16(NILFS_ERROR_FS);\n\t\t\tif (sbp[1])\n\t\t\t\tsbp[1]->s_state |= cpu_to_le16(NILFS_ERROR_FS);\n\t\t\tnilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n\t\t}\n\t}\n\tup_write(&nilfs->ns_sem);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void nilfs_set_error(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\n\tdown_write(&nilfs->ns_sem);\n\tif (!(nilfs->ns_mount_state & NILFS_ERROR_FS)) {\n\t\tnilfs->ns_mount_state |= NILFS_ERROR_FS;\n\t\tsbp = nilfs_prepare_super(sb, 0);\n\t\tif (likely(sbp)) {\n\t\t\tsbp[0]->s_state |= cpu_to_le16(NILFS_ERROR_FS);\n\t\t\tif (sbp[1])\n\t\t\t\tsbp[1]->s_state |= cpu_to_le16(NILFS_ERROR_FS);\n\t\t\tnilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n\t\t}\n\t}\n\tup_write(&nilfs->ns_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"NILFS error (device %s): %s: %pV\\n\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_error(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"NILFS error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tnilfs_set_error(sb);\n\n\t\tif (nilfs_test_opt(nilfs, ERRORS_RO)) {\n\t\t\tprintk(KERN_CRIT \"Remounting filesystem read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t}\n\t}\n\n\tif (nilfs_test_opt(nilfs, ERRORS_PANIC))\n\t\tpanic(\"NILFS (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n}"
  },
  {
    "function_name": "nilfs_set_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
    "lines": "78-95",
    "snippet": "static void nilfs_set_error(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\n\tdown_write(&nilfs->ns_sem);\n\tif (!(nilfs->ns_mount_state & NILFS_ERROR_FS)) {\n\t\tnilfs->ns_mount_state |= NILFS_ERROR_FS;\n\t\tsbp = nilfs_prepare_super(sb, 0);\n\t\tif (likely(sbp)) {\n\t\t\tsbp[0]->s_state |= cpu_to_le16(NILFS_ERROR_FS);\n\t\t\tif (sbp[1])\n\t\t\t\tsbp[1]->s_state |= cpu_to_le16(NILFS_ERROR_FS);\n\t\t\tnilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n\t\t}\n\t}\n\tup_write(&nilfs->ns_sem);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"segment.h\"",
      "#include \"dat.h\"",
      "#include \"ifile.h\"",
      "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
      "#include \"cpfile.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"btree.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"export.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_commit_super",
          "args": [
            "sb",
            "NILFS_SB_COMMIT_ALL"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "291-317",
          "snippet": "int nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "NILFS_ERROR_FS"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "NILFS_ERROR_FS"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sbp"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_prepare_super",
          "args": [
            "sb",
            "0"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_prepare_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "264-289",
          "snippet": "struct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstruct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void nilfs_set_error(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\n\tdown_write(&nilfs->ns_sem);\n\tif (!(nilfs->ns_mount_state & NILFS_ERROR_FS)) {\n\t\tnilfs->ns_mount_state |= NILFS_ERROR_FS;\n\t\tsbp = nilfs_prepare_super(sb, 0);\n\t\tif (likely(sbp)) {\n\t\t\tsbp[0]->s_state |= cpu_to_le16(NILFS_ERROR_FS);\n\t\t\tif (sbp[1])\n\t\t\t\tsbp[1]->s_state |= cpu_to_le16(NILFS_ERROR_FS);\n\t\t\tnilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n\t\t}\n\t}\n\tup_write(&nilfs->ns_sem);\n}"
  }
]