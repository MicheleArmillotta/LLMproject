[
  {
    "function_name": "xfs_attr_node_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "1411-1456",
    "snippet": "STATIC int\nxfs_attr_node_get(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\tint error, retval;\n\tint i;\n\n\ttrace_xfs_attr_node_get(args);\n\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error) {\n\t\tretval = error;\n\t} else if (retval == -EEXIST) {\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->bp != NULL);\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\t\t/*\n\t\t * Get the value, local or \"remote\"\n\t\t */\n\t\tretval = xfs_attr3_leaf_getvalue(blk->bp, args);\n\t\tif (!retval && (args->rmtblkno > 0)\n\t\t    && !(args->flags & ATTR_KERNOVAL)) {\n\t\t\tretval = xfs_attr_rmtval_get(args);\n\t\t}\n\t}\n\n\t/*\n\t * If not in a transaction, we have to release all the buffers.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\n\txfs_da_state_free(state);\n\treturn retval;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
      "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_state_free",
          "args": [
            "state"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "120-128",
          "snippet": "void\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nvoid\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "args->trans",
            "state->path.blk[i].bp"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_rmtval_get",
          "args": [
            "args"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_rmtval_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "331-390",
          "snippet": "int\nxfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_get(args);\n\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\tASSERT(args->rmtvaluelen == args->valuelen);\n\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/* roll attribute extent map forwards */\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define ATTR_RMTVALUE_MAPSIZE\t1\t/* # of map entries at once */"
          ],
          "globals_used": [
            "const struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define ATTR_RMTVALUE_MAPSIZE\t1\t/* # of map entries at once */\n\nconst struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};\n\nint\nxfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_get(args);\n\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\tASSERT(args->rmtvaluelen == args->valuelen);\n\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/* roll attribute extent map forwards */\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_getvalue",
          "args": [
            "blk->bp",
            "args"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_getvalue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "2180-2232",
          "snippet": "int\nxfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index < ichdr.count);\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       args->rmtvaluelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < args->rmtvaluelen) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = args->rmtvaluelen;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index < ichdr.count);\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       args->rmtvaluelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < args->rmtvaluelen) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = args->rmtvaluelen;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk->magic == XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk->bp != NULL"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_lookup_int",
          "args": [
            "state",
            "&retval"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1445-1597",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);",
            "STATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\nSTATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_state_alloc",
          "args": [],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "98-102",
          "snippet": "xfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nxfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_node_get",
          "args": [
            "args"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_node_get(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\tint error, retval;\n\tint i;\n\n\ttrace_xfs_attr_node_get(args);\n\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error) {\n\t\tretval = error;\n\t} else if (retval == -EEXIST) {\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->bp != NULL);\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\t\t/*\n\t\t * Get the value, local or \"remote\"\n\t\t */\n\t\tretval = xfs_attr3_leaf_getvalue(blk->bp, args);\n\t\tif (!retval && (args->rmtblkno > 0)\n\t\t    && !(args->flags & ATTR_KERNOVAL)) {\n\t\t\tretval = xfs_attr_rmtval_get(args);\n\t\t}\n\t}\n\n\t/*\n\t * If not in a transaction, we have to release all the buffers.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\n\txfs_da_state_free(state);\n\treturn retval;\n}"
  },
  {
    "function_name": "xfs_attr_refillstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "1354-1402",
    "snippet": "STATIC int\nxfs_attr_refillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level, error;\n\n\ttrace_xfs_attr_refillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
      "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da3_node_read",
          "args": [
            "state->args->trans",
            "state->args->dp",
            "blk->blkno",
            "blk->disk_blkno",
            "&blk->bp",
            "XFS_ATTR_FORK"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "248-286",
          "snippet": "int\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH)"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH)"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_refillstate",
          "args": [
            "state->args"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_refillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level, error;\n\n\ttrace_xfs_attr_refillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr_fillstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "1306-1346",
    "snippet": "STATIC int\nxfs_attr_fillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level;\n\n\ttrace_xfs_attr_fillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
      "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "blk->bp"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH)"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "blk->bp"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH)"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_fillstate",
          "args": [
            "state->args"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_fillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level;\n\n\ttrace_xfs_attr_fillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr_node_removename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "1145-1298",
    "snippet": "STATIC int\nxfs_attr_node_removename(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, committed, forkoff;\n\n\ttrace_xfs_attr_node_removename(args);\n\n\t/*\n\t * Tie a string around our finger to remind us where we are.\n\t */\n\tdp = args->dp;\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error || (retval != -EEXIST)) {\n\t\tif (error == 0)\n\t\t\terror = retval;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is an out-of-line value, de-allocate the blocks.\n\t * This is done before we remove the attribute so that we don't\n\t * overflow the maximum size of a transaction and/or hit a deadlock.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->bp != NULL);\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Fill in disk block numbers in the state structure\n\t\t * so that we can get the buffers back after we commit\n\t\t * several transactions in the following calls.\n\t\t */\n\t\terror = xfs_attr_fillstate(state);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Mark the attribute as INCOMPLETE, then bunmapi() the\n\t\t * remote value.\n\t\t */\n\t\terror = xfs_attr3_leaf_setflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = xfs_attr_rmtval_remove(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Refill the state structure with buffers, the prior calls\n\t\t * released our buffers.\n\t\t */\n\t\terror = xfs_attr_refillstate(state);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Remove the name and update the hashvals in the tree.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tretval = xfs_attr3_leaf_remove(blk->bp, args);\n\txfs_da3_fixhashpath(state, &state->path);\n\n\t/*\n\t * Check to see if the tree needs to be collapsed.\n\t */\n\tif (retval && (state->path.active > 1)) {\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_da3_join(state);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the Btree join operation and start a new trans.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If the result is small enough, push it all into the inode.\n\t */\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\t/*\n\t\t * Have to get rid of the copy of this dabuf in the state.\n\t\t */\n\t\tASSERT(state->path.active == 1);\n\t\tASSERT(state->path.blk[0].bp);\n\t\tstate->path.blk[0].bp = NULL;\n\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, 0, -1, &bp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t} else\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t}\n\terror = 0;\n\nout:\n\txfs_da_state_free(state);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
      "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_state_free",
          "args": [
            "state"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "120-128",
          "snippet": "void\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nvoid\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "args->trans",
            "bp"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "args->trans",
            "dp",
            "0"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "args->flist"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "committed"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&args->trans",
            "args->flist",
            "&committed"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_to_shortform",
          "args": [
            "bp",
            "args",
            "forkoff"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_to_shortform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "790-870",
          "snippet": "int\nxfs_attr3_leaf_to_shortform(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tforkoff)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_da_args\tnargs;\n\tstruct xfs_inode\t*dp = args->dp;\n\tchar\t\t\t*tmpbuffer;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_to_sf(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tif (!tmpbuffer)\n\t\treturn -ENOMEM;\n\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\n\tleaf = (xfs_attr_leafblock_t *)tmpbuffer;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\t/* XXX (dgc): buffer is about to be marked stale - why zero it? */\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\n\t/*\n\t * Clean out the prior contents of the attribute list.\n\t */\n\terror = xfs_da_shrink_inode(args, 0, bp);\n\tif (error)\n\t\tgoto out;\n\n\tif (forkoff == -1) {\n\t\tASSERT(dp->i_mount->m_flags & XFS_MOUNT_ATTR2);\n\t\tASSERT(dp->i_d.di_format != XFS_DINODE_FMT_BTREE);\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t\tgoto out;\n\t}\n\n\txfs_attr_shortform_create(args);\n\n\t/*\n\t * Copy the attributes\n\t */\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.geo = args->geo;\n\tnargs.dp = dp;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t/* don't copy partial entries */\n\t\tif (!entry->nameidx)\n\t\t\tcontinue;\n\t\tASSERT(entry->flags & XFS_ATTR_LOCAL);\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tnargs.name = name_loc->nameval;\n\t\tnargs.namelen = name_loc->namelen;\n\t\tnargs.value = &name_loc->nameval[nargs.namelen];\n\t\tnargs.valuelen = be16_to_cpu(name_loc->valuelen);\n\t\tnargs.hashval = be32_to_cpu(entry->hashval);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(entry->flags);\n\t\txfs_attr_shortform_add(&nargs, forkoff);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_leaf_to_shortform(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tforkoff)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_da_args\tnargs;\n\tstruct xfs_inode\t*dp = args->dp;\n\tchar\t\t\t*tmpbuffer;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_to_sf(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tif (!tmpbuffer)\n\t\treturn -ENOMEM;\n\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\n\tleaf = (xfs_attr_leafblock_t *)tmpbuffer;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\t/* XXX (dgc): buffer is about to be marked stale - why zero it? */\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\n\t/*\n\t * Clean out the prior contents of the attribute list.\n\t */\n\terror = xfs_da_shrink_inode(args, 0, bp);\n\tif (error)\n\t\tgoto out;\n\n\tif (forkoff == -1) {\n\t\tASSERT(dp->i_mount->m_flags & XFS_MOUNT_ATTR2);\n\t\tASSERT(dp->i_d.di_format != XFS_DINODE_FMT_BTREE);\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t\tgoto out;\n\t}\n\n\txfs_attr_shortform_create(args);\n\n\t/*\n\t * Copy the attributes\n\t */\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.geo = args->geo;\n\tnargs.dp = dp;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t/* don't copy partial entries */\n\t\tif (!entry->nameidx)\n\t\t\tcontinue;\n\t\tASSERT(entry->flags & XFS_ATTR_LOCAL);\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tnargs.name = name_loc->nameval;\n\t\tnargs.namelen = name_loc->namelen;\n\t\tnargs.value = &name_loc->nameval[nargs.namelen];\n\t\tnargs.valuelen = be16_to_cpu(name_loc->valuelen);\n\t\tnargs.hashval = be32_to_cpu(entry->hashval);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(entry->flags);\n\t\txfs_attr_shortform_add(&nargs, forkoff);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "args->flist",
            "args->firstblock"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_allfit",
          "args": [
            "bp",
            "dp"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_allfit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "749-785",
          "snippet": "int\nxfs_attr_shortform_allfit(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tint\t\t\tbytes;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\tbytes = sizeof(struct xfs_attr_sf_hdr);\n\tfor (i = 0; i < leafhdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* don't copy partial entries */\n\t\tif (!(entry->flags & XFS_ATTR_LOCAL))\n\t\t\treturn 0;\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tif (name_loc->namelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tif (be16_to_cpu(name_loc->valuelen) >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tbytes += sizeof(struct xfs_attr_sf_entry) - 1\n\t\t\t\t+ name_loc->namelen\n\t\t\t\t+ be16_to_cpu(name_loc->valuelen);\n\t}\n\tif ((dp->i_mount->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    (bytes == sizeof(struct xfs_attr_sf_hdr)))\n\t\treturn -1;\n\treturn xfs_attr_shortform_bytesfit(dp, bytes);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_allfit(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tint\t\t\tbytes;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\tbytes = sizeof(struct xfs_attr_sf_hdr);\n\tfor (i = 0; i < leafhdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* don't copy partial entries */\n\t\tif (!(entry->flags & XFS_ATTR_LOCAL))\n\t\t\treturn 0;\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tif (name_loc->namelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tif (be16_to_cpu(name_loc->valuelen) >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tbytes += sizeof(struct xfs_attr_sf_entry) - 1\n\t\t\t\t+ name_loc->namelen\n\t\t\t\t+ be16_to_cpu(name_loc->valuelen);\n\t}\n\tif ((dp->i_mount->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    (bytes == sizeof(struct xfs_attr_sf_hdr)))\n\t\treturn -1;\n\treturn xfs_attr_shortform_bytesfit(dp, bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_read",
          "args": [
            "args->trans",
            "args->dp",
            "0",
            "-1",
            "&bp"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "256-271",
          "snippet": "int\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
            "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->path.blk[0].bp"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->path.active == 1"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_one_block",
          "args": [
            "dp",
            "XFS_ATTR_FORK"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_one_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1703-1729",
          "snippet": "int\t\t\t\t\t/* 1=>1 block, 0=>otherwise */\nxfs_bmap_one_block(\n\txfs_inode_t\t*ip,\t\t/* incore inode */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* ptr to fork's extent */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\trval;\t\t/* return value */\n\txfs_bmbt_irec_t\ts;\t\t/* internal version of extent */\n\n#ifndef DEBUG\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize;\n#endif\t/* !DEBUG */\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) != 1)\n\t\treturn 0;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\treturn 0;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_get_all(ep, &s);\n\trval = s.br_startoff == 0 && s.br_blockcount == 1;\n\tif (rval && whichfork == XFS_DATA_FORK)\n\t\tASSERT(XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* 1=>1 block, 0=>otherwise */\nxfs_bmap_one_block(\n\txfs_inode_t\t*ip,\t\t/* incore inode */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* ptr to fork's extent */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\trval;\t\t/* return value */\n\txfs_bmbt_irec_t\ts;\t\t/* internal version of extent */\n\n#ifndef DEBUG\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize;\n#endif\t/* !DEBUG */\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) != 1)\n\t\treturn 0;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\treturn 0;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_get_all(ep, &s);\n\trval = s.br_startoff == 0 && s.br_blockcount == 1;\n\tif (rval && whichfork == XFS_DATA_FORK)\n\t\tASSERT(XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_roll",
          "args": [
            "&args->trans",
            "dp"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_roll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "995-1055",
          "snippet": "int\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "committed"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_join",
          "args": [
            "state"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "929-1010",
          "snippet": "int\nxfs_da3_join(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*drop_blk;\n\tstruct xfs_da_state_blk\t*save_blk;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_join(state->args);\n\n\tdrop_blk = &state->path.blk[ state->path.active-1 ];\n\tsave_blk = &state->altpath.blk[ state->path.active-1 ];\n\tASSERT(state->path.blk[0].magic == XFS_DA_NODE_MAGIC);\n\tASSERT(drop_blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\n\t/*\n\t * Walk back up the tree joining/deallocating as necessary.\n\t * When we stop dropping blocks, break out.\n\t */\n\tfor (  ; state->path.active >= 2; drop_blk--, save_blk--,\n\t\t state->path.active--) {\n\t\t/*\n\t\t * See if we can combine the block with a neighbor.\n\t\t *   (action == 0) => no options, just leave\n\t\t *   (action == 1) => coalesce, then unlink\n\t\t *   (action == 2) => block empty, unlink it\n\t\t */\n\t\tswitch (drop_blk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_attr3_leaf_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_dir2_leafn_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\t/*\n\t\t\t * Remove the offending node, fixup hashvals,\n\t\t\t * check for a toosmall neighbor.\n\t\t\t */\n\t\t\txfs_da3_node_remove(state, drop_blk);\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t\t\terror = xfs_da3_node_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_da3_node_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\t}\n\t\txfs_da3_fixhashpath(state, &state->altpath);\n\t\terror = xfs_da3_blk_unlink(state, drop_blk, save_blk);\n\t\txfs_da_state_kill_altpath(state);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_da_shrink_inode(state->args, drop_blk->blkno,\n\t\t\t\t\t\t\t drop_blk->bp);\n\t\tdrop_blk->bp = NULL;\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/*\n\t * We joined all the way to the top.  If it turns out that\n\t * we only have one entry in the root, make the child block\n\t * the new root.\n\t */\n\txfs_da3_node_remove(state, drop_blk);\n\txfs_da3_fixhashpath(state, &state->path);\n\terror = xfs_da3_root_join(state, &state->path.blk[0]);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);",
            "STATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);\nSTATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);\n\nint\nxfs_da3_join(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*drop_blk;\n\tstruct xfs_da_state_blk\t*save_blk;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_join(state->args);\n\n\tdrop_blk = &state->path.blk[ state->path.active-1 ];\n\tsave_blk = &state->altpath.blk[ state->path.active-1 ];\n\tASSERT(state->path.blk[0].magic == XFS_DA_NODE_MAGIC);\n\tASSERT(drop_blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\n\t/*\n\t * Walk back up the tree joining/deallocating as necessary.\n\t * When we stop dropping blocks, break out.\n\t */\n\tfor (  ; state->path.active >= 2; drop_blk--, save_blk--,\n\t\t state->path.active--) {\n\t\t/*\n\t\t * See if we can combine the block with a neighbor.\n\t\t *   (action == 0) => no options, just leave\n\t\t *   (action == 1) => coalesce, then unlink\n\t\t *   (action == 2) => block empty, unlink it\n\t\t */\n\t\tswitch (drop_blk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_attr3_leaf_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_dir2_leafn_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\t/*\n\t\t\t * Remove the offending node, fixup hashvals,\n\t\t\t * check for a toosmall neighbor.\n\t\t\t */\n\t\t\txfs_da3_node_remove(state, drop_blk);\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t\t\terror = xfs_da3_node_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_da3_node_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\t}\n\t\txfs_da3_fixhashpath(state, &state->altpath);\n\t\terror = xfs_da3_blk_unlink(state, drop_blk, save_blk);\n\t\txfs_da_state_kill_altpath(state);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_da_shrink_inode(state->args, drop_blk->blkno,\n\t\t\t\t\t\t\t drop_blk->bp);\n\t\tdrop_blk->bp = NULL;\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/*\n\t * We joined all the way to the top.  If it turns out that\n\t * we only have one entry in the root, make the child block\n\t * the new root.\n\t */\n\txfs_da3_node_remove(state, drop_blk);\n\txfs_da3_fixhashpath(state, &state->path);\n\terror = xfs_da3_root_join(state, &state->path.blk[0]);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_fixhashpath",
          "args": [
            "state",
            "&state->path"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_fixhashpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1256-1306",
          "snippet": "void\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_remove",
          "args": [
            "blk->bp",
            "args"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1789-1939",
          "snippet": "int\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t/*\n\t * Scan through free region table:\n\t *    check for adjacency of free'd entry with an existing one,\n\t *    find smallest free region in case we need to replace it,\n\t *    adjust any map that borders the entry table,\n\t */\n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t/*\n\t * Coalesce adjacent freemap regions,\n\t * or replace the smallest region.\n\t */\n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Replace smallest region (if it is smaller than free'd entry)\n\t\t */\n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t/*\n\t * Did we remove the first entry?\n\t */\n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t/*\n\t * Compress the remaining entries and zero out the removed stuff.\n\t */\n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t/*\n\t * If we removed the first entry, re-find the first used byte\n\t * in the name area.  Note that if the entry was the \"firstused\",\n\t * then we don't have a \"hole\" in our block resulting from\n\t * removing the name.\n\t */\n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tif (!ichdr.firstused)\n\t\t\tichdr.firstused = tmp - XFS_ATTR_LEAF_NAME_ALIGN;\n\t} else {\n\t\tichdr.holes = 1;\t/* mark as needing compaction */\n\t}\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t/*\n\t * Check if leaf is less than 50% full, caller may want to\n\t * \"join\" the leaf with a sibling if so.\n\t */\n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct; /* leaf is < 37% full */\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t/*\n\t * Scan through free region table:\n\t *    check for adjacency of free'd entry with an existing one,\n\t *    find smallest free region in case we need to replace it,\n\t *    adjust any map that borders the entry table,\n\t */\n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t/*\n\t * Coalesce adjacent freemap regions,\n\t * or replace the smallest region.\n\t */\n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Replace smallest region (if it is smaller than free'd entry)\n\t\t */\n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t/*\n\t * Did we remove the first entry?\n\t */\n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t/*\n\t * Compress the remaining entries and zero out the removed stuff.\n\t */\n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t/*\n\t * If we removed the first entry, re-find the first used byte\n\t * in the name area.  Note that if the entry was the \"firstused\",\n\t * then we don't have a \"hole\" in our block resulting from\n\t * removing the name.\n\t */\n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tif (!ichdr.firstused)\n\t\t\tichdr.firstused = tmp - XFS_ATTR_LEAF_NAME_ALIGN;\n\t} else {\n\t\tichdr.holes = 1;\t/* mark as needing compaction */\n\t}\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t/*\n\t * Check if leaf is less than 50% full, caller may want to\n\t * \"join\" the leaf with a sibling if so.\n\t */\n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct; /* leaf is < 37% full */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk->magic == XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_refillstate",
          "args": [
            "state"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_refillstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "1354-1402",
          "snippet": "STATIC int\nxfs_attr_refillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level, error;\n\n\ttrace_xfs_attr_refillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
            "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_refillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level, error;\n\n\ttrace_xfs_attr_refillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_rmtval_remove",
          "args": [
            "args"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_rmtval_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "533-626",
          "snippet": "int\nxfs_attr_rmtval_remove(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\txfs_dablk_t\t\tlblkno;\n\tint\t\t\tblkcnt;\n\tint\t\t\terror;\n\tint\t\t\tdone;\n\n\ttrace_xfs_attr_rmtval_remove(args);\n\n\t/*\n\t * Roll through the \"value\", invalidating the attribute value's blocks.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\twhile (blkcnt > 0) {\n\t\tstruct xfs_bmbt_irec\tmap;\n\t\tstruct xfs_buf\t\t*bp;\n\t\txfs_daddr_t\t\tdblkno;\n\t\tint\t\t\tdblkcnt;\n\t\tint\t\t\tnmap;\n\n\t\t/*\n\t\t * Try to remember where we decided to put the value.\n\t\t */\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\t/*\n\t\t * If the \"remote\" value is in the cache, remove it.\n\t\t */\n\t\tbp = xfs_incore(mp->m_ddev_targp, dblkno, dblkcnt, XBF_TRYLOCK);\n\t\tif (bp) {\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t\tbp = NULL;\n\t\t}\n\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\n\t/*\n\t * Keep de-allocating extents until the remote-value region is gone.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tdone = 0;\n\twhile (!done) {\n\t\tint committed;\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,\n\t\t\t\t    XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t    1, args->firstblock, args->flist,\n\t\t\t\t    &done);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, args->dp, 0);\n\n\t\t/*\n\t\t * Close out trans and start the next one in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, args->dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_rmtval_remove(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\txfs_dablk_t\t\tlblkno;\n\tint\t\t\tblkcnt;\n\tint\t\t\terror;\n\tint\t\t\tdone;\n\n\ttrace_xfs_attr_rmtval_remove(args);\n\n\t/*\n\t * Roll through the \"value\", invalidating the attribute value's blocks.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\twhile (blkcnt > 0) {\n\t\tstruct xfs_bmbt_irec\tmap;\n\t\tstruct xfs_buf\t\t*bp;\n\t\txfs_daddr_t\t\tdblkno;\n\t\tint\t\t\tdblkcnt;\n\t\tint\t\t\tnmap;\n\n\t\t/*\n\t\t * Try to remember where we decided to put the value.\n\t\t */\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\t/*\n\t\t * If the \"remote\" value is in the cache, remove it.\n\t\t */\n\t\tbp = xfs_incore(mp->m_ddev_targp, dblkno, dblkcnt, XBF_TRYLOCK);\n\t\tif (bp) {\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t\tbp = NULL;\n\t\t}\n\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\n\t/*\n\t * Keep de-allocating extents until the remote-value region is gone.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tdone = 0;\n\twhile (!done) {\n\t\tint committed;\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,\n\t\t\t\t    XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t    1, args->firstblock, args->flist,\n\t\t\t\t    &done);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, args->dp, 0);\n\n\t\t/*\n\t\t * Close out trans and start the next one in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, args->dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_setflag",
          "args": [
            "args"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_fillstate",
          "args": [
            "state"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_fillstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "1306-1346",
          "snippet": "STATIC int\nxfs_attr_fillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level;\n\n\ttrace_xfs_attr_fillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
            "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_fillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level;\n\n\ttrace_xfs_attr_fillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk->magic == XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk->bp != NULL"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_lookup_int",
          "args": [
            "state",
            "&retval"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1445-1597",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);",
            "STATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\nSTATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_state_alloc",
          "args": [],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "98-102",
          "snippet": "xfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nxfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_node_removename",
          "args": [
            "args"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_node_removename(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, committed, forkoff;\n\n\ttrace_xfs_attr_node_removename(args);\n\n\t/*\n\t * Tie a string around our finger to remind us where we are.\n\t */\n\tdp = args->dp;\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error || (retval != -EEXIST)) {\n\t\tif (error == 0)\n\t\t\terror = retval;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is an out-of-line value, de-allocate the blocks.\n\t * This is done before we remove the attribute so that we don't\n\t * overflow the maximum size of a transaction and/or hit a deadlock.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->bp != NULL);\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Fill in disk block numbers in the state structure\n\t\t * so that we can get the buffers back after we commit\n\t\t * several transactions in the following calls.\n\t\t */\n\t\terror = xfs_attr_fillstate(state);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Mark the attribute as INCOMPLETE, then bunmapi() the\n\t\t * remote value.\n\t\t */\n\t\terror = xfs_attr3_leaf_setflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = xfs_attr_rmtval_remove(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Refill the state structure with buffers, the prior calls\n\t\t * released our buffers.\n\t\t */\n\t\terror = xfs_attr_refillstate(state);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Remove the name and update the hashvals in the tree.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tretval = xfs_attr3_leaf_remove(blk->bp, args);\n\txfs_da3_fixhashpath(state, &state->path);\n\n\t/*\n\t * Check to see if the tree needs to be collapsed.\n\t */\n\tif (retval && (state->path.active > 1)) {\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_da3_join(state);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the Btree join operation and start a new trans.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If the result is small enough, push it all into the inode.\n\t */\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\t/*\n\t\t * Have to get rid of the copy of this dabuf in the state.\n\t\t */\n\t\tASSERT(state->path.active == 1);\n\t\tASSERT(state->path.blk[0].bp);\n\t\tstate->path.blk[0].bp = NULL;\n\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, 0, -1, &bp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t} else\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t}\n\terror = 0;\n\nout:\n\txfs_da_state_free(state);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr_node_addname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "876-1136",
    "snippet": "STATIC int\nxfs_attr_node_addname(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\txfs_mount_t *mp;\n\tint committed, retval, error;\n\n\ttrace_xfs_attr_node_addname(args);\n\n\t/*\n\t * Fill in bucket of arguments/results/context to carry around.\n\t */\n\tdp = args->dp;\n\tmp = dp->i_mount;\nrestart:\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = mp;\n\n\t/*\n\t * Search to see if name already exists, and get back a pointer\n\t * to where it should go.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error)\n\t\tgoto out;\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\tgoto out;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\tgoto out;\n\n\t\ttrace_xfs_attr_node_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* atomic rename op */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\tretval = xfs_attr3_leaf_add(blk->bp, state->args);\n\tif (retval == -ENOSPC) {\n\t\tif (state->path.active == 1) {\n\t\t\t/*\n\t\t\t * Its really a single leaf node, but it had\n\t\t\t * out-of-line values so it looked like it *might*\n\t\t\t * have been a b-tree.\n\t\t\t */\n\t\t\txfs_da_state_free(state);\n\t\t\tstate = NULL;\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_node(args);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t\t/*\n\t\t\t * Commit the node conversion and start the next\n\t\t\t * trans in the chain.\n\t\t\t */\n\t\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/*\n\t\t * Split as many Btree elements as required.\n\t\t * This code tracks the new and old attr's location\n\t\t * in the index/blkno/rmtblkno/rmtblkcnt fields and\n\t\t * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_da3_split(state);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t} else {\n\t\t/*\n\t\t * Addition succeeded, update Btree hashvals.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\n\t/*\n\t * Kill the state structure, we're done with it and need to\n\t * allow the buffers to come back later.\n\t */\n\txfs_da_state_free(state);\n\tstate = NULL;\n\n\t/*\n\t * Commit the leaf addition or btree split and start the next\n\t * trans in the chain.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Re-find the \"old\" attribute entry after any split ops.\n\t\t * The INCOMPLETE flag means that we will find the \"old\"\n\t\t * attr, not the \"new\" one.\n\t\t */\n\t\targs->flags |= XFS_ATTR_INCOMPLETE;\n\t\tstate = xfs_da_state_alloc();\n\t\tstate->args = args;\n\t\tstate->mp = mp;\n\t\tstate->inleaf = 0;\n\t\terror = xfs_da3_node_lookup_int(state, &retval);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Remove the name and update the hashvals in the tree.\n\t\t */\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\t\terror = xfs_attr3_leaf_remove(blk->bp, args);\n\t\txfs_da3_fixhashpath(state, &state->path);\n\n\t\t/*\n\t\t * Check to see if the tree needs to be collapsed.\n\t\t */\n\t\tif (retval && (state->path.active > 1)) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_da3_join(state);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit and start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tretval = error = 0;\n\nout:\n\tif (state)\n\t\txfs_da_state_free(state);\n\tif (error)\n\t\treturn error;\n\treturn retval;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
      "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_state_free",
          "args": [
            "state"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "120-128",
          "snippet": "void\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nvoid\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_clearflag",
          "args": [
            "args"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_roll",
          "args": [
            "&args->trans",
            "dp"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_roll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "995-1055",
          "snippet": "int\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "args->trans",
            "dp",
            "0"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "args->flist"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "committed"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&args->trans",
            "args->flist",
            "&committed"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_join",
          "args": [
            "state"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "929-1010",
          "snippet": "int\nxfs_da3_join(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*drop_blk;\n\tstruct xfs_da_state_blk\t*save_blk;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_join(state->args);\n\n\tdrop_blk = &state->path.blk[ state->path.active-1 ];\n\tsave_blk = &state->altpath.blk[ state->path.active-1 ];\n\tASSERT(state->path.blk[0].magic == XFS_DA_NODE_MAGIC);\n\tASSERT(drop_blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\n\t/*\n\t * Walk back up the tree joining/deallocating as necessary.\n\t * When we stop dropping blocks, break out.\n\t */\n\tfor (  ; state->path.active >= 2; drop_blk--, save_blk--,\n\t\t state->path.active--) {\n\t\t/*\n\t\t * See if we can combine the block with a neighbor.\n\t\t *   (action == 0) => no options, just leave\n\t\t *   (action == 1) => coalesce, then unlink\n\t\t *   (action == 2) => block empty, unlink it\n\t\t */\n\t\tswitch (drop_blk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_attr3_leaf_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_dir2_leafn_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\t/*\n\t\t\t * Remove the offending node, fixup hashvals,\n\t\t\t * check for a toosmall neighbor.\n\t\t\t */\n\t\t\txfs_da3_node_remove(state, drop_blk);\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t\t\terror = xfs_da3_node_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_da3_node_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\t}\n\t\txfs_da3_fixhashpath(state, &state->altpath);\n\t\terror = xfs_da3_blk_unlink(state, drop_blk, save_blk);\n\t\txfs_da_state_kill_altpath(state);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_da_shrink_inode(state->args, drop_blk->blkno,\n\t\t\t\t\t\t\t drop_blk->bp);\n\t\tdrop_blk->bp = NULL;\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/*\n\t * We joined all the way to the top.  If it turns out that\n\t * we only have one entry in the root, make the child block\n\t * the new root.\n\t */\n\txfs_da3_node_remove(state, drop_blk);\n\txfs_da3_fixhashpath(state, &state->path);\n\terror = xfs_da3_root_join(state, &state->path.blk[0]);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);",
            "STATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);\nSTATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);\n\nint\nxfs_da3_join(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*drop_blk;\n\tstruct xfs_da_state_blk\t*save_blk;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_join(state->args);\n\n\tdrop_blk = &state->path.blk[ state->path.active-1 ];\n\tsave_blk = &state->altpath.blk[ state->path.active-1 ];\n\tASSERT(state->path.blk[0].magic == XFS_DA_NODE_MAGIC);\n\tASSERT(drop_blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\n\t/*\n\t * Walk back up the tree joining/deallocating as necessary.\n\t * When we stop dropping blocks, break out.\n\t */\n\tfor (  ; state->path.active >= 2; drop_blk--, save_blk--,\n\t\t state->path.active--) {\n\t\t/*\n\t\t * See if we can combine the block with a neighbor.\n\t\t *   (action == 0) => no options, just leave\n\t\t *   (action == 1) => coalesce, then unlink\n\t\t *   (action == 2) => block empty, unlink it\n\t\t */\n\t\tswitch (drop_blk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_attr3_leaf_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_dir2_leafn_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\t/*\n\t\t\t * Remove the offending node, fixup hashvals,\n\t\t\t * check for a toosmall neighbor.\n\t\t\t */\n\t\t\txfs_da3_node_remove(state, drop_blk);\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t\t\terror = xfs_da3_node_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_da3_node_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\t}\n\t\txfs_da3_fixhashpath(state, &state->altpath);\n\t\terror = xfs_da3_blk_unlink(state, drop_blk, save_blk);\n\t\txfs_da_state_kill_altpath(state);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_da_shrink_inode(state->args, drop_blk->blkno,\n\t\t\t\t\t\t\t drop_blk->bp);\n\t\tdrop_blk->bp = NULL;\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/*\n\t * We joined all the way to the top.  If it turns out that\n\t * we only have one entry in the root, make the child block\n\t * the new root.\n\t */\n\txfs_da3_node_remove(state, drop_blk);\n\txfs_da3_fixhashpath(state, &state->path);\n\terror = xfs_da3_root_join(state, &state->path.blk[0]);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "args->flist",
            "args->firstblock"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_fixhashpath",
          "args": [
            "state",
            "&state->path"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_fixhashpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1256-1306",
          "snippet": "void\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_remove",
          "args": [
            "blk->bp",
            "args"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1789-1939",
          "snippet": "int\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t/*\n\t * Scan through free region table:\n\t *    check for adjacency of free'd entry with an existing one,\n\t *    find smallest free region in case we need to replace it,\n\t *    adjust any map that borders the entry table,\n\t */\n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t/*\n\t * Coalesce adjacent freemap regions,\n\t * or replace the smallest region.\n\t */\n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Replace smallest region (if it is smaller than free'd entry)\n\t\t */\n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t/*\n\t * Did we remove the first entry?\n\t */\n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t/*\n\t * Compress the remaining entries and zero out the removed stuff.\n\t */\n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t/*\n\t * If we removed the first entry, re-find the first used byte\n\t * in the name area.  Note that if the entry was the \"firstused\",\n\t * then we don't have a \"hole\" in our block resulting from\n\t * removing the name.\n\t */\n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tif (!ichdr.firstused)\n\t\t\tichdr.firstused = tmp - XFS_ATTR_LEAF_NAME_ALIGN;\n\t} else {\n\t\tichdr.holes = 1;\t/* mark as needing compaction */\n\t}\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t/*\n\t * Check if leaf is less than 50% full, caller may want to\n\t * \"join\" the leaf with a sibling if so.\n\t */\n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct; /* leaf is < 37% full */\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t/*\n\t * Scan through free region table:\n\t *    check for adjacency of free'd entry with an existing one,\n\t *    find smallest free region in case we need to replace it,\n\t *    adjust any map that borders the entry table,\n\t */\n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t/*\n\t * Coalesce adjacent freemap regions,\n\t * or replace the smallest region.\n\t */\n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Replace smallest region (if it is smaller than free'd entry)\n\t\t */\n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t/*\n\t * Did we remove the first entry?\n\t */\n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t/*\n\t * Compress the remaining entries and zero out the removed stuff.\n\t */\n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t/*\n\t * If we removed the first entry, re-find the first used byte\n\t * in the name area.  Note that if the entry was the \"firstused\",\n\t * then we don't have a \"hole\" in our block resulting from\n\t * removing the name.\n\t */\n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tif (!ichdr.firstused)\n\t\t\tichdr.firstused = tmp - XFS_ATTR_LEAF_NAME_ALIGN;\n\t} else {\n\t\tichdr.holes = 1;\t/* mark as needing compaction */\n\t}\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t/*\n\t * Check if leaf is less than 50% full, caller may want to\n\t * \"join\" the leaf with a sibling if so.\n\t */\n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct; /* leaf is < 37% full */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk->magic == XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_lookup_int",
          "args": [
            "state",
            "&retval"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1445-1597",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);",
            "STATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\nSTATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_state_alloc",
          "args": [],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "98-102",
          "snippet": "xfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nxfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_rmtval_remove",
          "args": [
            "args"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_rmtval_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "533-626",
          "snippet": "int\nxfs_attr_rmtval_remove(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\txfs_dablk_t\t\tlblkno;\n\tint\t\t\tblkcnt;\n\tint\t\t\terror;\n\tint\t\t\tdone;\n\n\ttrace_xfs_attr_rmtval_remove(args);\n\n\t/*\n\t * Roll through the \"value\", invalidating the attribute value's blocks.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\twhile (blkcnt > 0) {\n\t\tstruct xfs_bmbt_irec\tmap;\n\t\tstruct xfs_buf\t\t*bp;\n\t\txfs_daddr_t\t\tdblkno;\n\t\tint\t\t\tdblkcnt;\n\t\tint\t\t\tnmap;\n\n\t\t/*\n\t\t * Try to remember where we decided to put the value.\n\t\t */\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\t/*\n\t\t * If the \"remote\" value is in the cache, remove it.\n\t\t */\n\t\tbp = xfs_incore(mp->m_ddev_targp, dblkno, dblkcnt, XBF_TRYLOCK);\n\t\tif (bp) {\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t\tbp = NULL;\n\t\t}\n\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\n\t/*\n\t * Keep de-allocating extents until the remote-value region is gone.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tdone = 0;\n\twhile (!done) {\n\t\tint committed;\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,\n\t\t\t\t    XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t    1, args->firstblock, args->flist,\n\t\t\t\t    &done);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, args->dp, 0);\n\n\t\t/*\n\t\t * Close out trans and start the next one in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, args->dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_rmtval_remove(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\txfs_dablk_t\t\tlblkno;\n\tint\t\t\tblkcnt;\n\tint\t\t\terror;\n\tint\t\t\tdone;\n\n\ttrace_xfs_attr_rmtval_remove(args);\n\n\t/*\n\t * Roll through the \"value\", invalidating the attribute value's blocks.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\twhile (blkcnt > 0) {\n\t\tstruct xfs_bmbt_irec\tmap;\n\t\tstruct xfs_buf\t\t*bp;\n\t\txfs_daddr_t\t\tdblkno;\n\t\tint\t\t\tdblkcnt;\n\t\tint\t\t\tnmap;\n\n\t\t/*\n\t\t * Try to remember where we decided to put the value.\n\t\t */\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\t/*\n\t\t * If the \"remote\" value is in the cache, remove it.\n\t\t */\n\t\tbp = xfs_incore(mp->m_ddev_targp, dblkno, dblkcnt, XBF_TRYLOCK);\n\t\tif (bp) {\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t\tbp = NULL;\n\t\t}\n\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\n\t/*\n\t * Keep de-allocating extents until the remote-value region is gone.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tdone = 0;\n\twhile (!done) {\n\t\tint committed;\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,\n\t\t\t\t    XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t    1, args->firstblock, args->flist,\n\t\t\t\t    &done);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, args->dp, 0);\n\n\t\t/*\n\t\t * Close out trans and start the next one in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, args->dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_flipflags",
          "args": [
            "args"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_rmtval_set",
          "args": [
            "args"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_rmtval_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "396-527",
          "snippet": "int\nxfs_attr_rmtval_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\t__uint8_t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t */\n\twhile (blkcnt > 0) {\n\t\tint\tcommitted;\n\n\t\t/*\n\t\t * Allocate a single extent, up to the size of the value.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t  blkcnt,\n\t\t\t\t  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t  args->firstblock, args->total, &map, &nmap,\n\t\t\t\t  args->flist);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\n\t\t/*\n\t\t * Start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\tbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t/* GROT: NOTE: synchronous write */\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t/* roll attribute extent map forwards */\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};\n\nint\nxfs_attr_rmtval_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\t__uint8_t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t */\n\twhile (blkcnt > 0) {\n\t\tint\tcommitted;\n\n\t\t/*\n\t\t * Allocate a single extent, up to the size of the value.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t  blkcnt,\n\t\t\t\t  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t  args->firstblock, args->total, &map, &nmap,\n\t\t\t\t  args->flist);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\n\t\t/*\n\t\t * Start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\tbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t/* GROT: NOTE: synchronous write */\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t/* roll attribute extent map forwards */\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "committed"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_split",
          "args": [
            "state"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "345-494",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_split(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*oldblk;\n\tstruct xfs_da_state_blk\t*newblk;\n\tstruct xfs_da_state_blk\t*addblk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tmax;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_da_split(state->args);\n\n\t/*\n\t * Walk back up the tree splitting/inserting/adjusting as necessary.\n\t * If we need to insert and there isn't room, split the node, then\n\t * decide which fragment to insert the new block from below into.\n\t * Note that we may split the root this way, but we need more fixup.\n\t */\n\tmax = state->path.active - 1;\n\tASSERT((max >= 0) && (max < XFS_DA_NODE_MAXDEPTH));\n\tASSERT(state->path.blk[max].magic == XFS_ATTR_LEAF_MAGIC ||\n\t       state->path.blk[max].magic == XFS_DIR2_LEAFN_MAGIC);\n\n\taddblk = &state->path.blk[max];\t\t/* initial dummy value */\n\tfor (i = max; (i >= 0) && addblk; state->path.active--, i--) {\n\t\toldblk = &state->path.blk[i];\n\t\tnewblk = &state->altpath.blk[i];\n\n\t\t/*\n\t\t * If a leaf node then\n\t\t *     Allocate a new leaf node, then rebalance across them.\n\t\t * else if an intermediate node then\n\t\t *     We split on the last layer, must we split the node?\n\t\t */\n\t\tswitch (oldblk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_split(state, oldblk, newblk);\n\t\t\tif ((error != 0) && (error != -ENOSPC)) {\n\t\t\t\treturn error;\t/* GROT: attr is inconsistent */\n\t\t\t}\n\t\t\tif (!error) {\n\t\t\t\taddblk = newblk;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Entry wouldn't fit, split the leaf again.\n\t\t\t */\n\t\t\tstate->extravalid = 1;\n\t\t\tif (state->inleaf) {\n\t\t\t\tstate->extraafter = 0;\t/* before newblk */\n\t\t\t\ttrace_xfs_attr_leaf_split_before(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, oldblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t} else {\n\t\t\t\tstate->extraafter = 1;\t/* after newblk */\n\t\t\t\ttrace_xfs_attr_leaf_split_after(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, newblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn error;\t/* GROT: attr inconsistent */\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_split(state, oldblk, newblk);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\terror = xfs_da3_node_split(state, oldblk, newblk, addblk,\n\t\t\t\t\t\t\t max - i, &action);\n\t\t\taddblk->bp = NULL;\n\t\t\tif (error)\n\t\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\t\t\t/*\n\t\t\t * Record the newly split block for the next time thru?\n\t\t\t */\n\t\t\tif (action)\n\t\t\t\taddblk = newblk;\n\t\t\telse\n\t\t\t\taddblk = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Update the btree to show the new hashval for this child.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\tif (!addblk)\n\t\treturn 0;\n\n\t/*\n\t * Split the root node.\n\t */\n\tASSERT(state->path.active == 0);\n\toldblk = &state->path.blk[0];\n\terror = xfs_da3_root_split(state, oldblk, addblk);\n\tif (error) {\n\t\taddblk->bp = NULL;\n\t\treturn error;\t/* GROT: dir is inconsistent */\n\t}\n\n\t/*\n\t * Update pointers to the node which used to be block 0 and\n\t * just got bumped because of the addition of a new root node.\n\t * There might be three blocks involved if a double split occurred,\n\t * and the original block 0 could be at any position in the list.\n\t *\n\t * Note: the magic numbers and sibling pointers are in the same\n\t * physical place for both v2 and v3 headers (by design). Hence it\n\t * doesn't matter which version of the xfs_da_intnode structure we use\n\t * here as the result will be the same using either structure.\n\t */\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.forw) {\n\t\tif (be32_to_cpu(node->hdr.info.forw) == addblk->blkno) {\n\t\t\tbp = addblk->bp;\n\t\t} else {\n\t\t\tASSERT(state->extravalid);\n\t\t\tbp = state->extrablk.bp;\n\t\t}\n\t\tnode = bp->b_addr;\n\t\tnode->hdr.info.back = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info)));\n\t}\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.back) {\n\t\tif (be32_to_cpu(node->hdr.info.back) == addblk->blkno) {\n\t\t\tbp = addblk->bp;\n\t\t} else {\n\t\t\tASSERT(state->extravalid);\n\t\t\tbp = state->extrablk.bp;\n\t\t}\n\t\tnode = bp->b_addr;\n\t\tnode->hdr.info.forw = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info)));\n\t}\n\taddblk->bp = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_split(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*oldblk;\n\tstruct xfs_da_state_blk\t*newblk;\n\tstruct xfs_da_state_blk\t*addblk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tmax;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_da_split(state->args);\n\n\t/*\n\t * Walk back up the tree splitting/inserting/adjusting as necessary.\n\t * If we need to insert and there isn't room, split the node, then\n\t * decide which fragment to insert the new block from below into.\n\t * Note that we may split the root this way, but we need more fixup.\n\t */\n\tmax = state->path.active - 1;\n\tASSERT((max >= 0) && (max < XFS_DA_NODE_MAXDEPTH));\n\tASSERT(state->path.blk[max].magic == XFS_ATTR_LEAF_MAGIC ||\n\t       state->path.blk[max].magic == XFS_DIR2_LEAFN_MAGIC);\n\n\taddblk = &state->path.blk[max];\t\t/* initial dummy value */\n\tfor (i = max; (i >= 0) && addblk; state->path.active--, i--) {\n\t\toldblk = &state->path.blk[i];\n\t\tnewblk = &state->altpath.blk[i];\n\n\t\t/*\n\t\t * If a leaf node then\n\t\t *     Allocate a new leaf node, then rebalance across them.\n\t\t * else if an intermediate node then\n\t\t *     We split on the last layer, must we split the node?\n\t\t */\n\t\tswitch (oldblk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_split(state, oldblk, newblk);\n\t\t\tif ((error != 0) && (error != -ENOSPC)) {\n\t\t\t\treturn error;\t/* GROT: attr is inconsistent */\n\t\t\t}\n\t\t\tif (!error) {\n\t\t\t\taddblk = newblk;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Entry wouldn't fit, split the leaf again.\n\t\t\t */\n\t\t\tstate->extravalid = 1;\n\t\t\tif (state->inleaf) {\n\t\t\t\tstate->extraafter = 0;\t/* before newblk */\n\t\t\t\ttrace_xfs_attr_leaf_split_before(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, oldblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t} else {\n\t\t\t\tstate->extraafter = 1;\t/* after newblk */\n\t\t\t\ttrace_xfs_attr_leaf_split_after(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, newblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn error;\t/* GROT: attr inconsistent */\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_split(state, oldblk, newblk);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\terror = xfs_da3_node_split(state, oldblk, newblk, addblk,\n\t\t\t\t\t\t\t max - i, &action);\n\t\t\taddblk->bp = NULL;\n\t\t\tif (error)\n\t\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\t\t\t/*\n\t\t\t * Record the newly split block for the next time thru?\n\t\t\t */\n\t\t\tif (action)\n\t\t\t\taddblk = newblk;\n\t\t\telse\n\t\t\t\taddblk = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Update the btree to show the new hashval for this child.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\tif (!addblk)\n\t\treturn 0;\n\n\t/*\n\t * Split the root node.\n\t */\n\tASSERT(state->path.active == 0);\n\toldblk = &state->path.blk[0];\n\terror = xfs_da3_root_split(state, oldblk, addblk);\n\tif (error) {\n\t\taddblk->bp = NULL;\n\t\treturn error;\t/* GROT: dir is inconsistent */\n\t}\n\n\t/*\n\t * Update pointers to the node which used to be block 0 and\n\t * just got bumped because of the addition of a new root node.\n\t * There might be three blocks involved if a double split occurred,\n\t * and the original block 0 could be at any position in the list.\n\t *\n\t * Note: the magic numbers and sibling pointers are in the same\n\t * physical place for both v2 and v3 headers (by design). Hence it\n\t * doesn't matter which version of the xfs_da_intnode structure we use\n\t * here as the result will be the same using either structure.\n\t */\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.forw) {\n\t\tif (be32_to_cpu(node->hdr.info.forw) == addblk->blkno) {\n\t\t\tbp = addblk->bp;\n\t\t} else {\n\t\t\tASSERT(state->extravalid);\n\t\t\tbp = state->extrablk.bp;\n\t\t}\n\t\tnode = bp->b_addr;\n\t\tnode->hdr.info.back = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info)));\n\t}\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.back) {\n\t\tif (be32_to_cpu(node->hdr.info.back) == addblk->blkno) {\n\t\t\tbp = addblk->bp;\n\t\t} else {\n\t\t\tASSERT(state->extravalid);\n\t\t\tbp = state->extrablk.bp;\n\t\t}\n\t\tnode = bp->b_addr;\n\t\tnode->hdr.info.forw = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info)));\n\t}\n\taddblk->bp = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "committed"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_to_node",
          "args": [
            "args"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_to_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "875-938",
          "snippet": "int\nxfs_attr3_leaf_to_node(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr icleafhdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr icnodehdr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp1 = NULL;\n\tstruct xfs_buf\t\t*bp2 = NULL;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_to_node(args);\n\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\tgoto out;\n\terror = xfs_attr3_leaf_read(args->trans, dp, 0, -1, &bp1);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_da_get_buf(args->trans, dp, blkno, -1, &bp2, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\n\t/* copy leaf to new buffer, update identifiers */\n\txfs_trans_buf_set_type(args->trans, bp2, XFS_BLFT_ATTR_LEAF_BUF);\n\tbp2->b_ops = bp1->b_ops;\n\tmemcpy(bp2->b_addr, bp1->b_addr, args->geo->blksize);\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp2->b_addr;\n\t\thdr3->blkno = cpu_to_be64(bp2->b_bn);\n\t}\n\txfs_trans_log_buf(args->trans, bp2, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Set up the new root node.\n\t */\n\terror = xfs_da3_node_create(args, 0, 1, &bp1, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\tnode = bp1->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&icnodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\n\tleaf = bp2->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&icleafhdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\t/* both on-disk, don't endian-flip twice */\n\tbtree[0].hashval = entries[icleafhdr.count - 1].hashval;\n\tbtree[0].before = cpu_to_be32(blkno);\n\ticnodehdr.count = 1;\n\tdp->d_ops->node_hdr_to_disk(node, &icnodehdr);\n\txfs_trans_log_buf(args->trans, bp1, 0, args->geo->blksize - 1);\n\terror = 0;\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_leaf_to_node(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr icleafhdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr icnodehdr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp1 = NULL;\n\tstruct xfs_buf\t\t*bp2 = NULL;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_to_node(args);\n\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\tgoto out;\n\terror = xfs_attr3_leaf_read(args->trans, dp, 0, -1, &bp1);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_da_get_buf(args->trans, dp, blkno, -1, &bp2, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\n\t/* copy leaf to new buffer, update identifiers */\n\txfs_trans_buf_set_type(args->trans, bp2, XFS_BLFT_ATTR_LEAF_BUF);\n\tbp2->b_ops = bp1->b_ops;\n\tmemcpy(bp2->b_addr, bp1->b_addr, args->geo->blksize);\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp2->b_addr;\n\t\thdr3->blkno = cpu_to_be64(bp2->b_bn);\n\t}\n\txfs_trans_log_buf(args->trans, bp2, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Set up the new root node.\n\t */\n\terror = xfs_da3_node_create(args, 0, 1, &bp1, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\tnode = bp1->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&icnodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\n\tleaf = bp2->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&icleafhdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\t/* both on-disk, don't endian-flip twice */\n\tbtree[0].hashval = entries[icleafhdr.count - 1].hashval;\n\tbtree[0].before = cpu_to_be32(blkno);\n\ticnodehdr.count = 1;\n\tdp->d_ops->node_hdr_to_disk(node, &icnodehdr);\n\txfs_trans_log_buf(args->trans, bp1, 0, args->geo->blksize - 1);\n\terror = 0;\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_add",
          "args": [
            "blk->bp",
            "state->args"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1060-1134",
          "snippet": "int\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t/*\n\t * Search through freemap for first-fit on new name length.\n\t * (may need to figure in size of entry struct too)\n\t */\n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t/* no space in this map */\n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t/*\n\t * If there are no holes in the address space of the block,\n\t * and we don't have enough freespace, then compaction will do us\n\t * no good and we should just give up.\n\t */\n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * Compact the entries to coalesce free space.\n\t * This may change the hdr->count via dropping INCOMPLETE entries.\n\t */\n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t/*\n\t * After compaction, the block is guaranteed to have only one\n\t * free region, in freemap[0].  If it is not big enough, give up.\n\t */\n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t/*\n\t * Search through freemap for first-fit on new name length.\n\t * (may need to figure in size of entry struct too)\n\t */\n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t/* no space in this map */\n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t/*\n\t * If there are no holes in the address space of the block,\n\t * and we don't have enough freespace, then compaction will do us\n\t * no good and we should just give up.\n\t */\n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * Compact the entries to coalesce free space.\n\t * This may change the hdr->count via dropping INCOMPLETE entries.\n\t */\n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t/*\n\t * After compaction, the block is guaranteed to have only one\n\t * free region, in freemap[0].  If it is not big enough, give up.\n\t */\n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_node_replace",
          "args": [
            "args"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk->magic == XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_node_addname",
          "args": [
            "args"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_node_addname(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\txfs_mount_t *mp;\n\tint committed, retval, error;\n\n\ttrace_xfs_attr_node_addname(args);\n\n\t/*\n\t * Fill in bucket of arguments/results/context to carry around.\n\t */\n\tdp = args->dp;\n\tmp = dp->i_mount;\nrestart:\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = mp;\n\n\t/*\n\t * Search to see if name already exists, and get back a pointer\n\t * to where it should go.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error)\n\t\tgoto out;\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\tgoto out;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\tgoto out;\n\n\t\ttrace_xfs_attr_node_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* atomic rename op */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\tretval = xfs_attr3_leaf_add(blk->bp, state->args);\n\tif (retval == -ENOSPC) {\n\t\tif (state->path.active == 1) {\n\t\t\t/*\n\t\t\t * Its really a single leaf node, but it had\n\t\t\t * out-of-line values so it looked like it *might*\n\t\t\t * have been a b-tree.\n\t\t\t */\n\t\t\txfs_da_state_free(state);\n\t\t\tstate = NULL;\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_node(args);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t\t/*\n\t\t\t * Commit the node conversion and start the next\n\t\t\t * trans in the chain.\n\t\t\t */\n\t\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/*\n\t\t * Split as many Btree elements as required.\n\t\t * This code tracks the new and old attr's location\n\t\t * in the index/blkno/rmtblkno/rmtblkcnt fields and\n\t\t * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_da3_split(state);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t} else {\n\t\t/*\n\t\t * Addition succeeded, update Btree hashvals.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\n\t/*\n\t * Kill the state structure, we're done with it and need to\n\t * allow the buffers to come back later.\n\t */\n\txfs_da_state_free(state);\n\tstate = NULL;\n\n\t/*\n\t * Commit the leaf addition or btree split and start the next\n\t * trans in the chain.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Re-find the \"old\" attribute entry after any split ops.\n\t\t * The INCOMPLETE flag means that we will find the \"old\"\n\t\t * attr, not the \"new\" one.\n\t\t */\n\t\targs->flags |= XFS_ATTR_INCOMPLETE;\n\t\tstate = xfs_da_state_alloc();\n\t\tstate->args = args;\n\t\tstate->mp = mp;\n\t\tstate->inleaf = 0;\n\t\terror = xfs_da3_node_lookup_int(state, &retval);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Remove the name and update the hashvals in the tree.\n\t\t */\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\t\terror = xfs_attr3_leaf_remove(blk->bp, args);\n\t\txfs_da3_fixhashpath(state, &state->path);\n\n\t\t/*\n\t\t * Check to see if the tree needs to be collapsed.\n\t\t */\n\t\tif (retval && (state->path.active > 1)) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_da3_join(state);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit and start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tretval = error = 0;\n\nout:\n\tif (state)\n\t\txfs_da_state_free(state);\n\tif (error)\n\t\treturn error;\n\treturn retval;\n}"
  },
  {
    "function_name": "xfs_attr_leaf_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "836-860",
    "snippet": "STATIC int\nxfs_attr_leaf_get(xfs_da_args_t *args)\n{\n\tstruct xfs_buf *bp;\n\tint error;\n\n\ttrace_xfs_attr_leaf_get(args);\n\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tif (error != -EEXIST)  {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t}\n\terror = xfs_attr3_leaf_getvalue(bp, args);\n\txfs_trans_brelse(args->trans, bp);\n\tif (!error && (args->rmtblkno > 0) && !(args->flags & ATTR_KERNOVAL)) {\n\t\terror = xfs_attr_rmtval_get(args);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_rmtval_get",
          "args": [
            "args"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_rmtval_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "331-390",
          "snippet": "int\nxfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_get(args);\n\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\tASSERT(args->rmtvaluelen == args->valuelen);\n\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/* roll attribute extent map forwards */\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define ATTR_RMTVALUE_MAPSIZE\t1\t/* # of map entries at once */"
          ],
          "globals_used": [
            "const struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define ATTR_RMTVALUE_MAPSIZE\t1\t/* # of map entries at once */\n\nconst struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};\n\nint\nxfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_get(args);\n\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\tASSERT(args->rmtvaluelen == args->valuelen);\n\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/* roll attribute extent map forwards */\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "args->trans",
            "bp"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_getvalue",
          "args": [
            "bp",
            "args"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_getvalue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "2180-2232",
          "snippet": "int\nxfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index < ichdr.count);\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       args->rmtvaluelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < args->rmtvaluelen) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = args->rmtvaluelen;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index < ichdr.count);\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       args->rmtvaluelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < args->rmtvaluelen) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = args->rmtvaluelen;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_lookup_int",
          "args": [
            "bp",
            "args"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "2070-2174",
          "snippet": "int\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_read",
          "args": [
            "args->trans",
            "args->dp",
            "args->blkno",
            "-1",
            "&bp"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "256-271",
          "snippet": "int\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
            "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_get",
          "args": [
            "args"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nSTATIC int\nxfs_attr_leaf_get(xfs_da_args_t *args)\n{\n\tstruct xfs_buf *bp;\n\tint error;\n\n\ttrace_xfs_attr_leaf_get(args);\n\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tif (error != -EEXIST)  {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t}\n\terror = xfs_attr3_leaf_getvalue(bp, args);\n\txfs_trans_brelse(args->trans, bp);\n\tif (!error && (args->rmtblkno > 0) && !(args->flags & ATTR_KERNOVAL)) {\n\t\terror = xfs_attr_rmtval_get(args);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr_leaf_removename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "776-828",
    "snippet": "STATIC int\nxfs_attr_leaf_removename(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint error, committed, forkoff;\n\n\ttrace_xfs_attr_leaf_removename(args);\n\n\t/*\n\t * Remove the attribute.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tif (error == -ENOATTR) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t}\n\n\txfs_attr3_leaf_remove(bp, args);\n\n\t/*\n\t * If the result is small enough, shrink it all into the inode.\n\t */\n\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "args->trans",
            "dp",
            "0"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "args->flist"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "committed"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&args->trans",
            "args->flist",
            "&committed"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_to_shortform",
          "args": [
            "bp",
            "args",
            "forkoff"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_to_shortform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "790-870",
          "snippet": "int\nxfs_attr3_leaf_to_shortform(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tforkoff)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_da_args\tnargs;\n\tstruct xfs_inode\t*dp = args->dp;\n\tchar\t\t\t*tmpbuffer;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_to_sf(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tif (!tmpbuffer)\n\t\treturn -ENOMEM;\n\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\n\tleaf = (xfs_attr_leafblock_t *)tmpbuffer;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\t/* XXX (dgc): buffer is about to be marked stale - why zero it? */\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\n\t/*\n\t * Clean out the prior contents of the attribute list.\n\t */\n\terror = xfs_da_shrink_inode(args, 0, bp);\n\tif (error)\n\t\tgoto out;\n\n\tif (forkoff == -1) {\n\t\tASSERT(dp->i_mount->m_flags & XFS_MOUNT_ATTR2);\n\t\tASSERT(dp->i_d.di_format != XFS_DINODE_FMT_BTREE);\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t\tgoto out;\n\t}\n\n\txfs_attr_shortform_create(args);\n\n\t/*\n\t * Copy the attributes\n\t */\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.geo = args->geo;\n\tnargs.dp = dp;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t/* don't copy partial entries */\n\t\tif (!entry->nameidx)\n\t\t\tcontinue;\n\t\tASSERT(entry->flags & XFS_ATTR_LOCAL);\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tnargs.name = name_loc->nameval;\n\t\tnargs.namelen = name_loc->namelen;\n\t\tnargs.value = &name_loc->nameval[nargs.namelen];\n\t\tnargs.valuelen = be16_to_cpu(name_loc->valuelen);\n\t\tnargs.hashval = be32_to_cpu(entry->hashval);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(entry->flags);\n\t\txfs_attr_shortform_add(&nargs, forkoff);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_leaf_to_shortform(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tforkoff)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_da_args\tnargs;\n\tstruct xfs_inode\t*dp = args->dp;\n\tchar\t\t\t*tmpbuffer;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_to_sf(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tif (!tmpbuffer)\n\t\treturn -ENOMEM;\n\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\n\tleaf = (xfs_attr_leafblock_t *)tmpbuffer;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\t/* XXX (dgc): buffer is about to be marked stale - why zero it? */\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\n\t/*\n\t * Clean out the prior contents of the attribute list.\n\t */\n\terror = xfs_da_shrink_inode(args, 0, bp);\n\tif (error)\n\t\tgoto out;\n\n\tif (forkoff == -1) {\n\t\tASSERT(dp->i_mount->m_flags & XFS_MOUNT_ATTR2);\n\t\tASSERT(dp->i_d.di_format != XFS_DINODE_FMT_BTREE);\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t\tgoto out;\n\t}\n\n\txfs_attr_shortform_create(args);\n\n\t/*\n\t * Copy the attributes\n\t */\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.geo = args->geo;\n\tnargs.dp = dp;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t/* don't copy partial entries */\n\t\tif (!entry->nameidx)\n\t\t\tcontinue;\n\t\tASSERT(entry->flags & XFS_ATTR_LOCAL);\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tnargs.name = name_loc->nameval;\n\t\tnargs.namelen = name_loc->namelen;\n\t\tnargs.value = &name_loc->nameval[nargs.namelen];\n\t\tnargs.valuelen = be16_to_cpu(name_loc->valuelen);\n\t\tnargs.hashval = be32_to_cpu(entry->hashval);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(entry->flags);\n\t\txfs_attr_shortform_add(&nargs, forkoff);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "args->flist",
            "args->firstblock"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_allfit",
          "args": [
            "bp",
            "dp"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_allfit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "749-785",
          "snippet": "int\nxfs_attr_shortform_allfit(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tint\t\t\tbytes;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\tbytes = sizeof(struct xfs_attr_sf_hdr);\n\tfor (i = 0; i < leafhdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* don't copy partial entries */\n\t\tif (!(entry->flags & XFS_ATTR_LOCAL))\n\t\t\treturn 0;\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tif (name_loc->namelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tif (be16_to_cpu(name_loc->valuelen) >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tbytes += sizeof(struct xfs_attr_sf_entry) - 1\n\t\t\t\t+ name_loc->namelen\n\t\t\t\t+ be16_to_cpu(name_loc->valuelen);\n\t}\n\tif ((dp->i_mount->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    (bytes == sizeof(struct xfs_attr_sf_hdr)))\n\t\treturn -1;\n\treturn xfs_attr_shortform_bytesfit(dp, bytes);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_allfit(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tint\t\t\tbytes;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\tbytes = sizeof(struct xfs_attr_sf_hdr);\n\tfor (i = 0; i < leafhdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* don't copy partial entries */\n\t\tif (!(entry->flags & XFS_ATTR_LOCAL))\n\t\t\treturn 0;\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tif (name_loc->namelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tif (be16_to_cpu(name_loc->valuelen) >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tbytes += sizeof(struct xfs_attr_sf_entry) - 1\n\t\t\t\t+ name_loc->namelen\n\t\t\t\t+ be16_to_cpu(name_loc->valuelen);\n\t}\n\tif ((dp->i_mount->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    (bytes == sizeof(struct xfs_attr_sf_hdr)))\n\t\treturn -1;\n\treturn xfs_attr_shortform_bytesfit(dp, bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_remove",
          "args": [
            "bp",
            "args"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1789-1939",
          "snippet": "int\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t/*\n\t * Scan through free region table:\n\t *    check for adjacency of free'd entry with an existing one,\n\t *    find smallest free region in case we need to replace it,\n\t *    adjust any map that borders the entry table,\n\t */\n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t/*\n\t * Coalesce adjacent freemap regions,\n\t * or replace the smallest region.\n\t */\n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Replace smallest region (if it is smaller than free'd entry)\n\t\t */\n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t/*\n\t * Did we remove the first entry?\n\t */\n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t/*\n\t * Compress the remaining entries and zero out the removed stuff.\n\t */\n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t/*\n\t * If we removed the first entry, re-find the first used byte\n\t * in the name area.  Note that if the entry was the \"firstused\",\n\t * then we don't have a \"hole\" in our block resulting from\n\t * removing the name.\n\t */\n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tif (!ichdr.firstused)\n\t\t\tichdr.firstused = tmp - XFS_ATTR_LEAF_NAME_ALIGN;\n\t} else {\n\t\tichdr.holes = 1;\t/* mark as needing compaction */\n\t}\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t/*\n\t * Check if leaf is less than 50% full, caller may want to\n\t * \"join\" the leaf with a sibling if so.\n\t */\n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct; /* leaf is < 37% full */\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t/*\n\t * Scan through free region table:\n\t *    check for adjacency of free'd entry with an existing one,\n\t *    find smallest free region in case we need to replace it,\n\t *    adjust any map that borders the entry table,\n\t */\n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t/*\n\t * Coalesce adjacent freemap regions,\n\t * or replace the smallest region.\n\t */\n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Replace smallest region (if it is smaller than free'd entry)\n\t\t */\n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t/*\n\t * Did we remove the first entry?\n\t */\n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t/*\n\t * Compress the remaining entries and zero out the removed stuff.\n\t */\n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t/*\n\t * If we removed the first entry, re-find the first used byte\n\t * in the name area.  Note that if the entry was the \"firstused\",\n\t * then we don't have a \"hole\" in our block resulting from\n\t * removing the name.\n\t */\n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tif (!ichdr.firstused)\n\t\t\tichdr.firstused = tmp - XFS_ATTR_LEAF_NAME_ALIGN;\n\t} else {\n\t\tichdr.holes = 1;\t/* mark as needing compaction */\n\t}\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t/*\n\t * Check if leaf is less than 50% full, caller may want to\n\t * \"join\" the leaf with a sibling if so.\n\t */\n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct; /* leaf is < 37% full */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "args->trans",
            "bp"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_lookup_int",
          "args": [
            "bp",
            "args"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "2070-2174",
          "snippet": "int\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_read",
          "args": [
            "args->trans",
            "args->dp",
            "args->blkno",
            "-1",
            "&bp"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "256-271",
          "snippet": "int\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
            "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_removename",
          "args": [
            "args"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nSTATIC int\nxfs_attr_leaf_removename(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint error, committed, forkoff;\n\n\ttrace_xfs_attr_leaf_removename(args);\n\n\t/*\n\t * Remove the attribute.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tif (error == -ENOATTR) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t}\n\n\txfs_attr3_leaf_remove(bp, args);\n\n\t/*\n\t * If the result is small enough, shrink it all into the inode.\n\t */\n\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr_leaf_addname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "569-768",
    "snippet": "STATIC int\nxfs_attr_leaf_addname(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, committed, forkoff;\n\n\ttrace_xfs_attr_leaf_addname(args);\n\n\t/*\n\t * Read the (only) block in the attribute list in.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the given attribute in the leaf block.  Figure out if\n\t * the given flags produce an error or call for an atomic rename.\n\t */\n\tretval = xfs_attr3_leaf_lookup_int(bp, args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE) {\t/* pure create op */\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t\t\treturn retval;\n\t\t}\n\n\t\ttrace_xfs_attr_leaf_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* an atomic rename */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\t/*\n\t * Add the attribute to the leaf block, transitioning to a Btree\n\t * if required.\n\t */\n\tretval = xfs_attr3_leaf_add(bp, args);\n\tif (retval == -ENOSPC) {\n\t\t/*\n\t\t * Promote the attribute list to the Btree format, then\n\t\t * Commit that transaction so that the node_addname() call\n\t\t * can manage its own transactions.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_node(args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the current trans (including the inode) and start\n\t\t * a new one.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Fob the whole rest of the problem off on the Btree code.\n\t\t */\n\t\terror = xfs_attr_node_addname(args);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Commit the transaction that added the attr name so that\n\t * later routines can manage their own transactions.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Read in the block containing the \"old\" attr, then\n\t\t * remove the \"old\" attr from that block (neat, huh!)\n\t\t */\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,\n\t\t\t\t\t   -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_remove(bp, args);\n\n\t\t/*\n\t\t * If the result is small enough, shrink it all into the inode.\n\t\t */\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit the remove and start the next trans in series.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
      "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_clearflag",
          "args": [
            "args"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_roll",
          "args": [
            "&args->trans",
            "dp"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_roll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "995-1055",
          "snippet": "int\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "args->trans",
            "dp",
            "0"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "args->flist"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "committed"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&args->trans",
            "args->flist",
            "&committed"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_to_shortform",
          "args": [
            "bp",
            "args",
            "forkoff"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_to_shortform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "790-870",
          "snippet": "int\nxfs_attr3_leaf_to_shortform(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tforkoff)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_da_args\tnargs;\n\tstruct xfs_inode\t*dp = args->dp;\n\tchar\t\t\t*tmpbuffer;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_to_sf(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tif (!tmpbuffer)\n\t\treturn -ENOMEM;\n\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\n\tleaf = (xfs_attr_leafblock_t *)tmpbuffer;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\t/* XXX (dgc): buffer is about to be marked stale - why zero it? */\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\n\t/*\n\t * Clean out the prior contents of the attribute list.\n\t */\n\terror = xfs_da_shrink_inode(args, 0, bp);\n\tif (error)\n\t\tgoto out;\n\n\tif (forkoff == -1) {\n\t\tASSERT(dp->i_mount->m_flags & XFS_MOUNT_ATTR2);\n\t\tASSERT(dp->i_d.di_format != XFS_DINODE_FMT_BTREE);\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t\tgoto out;\n\t}\n\n\txfs_attr_shortform_create(args);\n\n\t/*\n\t * Copy the attributes\n\t */\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.geo = args->geo;\n\tnargs.dp = dp;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t/* don't copy partial entries */\n\t\tif (!entry->nameidx)\n\t\t\tcontinue;\n\t\tASSERT(entry->flags & XFS_ATTR_LOCAL);\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tnargs.name = name_loc->nameval;\n\t\tnargs.namelen = name_loc->namelen;\n\t\tnargs.value = &name_loc->nameval[nargs.namelen];\n\t\tnargs.valuelen = be16_to_cpu(name_loc->valuelen);\n\t\tnargs.hashval = be32_to_cpu(entry->hashval);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(entry->flags);\n\t\txfs_attr_shortform_add(&nargs, forkoff);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_leaf_to_shortform(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tforkoff)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_da_args\tnargs;\n\tstruct xfs_inode\t*dp = args->dp;\n\tchar\t\t\t*tmpbuffer;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_to_sf(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tif (!tmpbuffer)\n\t\treturn -ENOMEM;\n\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\n\tleaf = (xfs_attr_leafblock_t *)tmpbuffer;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\t/* XXX (dgc): buffer is about to be marked stale - why zero it? */\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\n\t/*\n\t * Clean out the prior contents of the attribute list.\n\t */\n\terror = xfs_da_shrink_inode(args, 0, bp);\n\tif (error)\n\t\tgoto out;\n\n\tif (forkoff == -1) {\n\t\tASSERT(dp->i_mount->m_flags & XFS_MOUNT_ATTR2);\n\t\tASSERT(dp->i_d.di_format != XFS_DINODE_FMT_BTREE);\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t\tgoto out;\n\t}\n\n\txfs_attr_shortform_create(args);\n\n\t/*\n\t * Copy the attributes\n\t */\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.geo = args->geo;\n\tnargs.dp = dp;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t/* don't copy partial entries */\n\t\tif (!entry->nameidx)\n\t\t\tcontinue;\n\t\tASSERT(entry->flags & XFS_ATTR_LOCAL);\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tnargs.name = name_loc->nameval;\n\t\tnargs.namelen = name_loc->namelen;\n\t\tnargs.value = &name_loc->nameval[nargs.namelen];\n\t\tnargs.valuelen = be16_to_cpu(name_loc->valuelen);\n\t\tnargs.hashval = be32_to_cpu(entry->hashval);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(entry->flags);\n\t\txfs_attr_shortform_add(&nargs, forkoff);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "args->flist",
            "args->firstblock"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_allfit",
          "args": [
            "bp",
            "dp"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_allfit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "749-785",
          "snippet": "int\nxfs_attr_shortform_allfit(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tint\t\t\tbytes;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\tbytes = sizeof(struct xfs_attr_sf_hdr);\n\tfor (i = 0; i < leafhdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* don't copy partial entries */\n\t\tif (!(entry->flags & XFS_ATTR_LOCAL))\n\t\t\treturn 0;\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tif (name_loc->namelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tif (be16_to_cpu(name_loc->valuelen) >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tbytes += sizeof(struct xfs_attr_sf_entry) - 1\n\t\t\t\t+ name_loc->namelen\n\t\t\t\t+ be16_to_cpu(name_loc->valuelen);\n\t}\n\tif ((dp->i_mount->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    (bytes == sizeof(struct xfs_attr_sf_hdr)))\n\t\treturn -1;\n\treturn xfs_attr_shortform_bytesfit(dp, bytes);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_allfit(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tint\t\t\tbytes;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\tbytes = sizeof(struct xfs_attr_sf_hdr);\n\tfor (i = 0; i < leafhdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* don't copy partial entries */\n\t\tif (!(entry->flags & XFS_ATTR_LOCAL))\n\t\t\treturn 0;\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tif (name_loc->namelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tif (be16_to_cpu(name_loc->valuelen) >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tbytes += sizeof(struct xfs_attr_sf_entry) - 1\n\t\t\t\t+ name_loc->namelen\n\t\t\t\t+ be16_to_cpu(name_loc->valuelen);\n\t}\n\tif ((dp->i_mount->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    (bytes == sizeof(struct xfs_attr_sf_hdr)))\n\t\treturn -1;\n\treturn xfs_attr_shortform_bytesfit(dp, bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_remove",
          "args": [
            "bp",
            "args"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1789-1939",
          "snippet": "int\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t/*\n\t * Scan through free region table:\n\t *    check for adjacency of free'd entry with an existing one,\n\t *    find smallest free region in case we need to replace it,\n\t *    adjust any map that borders the entry table,\n\t */\n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t/*\n\t * Coalesce adjacent freemap regions,\n\t * or replace the smallest region.\n\t */\n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Replace smallest region (if it is smaller than free'd entry)\n\t\t */\n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t/*\n\t * Did we remove the first entry?\n\t */\n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t/*\n\t * Compress the remaining entries and zero out the removed stuff.\n\t */\n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t/*\n\t * If we removed the first entry, re-find the first used byte\n\t * in the name area.  Note that if the entry was the \"firstused\",\n\t * then we don't have a \"hole\" in our block resulting from\n\t * removing the name.\n\t */\n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tif (!ichdr.firstused)\n\t\t\tichdr.firstused = tmp - XFS_ATTR_LEAF_NAME_ALIGN;\n\t} else {\n\t\tichdr.holes = 1;\t/* mark as needing compaction */\n\t}\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t/*\n\t * Check if leaf is less than 50% full, caller may want to\n\t * \"join\" the leaf with a sibling if so.\n\t */\n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct; /* leaf is < 37% full */\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t/*\n\t * Scan through free region table:\n\t *    check for adjacency of free'd entry with an existing one,\n\t *    find smallest free region in case we need to replace it,\n\t *    adjust any map that borders the entry table,\n\t */\n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t/*\n\t * Coalesce adjacent freemap regions,\n\t * or replace the smallest region.\n\t */\n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Replace smallest region (if it is smaller than free'd entry)\n\t\t */\n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t/*\n\t * Did we remove the first entry?\n\t */\n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t/*\n\t * Compress the remaining entries and zero out the removed stuff.\n\t */\n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t/*\n\t * If we removed the first entry, re-find the first used byte\n\t * in the name area.  Note that if the entry was the \"firstused\",\n\t * then we don't have a \"hole\" in our block resulting from\n\t * removing the name.\n\t */\n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tif (!ichdr.firstused)\n\t\t\tichdr.firstused = tmp - XFS_ATTR_LEAF_NAME_ALIGN;\n\t} else {\n\t\tichdr.holes = 1;\t/* mark as needing compaction */\n\t}\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t/*\n\t * Check if leaf is less than 50% full, caller may want to\n\t * \"join\" the leaf with a sibling if so.\n\t */\n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct; /* leaf is < 37% full */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_read",
          "args": [
            "args->trans",
            "args->dp",
            "args->blkno",
            "-1",
            "&bp"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "256-271",
          "snippet": "int\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);",
            "const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_rmtval_remove",
          "args": [
            "args"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_rmtval_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "533-626",
          "snippet": "int\nxfs_attr_rmtval_remove(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\txfs_dablk_t\t\tlblkno;\n\tint\t\t\tblkcnt;\n\tint\t\t\terror;\n\tint\t\t\tdone;\n\n\ttrace_xfs_attr_rmtval_remove(args);\n\n\t/*\n\t * Roll through the \"value\", invalidating the attribute value's blocks.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\twhile (blkcnt > 0) {\n\t\tstruct xfs_bmbt_irec\tmap;\n\t\tstruct xfs_buf\t\t*bp;\n\t\txfs_daddr_t\t\tdblkno;\n\t\tint\t\t\tdblkcnt;\n\t\tint\t\t\tnmap;\n\n\t\t/*\n\t\t * Try to remember where we decided to put the value.\n\t\t */\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\t/*\n\t\t * If the \"remote\" value is in the cache, remove it.\n\t\t */\n\t\tbp = xfs_incore(mp->m_ddev_targp, dblkno, dblkcnt, XBF_TRYLOCK);\n\t\tif (bp) {\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t\tbp = NULL;\n\t\t}\n\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\n\t/*\n\t * Keep de-allocating extents until the remote-value region is gone.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tdone = 0;\n\twhile (!done) {\n\t\tint committed;\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,\n\t\t\t\t    XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t    1, args->firstblock, args->flist,\n\t\t\t\t    &done);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, args->dp, 0);\n\n\t\t/*\n\t\t * Close out trans and start the next one in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, args->dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_rmtval_remove(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\txfs_dablk_t\t\tlblkno;\n\tint\t\t\tblkcnt;\n\tint\t\t\terror;\n\tint\t\t\tdone;\n\n\ttrace_xfs_attr_rmtval_remove(args);\n\n\t/*\n\t * Roll through the \"value\", invalidating the attribute value's blocks.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\twhile (blkcnt > 0) {\n\t\tstruct xfs_bmbt_irec\tmap;\n\t\tstruct xfs_buf\t\t*bp;\n\t\txfs_daddr_t\t\tdblkno;\n\t\tint\t\t\tdblkcnt;\n\t\tint\t\t\tnmap;\n\n\t\t/*\n\t\t * Try to remember where we decided to put the value.\n\t\t */\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\t/*\n\t\t * If the \"remote\" value is in the cache, remove it.\n\t\t */\n\t\tbp = xfs_incore(mp->m_ddev_targp, dblkno, dblkcnt, XBF_TRYLOCK);\n\t\tif (bp) {\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t\tbp = NULL;\n\t\t}\n\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\n\t/*\n\t * Keep de-allocating extents until the remote-value region is gone.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tdone = 0;\n\twhile (!done) {\n\t\tint committed;\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,\n\t\t\t\t    XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t    1, args->firstblock, args->flist,\n\t\t\t\t    &done);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, args->dp, 0);\n\n\t\t/*\n\t\t * Close out trans and start the next one in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, args->dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_flipflags",
          "args": [
            "args"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_rmtval_set",
          "args": [
            "args"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_rmtval_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "396-527",
          "snippet": "int\nxfs_attr_rmtval_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\t__uint8_t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t */\n\twhile (blkcnt > 0) {\n\t\tint\tcommitted;\n\n\t\t/*\n\t\t * Allocate a single extent, up to the size of the value.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t  blkcnt,\n\t\t\t\t  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t  args->firstblock, args->total, &map, &nmap,\n\t\t\t\t  args->flist);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\n\t\t/*\n\t\t * Start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\tbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t/* GROT: NOTE: synchronous write */\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t/* roll attribute extent map forwards */\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};\n\nint\nxfs_attr_rmtval_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\t__uint8_t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t */\n\twhile (blkcnt > 0) {\n\t\tint\tcommitted;\n\n\t\t/*\n\t\t * Allocate a single extent, up to the size of the value.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t  blkcnt,\n\t\t\t\t  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t  args->firstblock, args->total, &map, &nmap,\n\t\t\t\t  args->flist);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\n\t\t/*\n\t\t * Start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\tbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t/* GROT: NOTE: synchronous write */\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t/* roll attribute extent map forwards */\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_node_addname",
          "args": [
            "args"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_node_addname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "876-1136",
          "snippet": "STATIC int\nxfs_attr_node_addname(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\txfs_mount_t *mp;\n\tint committed, retval, error;\n\n\ttrace_xfs_attr_node_addname(args);\n\n\t/*\n\t * Fill in bucket of arguments/results/context to carry around.\n\t */\n\tdp = args->dp;\n\tmp = dp->i_mount;\nrestart:\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = mp;\n\n\t/*\n\t * Search to see if name already exists, and get back a pointer\n\t * to where it should go.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error)\n\t\tgoto out;\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\tgoto out;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\tgoto out;\n\n\t\ttrace_xfs_attr_node_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* atomic rename op */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\tretval = xfs_attr3_leaf_add(blk->bp, state->args);\n\tif (retval == -ENOSPC) {\n\t\tif (state->path.active == 1) {\n\t\t\t/*\n\t\t\t * Its really a single leaf node, but it had\n\t\t\t * out-of-line values so it looked like it *might*\n\t\t\t * have been a b-tree.\n\t\t\t */\n\t\t\txfs_da_state_free(state);\n\t\t\tstate = NULL;\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_node(args);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t\t/*\n\t\t\t * Commit the node conversion and start the next\n\t\t\t * trans in the chain.\n\t\t\t */\n\t\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/*\n\t\t * Split as many Btree elements as required.\n\t\t * This code tracks the new and old attr's location\n\t\t * in the index/blkno/rmtblkno/rmtblkcnt fields and\n\t\t * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_da3_split(state);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t} else {\n\t\t/*\n\t\t * Addition succeeded, update Btree hashvals.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\n\t/*\n\t * Kill the state structure, we're done with it and need to\n\t * allow the buffers to come back later.\n\t */\n\txfs_da_state_free(state);\n\tstate = NULL;\n\n\t/*\n\t * Commit the leaf addition or btree split and start the next\n\t * trans in the chain.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Re-find the \"old\" attribute entry after any split ops.\n\t\t * The INCOMPLETE flag means that we will find the \"old\"\n\t\t * attr, not the \"new\" one.\n\t\t */\n\t\targs->flags |= XFS_ATTR_INCOMPLETE;\n\t\tstate = xfs_da_state_alloc();\n\t\tstate->args = args;\n\t\tstate->mp = mp;\n\t\tstate->inleaf = 0;\n\t\terror = xfs_da3_node_lookup_int(state, &retval);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Remove the name and update the hashvals in the tree.\n\t\t */\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\t\terror = xfs_attr3_leaf_remove(blk->bp, args);\n\t\txfs_da3_fixhashpath(state, &state->path);\n\n\t\t/*\n\t\t * Check to see if the tree needs to be collapsed.\n\t\t */\n\t\tif (retval && (state->path.active > 1)) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_da3_join(state);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit and start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tretval = error = 0;\n\nout:\n\tif (state)\n\t\txfs_da_state_free(state);\n\tif (error)\n\t\treturn error;\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
            "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_node_addname(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\txfs_mount_t *mp;\n\tint committed, retval, error;\n\n\ttrace_xfs_attr_node_addname(args);\n\n\t/*\n\t * Fill in bucket of arguments/results/context to carry around.\n\t */\n\tdp = args->dp;\n\tmp = dp->i_mount;\nrestart:\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = mp;\n\n\t/*\n\t * Search to see if name already exists, and get back a pointer\n\t * to where it should go.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error)\n\t\tgoto out;\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\tgoto out;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\tgoto out;\n\n\t\ttrace_xfs_attr_node_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* atomic rename op */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\tretval = xfs_attr3_leaf_add(blk->bp, state->args);\n\tif (retval == -ENOSPC) {\n\t\tif (state->path.active == 1) {\n\t\t\t/*\n\t\t\t * Its really a single leaf node, but it had\n\t\t\t * out-of-line values so it looked like it *might*\n\t\t\t * have been a b-tree.\n\t\t\t */\n\t\t\txfs_da_state_free(state);\n\t\t\tstate = NULL;\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_node(args);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t\t/*\n\t\t\t * Commit the node conversion and start the next\n\t\t\t * trans in the chain.\n\t\t\t */\n\t\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/*\n\t\t * Split as many Btree elements as required.\n\t\t * This code tracks the new and old attr's location\n\t\t * in the index/blkno/rmtblkno/rmtblkcnt fields and\n\t\t * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_da3_split(state);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t} else {\n\t\t/*\n\t\t * Addition succeeded, update Btree hashvals.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\n\t/*\n\t * Kill the state structure, we're done with it and need to\n\t * allow the buffers to come back later.\n\t */\n\txfs_da_state_free(state);\n\tstate = NULL;\n\n\t/*\n\t * Commit the leaf addition or btree split and start the next\n\t * trans in the chain.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Re-find the \"old\" attribute entry after any split ops.\n\t\t * The INCOMPLETE flag means that we will find the \"old\"\n\t\t * attr, not the \"new\" one.\n\t\t */\n\t\targs->flags |= XFS_ATTR_INCOMPLETE;\n\t\tstate = xfs_da_state_alloc();\n\t\tstate->args = args;\n\t\tstate->mp = mp;\n\t\tstate->inleaf = 0;\n\t\terror = xfs_da3_node_lookup_int(state, &retval);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Remove the name and update the hashvals in the tree.\n\t\t */\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\t\terror = xfs_attr3_leaf_remove(blk->bp, args);\n\t\txfs_da3_fixhashpath(state, &state->path);\n\n\t\t/*\n\t\t * Check to see if the tree needs to be collapsed.\n\t\t */\n\t\tif (retval && (state->path.active > 1)) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_da3_join(state);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit and start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tretval = error = 0;\n\nout:\n\tif (state)\n\t\txfs_da_state_free(state);\n\tif (error)\n\t\treturn error;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "committed"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_to_node",
          "args": [
            "args"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_to_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "875-938",
          "snippet": "int\nxfs_attr3_leaf_to_node(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr icleafhdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr icnodehdr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp1 = NULL;\n\tstruct xfs_buf\t\t*bp2 = NULL;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_to_node(args);\n\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\tgoto out;\n\terror = xfs_attr3_leaf_read(args->trans, dp, 0, -1, &bp1);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_da_get_buf(args->trans, dp, blkno, -1, &bp2, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\n\t/* copy leaf to new buffer, update identifiers */\n\txfs_trans_buf_set_type(args->trans, bp2, XFS_BLFT_ATTR_LEAF_BUF);\n\tbp2->b_ops = bp1->b_ops;\n\tmemcpy(bp2->b_addr, bp1->b_addr, args->geo->blksize);\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp2->b_addr;\n\t\thdr3->blkno = cpu_to_be64(bp2->b_bn);\n\t}\n\txfs_trans_log_buf(args->trans, bp2, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Set up the new root node.\n\t */\n\terror = xfs_da3_node_create(args, 0, 1, &bp1, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\tnode = bp1->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&icnodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\n\tleaf = bp2->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&icleafhdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\t/* both on-disk, don't endian-flip twice */\n\tbtree[0].hashval = entries[icleafhdr.count - 1].hashval;\n\tbtree[0].before = cpu_to_be32(blkno);\n\ticnodehdr.count = 1;\n\tdp->d_ops->node_hdr_to_disk(node, &icnodehdr);\n\txfs_trans_log_buf(args->trans, bp1, 0, args->geo->blksize - 1);\n\terror = 0;\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_leaf_to_node(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr icleafhdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr icnodehdr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp1 = NULL;\n\tstruct xfs_buf\t\t*bp2 = NULL;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_to_node(args);\n\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\tgoto out;\n\terror = xfs_attr3_leaf_read(args->trans, dp, 0, -1, &bp1);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_da_get_buf(args->trans, dp, blkno, -1, &bp2, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\n\t/* copy leaf to new buffer, update identifiers */\n\txfs_trans_buf_set_type(args->trans, bp2, XFS_BLFT_ATTR_LEAF_BUF);\n\tbp2->b_ops = bp1->b_ops;\n\tmemcpy(bp2->b_addr, bp1->b_addr, args->geo->blksize);\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp2->b_addr;\n\t\thdr3->blkno = cpu_to_be64(bp2->b_bn);\n\t}\n\txfs_trans_log_buf(args->trans, bp2, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Set up the new root node.\n\t */\n\terror = xfs_da3_node_create(args, 0, 1, &bp1, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\tnode = bp1->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&icnodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\n\tleaf = bp2->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&icleafhdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\t/* both on-disk, don't endian-flip twice */\n\tbtree[0].hashval = entries[icleafhdr.count - 1].hashval;\n\tbtree[0].before = cpu_to_be32(blkno);\n\ticnodehdr.count = 1;\n\tdp->d_ops->node_hdr_to_disk(node, &icnodehdr);\n\txfs_trans_log_buf(args->trans, bp1, 0, args->geo->blksize - 1);\n\terror = 0;\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_add",
          "args": [
            "bp",
            "args"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "1060-1134",
          "snippet": "int\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t/*\n\t * Search through freemap for first-fit on new name length.\n\t * (may need to figure in size of entry struct too)\n\t */\n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t/* no space in this map */\n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t/*\n\t * If there are no holes in the address space of the block,\n\t * and we don't have enough freespace, then compaction will do us\n\t * no good and we should just give up.\n\t */\n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * Compact the entries to coalesce free space.\n\t * This may change the hdr->count via dropping INCOMPLETE entries.\n\t */\n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t/*\n\t * After compaction, the block is guaranteed to have only one\n\t * free region, in freemap[0].  If it is not big enough, give up.\n\t */\n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t/*\n\t * Search through freemap for first-fit on new name length.\n\t * (may need to figure in size of entry struct too)\n\t */\n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t/* no space in this map */\n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t/*\n\t * If there are no holes in the address space of the block,\n\t * and we don't have enough freespace, then compaction will do us\n\t * no good and we should just give up.\n\t */\n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * Compact the entries to coalesce free space.\n\t * This may change the hdr->count via dropping INCOMPLETE entries.\n\t */\n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t/*\n\t * After compaction, the block is guaranteed to have only one\n\t * free region, in freemap[0].  If it is not big enough, give up.\n\t */\n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_replace",
          "args": [
            "args"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "args->trans",
            "bp"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_lookup_int",
          "args": [
            "bp",
            "args"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "2070-2174",
          "snippet": "int\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_leaf_addname",
          "args": [
            "args"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_leaf_addname(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, committed, forkoff;\n\n\ttrace_xfs_attr_leaf_addname(args);\n\n\t/*\n\t * Read the (only) block in the attribute list in.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the given attribute in the leaf block.  Figure out if\n\t * the given flags produce an error or call for an atomic rename.\n\t */\n\tretval = xfs_attr3_leaf_lookup_int(bp, args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE) {\t/* pure create op */\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t\t\treturn retval;\n\t\t}\n\n\t\ttrace_xfs_attr_leaf_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* an atomic rename */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\t/*\n\t * Add the attribute to the leaf block, transitioning to a Btree\n\t * if required.\n\t */\n\tretval = xfs_attr3_leaf_add(bp, args);\n\tif (retval == -ENOSPC) {\n\t\t/*\n\t\t * Promote the attribute list to the Btree format, then\n\t\t * Commit that transaction so that the node_addname() call\n\t\t * can manage its own transactions.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_node(args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the current trans (including the inode) and start\n\t\t * a new one.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Fob the whole rest of the problem off on the Btree code.\n\t\t */\n\t\terror = xfs_attr_node_addname(args);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Commit the transaction that added the attr name so that\n\t * later routines can manage their own transactions.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Read in the block containing the \"old\" attr, then\n\t\t * remove the \"old\" attr from that block (neat, huh!)\n\t\t */\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,\n\t\t\t\t\t   -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_remove(bp, args);\n\n\t\t/*\n\t\t * If the result is small enough, shrink it all into the inode.\n\t\t */\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit the remove and start the next trans in series.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr_shortform_addname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "526-556",
    "snippet": "STATIC int\nxfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\n\ttrace_xfs_attr_sf_addname(args);\n\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_shortform_add",
          "args": [
            "args",
            "forkoff"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "447-495",
          "snippet": "void\nxfs_attr_shortform_add(xfs_da_args_t *args, int forkoff)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i, offset, size;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_add(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tdp->i_d.di_forkoff = forkoff;\n\n\tifp = dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n#ifdef DEBUG\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tASSERT(0);\n#endif\n\t}\n\n\toffset = (char *)sfe - (char *)sf;\n\tsize = XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = (xfs_attr_sf_entry_t *)((char *)sf + offset);\n\n\tsfe->namelen = args->namelen;\n\tsfe->valuelen = args->valuelen;\n\tsfe->flags = XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tmemcpy(sfe->nameval, args->name, args->namelen);\n\tmemcpy(&sfe->nameval[args->namelen], args->value, args->valuelen);\n\tsf->hdr.count++;\n\tbe16_add_cpu(&sf->hdr.totsize, size);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr_shortform_add(xfs_da_args_t *args, int forkoff)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i, offset, size;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_add(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tdp->i_d.di_forkoff = forkoff;\n\n\tifp = dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n#ifdef DEBUG\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tASSERT(0);\n#endif\n\t}\n\n\toffset = (char *)sfe - (char *)sf;\n\tsize = XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = (xfs_attr_sf_entry_t *)((char *)sf + offset);\n\n\tsfe->namelen = args->namelen;\n\tsfe->valuelen = args->valuelen;\n\tsfe->flags = XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tmemcpy(sfe->nameval, args->name, args->namelen);\n\tmemcpy(&sfe->nameval[args->namelen], args->value, args->valuelen);\n\tsf->hdr.count++;\n\tbe16_add_cpu(&sf->hdr.totsize, size);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_bytesfit",
          "args": [
            "args->dp",
            "newsize"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_bytesfit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "302-392",
          "snippet": "int\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\n{\n\tint offset;\n\tint minforkoff;\t/* lower limit on valid forkoff locations */\n\tint maxforkoff;\t/* upper limit on valid forkoff locations */\n\tint dsize;\n\txfs_mount_t *mp = dp->i_mount;\n\n\t/* rounded down */\n\toffset = (XFS_LITINO(mp, dp->i_d.di_version) - bytes) >> 3;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tminforkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t/*\n\t * If the requested numbers of bytes is smaller or equal to the\n\t * current attribute fork size we can always proceed.\n\t *\n\t * Note that if_bytes in the data fork might actually be larger than\n\t * the current data fork size is due to delalloc extents. In that\n\t * case either the extent count will go down when they are converted\n\t * to real extents, or the delalloc conversion will take care of the\n\t * literal area rebalancing.\n\t */\n\tif (bytes <= XFS_IFORK_ASIZE(dp))\n\t\treturn dp->i_d.di_forkoff;\n\n\t/*\n\t * For attr2 we can try to move the forkoff if there is space in the\n\t * literal area, but for the old format we are done if there is no\n\t * space in the fixed attribute fork.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_ATTR2))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/*\n\t\t * If there is no attr fork and the data fork is extents, \n\t\t * determine if creating the default attr fork will result\n\t\t * in the extents form migrating to btree. If so, the\n\t\t * minimum offset only needs to be the space required for\n\t\t * the btree root.\n\t\t */\n\t\tif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t/*\n\t\t * If we have a data btree then keep forkoff if we have one,\n\t\t * otherwise we are adding a new attr, so then we set\n\t\t * minforkoff to where the btree root can finish so we have\n\t\t * plenty of room for attrs\n\t\t */\n\t\tif (dp->i_d.di_forkoff) {\n\t\t\tif (offset < dp->i_d.di_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_d.di_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A data fork btree root must have space for at least\n\t * MINDBTPTRS key/ptr pairs if the data fork is small or empty.\n\t */\n\tminforkoff = MAX(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t/* attr fork btree root can have at least this many key/ptr pairs */\n\tmaxforkoff = XFS_LITINO(mp, dp->i_d.di_version) -\n\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t/* rounded down */\n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\n{\n\tint offset;\n\tint minforkoff;\t/* lower limit on valid forkoff locations */\n\tint maxforkoff;\t/* upper limit on valid forkoff locations */\n\tint dsize;\n\txfs_mount_t *mp = dp->i_mount;\n\n\t/* rounded down */\n\toffset = (XFS_LITINO(mp, dp->i_d.di_version) - bytes) >> 3;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tminforkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t/*\n\t * If the requested numbers of bytes is smaller or equal to the\n\t * current attribute fork size we can always proceed.\n\t *\n\t * Note that if_bytes in the data fork might actually be larger than\n\t * the current data fork size is due to delalloc extents. In that\n\t * case either the extent count will go down when they are converted\n\t * to real extents, or the delalloc conversion will take care of the\n\t * literal area rebalancing.\n\t */\n\tif (bytes <= XFS_IFORK_ASIZE(dp))\n\t\treturn dp->i_d.di_forkoff;\n\n\t/*\n\t * For attr2 we can try to move the forkoff if there is space in the\n\t * literal area, but for the old format we are done if there is no\n\t * space in the fixed attribute fork.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_ATTR2))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/*\n\t\t * If there is no attr fork and the data fork is extents, \n\t\t * determine if creating the default attr fork will result\n\t\t * in the extents form migrating to btree. If so, the\n\t\t * minimum offset only needs to be the space required for\n\t\t * the btree root.\n\t\t */\n\t\tif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t/*\n\t\t * If we have a data btree then keep forkoff if we have one,\n\t\t * otherwise we are adding a new attr, so then we set\n\t\t * minforkoff to where the btree root can finish so we have\n\t\t * plenty of room for attrs\n\t\t */\n\t\tif (dp->i_d.di_forkoff) {\n\t\t\tif (offset < dp->i_d.di_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_d.di_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A data fork btree root must have space for at least\n\t * MINDBTPTRS key/ptr pairs if the data fork is small or empty.\n\t */\n\tminforkoff = MAX(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t/* attr fork btree root can have at least this many key/ptr pairs */\n\tmaxforkoff = XFS_LITINO(mp, dp->i_d.di_version) -\n\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t/* rounded down */\n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_SF_ENTSIZE_BYNAME",
          "args": [
            "args->namelen",
            "args->valuelen"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_SF_TOTSIZE",
          "args": [
            "args->dp"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "retval == 0"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_remove",
          "args": [
            "args"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "519-584",
          "snippet": "int\nxfs_attr_shortform_remove(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint base, size=0, end, totsize, i;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\n\ttrace_xfs_attr_sf_remove(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tbase = sizeof(xfs_attr_sf_hdr_t);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tend = sf->hdr.count;\n\tfor (i = 0; i < end; sfe = XFS_ATTR_SF_NEXTENTRY(sfe),\n\t\t\t\t\tbase += size, i++) {\n\t\tsize = XFS_ATTR_SF_ENTSIZE(sfe);\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(sfe->nameval, args->name, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (i == end)\n\t\treturn -ENOATTR;\n\n\t/*\n\t * Fix up the attribute fork data, covering the hole\n\t */\n\tend = base + size;\n\ttotsize = be16_to_cpu(sf->hdr.totsize);\n\tif (end != totsize)\n\t\tmemmove(&((char *)sf)[base], &((char *)sf)[end], totsize - end);\n\tsf->hdr.count--;\n\tbe16_add_cpu(&sf->hdr.totsize, -size);\n\n\t/*\n\t * Fix up the start offset of the attribute fork\n\t */\n\ttotsize -= size;\n\tif (totsize == sizeof(xfs_attr_sf_hdr_t) &&\n\t    (mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    !(args->op_flags & XFS_DA_OP_ADDNAME)) {\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t} else {\n\t\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\t\tdp->i_d.di_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);\n\t\tASSERT(dp->i_d.di_forkoff);\n\t\tASSERT(totsize > sizeof(xfs_attr_sf_hdr_t) ||\n\t\t\t\t(args->op_flags & XFS_DA_OP_ADDNAME) ||\n\t\t\t\t!(mp->m_flags & XFS_MOUNT_ATTR2) ||\n\t\t\t\tdp->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\t\txfs_trans_log_inode(args->trans, dp,\n\t\t\t\t\tXFS_ILOG_CORE | XFS_ILOG_ADATA);\n\t}\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_remove(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint base, size=0, end, totsize, i;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\n\ttrace_xfs_attr_sf_remove(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tbase = sizeof(xfs_attr_sf_hdr_t);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tend = sf->hdr.count;\n\tfor (i = 0; i < end; sfe = XFS_ATTR_SF_NEXTENTRY(sfe),\n\t\t\t\t\tbase += size, i++) {\n\t\tsize = XFS_ATTR_SF_ENTSIZE(sfe);\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(sfe->nameval, args->name, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (i == end)\n\t\treturn -ENOATTR;\n\n\t/*\n\t * Fix up the attribute fork data, covering the hole\n\t */\n\tend = base + size;\n\ttotsize = be16_to_cpu(sf->hdr.totsize);\n\tif (end != totsize)\n\t\tmemmove(&((char *)sf)[base], &((char *)sf)[end], totsize - end);\n\tsf->hdr.count--;\n\tbe16_add_cpu(&sf->hdr.totsize, -size);\n\n\t/*\n\t * Fix up the start offset of the attribute fork\n\t */\n\ttotsize -= size;\n\tif (totsize == sizeof(xfs_attr_sf_hdr_t) &&\n\t    (mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    !(args->op_flags & XFS_DA_OP_ADDNAME)) {\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t} else {\n\t\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\t\tdp->i_d.di_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);\n\t\tASSERT(dp->i_d.di_forkoff);\n\t\tASSERT(totsize > sizeof(xfs_attr_sf_hdr_t) ||\n\t\t\t\t(args->op_flags & XFS_DA_OP_ADDNAME) ||\n\t\t\t\t!(mp->m_flags & XFS_MOUNT_ATTR2) ||\n\t\t\t\tdp->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\t\txfs_trans_log_inode(args->trans, dp,\n\t\t\t\t\tXFS_ILOG_CORE | XFS_ILOG_ADATA);\n\t}\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_lookup",
          "args": [
            "args"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "590-615",
          "snippet": "int\nxfs_attr_shortform_lookup(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_lookup(args);\n\n\tifp = args->dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_lookup(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_lookup(args);\n\n\tifp = args->dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_sf_addname",
          "args": [
            "args"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nSTATIC int\nxfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\n\ttrace_xfs_attr_sf_addname(args);\n\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "404-516",
    "snippet": "int\nxfs_attr_remove(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_remove);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(dp))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\n\t/*\n\t * we have no control over the attribute names that userspace passes us\n\t * to remove, so we have to allow the name lookup prior to attribute\n\t * removal to fail.\n\t */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_RM);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (flags & ATTR_ROOT)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\terror = xfs_trans_reserve(args.trans, &M_RES(mp)->tr_attrrm,\n\t\t\t\t  XFS_ATTRRM_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks not allocate in the common case.\n\t */\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = -ENOATTR;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\tASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\n\t\terror = xfs_attr_shortform_remove(&args);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_removename(&args);\n\t} else {\n\t\terror = xfs_attr_node_removename(&args);\n\t}\n\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "dp",
            "XFS_ILOCK_EXCL"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "args.trans",
            "XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "args.trans",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args.trans",
            "dp",
            "XFS_ILOG_CORE"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "args.trans",
            "dp",
            "XFS_ICHGTIME_CHG"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "args.trans"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_node_removename",
          "args": [
            "&args"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_node_removename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "1145-1298",
          "snippet": "STATIC int\nxfs_attr_node_removename(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, committed, forkoff;\n\n\ttrace_xfs_attr_node_removename(args);\n\n\t/*\n\t * Tie a string around our finger to remind us where we are.\n\t */\n\tdp = args->dp;\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error || (retval != -EEXIST)) {\n\t\tif (error == 0)\n\t\t\terror = retval;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is an out-of-line value, de-allocate the blocks.\n\t * This is done before we remove the attribute so that we don't\n\t * overflow the maximum size of a transaction and/or hit a deadlock.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->bp != NULL);\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Fill in disk block numbers in the state structure\n\t\t * so that we can get the buffers back after we commit\n\t\t * several transactions in the following calls.\n\t\t */\n\t\terror = xfs_attr_fillstate(state);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Mark the attribute as INCOMPLETE, then bunmapi() the\n\t\t * remote value.\n\t\t */\n\t\terror = xfs_attr3_leaf_setflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = xfs_attr_rmtval_remove(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Refill the state structure with buffers, the prior calls\n\t\t * released our buffers.\n\t\t */\n\t\terror = xfs_attr_refillstate(state);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Remove the name and update the hashvals in the tree.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tretval = xfs_attr3_leaf_remove(blk->bp, args);\n\txfs_da3_fixhashpath(state, &state->path);\n\n\t/*\n\t * Check to see if the tree needs to be collapsed.\n\t */\n\tif (retval && (state->path.active > 1)) {\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_da3_join(state);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the Btree join operation and start a new trans.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If the result is small enough, push it all into the inode.\n\t */\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\t/*\n\t\t * Have to get rid of the copy of this dabuf in the state.\n\t\t */\n\t\tASSERT(state->path.active == 1);\n\t\tASSERT(state->path.blk[0].bp);\n\t\tstate->path.blk[0].bp = NULL;\n\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, 0, -1, &bp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t} else\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t}\n\terror = 0;\n\nout:\n\txfs_da_state_free(state);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
            "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_node_removename(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, committed, forkoff;\n\n\ttrace_xfs_attr_node_removename(args);\n\n\t/*\n\t * Tie a string around our finger to remind us where we are.\n\t */\n\tdp = args->dp;\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error || (retval != -EEXIST)) {\n\t\tif (error == 0)\n\t\t\terror = retval;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is an out-of-line value, de-allocate the blocks.\n\t * This is done before we remove the attribute so that we don't\n\t * overflow the maximum size of a transaction and/or hit a deadlock.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->bp != NULL);\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Fill in disk block numbers in the state structure\n\t\t * so that we can get the buffers back after we commit\n\t\t * several transactions in the following calls.\n\t\t */\n\t\terror = xfs_attr_fillstate(state);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Mark the attribute as INCOMPLETE, then bunmapi() the\n\t\t * remote value.\n\t\t */\n\t\terror = xfs_attr3_leaf_setflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = xfs_attr_rmtval_remove(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Refill the state structure with buffers, the prior calls\n\t\t * released our buffers.\n\t\t */\n\t\terror = xfs_attr_refillstate(state);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Remove the name and update the hashvals in the tree.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tretval = xfs_attr3_leaf_remove(blk->bp, args);\n\txfs_da3_fixhashpath(state, &state->path);\n\n\t/*\n\t * Check to see if the tree needs to be collapsed.\n\t */\n\tif (retval && (state->path.active > 1)) {\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_da3_join(state);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the Btree join operation and start a new trans.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If the result is small enough, push it all into the inode.\n\t */\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\t/*\n\t\t * Have to get rid of the copy of this dabuf in the state.\n\t\t */\n\t\tASSERT(state->path.active == 1);\n\t\tASSERT(state->path.blk[0].bp);\n\t\tstate->path.blk[0].bp = NULL;\n\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, 0, -1, &bp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t} else\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t}\n\terror = 0;\n\nout:\n\txfs_da_state_free(state);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_removename",
          "args": [
            "&args"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_leaf_removename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "776-828",
          "snippet": "STATIC int\nxfs_attr_leaf_removename(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint error, committed, forkoff;\n\n\ttrace_xfs_attr_leaf_removename(args);\n\n\t/*\n\t * Remove the attribute.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tif (error == -ENOATTR) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t}\n\n\txfs_attr3_leaf_remove(bp, args);\n\n\t/*\n\t * If the result is small enough, shrink it all into the inode.\n\t */\n\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nSTATIC int\nxfs_attr_leaf_removename(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint error, committed, forkoff;\n\n\ttrace_xfs_attr_leaf_removename(args);\n\n\t/*\n\t * Remove the attribute.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tif (error == -ENOATTR) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t}\n\n\txfs_attr3_leaf_remove(bp, args);\n\n\t/*\n\t * If the result is small enough, shrink it all into the inode.\n\t */\n\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_one_block",
          "args": [
            "dp",
            "XFS_ATTR_FORK"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_one_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1703-1729",
          "snippet": "int\t\t\t\t\t/* 1=>1 block, 0=>otherwise */\nxfs_bmap_one_block(\n\txfs_inode_t\t*ip,\t\t/* incore inode */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* ptr to fork's extent */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\trval;\t\t/* return value */\n\txfs_bmbt_irec_t\ts;\t\t/* internal version of extent */\n\n#ifndef DEBUG\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize;\n#endif\t/* !DEBUG */\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) != 1)\n\t\treturn 0;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\treturn 0;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_get_all(ep, &s);\n\trval = s.br_startoff == 0 && s.br_blockcount == 1;\n\tif (rval && whichfork == XFS_DATA_FORK)\n\t\tASSERT(XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* 1=>1 block, 0=>otherwise */\nxfs_bmap_one_block(\n\txfs_inode_t\t*ip,\t\t/* incore inode */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* ptr to fork's extent */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\trval;\t\t/* return value */\n\txfs_bmbt_irec_t\ts;\t\t/* internal version of extent */\n\n#ifndef DEBUG\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize;\n#endif\t/* !DEBUG */\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) != 1)\n\t\treturn 0;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\treturn 0;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_get_all(ep, &s);\n\trval = s.br_startoff == 0 && s.br_blockcount == 1;\n\tif (rval && whichfork == XFS_DATA_FORK)\n\t\tASSERT(XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_remove",
          "args": [
            "&args"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "519-584",
          "snippet": "int\nxfs_attr_shortform_remove(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint base, size=0, end, totsize, i;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\n\ttrace_xfs_attr_sf_remove(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tbase = sizeof(xfs_attr_sf_hdr_t);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tend = sf->hdr.count;\n\tfor (i = 0; i < end; sfe = XFS_ATTR_SF_NEXTENTRY(sfe),\n\t\t\t\t\tbase += size, i++) {\n\t\tsize = XFS_ATTR_SF_ENTSIZE(sfe);\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(sfe->nameval, args->name, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (i == end)\n\t\treturn -ENOATTR;\n\n\t/*\n\t * Fix up the attribute fork data, covering the hole\n\t */\n\tend = base + size;\n\ttotsize = be16_to_cpu(sf->hdr.totsize);\n\tif (end != totsize)\n\t\tmemmove(&((char *)sf)[base], &((char *)sf)[end], totsize - end);\n\tsf->hdr.count--;\n\tbe16_add_cpu(&sf->hdr.totsize, -size);\n\n\t/*\n\t * Fix up the start offset of the attribute fork\n\t */\n\ttotsize -= size;\n\tif (totsize == sizeof(xfs_attr_sf_hdr_t) &&\n\t    (mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    !(args->op_flags & XFS_DA_OP_ADDNAME)) {\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t} else {\n\t\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\t\tdp->i_d.di_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);\n\t\tASSERT(dp->i_d.di_forkoff);\n\t\tASSERT(totsize > sizeof(xfs_attr_sf_hdr_t) ||\n\t\t\t\t(args->op_flags & XFS_DA_OP_ADDNAME) ||\n\t\t\t\t!(mp->m_flags & XFS_MOUNT_ATTR2) ||\n\t\t\t\tdp->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\t\txfs_trans_log_inode(args->trans, dp,\n\t\t\t\t\tXFS_ILOG_CORE | XFS_ILOG_ADATA);\n\t}\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_remove(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint base, size=0, end, totsize, i;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\n\ttrace_xfs_attr_sf_remove(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tbase = sizeof(xfs_attr_sf_hdr_t);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tend = sf->hdr.count;\n\tfor (i = 0; i < end; sfe = XFS_ATTR_SF_NEXTENTRY(sfe),\n\t\t\t\t\tbase += size, i++) {\n\t\tsize = XFS_ATTR_SF_ENTSIZE(sfe);\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(sfe->nameval, args->name, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (i == end)\n\t\treturn -ENOATTR;\n\n\t/*\n\t * Fix up the attribute fork data, covering the hole\n\t */\n\tend = base + size;\n\ttotsize = be16_to_cpu(sf->hdr.totsize);\n\tif (end != totsize)\n\t\tmemmove(&((char *)sf)[base], &((char *)sf)[end], totsize - end);\n\tsf->hdr.count--;\n\tbe16_add_cpu(&sf->hdr.totsize, -size);\n\n\t/*\n\t * Fix up the start offset of the attribute fork\n\t */\n\ttotsize -= size;\n\tif (totsize == sizeof(xfs_attr_sf_hdr_t) &&\n\t    (mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    !(args->op_flags & XFS_DA_OP_ADDNAME)) {\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t} else {\n\t\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\t\tdp->i_d.di_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);\n\t\tASSERT(dp->i_d.di_forkoff);\n\t\tASSERT(totsize > sizeof(xfs_attr_sf_hdr_t) ||\n\t\t\t\t(args->op_flags & XFS_DA_OP_ADDNAME) ||\n\t\t\t\t!(mp->m_flags & XFS_MOUNT_ATTR2) ||\n\t\t\t\tdp->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\t\txfs_trans_log_inode(args->trans, dp,\n\t\t\t\t\tXFS_ILOG_CORE | XFS_ILOG_ADATA);\n\t}\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_afp->if_flags & XFS_IFINLINE"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inode_hasattr",
          "args": [
            "dp"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_hasattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "101-110",
          "snippet": "int\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!XFS_IFORK_Q(ip) ||\n\t    (ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     ip->i_d.di_anextents == 0))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!XFS_IFORK_Q(ip) ||\n\t    (ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     ip->i_d.di_anextents == 0))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "args.trans",
            "dp",
            "0"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "dp",
            "XFS_ILOCK_EXCL"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "args.trans",
            "&M_RES(mp)->tr_attrrm",
            "XFS_ATTRRM_SPACE_RES(mp)",
            "0"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ATTRRM_SPACE_RES",
          "args": [
            "mp"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_ATTR_RM"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqattach",
          "args": [
            "dp",
            "0"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "379-394",
          "snippet": "int\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_args_init",
          "args": [
            "&args",
            "dp",
            "name",
            "flags"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_args_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "76-99",
          "snippet": "STATIC int\nxfs_attr_args_init(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tmemset(args, 0, sizeof(*args));\n\targs->geo = dp->i_mount->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->dp = dp;\n\targs->flags = flags;\n\targs->name = name;\n\targs->namelen = strlen((const char *)name);\n\tif (args->namelen >= MAXNAMELEN)\n\t\treturn -EFAULT;\t\t/* match IRIX behaviour */\n\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nSTATIC int\nxfs_attr_args_init(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tmemset(args, 0, sizeof(*args));\n\targs->geo = dp->i_mount->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->dp = dp;\n\targs->flags = flags;\n\targs->name = name;\n\targs->namelen = strlen((const char *)name);\n\tif (args->namelen >= MAXNAMELEN)\n\t\treturn -EFAULT;\t\t/* match IRIX behaviour */\n\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "dp->i_mount"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_attr_remove"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_remove(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_remove);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(dp))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\n\t/*\n\t * we have no control over the attribute names that userspace passes us\n\t * to remove, so we have to allow the name lookup prior to attribute\n\t * removal to fail.\n\t */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_RM);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (flags & ATTR_ROOT)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\terror = xfs_trans_reserve(args.trans, &M_RES(mp)->tr_attrrm,\n\t\t\t\t  XFS_ATTRRM_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks not allocate in the common case.\n\t */\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = -ENOATTR;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\tASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\n\t\terror = xfs_attr_shortform_remove(&args);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_removename(&args);\n\t} else {\n\t\terror = xfs_attr_node_removename(&args);\n\t}\n\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "194-398",
    "snippet": "int\nxfs_attr_set(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\tstruct xfs_trans_res\ttres;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\trsvd = (flags & ATTR_ROOT) != 0;\n\tint\t\t\terror, err2, committed, local;\n\n\tXFS_STATS_INC(xs_attr_set);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = valuelen;\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\targs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\targs.total = xfs_attr_calc_size(&args, &local);\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the inode doesn't have an attribute fork, add one.\n\t * (inode must not be locked when we call this routine)\n\t */\n\tif (XFS_IFORK_Q(dp) == 0) {\n\t\tint sf_size = sizeof(xfs_attr_sf_hdr_t) +\n\t\t\tXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\n\n\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (rsvd)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\ttres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres * args.total;\n\ttres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(args.trans, &tres, args.total, 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\terror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\n\t\t\t\trsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS);\n\tif (error) {\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t/*\n\t * If the attribute list is non-existent or a shortform list,\n\t * upgrade it to a single-leaf-block attribute list.\n\t */\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\n\t    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     dp->i_d.di_anextents == 0)) {\n\n\t\t/*\n\t\t * Build initial attribute list (if required).\n\t\t */\n\t\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\n\t\t\txfs_attr_shortform_create(&args);\n\n\t\t/*\n\t\t * Try to add the attr to the attribute list in\n\t\t * the inode.\n\t\t */\n\t\terror = xfs_attr_shortform_addname(&args);\n\t\tif (error != -ENOSPC) {\n\t\t\t/*\n\t\t\t * Commit the shortform mods, and we're done.\n\t\t\t * NOTE: this is also the error path (EEXIST, etc).\n\t\t\t */\n\t\t\tASSERT(args.trans != NULL);\n\n\t\t\t/*\n\t\t\t * If this is a synchronous mount, make sure that\n\t\t\t * the transaction goes to disk before returning\n\t\t\t * to the user.\n\t\t\t */\n\t\t\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\t\t\txfs_trans_set_sync(args.trans);\n\n\t\t\tif (!error && (flags & ATTR_KERNOTIME) == 0) {\n\t\t\t\txfs_trans_ichgtime(args.trans, dp,\n\t\t\t\t\t\t\tXFS_ICHGTIME_CHG);\n\t\t\t}\n\t\t\terr2 = xfs_trans_commit(args.trans,\n\t\t\t\t\t\t XFS_TRANS_RELEASE_LOG_RES);\n\t\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\t\t\treturn error ? error : err2;\n\t\t}\n\n\t\t/*\n\t\t * It won't fit in the shortform, transform to a leaf block.\n\t\t * GROT: another possible req'mt for a double-split btree op.\n\t\t */\n\t\txfs_bmap_init(args.flist, args.firstblock);\n\t\terror = xfs_attr_shortform_to_leaf(&args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args.trans, args.flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs.trans = NULL;\n\t\t\txfs_bmap_cancel(&flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the leaf transformation.  We'll need another (linked)\n\t\t * transaction to add the new attribute to the leaf.\n\t\t */\n\n\t\terror = xfs_trans_roll(&args.trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t}\n\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_addname(&args);\n\telse\n\t\terror = xfs_attr_node_addname(&args);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "dp",
            "XFS_ILOCK_EXCL"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "args.trans",
            "XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "args.trans",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args.trans",
            "dp",
            "XFS_ILOG_CORE"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "args.trans",
            "dp",
            "XFS_ICHGTIME_CHG"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "args.trans"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_node_addname",
          "args": [
            "&args"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_node_addname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "876-1136",
          "snippet": "STATIC int\nxfs_attr_node_addname(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\txfs_mount_t *mp;\n\tint committed, retval, error;\n\n\ttrace_xfs_attr_node_addname(args);\n\n\t/*\n\t * Fill in bucket of arguments/results/context to carry around.\n\t */\n\tdp = args->dp;\n\tmp = dp->i_mount;\nrestart:\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = mp;\n\n\t/*\n\t * Search to see if name already exists, and get back a pointer\n\t * to where it should go.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error)\n\t\tgoto out;\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\tgoto out;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\tgoto out;\n\n\t\ttrace_xfs_attr_node_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* atomic rename op */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\tretval = xfs_attr3_leaf_add(blk->bp, state->args);\n\tif (retval == -ENOSPC) {\n\t\tif (state->path.active == 1) {\n\t\t\t/*\n\t\t\t * Its really a single leaf node, but it had\n\t\t\t * out-of-line values so it looked like it *might*\n\t\t\t * have been a b-tree.\n\t\t\t */\n\t\t\txfs_da_state_free(state);\n\t\t\tstate = NULL;\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_node(args);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t\t/*\n\t\t\t * Commit the node conversion and start the next\n\t\t\t * trans in the chain.\n\t\t\t */\n\t\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/*\n\t\t * Split as many Btree elements as required.\n\t\t * This code tracks the new and old attr's location\n\t\t * in the index/blkno/rmtblkno/rmtblkcnt fields and\n\t\t * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_da3_split(state);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t} else {\n\t\t/*\n\t\t * Addition succeeded, update Btree hashvals.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\n\t/*\n\t * Kill the state structure, we're done with it and need to\n\t * allow the buffers to come back later.\n\t */\n\txfs_da_state_free(state);\n\tstate = NULL;\n\n\t/*\n\t * Commit the leaf addition or btree split and start the next\n\t * trans in the chain.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Re-find the \"old\" attribute entry after any split ops.\n\t\t * The INCOMPLETE flag means that we will find the \"old\"\n\t\t * attr, not the \"new\" one.\n\t\t */\n\t\targs->flags |= XFS_ATTR_INCOMPLETE;\n\t\tstate = xfs_da_state_alloc();\n\t\tstate->args = args;\n\t\tstate->mp = mp;\n\t\tstate->inleaf = 0;\n\t\terror = xfs_da3_node_lookup_int(state, &retval);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Remove the name and update the hashvals in the tree.\n\t\t */\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\t\terror = xfs_attr3_leaf_remove(blk->bp, args);\n\t\txfs_da3_fixhashpath(state, &state->path);\n\n\t\t/*\n\t\t * Check to see if the tree needs to be collapsed.\n\t\t */\n\t\tif (retval && (state->path.active > 1)) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_da3_join(state);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit and start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tretval = error = 0;\n\nout:\n\tif (state)\n\t\txfs_da_state_free(state);\n\tif (error)\n\t\treturn error;\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
            "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_node_addname(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\txfs_mount_t *mp;\n\tint committed, retval, error;\n\n\ttrace_xfs_attr_node_addname(args);\n\n\t/*\n\t * Fill in bucket of arguments/results/context to carry around.\n\t */\n\tdp = args->dp;\n\tmp = dp->i_mount;\nrestart:\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = mp;\n\n\t/*\n\t * Search to see if name already exists, and get back a pointer\n\t * to where it should go.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error)\n\t\tgoto out;\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\tgoto out;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\tgoto out;\n\n\t\ttrace_xfs_attr_node_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* atomic rename op */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\tretval = xfs_attr3_leaf_add(blk->bp, state->args);\n\tif (retval == -ENOSPC) {\n\t\tif (state->path.active == 1) {\n\t\t\t/*\n\t\t\t * Its really a single leaf node, but it had\n\t\t\t * out-of-line values so it looked like it *might*\n\t\t\t * have been a b-tree.\n\t\t\t */\n\t\t\txfs_da_state_free(state);\n\t\t\tstate = NULL;\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_node(args);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t\t/*\n\t\t\t * Commit the node conversion and start the next\n\t\t\t * trans in the chain.\n\t\t\t */\n\t\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/*\n\t\t * Split as many Btree elements as required.\n\t\t * This code tracks the new and old attr's location\n\t\t * in the index/blkno/rmtblkno/rmtblkcnt fields and\n\t\t * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_da3_split(state);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t} else {\n\t\t/*\n\t\t * Addition succeeded, update Btree hashvals.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\n\t/*\n\t * Kill the state structure, we're done with it and need to\n\t * allow the buffers to come back later.\n\t */\n\txfs_da_state_free(state);\n\tstate = NULL;\n\n\t/*\n\t * Commit the leaf addition or btree split and start the next\n\t * trans in the chain.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Re-find the \"old\" attribute entry after any split ops.\n\t\t * The INCOMPLETE flag means that we will find the \"old\"\n\t\t * attr, not the \"new\" one.\n\t\t */\n\t\targs->flags |= XFS_ATTR_INCOMPLETE;\n\t\tstate = xfs_da_state_alloc();\n\t\tstate->args = args;\n\t\tstate->mp = mp;\n\t\tstate->inleaf = 0;\n\t\terror = xfs_da3_node_lookup_int(state, &retval);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Remove the name and update the hashvals in the tree.\n\t\t */\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\t\terror = xfs_attr3_leaf_remove(blk->bp, args);\n\t\txfs_da3_fixhashpath(state, &state->path);\n\n\t\t/*\n\t\t * Check to see if the tree needs to be collapsed.\n\t\t */\n\t\tif (retval && (state->path.active > 1)) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_da3_join(state);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit and start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tretval = error = 0;\n\nout:\n\tif (state)\n\t\txfs_da_state_free(state);\n\tif (error)\n\t\treturn error;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_addname",
          "args": [
            "&args"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_leaf_addname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "569-768",
          "snippet": "STATIC int\nxfs_attr_leaf_addname(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, committed, forkoff;\n\n\ttrace_xfs_attr_leaf_addname(args);\n\n\t/*\n\t * Read the (only) block in the attribute list in.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the given attribute in the leaf block.  Figure out if\n\t * the given flags produce an error or call for an atomic rename.\n\t */\n\tretval = xfs_attr3_leaf_lookup_int(bp, args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE) {\t/* pure create op */\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t\t\treturn retval;\n\t\t}\n\n\t\ttrace_xfs_attr_leaf_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* an atomic rename */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\t/*\n\t * Add the attribute to the leaf block, transitioning to a Btree\n\t * if required.\n\t */\n\tretval = xfs_attr3_leaf_add(bp, args);\n\tif (retval == -ENOSPC) {\n\t\t/*\n\t\t * Promote the attribute list to the Btree format, then\n\t\t * Commit that transaction so that the node_addname() call\n\t\t * can manage its own transactions.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_node(args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the current trans (including the inode) and start\n\t\t * a new one.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Fob the whole rest of the problem off on the Btree code.\n\t\t */\n\t\terror = xfs_attr_node_addname(args);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Commit the transaction that added the attr name so that\n\t * later routines can manage their own transactions.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Read in the block containing the \"old\" attr, then\n\t\t * remove the \"old\" attr from that block (neat, huh!)\n\t\t */\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,\n\t\t\t\t\t   -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_remove(bp, args);\n\n\t\t/*\n\t\t * If the result is small enough, shrink it all into the inode.\n\t\t */\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit the remove and start the next trans in series.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
            "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_leaf_addname(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, committed, forkoff;\n\n\ttrace_xfs_attr_leaf_addname(args);\n\n\t/*\n\t * Read the (only) block in the attribute list in.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the given attribute in the leaf block.  Figure out if\n\t * the given flags produce an error or call for an atomic rename.\n\t */\n\tretval = xfs_attr3_leaf_lookup_int(bp, args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE) {\t/* pure create op */\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t\t\treturn retval;\n\t\t}\n\n\t\ttrace_xfs_attr_leaf_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* an atomic rename */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\t/*\n\t * Add the attribute to the leaf block, transitioning to a Btree\n\t * if required.\n\t */\n\tretval = xfs_attr3_leaf_add(bp, args);\n\tif (retval == -ENOSPC) {\n\t\t/*\n\t\t * Promote the attribute list to the Btree format, then\n\t\t * Commit that transaction so that the node_addname() call\n\t\t * can manage its own transactions.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_node(args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the current trans (including the inode) and start\n\t\t * a new one.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Fob the whole rest of the problem off on the Btree code.\n\t\t */\n\t\terror = xfs_attr_node_addname(args);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Commit the transaction that added the attr name so that\n\t * later routines can manage their own transactions.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Read in the block containing the \"old\" attr, then\n\t\t * remove the \"old\" attr from that block (neat, huh!)\n\t\t */\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,\n\t\t\t\t\t   -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_remove(bp, args);\n\n\t\t/*\n\t\t * If the result is small enough, shrink it all into the inode.\n\t\t */\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit the remove and start the next trans in series.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_one_block",
          "args": [
            "dp",
            "XFS_ATTR_FORK"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_one_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1703-1729",
          "snippet": "int\t\t\t\t\t/* 1=>1 block, 0=>otherwise */\nxfs_bmap_one_block(\n\txfs_inode_t\t*ip,\t\t/* incore inode */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* ptr to fork's extent */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\trval;\t\t/* return value */\n\txfs_bmbt_irec_t\ts;\t\t/* internal version of extent */\n\n#ifndef DEBUG\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize;\n#endif\t/* !DEBUG */\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) != 1)\n\t\treturn 0;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\treturn 0;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_get_all(ep, &s);\n\trval = s.br_startoff == 0 && s.br_blockcount == 1;\n\tif (rval && whichfork == XFS_DATA_FORK)\n\t\tASSERT(XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* 1=>1 block, 0=>otherwise */\nxfs_bmap_one_block(\n\txfs_inode_t\t*ip,\t\t/* incore inode */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* ptr to fork's extent */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\trval;\t\t/* return value */\n\txfs_bmbt_irec_t\ts;\t\t/* internal version of extent */\n\n#ifndef DEBUG\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize;\n#endif\t/* !DEBUG */\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) != 1)\n\t\treturn 0;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\treturn 0;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_get_all(ep, &s);\n\trval = s.br_startoff == 0 && s.br_blockcount == 1;\n\tif (rval && whichfork == XFS_DATA_FORK)\n\t\tASSERT(XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_roll",
          "args": [
            "&args.trans",
            "dp"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_roll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "995-1055",
          "snippet": "int\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "args.trans",
            "dp",
            "0"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "&flist"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "committed"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&args.trans",
            "args.flist",
            "&committed"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_to_leaf",
          "args": [
            "&args"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_to_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "658-743",
          "snippet": "int\nxfs_attr_shortform_to_leaf(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\terror = xfs_da_shrink_inode(args, 0, bp);\n\t\tbp = NULL;\n\t\tif (error)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\nint\nxfs_attr_shortform_to_leaf(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\terror = xfs_da_shrink_inode(args, 0, bp);\n\t\tbp = NULL;\n\t\tif (error)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "args.flist",
            "args.firstblock"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "args.trans"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args.trans != NULL"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_addname",
          "args": [
            "&args"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_addname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "526-556",
          "snippet": "STATIC int\nxfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\n\ttrace_xfs_attr_sf_addname(args);\n\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nSTATIC int\nxfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\n\ttrace_xfs_attr_sf_addname(args);\n\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_create",
          "args": [
            "&args"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "415-441",
          "snippet": "void\nxfs_attr_shortform_create(xfs_da_args_t *args)\n{\n\txfs_attr_sf_hdr_t *hdr;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_create(args);\n\n\tdp = args->dp;\n\tASSERT(dp != NULL);\n\tifp = dp->i_afp;\n\tASSERT(ifp != NULL);\n\tASSERT(ifp->if_bytes == 0);\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS) {\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\t/* just in case */\n\t\tdp->i_d.di_aformat = XFS_DINODE_FMT_LOCAL;\n\t\tifp->if_flags |= XFS_IFINLINE;\n\t} else {\n\t\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t}\n\txfs_idata_realloc(dp, sizeof(*hdr), XFS_ATTR_FORK);\n\thdr = (xfs_attr_sf_hdr_t *)ifp->if_u1.if_data;\n\thdr->count = 0;\n\thdr->totsize = cpu_to_be16(sizeof(*hdr));\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr_shortform_create(xfs_da_args_t *args)\n{\n\txfs_attr_sf_hdr_t *hdr;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_create(args);\n\n\tdp = args->dp;\n\tASSERT(dp != NULL);\n\tifp = dp->i_afp;\n\tASSERT(ifp != NULL);\n\tASSERT(ifp->if_bytes == 0);\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS) {\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\t/* just in case */\n\t\tdp->i_d.di_aformat = XFS_DINODE_FMT_LOCAL;\n\t\tifp->if_flags |= XFS_IFINLINE;\n\t} else {\n\t\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t}\n\txfs_idata_realloc(dp, sizeof(*hdr), XFS_ATTR_FORK);\n\thdr = (xfs_attr_sf_hdr_t *)ifp->if_u1.if_data;\n\thdr->count = 0;\n\thdr->totsize = cpu_to_be16(sizeof(*hdr));\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve_quota_nblks",
          "args": [
            "args.trans",
            "dp",
            "args.total",
            "0",
            "rsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve_quota_nblks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "802-832",
          "snippet": "int\nxfs_trans_reserve_quota_nblks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\tflags |= XFS_QMOPT_ENOSPC;\n\n\tASSERT(!xfs_is_quota_inode(&mp->m_sb, ip->i_ino));\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT((flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS);\n\n\t/*\n\t * Reserve nblks against these dquots, with trans as the mediator.\n\t */\n\treturn xfs_trans_reserve_quota_bydquots(tp, mp,\n\t\t\t\t\t\tip->i_udquot, ip->i_gdquot,\n\t\t\t\t\t\tip->i_pdquot,\n\t\t\t\t\t\tnblks, ninos, flags);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_nblks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\tflags |= XFS_QMOPT_ENOSPC;\n\n\tASSERT(!xfs_is_quota_inode(&mp->m_sb, ip->i_ino));\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT((flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS);\n\n\t/*\n\t * Reserve nblks against these dquots, with trans as the mediator.\n\t */\n\treturn xfs_trans_reserve_quota_bydquots(tp, mp,\n\t\t\t\t\t\tip->i_udquot, ip->i_gdquot,\n\t\t\t\t\t\tip->i_pdquot,\n\t\t\t\t\t\tnblks, ninos, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "dp",
            "XFS_ILOCK_EXCL"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "args.trans",
            "&tres",
            "args.total",
            "0"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_ATTR_SET"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_attrfork",
          "args": [
            "dp",
            "sf_size",
            "rsvd"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_attrfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1126-1257",
          "snippet": "int\t\t\t\t\t\t/* error code */\nxfs_bmap_add_attrfork(\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\tint\t\t\tsize,\t\t/* space new attribute needs */\n\tint\t\t\trsvd)\t\t/* xact may use reserved blks */\n{\n\txfs_fsblock_t\t\tfirstblock;\t/* 1st block/ag allocated */\n\txfs_bmap_free_t\t\tflist;\t\t/* freed extent records */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tint\t\t\tblks;\t\t/* space reservation */\n\tint\t\t\tversion = 1;\t/* superblock attr version */\n\tint\t\t\tcommitted;\t/* xaction was committed */\n\tint\t\t\tlogflags;\t/* logging flags */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tcancel_flags = 0;\n\n\tASSERT(XFS_IFORK_Q(ip) == 0);\n\n\tmp = ip->i_mount;\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_ADDAFORK);\n\tblks = XFS_ADDAFORK_SPACE_RES(mp);\n\tif (rsvd)\n\t\ttp->t_flags |= XFS_TRANS_RESERVE;\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_addafork, blks, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_trans_reserve_quota_nblks(tp, ip, blks, 0, rsvd ?\n\t\t\tXFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\tXFS_QMOPT_RES_REGBLKS);\n\tif (error)\n\t\tgoto trans_cancel;\n\tcancel_flags |= XFS_TRANS_ABORT;\n\tif (XFS_IFORK_Q(ip))\n\t\tgoto trans_cancel;\n\tif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS) {\n\t\t/*\n\t\t * For inodes coming from pre-6.2 filesystems.\n\t\t */\n\t\tASSERT(ip->i_d.di_aformat == 0);\n\t\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\t}\n\tASSERT(ip->i_d.di_anextents == 0);\n\n\txfs_trans_ijoin(tp, ip, 0);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tip->i_d.di_forkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tip->i_d.di_forkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tip->i_d.di_forkoff = xfs_attr_shortform_bytesfit(ip, size);\n\t\tif (!ip->i_d.di_forkoff)\n\t\t\tip->i_d.di_forkoff = xfs_default_attroffset(ip) >> 3;\n\t\telse if (mp->m_flags & XFS_MOUNT_ATTR2)\n\t\t\tversion = 2;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EINVAL;\n\t\tgoto trans_cancel;\n\t}\n\n\tASSERT(ip->i_afp == NULL);\n\tip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP);\n\tip->i_afp->if_flags = XFS_IFEXTENTS;\n\tlogflags = 0;\n\txfs_bmap_init(&flist, &firstblock);\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\terror = xfs_bmap_add_attrfork_local(tp, ip, &firstblock, &flist,\n\t\t\t&logflags);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_bmap_add_attrfork_extents(tp, ip, &firstblock,\n\t\t\t&flist, &logflags);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_bmap_add_attrfork_btree(tp, ip, &firstblock, &flist,\n\t\t\t&logflags);\n\t\tbreak;\n\tdefault:\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (error)\n\t\tgoto bmap_cancel;\n\tif (!xfs_sb_version_hasattr(&mp->m_sb) ||\n\t   (!xfs_sb_version_hasattr2(&mp->m_sb) && version == 2)) {\n\t\tbool log_sb = false;\n\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_sb_version_hasattr(&mp->m_sb)) {\n\t\t\txfs_sb_version_addattr(&mp->m_sb);\n\t\t\tlog_sb = true;\n\t\t}\n\t\tif (!xfs_sb_version_hasattr2(&mp->m_sb) && version == 2) {\n\t\t\txfs_sb_version_addattr2(&mp->m_sb);\n\t\t\tlog_sb = true;\n\t\t}\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\tif (log_sb)\n\t\t\txfs_log_sb(tp);\n\t}\n\n\terror = xfs_bmap_finish(&tp, &flist, &committed);\n\tif (error)\n\t\tgoto bmap_cancel;\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\nbmap_cancel:\n\txfs_bmap_cancel(&flist);\ntrans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error code */\nxfs_bmap_add_attrfork(\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\tint\t\t\tsize,\t\t/* space new attribute needs */\n\tint\t\t\trsvd)\t\t/* xact may use reserved blks */\n{\n\txfs_fsblock_t\t\tfirstblock;\t/* 1st block/ag allocated */\n\txfs_bmap_free_t\t\tflist;\t\t/* freed extent records */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tint\t\t\tblks;\t\t/* space reservation */\n\tint\t\t\tversion = 1;\t/* superblock attr version */\n\tint\t\t\tcommitted;\t/* xaction was committed */\n\tint\t\t\tlogflags;\t/* logging flags */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tcancel_flags = 0;\n\n\tASSERT(XFS_IFORK_Q(ip) == 0);\n\n\tmp = ip->i_mount;\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_ADDAFORK);\n\tblks = XFS_ADDAFORK_SPACE_RES(mp);\n\tif (rsvd)\n\t\ttp->t_flags |= XFS_TRANS_RESERVE;\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_addafork, blks, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_trans_reserve_quota_nblks(tp, ip, blks, 0, rsvd ?\n\t\t\tXFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\tXFS_QMOPT_RES_REGBLKS);\n\tif (error)\n\t\tgoto trans_cancel;\n\tcancel_flags |= XFS_TRANS_ABORT;\n\tif (XFS_IFORK_Q(ip))\n\t\tgoto trans_cancel;\n\tif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS) {\n\t\t/*\n\t\t * For inodes coming from pre-6.2 filesystems.\n\t\t */\n\t\tASSERT(ip->i_d.di_aformat == 0);\n\t\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\t}\n\tASSERT(ip->i_d.di_anextents == 0);\n\n\txfs_trans_ijoin(tp, ip, 0);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tip->i_d.di_forkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tip->i_d.di_forkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tip->i_d.di_forkoff = xfs_attr_shortform_bytesfit(ip, size);\n\t\tif (!ip->i_d.di_forkoff)\n\t\t\tip->i_d.di_forkoff = xfs_default_attroffset(ip) >> 3;\n\t\telse if (mp->m_flags & XFS_MOUNT_ATTR2)\n\t\t\tversion = 2;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EINVAL;\n\t\tgoto trans_cancel;\n\t}\n\n\tASSERT(ip->i_afp == NULL);\n\tip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP);\n\tip->i_afp->if_flags = XFS_IFEXTENTS;\n\tlogflags = 0;\n\txfs_bmap_init(&flist, &firstblock);\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\terror = xfs_bmap_add_attrfork_local(tp, ip, &firstblock, &flist,\n\t\t\t&logflags);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_bmap_add_attrfork_extents(tp, ip, &firstblock,\n\t\t\t&flist, &logflags);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_bmap_add_attrfork_btree(tp, ip, &firstblock, &flist,\n\t\t\t&logflags);\n\t\tbreak;\n\tdefault:\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (error)\n\t\tgoto bmap_cancel;\n\tif (!xfs_sb_version_hasattr(&mp->m_sb) ||\n\t   (!xfs_sb_version_hasattr2(&mp->m_sb) && version == 2)) {\n\t\tbool log_sb = false;\n\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_sb_version_hasattr(&mp->m_sb)) {\n\t\t\txfs_sb_version_addattr(&mp->m_sb);\n\t\t\tlog_sb = true;\n\t\t}\n\t\tif (!xfs_sb_version_hasattr2(&mp->m_sb) && version == 2) {\n\t\t\txfs_sb_version_addattr2(&mp->m_sb);\n\t\t\tlog_sb = true;\n\t\t}\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\tif (log_sb)\n\t\t\txfs_log_sb(tp);\n\t}\n\n\terror = xfs_bmap_finish(&tp, &flist, &committed);\n\tif (error)\n\t\tgoto bmap_cancel;\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\nbmap_cancel:\n\txfs_bmap_cancel(&flist);\ntrans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ATTR_SF_ENTSIZE_BYNAME",
          "args": [
            "args.namelen",
            "valuelen"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_Q",
          "args": [
            "dp"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqattach",
          "args": [
            "dp",
            "0"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "379-394",
          "snippet": "int\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_calc_size",
          "args": [
            "&args",
            "&local"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_calc_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "161-192",
          "snippet": "STATIC int\nxfs_attr_calc_size(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\t/*\n\t * Determine space new attribute will use, and if it would be\n\t * \"local\" or \"remote\" (note: local != inline).\n\t */\n\tsize = xfs_attr_leaf_newentsize(args, local);\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (args->geo->blksize / 2)) {\n\t\t\t/* Double split possible */\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Out of line attribute, cannot double split, but\n\t\t * make room for the attribute value itself.\n\t\t */\n\t\tuint\tdblocks = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\n\treturn nblks;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nSTATIC int\nxfs_attr_calc_size(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\t/*\n\t * Determine space new attribute will use, and if it would be\n\t * \"local\" or \"remote\" (note: local != inline).\n\t */\n\tsize = xfs_attr_leaf_newentsize(args, local);\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (args->geo->blksize / 2)) {\n\t\t\t/* Double split possible */\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Out of line attribute, cannot double split, but\n\t\t * make room for the attribute value itself.\n\t\t */\n\t\tuint\tdblocks = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\n\treturn nblks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_args_init",
          "args": [
            "&args",
            "dp",
            "name",
            "flags"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_args_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "76-99",
          "snippet": "STATIC int\nxfs_attr_args_init(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tmemset(args, 0, sizeof(*args));\n\targs->geo = dp->i_mount->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->dp = dp;\n\targs->flags = flags;\n\targs->name = name;\n\targs->namelen = strlen((const char *)name);\n\tif (args->namelen >= MAXNAMELEN)\n\t\treturn -EFAULT;\t\t/* match IRIX behaviour */\n\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nSTATIC int\nxfs_attr_args_init(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tmemset(args, 0, sizeof(*args));\n\targs->geo = dp->i_mount->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->dp = dp;\n\targs->flags = flags;\n\targs->name = name;\n\targs->namelen = strlen((const char *)name);\n\tif (args->namelen >= MAXNAMELEN)\n\t\treturn -EFAULT;\t\t/* match IRIX behaviour */\n\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "dp->i_mount"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_attr_set"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_set(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\tstruct xfs_trans_res\ttres;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\trsvd = (flags & ATTR_ROOT) != 0;\n\tint\t\t\terror, err2, committed, local;\n\n\tXFS_STATS_INC(xs_attr_set);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = valuelen;\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\targs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\targs.total = xfs_attr_calc_size(&args, &local);\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the inode doesn't have an attribute fork, add one.\n\t * (inode must not be locked when we call this routine)\n\t */\n\tif (XFS_IFORK_Q(dp) == 0) {\n\t\tint sf_size = sizeof(xfs_attr_sf_hdr_t) +\n\t\t\tXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\n\n\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (rsvd)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\ttres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres * args.total;\n\ttres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(args.trans, &tres, args.total, 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\terror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\n\t\t\t\trsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS);\n\tif (error) {\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t/*\n\t * If the attribute list is non-existent or a shortform list,\n\t * upgrade it to a single-leaf-block attribute list.\n\t */\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\n\t    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     dp->i_d.di_anextents == 0)) {\n\n\t\t/*\n\t\t * Build initial attribute list (if required).\n\t\t */\n\t\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\n\t\t\txfs_attr_shortform_create(&args);\n\n\t\t/*\n\t\t * Try to add the attr to the attribute list in\n\t\t * the inode.\n\t\t */\n\t\terror = xfs_attr_shortform_addname(&args);\n\t\tif (error != -ENOSPC) {\n\t\t\t/*\n\t\t\t * Commit the shortform mods, and we're done.\n\t\t\t * NOTE: this is also the error path (EEXIST, etc).\n\t\t\t */\n\t\t\tASSERT(args.trans != NULL);\n\n\t\t\t/*\n\t\t\t * If this is a synchronous mount, make sure that\n\t\t\t * the transaction goes to disk before returning\n\t\t\t * to the user.\n\t\t\t */\n\t\t\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\t\t\txfs_trans_set_sync(args.trans);\n\n\t\t\tif (!error && (flags & ATTR_KERNOTIME) == 0) {\n\t\t\t\txfs_trans_ichgtime(args.trans, dp,\n\t\t\t\t\t\t\tXFS_ICHGTIME_CHG);\n\t\t\t}\n\t\t\terr2 = xfs_trans_commit(args.trans,\n\t\t\t\t\t\t XFS_TRANS_RELEASE_LOG_RES);\n\t\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\t\t\treturn error ? error : err2;\n\t\t}\n\n\t\t/*\n\t\t * It won't fit in the shortform, transform to a leaf block.\n\t\t * GROT: another possible req'mt for a double-split btree op.\n\t\t */\n\t\txfs_bmap_init(args.flist, args.firstblock);\n\t\terror = xfs_attr_shortform_to_leaf(&args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args.trans, args.flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs.trans = NULL;\n\t\t\txfs_bmap_cancel(&flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the leaf transformation.  We'll need another (linked)\n\t\t * transaction to add the new attribute to the leaf.\n\t\t */\n\n\t\terror = xfs_trans_roll(&args.trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t}\n\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_addname(&args);\n\telse\n\t\terror = xfs_attr_node_addname(&args);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr_calc_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "161-192",
    "snippet": "STATIC int\nxfs_attr_calc_size(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\t/*\n\t * Determine space new attribute will use, and if it would be\n\t * \"local\" or \"remote\" (note: local != inline).\n\t */\n\tsize = xfs_attr_leaf_newentsize(args, local);\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (args->geo->blksize / 2)) {\n\t\t\t/* Double split possible */\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Out of line attribute, cannot double split, but\n\t\t * make room for the attribute value itself.\n\t\t */\n\t\tuint\tdblocks = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\n\treturn nblks;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_NEXTENTADD_SPACE_RES",
          "args": [
            "mp",
            "dblocks",
            "XFS_ATTR_FORK"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_rmt_blocks",
          "args": [
            "mp",
            "args->valuelen"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_rmt_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "50-60",
          "snippet": "int\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DAENTER_SPACE_RES",
          "args": [
            "mp",
            "XFS_ATTR_FORK"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_newentsize",
          "args": [
            "args",
            "local"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nSTATIC int\nxfs_attr_calc_size(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\t/*\n\t * Determine space new attribute will use, and if it would be\n\t * \"local\" or \"remote\" (note: local != inline).\n\t */\n\tsize = xfs_attr_leaf_newentsize(args, local);\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (args->geo->blksize / 2)) {\n\t\t\t/* Double split possible */\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Out of line attribute, cannot double split, but\n\t\t * make room for the attribute value itself.\n\t\t */\n\t\tuint\tdblocks = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\n\treturn nblks;\n}"
  },
  {
    "function_name": "xfs_attr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "116-156",
    "snippet": "int\nxfs_attr_get(\n\tstruct xfs_inode\t*ip,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\t*valuelenp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_da_args\targs;\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_get);\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, ip, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = *valuelenp;\n\n\tlock_mode = xfs_ilock_attr_map_shared(ip);\n\tif (!xfs_inode_hasattr(ip))\n\t\terror = -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\terror = xfs_attr_shortform_getvalue(&args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_get(&args);\n\telse\n\t\terror = xfs_attr_node_get(&args);\n\txfs_iunlock(ip, lock_mode);\n\n\t*valuelenp = args.valuelen;\n\treturn error == -EEXIST ? 0 : error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "lock_mode"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_node_get",
          "args": [
            "&args"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_node_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "1411-1456",
          "snippet": "STATIC int\nxfs_attr_node_get(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\tint error, retval;\n\tint i;\n\n\ttrace_xfs_attr_node_get(args);\n\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error) {\n\t\tretval = error;\n\t} else if (retval == -EEXIST) {\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->bp != NULL);\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\t\t/*\n\t\t * Get the value, local or \"remote\"\n\t\t */\n\t\tretval = xfs_attr3_leaf_getvalue(blk->bp, args);\n\t\tif (!retval && (args->rmtblkno > 0)\n\t\t    && !(args->flags & ATTR_KERNOVAL)) {\n\t\t\tretval = xfs_attr_rmtval_get(args);\n\t\t}\n\t}\n\n\t/*\n\t * If not in a transaction, we have to release all the buffers.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\n\txfs_da_state_free(state);\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_fillstate(xfs_da_state_t *state);",
            "STATIC int xfs_attr_refillstate(xfs_da_state_t *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\nSTATIC int\nxfs_attr_node_get(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\tint error, retval;\n\tint i;\n\n\ttrace_xfs_attr_node_get(args);\n\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error) {\n\t\tretval = error;\n\t} else if (retval == -EEXIST) {\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->bp != NULL);\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\t\t/*\n\t\t * Get the value, local or \"remote\"\n\t\t */\n\t\tretval = xfs_attr3_leaf_getvalue(blk->bp, args);\n\t\tif (!retval && (args->rmtblkno > 0)\n\t\t    && !(args->flags & ATTR_KERNOVAL)) {\n\t\t\tretval = xfs_attr_rmtval_get(args);\n\t\t}\n\t}\n\n\t/*\n\t * If not in a transaction, we have to release all the buffers.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\n\txfs_da_state_free(state);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_leaf_get",
          "args": [
            "&args"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_leaf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "836-860",
          "snippet": "STATIC int\nxfs_attr_leaf_get(xfs_da_args_t *args)\n{\n\tstruct xfs_buf *bp;\n\tint error;\n\n\ttrace_xfs_attr_leaf_get(args);\n\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tif (error != -EEXIST)  {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t}\n\terror = xfs_attr3_leaf_getvalue(bp, args);\n\txfs_trans_brelse(args->trans, bp);\n\tif (!error && (args->rmtblkno > 0) && !(args->flags & ATTR_KERNOVAL)) {\n\t\terror = xfs_attr_rmtval_get(args);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nSTATIC int\nxfs_attr_leaf_get(xfs_da_args_t *args)\n{\n\tstruct xfs_buf *bp;\n\tint error;\n\n\ttrace_xfs_attr_leaf_get(args);\n\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tif (error != -EEXIST)  {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t}\n\terror = xfs_attr3_leaf_getvalue(bp, args);\n\txfs_trans_brelse(args->trans, bp);\n\tif (!error && (args->rmtblkno > 0) && !(args->flags & ATTR_KERNOVAL)) {\n\t\terror = xfs_attr_rmtval_get(args);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_one_block",
          "args": [
            "ip",
            "XFS_ATTR_FORK"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_one_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1703-1729",
          "snippet": "int\t\t\t\t\t/* 1=>1 block, 0=>otherwise */\nxfs_bmap_one_block(\n\txfs_inode_t\t*ip,\t\t/* incore inode */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* ptr to fork's extent */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\trval;\t\t/* return value */\n\txfs_bmbt_irec_t\ts;\t\t/* internal version of extent */\n\n#ifndef DEBUG\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize;\n#endif\t/* !DEBUG */\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) != 1)\n\t\treturn 0;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\treturn 0;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_get_all(ep, &s);\n\trval = s.br_startoff == 0 && s.br_blockcount == 1;\n\tif (rval && whichfork == XFS_DATA_FORK)\n\t\tASSERT(XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* 1=>1 block, 0=>otherwise */\nxfs_bmap_one_block(\n\txfs_inode_t\t*ip,\t\t/* incore inode */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* ptr to fork's extent */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\trval;\t\t/* return value */\n\txfs_bmbt_irec_t\ts;\t\t/* internal version of extent */\n\n#ifndef DEBUG\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize;\n#endif\t/* !DEBUG */\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) != 1)\n\t\treturn 0;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\treturn 0;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_get_all(ep, &s);\n\trval = s.br_startoff == 0 && s.br_blockcount == 1;\n\tif (rval && whichfork == XFS_DATA_FORK)\n\t\tASSERT(XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_getvalue",
          "args": [
            "&args"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_getvalue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "621-653",
          "snippet": "int\nxfs_attr_shortform_getvalue(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\n\tASSERT(args->dp->i_afp->if_flags == XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)args->dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = sfe->valuelen;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (args->valuelen < sfe->valuelen) {\n\t\t\targs->valuelen = sfe->valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = sfe->valuelen;\n\t\tmemcpy(args->value, &sfe->nameval[args->namelen],\n\t\t\t\t\t\t    args->valuelen);\n\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_getvalue(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\n\tASSERT(args->dp->i_afp->if_flags == XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)args->dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = sfe->valuelen;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (args->valuelen < sfe->valuelen) {\n\t\t\targs->valuelen = sfe->valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = sfe->valuelen;\n\t\tmemcpy(args->value, &sfe->nameval[args->namelen],\n\t\t\t\t\t\t    args->valuelen);\n\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_hasattr",
          "args": [
            "ip"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_hasattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "101-110",
          "snippet": "int\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!XFS_IFORK_Q(ip) ||\n\t    (ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     ip->i_d.di_anextents == 0))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!XFS_IFORK_Q(ip) ||\n\t    (ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     ip->i_d.di_anextents == 0))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_attr_map_shared",
          "args": [
            "ip"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_attr_map_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "106-117",
          "snippet": "uint\nxfs_ilock_attr_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_afp->if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_attr_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_afp->if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_args_init",
          "args": [
            "&args",
            "ip",
            "name",
            "flags"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_args_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "76-99",
          "snippet": "STATIC int\nxfs_attr_args_init(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tmemset(args, 0, sizeof(*args));\n\targs->geo = dp->i_mount->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->dp = dp;\n\targs->flags = flags;\n\targs->name = name;\n\targs->namelen = strlen((const char *)name);\n\tif (args->namelen >= MAXNAMELEN)\n\t\treturn -EFAULT;\t\t/* match IRIX behaviour */\n\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nSTATIC int\nxfs_attr_args_init(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tmemset(args, 0, sizeof(*args));\n\targs->geo = dp->i_mount->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->dp = dp;\n\targs->flags = flags;\n\targs->name = name;\n\targs->namelen = strlen((const char *)name);\n\tif (args->namelen >= MAXNAMELEN)\n\t\treturn -EFAULT;\t\t/* match IRIX behaviour */\n\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_attr_get"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_get(\n\tstruct xfs_inode\t*ip,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\t*valuelenp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_da_args\targs;\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_get);\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, ip, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = *valuelenp;\n\n\tlock_mode = xfs_ilock_attr_map_shared(ip);\n\tif (!xfs_inode_hasattr(ip))\n\t\terror = -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\terror = xfs_attr_shortform_getvalue(&args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_get(&args);\n\telse\n\t\terror = xfs_attr_node_get(&args);\n\txfs_iunlock(ip, lock_mode);\n\n\t*valuelenp = args.valuelen;\n\treturn error == -EEXIST ? 0 : error;\n}"
  },
  {
    "function_name": "xfs_inode_hasattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "101-110",
    "snippet": "int\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!XFS_IFORK_Q(ip) ||\n\t    (ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     ip->i_d.di_anextents == 0))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_IFORK_Q",
          "args": [
            "ip"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!XFS_IFORK_Q(ip) ||\n\t    (ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     ip->i_d.di_anextents == 0))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "xfs_attr_args_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
    "lines": "76-99",
    "snippet": "STATIC int\nxfs_attr_args_init(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tmemset(args, 0, sizeof(*args));\n\targs->geo = dp->i_mount->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->dp = dp;\n\targs->flags = flags;\n\targs->name = name;\n\targs->namelen = strlen((const char *)name);\n\tif (args->namelen >= MAXNAMELEN)\n\t\treturn -EFAULT;\t\t/* match IRIX behaviour */\n\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
      "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_hashname",
          "args": [
            "args->name",
            "args->namelen"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_hashname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1944-1970",
          "snippet": "xfs_dahash_t\nxfs_da_hashname(const __uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t/*\n\t * Do four characters at a time as long as we can.\n\t */\n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t/*\n\t * Now do the rest of the characters.\n\t */\n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault: /* case 0: */\n\t\treturn hash;\n\t}\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dahash_t\nxfs_da_hashname(const __uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t/*\n\t * Do four characters at a time as long as we can.\n\t */\n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t/*\n\t * Now do the rest of the characters.\n\t */\n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault: /* case 0: */\n\t\treturn hash;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "(const char *)name"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "args",
            "0",
            "sizeof(*args)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nSTATIC int\nxfs_attr_args_init(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tmemset(args, 0, sizeof(*args));\n\targs->geo = dp->i_mount->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->dp = dp;\n\targs->flags = flags;\n\targs->name = name;\n\targs->namelen = strlen((const char *)name);\n\tif (args->namelen >= MAXNAMELEN)\n\t\treturn -EFAULT;\t\t/* match IRIX behaviour */\n\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\treturn 0;\n}"
  }
]